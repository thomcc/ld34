(function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require=="function"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error("Cannot find module '"+o+"'");throw f.code="MODULE_NOT_FOUND",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require=="function"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})({1:[function(require,module,exports){
(function (process,global){
/* @preserve
 * The MIT License (MIT)
 * 
 * Copyright (c) 2013-2015 Petka Antonov
 * 
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 * 
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 * 
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 * 
 */
/**
 * bluebird build version 3.0.6
 * Features enabled: core, race, call_get, generators, map, nodeify, promisify, props, reduce, settle, some, using, timers, filter, any, each
*/
!function(e){if("object"==typeof exports&&"undefined"!=typeof module)module.exports=e();else if("function"==typeof define&&define.amd)define([],e);else{var f;"undefined"!=typeof window?f=window:"undefined"!=typeof global?f=global:"undefined"!=typeof self&&(f=self),f.Promise=e()}}(function(){var define,module,exports;return (function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof _dereq_=="function"&&_dereq_;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error("Cannot find module '"+o+"'");throw f.code="MODULE_NOT_FOUND",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof _dereq_=="function"&&_dereq_;for(var o=0;o<r.length;o++)s(r[o]);return s})({1:[function(_dereq_,module,exports){
"use strict";
module.exports = function(Promise) {
var SomePromiseArray = Promise._SomePromiseArray;
function any(promises) {
    var ret = new SomePromiseArray(promises);
    var promise = ret.promise();
    ret.setHowMany(1);
    ret.setUnwrap();
    ret.init();
    return promise;
}

Promise.any = function (promises) {
    return any(promises);
};

Promise.prototype.any = function () {
    return any(this);
};

};

},{}],2:[function(_dereq_,module,exports){
"use strict";
var firstLineError;
try {throw new Error(); } catch (e) {firstLineError = e;}
var schedule = _dereq_("./schedule");
var Queue = _dereq_("./queue");
var util = _dereq_("./util");

function Async() {
    this._isTickUsed = false;
    this._lateQueue = new Queue(16);
    this._normalQueue = new Queue(16);
    this._haveDrainedQueues = false;
    this._trampolineEnabled = true;
    var self = this;
    this.drainQueues = function () {
        self._drainQueues();
    };
    this._schedule =
        schedule.isStatic ? schedule(this.drainQueues) : schedule;
}

Async.prototype.enableTrampoline = function() {
    this._trampolineEnabled = true;
};

Async.prototype.disableTrampolineIfNecessary = function() {
    if (util.hasDevTools) {
        this._trampolineEnabled = false;
    }
};

Async.prototype.haveItemsQueued = function () {
    return this._isTickUsed || this._haveDrainedQueues;
};


Async.prototype.fatalError = function(e, isNode) {
    if (isNode) {
        process.stderr.write("Fatal " + (e instanceof Error ? e.stack : e));
        process.exit(2);
    } else {
        this.throwLater(e);
    }
};

Async.prototype.throwLater = function(fn, arg) {
    if (arguments.length === 1) {
        arg = fn;
        fn = function () { throw arg; };
    }
    if (typeof setTimeout !== "undefined") {
        setTimeout(function() {
            fn(arg);
        }, 0);
    } else try {
        this._schedule(function() {
            fn(arg);
        });
    } catch (e) {
        throw new Error("No async scheduler available\u000a\u000a    See http://goo.gl/MqrFmX\u000a");
    }
};

function AsyncInvokeLater(fn, receiver, arg) {
    this._lateQueue.push(fn, receiver, arg);
    this._queueTick();
}

function AsyncInvoke(fn, receiver, arg) {
    this._normalQueue.push(fn, receiver, arg);
    this._queueTick();
}

function AsyncSettlePromises(promise) {
    this._normalQueue._pushOne(promise);
    this._queueTick();
}

if (!util.hasDevTools) {
    Async.prototype.invokeLater = AsyncInvokeLater;
    Async.prototype.invoke = AsyncInvoke;
    Async.prototype.settlePromises = AsyncSettlePromises;
} else {
    if (schedule.isStatic) {
        schedule = function(fn) { setTimeout(fn, 0); };
    }
    Async.prototype.invokeLater = function (fn, receiver, arg) {
        if (this._trampolineEnabled) {
            AsyncInvokeLater.call(this, fn, receiver, arg);
        } else {
            this._schedule(function() {
                setTimeout(function() {
                    fn.call(receiver, arg);
                }, 100);
            });
        }
    };

    Async.prototype.invoke = function (fn, receiver, arg) {
        if (this._trampolineEnabled) {
            AsyncInvoke.call(this, fn, receiver, arg);
        } else {
            this._schedule(function() {
                fn.call(receiver, arg);
            });
        }
    };

    Async.prototype.settlePromises = function(promise) {
        if (this._trampolineEnabled) {
            AsyncSettlePromises.call(this, promise);
        } else {
            this._schedule(function() {
                promise._settlePromises();
            });
        }
    };
}

Async.prototype.invokeFirst = function (fn, receiver, arg) {
    this._normalQueue.unshift(fn, receiver, arg);
    this._queueTick();
};

Async.prototype._drainQueue = function(queue) {
    while (queue.length() > 0) {
        var fn = queue.shift();
        if (typeof fn !== "function") {
            fn._settlePromises();
            continue;
        }
        var receiver = queue.shift();
        var arg = queue.shift();
        fn.call(receiver, arg);
    }
};

Async.prototype._drainQueues = function () {
    this._drainQueue(this._normalQueue);
    this._reset();
    this._haveDrainedQueues = true;
    this._drainQueue(this._lateQueue);
};

Async.prototype._queueTick = function () {
    if (!this._isTickUsed) {
        this._isTickUsed = true;
        this._schedule(this.drainQueues);
    }
};

Async.prototype._reset = function () {
    this._isTickUsed = false;
};

module.exports = Async;
module.exports.firstLineError = firstLineError;

},{"./queue":26,"./schedule":29,"./util":36}],3:[function(_dereq_,module,exports){
"use strict";
module.exports = function(Promise, INTERNAL, tryConvertToPromise, debug) {
var calledBind = false;
var rejectThis = function(_, e) {
    this._reject(e);
};

var targetRejected = function(e, context) {
    context.promiseRejectionQueued = true;
    context.bindingPromise._then(rejectThis, rejectThis, null, this, e);
};

var bindingResolved = function(thisArg, context) {
    if (((this._bitField & 50397184) === 0)) {
        this._resolveCallback(context.target);
    }
};

var bindingRejected = function(e, context) {
    if (!context.promiseRejectionQueued) this._reject(e);
};

Promise.prototype.bind = function (thisArg) {
    if (!calledBind) {
        calledBind = true;
        Promise.prototype._propagateFrom = debug.propagateFromFunction();
        Promise.prototype._boundValue = debug.boundValueFunction();
    }
    var maybePromise = tryConvertToPromise(thisArg);
    var ret = new Promise(INTERNAL);
    ret._propagateFrom(this, 1);
    var target = this._target();
    ret._setBoundTo(maybePromise);
    if (maybePromise instanceof Promise) {
        var context = {
            promiseRejectionQueued: false,
            promise: ret,
            target: target,
            bindingPromise: maybePromise
        };
        target._then(INTERNAL, targetRejected, undefined, ret, context);
        maybePromise._then(
            bindingResolved, bindingRejected, undefined, ret, context);
        ret._setOnCancel(maybePromise);
    } else {
        ret._resolveCallback(target);
    }
    return ret;
};

Promise.prototype._setBoundTo = function (obj) {
    if (obj !== undefined) {
        this._bitField = this._bitField | 2097152;
        this._boundTo = obj;
    } else {
        this._bitField = this._bitField & (~2097152);
    }
};

Promise.prototype._isBound = function () {
    return (this._bitField & 2097152) === 2097152;
};

Promise.bind = function (thisArg, value) {
    return Promise.resolve(value).bind(thisArg);
};
};

},{}],4:[function(_dereq_,module,exports){
"use strict";
var old;
if (typeof Promise !== "undefined") old = Promise;
function noConflict() {
    try { if (Promise === bluebird) Promise = old; }
    catch (e) {}
    return bluebird;
}
var bluebird = _dereq_("./promise")();
bluebird.noConflict = noConflict;
module.exports = bluebird;

},{"./promise":22}],5:[function(_dereq_,module,exports){
"use strict";
var cr = Object.create;
if (cr) {
    var callerCache = cr(null);
    var getterCache = cr(null);
    callerCache[" size"] = getterCache[" size"] = 0;
}

module.exports = function(Promise) {
var util = _dereq_("./util");
var canEvaluate = util.canEvaluate;
var isIdentifier = util.isIdentifier;

var getMethodCaller;
var getGetter;
if (!true) {
var makeMethodCaller = function (methodName) {
    return new Function("ensureMethod", "                                    \n\
        return function(obj) {                                               \n\
            'use strict'                                                     \n\
            var len = this.length;                                           \n\
            ensureMethod(obj, 'methodName');                                 \n\
            switch(len) {                                                    \n\
                case 1: return obj.methodName(this[0]);                      \n\
                case 2: return obj.methodName(this[0], this[1]);             \n\
                case 3: return obj.methodName(this[0], this[1], this[2]);    \n\
                case 0: return obj.methodName();                             \n\
                default:                                                     \n\
                    return obj.methodName.apply(obj, this);                  \n\
            }                                                                \n\
        };                                                                   \n\
        ".replace(/methodName/g, methodName))(ensureMethod);
};

var makeGetter = function (propertyName) {
    return new Function("obj", "                                             \n\
        'use strict';                                                        \n\
        return obj.propertyName;                                             \n\
        ".replace("propertyName", propertyName));
};

var getCompiled = function(name, compiler, cache) {
    var ret = cache[name];
    if (typeof ret !== "function") {
        if (!isIdentifier(name)) {
            return null;
        }
        ret = compiler(name);
        cache[name] = ret;
        cache[" size"]++;
        if (cache[" size"] > 512) {
            var keys = Object.keys(cache);
            for (var i = 0; i < 256; ++i) delete cache[keys[i]];
            cache[" size"] = keys.length - 256;
        }
    }
    return ret;
};

getMethodCaller = function(name) {
    return getCompiled(name, makeMethodCaller, callerCache);
};

getGetter = function(name) {
    return getCompiled(name, makeGetter, getterCache);
};
}

function ensureMethod(obj, methodName) {
    var fn;
    if (obj != null) fn = obj[methodName];
    if (typeof fn !== "function") {
        var message = "Object " + util.classString(obj) + " has no method '" +
            util.toString(methodName) + "'";
        throw new Promise.TypeError(message);
    }
    return fn;
}

function caller(obj) {
    var methodName = this.pop();
    var fn = ensureMethod(obj, methodName);
    return fn.apply(obj, this);
}
Promise.prototype.call = function (methodName) {
    var args = [].slice.call(arguments, 1);;
    if (!true) {
        if (canEvaluate) {
            var maybeCaller = getMethodCaller(methodName);
            if (maybeCaller !== null) {
                return this._then(
                    maybeCaller, undefined, undefined, args, undefined);
            }
        }
    }
    args.push(methodName);
    return this._then(caller, undefined, undefined, args, undefined);
};

function namedGetter(obj) {
    return obj[this];
}
function indexedGetter(obj) {
    var index = +this;
    if (index < 0) index = Math.max(0, index + obj.length);
    return obj[index];
}
Promise.prototype.get = function (propertyName) {
    var isIndex = (typeof propertyName === "number");
    var getter;
    if (!isIndex) {
        if (canEvaluate) {
            var maybeGetter = getGetter(propertyName);
            getter = maybeGetter !== null ? maybeGetter : namedGetter;
        } else {
            getter = namedGetter;
        }
    } else {
        getter = indexedGetter;
    }
    return this._then(getter, undefined, undefined, propertyName, undefined);
};
};

},{"./util":36}],6:[function(_dereq_,module,exports){
"use strict";
module.exports = function(Promise, PromiseArray, apiRejection, debug) {
var util = _dereq_("./util");
var tryCatch = util.tryCatch;
var errorObj = util.errorObj;
var async = Promise._async;

Promise.prototype["break"] = Promise.prototype.cancel = function() {
    if (!debug.cancellation()) return this._warn("cancellation is disabled");

    var promise = this;
    var child = promise;
    while (promise.isCancellable()) {
        if (!promise._cancelBy(child)) {
            if (child._isFollowing()) {
                child._followee().cancel();
            } else {
                child._cancelBranched();
            }
            break;
        }

        var parent = promise._cancellationParent;
        if (parent == null || !parent.isCancellable()) {
            if (promise._isFollowing()) {
                promise._followee().cancel();
            } else {
                promise._cancelBranched();
            }
            break;
        } else {
            if (promise._isFollowing()) promise._followee().cancel();
            child = promise;
            promise = parent;
        }
    }
};

Promise.prototype._branchHasCancelled = function() {
    this._branchesRemainingToCancel--;
};

Promise.prototype._enoughBranchesHaveCancelled = function() {
    return this._branchesRemainingToCancel === undefined ||
           this._branchesRemainingToCancel <= 0;
};

Promise.prototype._cancelBy = function(canceller) {
    if (canceller === this) {
        this._branchesRemainingToCancel = 0;
        this._invokeOnCancel();
        return true;
    } else {
        this._branchHasCancelled();
        if (this._enoughBranchesHaveCancelled()) {
            this._invokeOnCancel();
            return true;
        }
    }
    return false;
};

Promise.prototype._cancelBranched = function() {
    if (this._enoughBranchesHaveCancelled()) {
        this._cancel();
    }
};

Promise.prototype._cancel = function() {
    if (!this.isCancellable()) return;

    this._setCancelled();
    async.invoke(this._cancelPromises, this, undefined);
};

Promise.prototype._cancelPromises = function() {
    if (this._length() > 0) this._settlePromises();
};

Promise.prototype._unsetOnCancel = function() {
    this._onCancelField = undefined;
};

Promise.prototype.isCancellable = function() {
    return this.isPending() && !this.isCancelled();
};

Promise.prototype._doInvokeOnCancel = function(onCancelCallback, internalOnly) {
    if (util.isArray(onCancelCallback)) {
        for (var i = 0; i < onCancelCallback.length; ++i) {
            this._doInvokeOnCancel(onCancelCallback[i], internalOnly);
        }
    } else if (onCancelCallback !== undefined) {
        if (typeof onCancelCallback === "function") {
            if (!internalOnly) {
                var e = tryCatch(onCancelCallback).call(this._boundValue());
                if (e === errorObj) {
                    this._attachExtraTrace(e.e);
                    async.throwLater(e.e);
                }
            }
        } else {
            onCancelCallback._resultCancelled(this);
        }
    }
};

Promise.prototype._invokeOnCancel = function() {
    var onCancelCallback = this._onCancel();
    this._unsetOnCancel();
    async.invoke(this._doInvokeOnCancel, this, onCancelCallback);
};

Promise.prototype._invokeInternalOnCancel = function() {
    if (this.isCancellable()) {
        this._doInvokeOnCancel(this._onCancel(), true);
        this._unsetOnCancel();
    }
};

Promise.prototype._resultCancelled = function() {
    this.cancel();
};

};

},{"./util":36}],7:[function(_dereq_,module,exports){
"use strict";
module.exports = function(NEXT_FILTER) {
var util = _dereq_("./util");
var getKeys = _dereq_("./es5").keys;
var tryCatch = util.tryCatch;
var errorObj = util.errorObj;

function catchFilter(instances, cb, promise) {
    return function(e) {
        var boundTo = promise._boundValue();
        predicateLoop: for (var i = 0; i < instances.length; ++i) {
            var item = instances[i];

            if (item === Error ||
                (item != null && item.prototype instanceof Error)) {
                if (e instanceof item) {
                    return tryCatch(cb).call(boundTo, e);
                }
            } else if (typeof item === "function") {
                var matchesPredicate = tryCatch(item).call(boundTo, e);
                if (matchesPredicate === errorObj) {
                    return matchesPredicate;
                } else if (matchesPredicate) {
                    return tryCatch(cb).call(boundTo, e);
                }
            } else if (util.isObject(e)) {
                var keys = getKeys(item);
                for (var j = 0; j < keys.length; ++j) {
                    var key = keys[j];
                    if (item[key] != e[key]) {
                        continue predicateLoop;
                    }
                }
                return tryCatch(cb).call(boundTo, e);
            }
        }
        return NEXT_FILTER;
    };
}

return catchFilter;
};

},{"./es5":13,"./util":36}],8:[function(_dereq_,module,exports){
"use strict";
module.exports = function(Promise) {
var longStackTraces = false;
var contextStack = [];

Promise.prototype._promiseCreated = function() {};
Promise.prototype._pushContext = function() {};
Promise.prototype._popContext = function() {return null;};
Promise._peekContext = Promise.prototype._peekContext = function() {};

function Context() {
    this._trace = new Context.CapturedTrace(peekContext());
}
Context.prototype._pushContext = function () {
    if (this._trace !== undefined) {
        this._trace._promiseCreated = null;
        contextStack.push(this._trace);
    }
};

Context.prototype._popContext = function () {
    if (this._trace !== undefined) {
        var trace = contextStack.pop();
        var ret = trace._promiseCreated;
        trace._promiseCreated = null;
        return ret;
    }
    return null;
};

function createContext() {
    if (longStackTraces) return new Context();
}

function peekContext() {
    var lastIndex = contextStack.length - 1;
    if (lastIndex >= 0) {
        return contextStack[lastIndex];
    }
    return undefined;
}
Context.CapturedTrace = null;
Context.create = createContext;
Context.deactivateLongStackTraces = function() {};
Context.activateLongStackTraces = function() {
    var Promise_pushContext = Promise.prototype._pushContext;
    var Promise_popContext = Promise.prototype._popContext;
    var Promise_PeekContext = Promise._peekContext;
    var Promise_peekContext = Promise.prototype._peekContext;
    var Promise_promiseCreated = Promise.prototype._promiseCreated;
    Context.deactivateLongStackTraces = function() {
        Promise.prototype._pushContext = Promise_pushContext;
        Promise.prototype._popContext = Promise_popContext;
        Promise._peekContext = Promise_PeekContext;
        Promise.prototype._peekContext = Promise_peekContext;
        Promise.prototype._promiseCreated = Promise_promiseCreated;
        longStackTraces = false;
    };
    longStackTraces = true;
    Promise.prototype._pushContext = Context.prototype._pushContext;
    Promise.prototype._popContext = Context.prototype._popContext;
    Promise._peekContext = Promise.prototype._peekContext = peekContext;
    Promise.prototype._promiseCreated = function() {
        var ctx = this._peekContext();
        if (ctx && ctx._promiseCreated == null) ctx._promiseCreated = this;
    };
};
return Context;
};

},{}],9:[function(_dereq_,module,exports){
"use strict";
module.exports = function(Promise, Context) {
var getDomain = Promise._getDomain;
var async = Promise._async;
var Warning = _dereq_("./errors").Warning;
var util = _dereq_("./util");
var canAttachTrace = util.canAttachTrace;
var unhandledRejectionHandled;
var possiblyUnhandledRejection;
var bluebirdFramePattern =
    /[\\\/]bluebird[\\\/]js[\\\/](release|debug|instrumented)/;
var stackFramePattern = null;
var formatStack = null;
var indentStackFrames = false;
var printWarning;
var debugging = !!(util.env("BLUEBIRD_DEBUG") != 0 &&
                        (true ||
                         util.env("BLUEBIRD_DEBUG") ||
                         util.env("NODE_ENV") === "development"));
var warnings = !!(util.env("BLUEBIRD_WARNINGS") != 0 &&
    (debugging || util.env("BLUEBIRD_WARNINGS")));
var longStackTraces = !!(util.env("BLUEBIRD_LONG_STACK_TRACES") != 0 &&
    (debugging || util.env("BLUEBIRD_LONG_STACK_TRACES")));

Promise.prototype.suppressUnhandledRejections = function() {
    var target = this._target();
    target._bitField = ((target._bitField & (~1048576)) |
                      2097152);
};

Promise.prototype._ensurePossibleRejectionHandled = function () {
    if ((this._bitField & 2097152) !== 0) return;
    this._setRejectionIsUnhandled();
    async.invokeLater(this._notifyUnhandledRejection, this, undefined);
};

Promise.prototype._notifyUnhandledRejectionIsHandled = function () {
    fireRejectionEvent("rejectionHandled",
                                  unhandledRejectionHandled, undefined, this);
};

Promise.prototype._notifyUnhandledRejection = function () {
    if (this._isRejectionUnhandled()) {
        var reason = this._settledValue();
        this._setUnhandledRejectionIsNotified();
        fireRejectionEvent("unhandledRejection",
                                      possiblyUnhandledRejection, reason, this);
    }
};

Promise.prototype._setUnhandledRejectionIsNotified = function () {
    this._bitField = this._bitField | 262144;
};

Promise.prototype._unsetUnhandledRejectionIsNotified = function () {
    this._bitField = this._bitField & (~262144);
};

Promise.prototype._isUnhandledRejectionNotified = function () {
    return (this._bitField & 262144) > 0;
};

Promise.prototype._setRejectionIsUnhandled = function () {
    this._bitField = this._bitField | 1048576;
};

Promise.prototype._unsetRejectionIsUnhandled = function () {
    this._bitField = this._bitField & (~1048576);
    if (this._isUnhandledRejectionNotified()) {
        this._unsetUnhandledRejectionIsNotified();
        this._notifyUnhandledRejectionIsHandled();
    }
};

Promise.prototype._isRejectionUnhandled = function () {
    return (this._bitField & 1048576) > 0;
};

Promise.prototype._warn = function(message, shouldUseOwnTrace, promise) {
    return warn(message, shouldUseOwnTrace, promise || this);
};

Promise.onPossiblyUnhandledRejection = function (fn) {
    var domain = getDomain();
    possiblyUnhandledRejection =
        typeof fn === "function" ? (domain === null ? fn : domain.bind(fn))
                                 : undefined;
};

Promise.onUnhandledRejectionHandled = function (fn) {
    var domain = getDomain();
    unhandledRejectionHandled =
        typeof fn === "function" ? (domain === null ? fn : domain.bind(fn))
                                 : undefined;
};

var disableLongStackTraces = function() {};
Promise.longStackTraces = function () {
    if (async.haveItemsQueued() && !config.longStackTraces) {
        throw new Error("cannot enable long stack traces after promises have been created\u000a\u000a    See http://goo.gl/MqrFmX\u000a");
    }
    if (!config.longStackTraces && longStackTracesIsSupported()) {
        var Promise_captureStackTrace = Promise.prototype._captureStackTrace;
        var Promise_attachExtraTrace = Promise.prototype._attachExtraTrace;
        config.longStackTraces = true;
        disableLongStackTraces = function() {
            if (async.haveItemsQueued() && !config.longStackTraces) {
                throw new Error("cannot enable long stack traces after promises have been created\u000a\u000a    See http://goo.gl/MqrFmX\u000a");
            }
            Promise.prototype._captureStackTrace = Promise_captureStackTrace;
            Promise.prototype._attachExtraTrace = Promise_attachExtraTrace;
            Context.deactivateLongStackTraces();
            async.enableTrampoline();
            config.longStackTraces = false;
        };
        Promise.prototype._captureStackTrace = longStackTracesCaptureStackTrace;
        Promise.prototype._attachExtraTrace = longStackTracesAttachExtraTrace;
        Context.activateLongStackTraces();
        async.disableTrampolineIfNecessary();
    }
};

Promise.hasLongStackTraces = function () {
    return config.longStackTraces && longStackTracesIsSupported();
};

Promise.config = function(opts) {
    opts = Object(opts);
    if ("longStackTraces" in opts) {
        if (opts.longStackTraces) {
            Promise.longStackTraces();
        } else if (!opts.longStackTraces && Promise.hasLongStackTraces()) {
            disableLongStackTraces();
        }
    }
    if ("warnings" in opts) {
        config.warnings = !!opts.warnings;
    }
    if ("cancellation" in opts && opts.cancellation && !config.cancellation) {
        if (async.haveItemsQueued()) {
            throw new Error(
                "cannot enable cancellation after promises are in use");
        }
        Promise.prototype._clearCancellationData =
            cancellationClearCancellationData;
        Promise.prototype._propagateFrom = cancellationPropagateFrom;
        Promise.prototype._onCancel = cancellationOnCancel;
        Promise.prototype._setOnCancel = cancellationSetOnCancel;
        Promise.prototype._attachCancellationCallback =
            cancellationAttachCancellationCallback;
        Promise.prototype._execute = cancellationExecute;
        propagateFromFunction = cancellationPropagateFrom;
        config.cancellation = true;
    }
};

Promise.prototype._execute = function(executor, resolve, reject) {
    try {
        executor(resolve, reject);
    } catch (e) {
        return e;
    }
};
Promise.prototype._onCancel = function () {};
Promise.prototype._setOnCancel = function (handler) { ; };
Promise.prototype._attachCancellationCallback = function(onCancel) {
    ;
};
Promise.prototype._captureStackTrace = function () {};
Promise.prototype._attachExtraTrace = function () {};
Promise.prototype._clearCancellationData = function() {};
Promise.prototype._propagateFrom = function (parent, flags) {
    ;
    ;
};

function cancellationExecute(executor, resolve, reject) {
    var promise = this;
    try {
        executor(resolve, reject, function(onCancel) {
            if (typeof onCancel !== "function") {
                throw new TypeError("onCancel must be a function, got: " +
                                    util.toString(onCancel));
            }
            promise._attachCancellationCallback(onCancel);
        });
    } catch (e) {
        return e;
    }
}

function cancellationAttachCancellationCallback(onCancel) {
    if (!this.isCancellable()) return this;

    var previousOnCancel = this._onCancel();
    if (previousOnCancel !== undefined) {
        if (util.isArray(previousOnCancel)) {
            previousOnCancel.push(onCancel);
        } else {
            this._setOnCancel([previousOnCancel, onCancel]);
        }
    } else {
        this._setOnCancel(onCancel);
    }
}

function cancellationOnCancel() {
    return this._onCancelField;
}

function cancellationSetOnCancel(onCancel) {
    this._onCancelField = onCancel;
}

function cancellationClearCancellationData() {
    this._cancellationParent = undefined;
    this._onCancelField = undefined;
}

function cancellationPropagateFrom(parent, flags) {
    if ((flags & 1) !== 0) {
        this._cancellationParent = parent;
        var branchesRemainingToCancel = parent._branchesRemainingToCancel;
        if (branchesRemainingToCancel === undefined) {
            branchesRemainingToCancel = 0;
        }
        parent._branchesRemainingToCancel = branchesRemainingToCancel + 1;
    }
    if ((flags & 2) !== 0 && parent._isBound()) {
        this._setBoundTo(parent._boundTo);
    }
}

function bindingPropagateFrom(parent, flags) {
    if ((flags & 2) !== 0 && parent._isBound()) {
        this._setBoundTo(parent._boundTo);
    }
}
var propagateFromFunction = bindingPropagateFrom;

function boundValueFunction() {
    var ret = this._boundTo;
    if (ret !== undefined) {
        if (ret instanceof Promise) {
            if (ret.isFulfilled()) {
                return ret.value();
            } else {
                return undefined;
            }
        }
    }
    return ret;
}

function longStackTracesCaptureStackTrace() {
    this._trace = new CapturedTrace(this._peekContext());
}

function longStackTracesAttachExtraTrace(error, ignoreSelf) {
    if (canAttachTrace(error)) {
        var trace = this._trace;
        if (trace !== undefined) {
            if (ignoreSelf) trace = trace._parent;
        }
        if (trace !== undefined) {
            trace.attachExtraTrace(error);
        } else if (!error.__stackCleaned__) {
            var parsed = parseStackAndMessage(error);
            util.notEnumerableProp(error, "stack",
                parsed.message + "\n" + parsed.stack.join("\n"));
            util.notEnumerableProp(error, "__stackCleaned__", true);
        }
    }
}

function checkForgottenReturns(returnValue, promiseCreated, name, promise) {
    if (returnValue === undefined &&
        promiseCreated !== null &&
        config.longStackTraces &&
        config.warnings) {
        var msg = "a promise was created in a " + name +
            " handler but was not returned from it";
        promise._warn(msg, true, promiseCreated);
    }
}

function deprecated(name, replacement) {
    var message = name +
        " is deprecated and will be removed in a future version.";
    if (replacement) message += " Use " + replacement + " instead.";
    return warn(message);
}

function warn(message, shouldUseOwnTrace, promise) {
    if (!config.warnings) return;
    var warning = new Warning(message);
    var ctx;
    if (shouldUseOwnTrace) {
        promise._attachExtraTrace(warning);
    } else if (config.longStackTraces && (ctx = Promise._peekContext())) {
        ctx.attachExtraTrace(warning);
    } else {
        var parsed = parseStackAndMessage(warning);
        warning.stack = parsed.message + "\n" + parsed.stack.join("\n");
    }
    formatAndLogError(warning, "", true);
}

function reconstructStack(message, stacks) {
    for (var i = 0; i < stacks.length - 1; ++i) {
        stacks[i].push("From previous event:");
        stacks[i] = stacks[i].join("\n");
    }
    if (i < stacks.length) {
        stacks[i] = stacks[i].join("\n");
    }
    return message + "\n" + stacks.join("\n");
}

function removeDuplicateOrEmptyJumps(stacks) {
    for (var i = 0; i < stacks.length; ++i) {
        if (stacks[i].length === 0 ||
            ((i + 1 < stacks.length) && stacks[i][0] === stacks[i+1][0])) {
            stacks.splice(i, 1);
            i--;
        }
    }
}

function removeCommonRoots(stacks) {
    var current = stacks[0];
    for (var i = 1; i < stacks.length; ++i) {
        var prev = stacks[i];
        var currentLastIndex = current.length - 1;
        var currentLastLine = current[currentLastIndex];
        var commonRootMeetPoint = -1;

        for (var j = prev.length - 1; j >= 0; --j) {
            if (prev[j] === currentLastLine) {
                commonRootMeetPoint = j;
                break;
            }
        }

        for (var j = commonRootMeetPoint; j >= 0; --j) {
            var line = prev[j];
            if (current[currentLastIndex] === line) {
                current.pop();
                currentLastIndex--;
            } else {
                break;
            }
        }
        current = prev;
    }
}

function cleanStack(stack) {
    var ret = [];
    for (var i = 0; i < stack.length; ++i) {
        var line = stack[i];
        var isTraceLine = "    (No stack trace)" === line ||
            stackFramePattern.test(line);
        var isInternalFrame = isTraceLine && shouldIgnore(line);
        if (isTraceLine && !isInternalFrame) {
            if (indentStackFrames && line.charAt(0) !== " ") {
                line = "    " + line;
            }
            ret.push(line);
        }
    }
    return ret;
}

function stackFramesAsArray(error) {
    var stack = error.stack.replace(/\s+$/g, "").split("\n");
    for (var i = 0; i < stack.length; ++i) {
        var line = stack[i];
        if ("    (No stack trace)" === line || stackFramePattern.test(line)) {
            break;
        }
    }
    if (i > 0) {
        stack = stack.slice(i);
    }
    return stack;
}

function parseStackAndMessage(error) {
    var stack = error.stack;
    var message = error.toString();
    stack = typeof stack === "string" && stack.length > 0
                ? stackFramesAsArray(error) : ["    (No stack trace)"];
    return {
        message: message,
        stack: cleanStack(stack)
    };
}

function formatAndLogError(error, title, isSoft) {
    if (typeof console !== "undefined") {
        var message;
        if (util.isObject(error)) {
            var stack = error.stack;
            message = title + formatStack(stack, error);
        } else {
            message = title + String(error);
        }
        if (typeof printWarning === "function") {
            printWarning(message, isSoft);
        } else if (typeof console.log === "function" ||
            typeof console.log === "object") {
            console.log(message);
        }
    }
}

function fireRejectionEvent(name, localHandler, reason, promise) {
    var localEventFired = false;
    try {
        if (typeof localHandler === "function") {
            localEventFired = true;
            if (name === "rejectionHandled") {
                localHandler(promise);
            } else {
                localHandler(reason, promise);
            }
        }
    } catch (e) {
        async.throwLater(e);
    }

    var globalEventFired = false;
    try {
        globalEventFired = fireGlobalEvent(name, reason, promise);
    } catch (e) {
        globalEventFired = true;
        async.throwLater(e);
    }

    var domEventFired = false;
    if (fireDomEvent) {
        try {
            domEventFired = fireDomEvent(name.toLowerCase(), {
                reason: reason,
                promise: promise
            });
        } catch (e) {
            domEventFired = true;
            async.throwLater(e);
        }
    }

    if (!globalEventFired && !localEventFired && !domEventFired &&
        name === "unhandledRejection") {
        formatAndLogError(reason, "Unhandled rejection ");
    }
}

function formatNonError(obj) {
    var str;
    if (typeof obj === "function") {
        str = "[function " +
            (obj.name || "anonymous") +
            "]";
    } else {
        str = obj && typeof obj.toString === "function"
            ? obj.toString() : util.toString(obj);
        var ruselessToString = /\[object [a-zA-Z0-9$_]+\]/;
        if (ruselessToString.test(str)) {
            try {
                var newStr = JSON.stringify(obj);
                str = newStr;
            }
            catch(e) {

            }
        }
        if (str.length === 0) {
            str = "(empty array)";
        }
    }
    return ("(<" + snip(str) + ">, no stack trace)");
}

function snip(str) {
    var maxChars = 41;
    if (str.length < maxChars) {
        return str;
    }
    return str.substr(0, maxChars - 3) + "...";
}

function longStackTracesIsSupported() {
    return typeof captureStackTrace === "function";
}

var shouldIgnore = function() { return false; };
var parseLineInfoRegex = /[\/<\(]([^:\/]+):(\d+):(?:\d+)\)?\s*$/;
function parseLineInfo(line) {
    var matches = line.match(parseLineInfoRegex);
    if (matches) {
        return {
            fileName: matches[1],
            line: parseInt(matches[2], 10)
        };
    }
}

function setBounds(firstLineError, lastLineError) {
    if (!longStackTracesIsSupported()) return;
    var firstStackLines = firstLineError.stack.split("\n");
    var lastStackLines = lastLineError.stack.split("\n");
    var firstIndex = -1;
    var lastIndex = -1;
    var firstFileName;
    var lastFileName;
    for (var i = 0; i < firstStackLines.length; ++i) {
        var result = parseLineInfo(firstStackLines[i]);
        if (result) {
            firstFileName = result.fileName;
            firstIndex = result.line;
            break;
        }
    }
    for (var i = 0; i < lastStackLines.length; ++i) {
        var result = parseLineInfo(lastStackLines[i]);
        if (result) {
            lastFileName = result.fileName;
            lastIndex = result.line;
            break;
        }
    }
    if (firstIndex < 0 || lastIndex < 0 || !firstFileName || !lastFileName ||
        firstFileName !== lastFileName || firstIndex >= lastIndex) {
        return;
    }

    shouldIgnore = function(line) {
        if (bluebirdFramePattern.test(line)) return true;
        var info = parseLineInfo(line);
        if (info) {
            if (info.fileName === firstFileName &&
                (firstIndex <= info.line && info.line <= lastIndex)) {
                return true;
            }
        }
        return false;
    };
}

function CapturedTrace(parent) {
    this._parent = parent;
    this._promisesCreated = 0;
    var length = this._length = 1 + (parent === undefined ? 0 : parent._length);
    captureStackTrace(this, CapturedTrace);
    if (length > 32) this.uncycle();
}
util.inherits(CapturedTrace, Error);
Context.CapturedTrace = CapturedTrace;

CapturedTrace.prototype.uncycle = function() {
    var length = this._length;
    if (length < 2) return;
    var nodes = [];
    var stackToIndex = {};

    for (var i = 0, node = this; node !== undefined; ++i) {
        nodes.push(node);
        node = node._parent;
    }
    length = this._length = i;
    for (var i = length - 1; i >= 0; --i) {
        var stack = nodes[i].stack;
        if (stackToIndex[stack] === undefined) {
            stackToIndex[stack] = i;
        }
    }
    for (var i = 0; i < length; ++i) {
        var currentStack = nodes[i].stack;
        var index = stackToIndex[currentStack];
        if (index !== undefined && index !== i) {
            if (index > 0) {
                nodes[index - 1]._parent = undefined;
                nodes[index - 1]._length = 1;
            }
            nodes[i]._parent = undefined;
            nodes[i]._length = 1;
            var cycleEdgeNode = i > 0 ? nodes[i - 1] : this;

            if (index < length - 1) {
                cycleEdgeNode._parent = nodes[index + 1];
                cycleEdgeNode._parent.uncycle();
                cycleEdgeNode._length =
                    cycleEdgeNode._parent._length + 1;
            } else {
                cycleEdgeNode._parent = undefined;
                cycleEdgeNode._length = 1;
            }
            var currentChildLength = cycleEdgeNode._length + 1;
            for (var j = i - 2; j >= 0; --j) {
                nodes[j]._length = currentChildLength;
                currentChildLength++;
            }
            return;
        }
    }
};

CapturedTrace.prototype.attachExtraTrace = function(error) {
    if (error.__stackCleaned__) return;
    this.uncycle();
    var parsed = parseStackAndMessage(error);
    var message = parsed.message;
    var stacks = [parsed.stack];

    var trace = this;
    while (trace !== undefined) {
        stacks.push(cleanStack(trace.stack.split("\n")));
        trace = trace._parent;
    }
    removeCommonRoots(stacks);
    removeDuplicateOrEmptyJumps(stacks);
    util.notEnumerableProp(error, "stack", reconstructStack(message, stacks));
    util.notEnumerableProp(error, "__stackCleaned__", true);
};

var captureStackTrace = (function stackDetection() {
    var v8stackFramePattern = /^\s*at\s*/;
    var v8stackFormatter = function(stack, error) {
        if (typeof stack === "string") return stack;

        if (error.name !== undefined &&
            error.message !== undefined) {
            return error.toString();
        }
        return formatNonError(error);
    };

    if (typeof Error.stackTraceLimit === "number" &&
        typeof Error.captureStackTrace === "function") {
        Error.stackTraceLimit += 6;
        stackFramePattern = v8stackFramePattern;
        formatStack = v8stackFormatter;
        var captureStackTrace = Error.captureStackTrace;

        shouldIgnore = function(line) {
            return bluebirdFramePattern.test(line);
        };
        return function(receiver, ignoreUntil) {
            Error.stackTraceLimit += 6;
            captureStackTrace(receiver, ignoreUntil);
            Error.stackTraceLimit -= 6;
        };
    }
    var err = new Error();

    if (typeof err.stack === "string" &&
        err.stack.split("\n")[0].indexOf("stackDetection@") >= 0) {
        stackFramePattern = /@/;
        formatStack = v8stackFormatter;
        indentStackFrames = true;
        return function captureStackTrace(o) {
            o.stack = new Error().stack;
        };
    }

    var hasStackAfterThrow;
    try { throw new Error(); }
    catch(e) {
        hasStackAfterThrow = ("stack" in e);
    }
    if (!("stack" in err) && hasStackAfterThrow &&
        typeof Error.stackTraceLimit === "number") {
        stackFramePattern = v8stackFramePattern;
        formatStack = v8stackFormatter;
        return function captureStackTrace(o) {
            Error.stackTraceLimit += 6;
            try { throw new Error(); }
            catch(e) { o.stack = e.stack; }
            Error.stackTraceLimit -= 6;
        };
    }

    formatStack = function(stack, error) {
        if (typeof stack === "string") return stack;

        if ((typeof error === "object" ||
            typeof error === "function") &&
            error.name !== undefined &&
            error.message !== undefined) {
            return error.toString();
        }
        return formatNonError(error);
    };

    return null;

})([]);

var fireDomEvent;
var fireGlobalEvent = (function() {
    if (util.isNode) {
        return function(name, reason, promise) {
            if (name === "rejectionHandled") {
                return process.emit(name, promise);
            } else {
                return process.emit(name, reason, promise);
            }
        };
    } else {
        var customEventWorks = false;
        var anyEventWorks = true;
        try {
            var ev = new self.CustomEvent("test");
            customEventWorks = ev instanceof CustomEvent;
        } catch (e) {}
        if (!customEventWorks) {
            try {
                var event = document.createEvent("CustomEvent");
                event.initCustomEvent("testingtheevent", false, true, {});
                self.dispatchEvent(event);
            } catch (e) {
                anyEventWorks = false;
            }
        }
        if (anyEventWorks) {
            fireDomEvent = function(type, detail) {
                var event;
                if (customEventWorks) {
                    event = new self.CustomEvent(type, {
                        detail: detail,
                        bubbles: false,
                        cancelable: true
                    });
                } else if (self.dispatchEvent) {
                    event = document.createEvent("CustomEvent");
                    event.initCustomEvent(type, false, true, detail);
                }

                return event ? !self.dispatchEvent(event) : false;
            };
        }

        var toWindowMethodNameMap = {};
        toWindowMethodNameMap["unhandledRejection"] = ("on" +
            "unhandledRejection").toLowerCase();
        toWindowMethodNameMap["rejectionHandled"] = ("on" +
            "rejectionHandled").toLowerCase();

        return function(name, reason, promise) {
            var methodName = toWindowMethodNameMap[name];
            var method = self[methodName];
            if (!method) return false;
            if (name === "rejectionHandled") {
                method.call(self, promise);
            } else {
                method.call(self, reason, promise);
            }
            return true;
        };
    }
})();

if (typeof console !== "undefined" && typeof console.warn !== "undefined") {
    printWarning = function (message) {
        console.warn(message);
    };
    if (util.isNode && process.stderr.isTTY) {
        printWarning = function(message, isSoft) {
            var color = isSoft ? "\u001b[33m" : "\u001b[31m";
            console.warn(color + message + "\u001b[0m\n");
        };
    } else if (!util.isNode && typeof (new Error().stack) === "string") {
        printWarning = function(message, isSoft) {
            console.warn("%c" + message,
                        isSoft ? "color: darkorange" : "color: red");
        };
    }
}

var config = {
    warnings: warnings,
    longStackTraces: false,
    cancellation: false
};

if (longStackTraces) Promise.longStackTraces();

return {
    longStackTraces: function() {
        return config.longStackTraces;
    },
    warnings: function() {
        return config.warnings;
    },
    cancellation: function() {
        return config.cancellation;
    },
    propagateFromFunction: function() {
        return propagateFromFunction;
    },
    boundValueFunction: function() {
        return boundValueFunction;
    },
    checkForgottenReturns: checkForgottenReturns,
    setBounds: setBounds,
    warn: warn,
    deprecated: deprecated,
    CapturedTrace: CapturedTrace
};
};

},{"./errors":12,"./util":36}],10:[function(_dereq_,module,exports){
"use strict";
module.exports = function(Promise) {
function returner() {
    return this.value;
}
function thrower() {
    throw this.reason;
}

Promise.prototype["return"] =
Promise.prototype.thenReturn = function (value) {
    if (value instanceof Promise) value.suppressUnhandledRejections();
    return this._then(
        returner, undefined, undefined, {value: value}, undefined);
};

Promise.prototype["throw"] =
Promise.prototype.thenThrow = function (reason) {
    return this._then(
        thrower, undefined, undefined, {reason: reason}, undefined);
};

Promise.prototype.catchThrow = function (reason) {
    if (arguments.length <= 1) {
        return this._then(
            undefined, thrower, undefined, {reason: reason}, undefined);
    } else {
        var _reason = arguments[1];
        var handler = function() {throw _reason;};
        return this.caught(reason, handler);
    }
};

Promise.prototype.catchReturn = function (value) {
    if (arguments.length <= 1) {
        if (value instanceof Promise) value.suppressUnhandledRejections();
        return this._then(
            undefined, returner, undefined, {value: value}, undefined);
    } else {
        var _value = arguments[1];
        if (_value instanceof Promise) _value.suppressUnhandledRejections();
        var handler = function() {return _value;};
        return this.caught(value, handler);
    }
};
};

},{}],11:[function(_dereq_,module,exports){
"use strict";
module.exports = function(Promise, INTERNAL) {
var PromiseReduce = Promise.reduce;
var PromiseAll = Promise.all;

function promiseAllThis() {
    return PromiseAll(this);
}

function PromiseMapSeries(promises, fn) {
    return PromiseReduce(promises, fn, INTERNAL, INTERNAL);
}

Promise.prototype.each = function (fn) {
    return this.mapSeries(fn)
            ._then(promiseAllThis, undefined, undefined, this, undefined);
};

Promise.prototype.mapSeries = function (fn) {
    return PromiseReduce(this, fn, INTERNAL, INTERNAL);
};

Promise.each = function (promises, fn) {
    return PromiseMapSeries(promises, fn)
            ._then(promiseAllThis, undefined, undefined, promises, undefined);
};

Promise.mapSeries = PromiseMapSeries;
};

},{}],12:[function(_dereq_,module,exports){
"use strict";
var es5 = _dereq_("./es5");
var Objectfreeze = es5.freeze;
var util = _dereq_("./util");
var inherits = util.inherits;
var notEnumerableProp = util.notEnumerableProp;

function subError(nameProperty, defaultMessage) {
    function SubError(message) {
        if (!(this instanceof SubError)) return new SubError(message);
        notEnumerableProp(this, "message",
            typeof message === "string" ? message : defaultMessage);
        notEnumerableProp(this, "name", nameProperty);
        if (Error.captureStackTrace) {
            Error.captureStackTrace(this, this.constructor);
        } else {
            Error.call(this);
        }
    }
    inherits(SubError, Error);
    return SubError;
}

var _TypeError, _RangeError;
var Warning = subError("Warning", "warning");
var CancellationError = subError("CancellationError", "cancellation error");
var TimeoutError = subError("TimeoutError", "timeout error");
var AggregateError = subError("AggregateError", "aggregate error");
try {
    _TypeError = TypeError;
    _RangeError = RangeError;
} catch(e) {
    _TypeError = subError("TypeError", "type error");
    _RangeError = subError("RangeError", "range error");
}

var methods = ("join pop push shift unshift slice filter forEach some " +
    "every map indexOf lastIndexOf reduce reduceRight sort reverse").split(" ");

for (var i = 0; i < methods.length; ++i) {
    if (typeof Array.prototype[methods[i]] === "function") {
        AggregateError.prototype[methods[i]] = Array.prototype[methods[i]];
    }
}

es5.defineProperty(AggregateError.prototype, "length", {
    value: 0,
    configurable: false,
    writable: true,
    enumerable: true
});
AggregateError.prototype["isOperational"] = true;
var level = 0;
AggregateError.prototype.toString = function() {
    var indent = Array(level * 4 + 1).join(" ");
    var ret = "\n" + indent + "AggregateError of:" + "\n";
    level++;
    indent = Array(level * 4 + 1).join(" ");
    for (var i = 0; i < this.length; ++i) {
        var str = this[i] === this ? "[Circular AggregateError]" : this[i] + "";
        var lines = str.split("\n");
        for (var j = 0; j < lines.length; ++j) {
            lines[j] = indent + lines[j];
        }
        str = lines.join("\n");
        ret += str + "\n";
    }
    level--;
    return ret;
};

function OperationalError(message) {
    if (!(this instanceof OperationalError))
        return new OperationalError(message);
    notEnumerableProp(this, "name", "OperationalError");
    notEnumerableProp(this, "message", message);
    this.cause = message;
    this["isOperational"] = true;

    if (message instanceof Error) {
        notEnumerableProp(this, "message", message.message);
        notEnumerableProp(this, "stack", message.stack);
    } else if (Error.captureStackTrace) {
        Error.captureStackTrace(this, this.constructor);
    }

}
inherits(OperationalError, Error);

var errorTypes = Error["__BluebirdErrorTypes__"];
if (!errorTypes) {
    errorTypes = Objectfreeze({
        CancellationError: CancellationError,
        TimeoutError: TimeoutError,
        OperationalError: OperationalError,
        RejectionError: OperationalError,
        AggregateError: AggregateError
    });
    notEnumerableProp(Error, "__BluebirdErrorTypes__", errorTypes);
}

module.exports = {
    Error: Error,
    TypeError: _TypeError,
    RangeError: _RangeError,
    CancellationError: errorTypes.CancellationError,
    OperationalError: errorTypes.OperationalError,
    TimeoutError: errorTypes.TimeoutError,
    AggregateError: errorTypes.AggregateError,
    Warning: Warning
};

},{"./es5":13,"./util":36}],13:[function(_dereq_,module,exports){
var isES5 = (function(){
    "use strict";
    return this === undefined;
})();

if (isES5) {
    module.exports = {
        freeze: Object.freeze,
        defineProperty: Object.defineProperty,
        getDescriptor: Object.getOwnPropertyDescriptor,
        keys: Object.keys,
        names: Object.getOwnPropertyNames,
        getPrototypeOf: Object.getPrototypeOf,
        isArray: Array.isArray,
        isES5: isES5,
        propertyIsWritable: function(obj, prop) {
            var descriptor = Object.getOwnPropertyDescriptor(obj, prop);
            return !!(!descriptor || descriptor.writable || descriptor.set);
        }
    };
} else {
    var has = {}.hasOwnProperty;
    var str = {}.toString;
    var proto = {}.constructor.prototype;

    var ObjectKeys = function (o) {
        var ret = [];
        for (var key in o) {
            if (has.call(o, key)) {
                ret.push(key);
            }
        }
        return ret;
    };

    var ObjectGetDescriptor = function(o, key) {
        return {value: o[key]};
    };

    var ObjectDefineProperty = function (o, key, desc) {
        o[key] = desc.value;
        return o;
    };

    var ObjectFreeze = function (obj) {
        return obj;
    };

    var ObjectGetPrototypeOf = function (obj) {
        try {
            return Object(obj).constructor.prototype;
        }
        catch (e) {
            return proto;
        }
    };

    var ArrayIsArray = function (obj) {
        try {
            return str.call(obj) === "[object Array]";
        }
        catch(e) {
            return false;
        }
    };

    module.exports = {
        isArray: ArrayIsArray,
        keys: ObjectKeys,
        names: ObjectKeys,
        defineProperty: ObjectDefineProperty,
        getDescriptor: ObjectGetDescriptor,
        freeze: ObjectFreeze,
        getPrototypeOf: ObjectGetPrototypeOf,
        isES5: isES5,
        propertyIsWritable: function() {
            return true;
        }
    };
}

},{}],14:[function(_dereq_,module,exports){
"use strict";
module.exports = function(Promise, INTERNAL) {
var PromiseMap = Promise.map;

Promise.prototype.filter = function (fn, options) {
    return PromiseMap(this, fn, options, INTERNAL);
};

Promise.filter = function (promises, fn, options) {
    return PromiseMap(promises, fn, options, INTERNAL);
};
};

},{}],15:[function(_dereq_,module,exports){
"use strict";
module.exports = function(Promise, tryConvertToPromise) {
var util = _dereq_("./util");
var CancellationError = Promise.CancellationError;
var errorObj = util.errorObj;

function FinallyHandlerCancelReaction(finallyHandler) {
    this.finallyHandler = finallyHandler;
}

FinallyHandlerCancelReaction.prototype._resultCancelled = function() {
    checkCancel(this.finallyHandler);
};

function checkCancel(ctx, reason) {
    if (ctx.cancelPromise != null) {
        if (arguments.length > 1) {
            ctx.cancelPromise._reject(reason);
        } else {
            ctx.cancelPromise._cancel();
        }
        ctx.cancelPromise = null;
        return true;
    }
    return false;
}

function succeed() {
    return finallyHandler.call(this, this.promise._target()._settledValue());
}
function fail(reason) {
    if (checkCancel(this, reason)) return;
    errorObj.e = reason;
    return errorObj;
}
function finallyHandler(reasonOrValue) {
    var promise = this.promise;
    var handler = this.handler;

    if (!this.called) {
        this.called = true;
        var ret = this.type === 0
            ? handler.call(promise._boundValue())
            : handler.call(promise._boundValue(), reasonOrValue);
        if (ret !== undefined) {
            var maybePromise = tryConvertToPromise(ret, promise);
            if (maybePromise instanceof Promise) {
                if (this.cancelPromise != null) {
                    if (maybePromise.isCancelled()) {
                        var reason =
                            new CancellationError("late cancellation observer");
                        promise._attachExtraTrace(reason);
                        errorObj.e = reason;
                        return errorObj;
                    } else if (maybePromise.isPending()) {
                        maybePromise._attachCancellationCallback(
                            new FinallyHandlerCancelReaction(this));
                    }
                }
                return maybePromise._then(
                    succeed, fail, undefined, this, undefined);
            }
        }
    }

    if (promise.isRejected()) {
        checkCancel(this);
        errorObj.e = reasonOrValue;
        return errorObj;
    } else {
        checkCancel(this);
        return reasonOrValue;
    }
}

Promise.prototype._passThrough = function(handler, type, success, fail) {
    if (typeof handler !== "function") return this.then();
    return this._then(success, fail, undefined, {
        promise: this,
        handler: handler,
        called: false,
        cancelPromise: null,
        type: type
    }, undefined);
};

Promise.prototype.lastly =
Promise.prototype["finally"] = function (handler) {
    return this._passThrough(handler,
                             0,
                             finallyHandler,
                             finallyHandler);
};

Promise.prototype.tap = function (handler) {
    return this._passThrough(handler, 1, finallyHandler);
};

return finallyHandler;
};

},{"./util":36}],16:[function(_dereq_,module,exports){
"use strict";
module.exports = function(Promise,
                          apiRejection,
                          INTERNAL,
                          tryConvertToPromise,
                          Proxyable,
                          debug) {
var errors = _dereq_("./errors");
var TypeError = errors.TypeError;
var util = _dereq_("./util");
var errorObj = util.errorObj;
var tryCatch = util.tryCatch;
var yieldHandlers = [];

function promiseFromYieldHandler(value, yieldHandlers, traceParent) {
    for (var i = 0; i < yieldHandlers.length; ++i) {
        traceParent._pushContext();
        var result = tryCatch(yieldHandlers[i])(value);
        traceParent._popContext();
        if (result === errorObj) {
            traceParent._pushContext();
            var ret = Promise.reject(errorObj.e);
            traceParent._popContext();
            return ret;
        }
        var maybePromise = tryConvertToPromise(result, traceParent);
        if (maybePromise instanceof Promise) return maybePromise;
    }
    return null;
}

function PromiseSpawn(generatorFunction, receiver, yieldHandler, stack) {
    var promise = this._promise = new Promise(INTERNAL);
    promise._captureStackTrace();
    promise._setOnCancel(this);
    this._stack = stack;
    this._generatorFunction = generatorFunction;
    this._receiver = receiver;
    this._generator = undefined;
    this._yieldHandlers = typeof yieldHandler === "function"
        ? [yieldHandler].concat(yieldHandlers)
        : yieldHandlers;
    this._yieldedPromise = null;
}
util.inherits(PromiseSpawn, Proxyable);

PromiseSpawn.prototype._isResolved = function() {
    return this.promise === null;
};

PromiseSpawn.prototype._cleanup = function() {
    this._promise = this._generator = null;
};

PromiseSpawn.prototype._promiseCancelled = function() {
    if (this._isResolved()) return;
    var implementsReturn = typeof this._generator["return"] !== "undefined";

    var result;
    if (!implementsReturn) {
        var reason = new Promise.CancellationError(
            "generator .return() sentinel");
        Promise.coroutine.returnSentinel = reason;
        this._promise._attachExtraTrace(reason);
        this._promise._pushContext();
        result = tryCatch(this._generator["throw"]).call(this._generator,
                                                         reason);
        this._promise._popContext();
        if (result === errorObj && result.e === reason) {
            result = null;
        }
    } else {
        this._promise._pushContext();
        result = tryCatch(this._generator["return"]).call(this._generator,
                                                          undefined);
        this._promise._popContext();
    }
    var promise = this._promise;
    this._cleanup();
    if (result === errorObj) {
        promise._rejectCallback(result.e, false);
    } else {
        promise.cancel();
    }
};

PromiseSpawn.prototype._promiseFulfilled = function(value) {
    this._yieldedPromise = null;
    this._promise._pushContext();
    var result = tryCatch(this._generator.next).call(this._generator, value);
    this._promise._popContext();
    this._continue(result);
};

PromiseSpawn.prototype._promiseRejected = function(reason) {
    this._yieldedPromise = null;
    this._promise._attachExtraTrace(reason);
    this._promise._pushContext();
    var result = tryCatch(this._generator["throw"])
        .call(this._generator, reason);
    this._promise._popContext();
    this._continue(result);
};

PromiseSpawn.prototype._resultCancelled = function() {
    if (this._yieldedPromise instanceof Promise) {
        var promise = this._yieldedPromise;
        this._yieldedPromise = null;
        promise.cancel();
    }
};

PromiseSpawn.prototype.promise = function () {
    return this._promise;
};

PromiseSpawn.prototype._run = function () {
    this._generator = this._generatorFunction.call(this._receiver);
    this._receiver =
        this._generatorFunction = undefined;
    this._promiseFulfilled(undefined);
};

PromiseSpawn.prototype._continue = function (result) {
    var promise = this._promise;
    if (result === errorObj) {
        this._cleanup();
        return promise._rejectCallback(result.e, false);
    }

    var value = result.value;
    if (result.done === true) {
        this._cleanup();
        return promise._resolveCallback(value);
    } else {
        var maybePromise = tryConvertToPromise(value, this._promise);
        if (!(maybePromise instanceof Promise)) {
            maybePromise =
                promiseFromYieldHandler(maybePromise,
                                        this._yieldHandlers,
                                        this._promise);
            if (maybePromise === null) {
                this._promiseRejected(
                    new TypeError(
                        "A value %s was yielded that could not be treated as a promise\u000a\u000a    See http://goo.gl/MqrFmX\u000a\u000a".replace("%s", value) +
                        "From coroutine:\u000a" +
                        this._stack.split("\n").slice(1, -7).join("\n")
                    )
                );
                return;
            }
        }
        maybePromise = maybePromise._target();
        var bitField = maybePromise._bitField;
        ;
        if (((bitField & 50397184) === 0)) {
            this._yieldedPromise = maybePromise;
            maybePromise._proxy(this, null);
        } else if (((bitField & 33554432) !== 0)) {
            this._promiseFulfilled(maybePromise._value());
        } else if (((bitField & 16777216) !== 0)) {
            this._promiseRejected(maybePromise._reason());
        } else {
            this._promiseCancelled();
        }
    }
};

Promise.coroutine = function (generatorFunction, options) {
    if (typeof generatorFunction !== "function") {
        throw new TypeError("generatorFunction must be a function\u000a\u000a    See http://goo.gl/MqrFmX\u000a");
    }
    var yieldHandler = Object(options).yieldHandler;
    var PromiseSpawn$ = PromiseSpawn;
    var stack = new Error().stack;
    return function () {
        var generator = generatorFunction.apply(this, arguments);
        var spawn = new PromiseSpawn$(undefined, undefined, yieldHandler,
                                      stack);
        var ret = spawn.promise();
        spawn._generator = generator;
        spawn._promiseFulfilled(undefined);
        return ret;
    };
};

Promise.coroutine.addYieldHandler = function(fn) {
    if (typeof fn !== "function") {
        throw new TypeError("expecting a function but got " + util.classString(fn));
    }
    yieldHandlers.push(fn);
};

Promise.spawn = function (generatorFunction) {
    debug.deprecated("Promise.spawn()", "Promise.coroutine()");
    if (typeof generatorFunction !== "function") {
        return apiRejection("generatorFunction must be a function\u000a\u000a    See http://goo.gl/MqrFmX\u000a");
    }
    var spawn = new PromiseSpawn(generatorFunction, this);
    var ret = spawn.promise();
    spawn._run(Promise.spawn);
    return ret;
};
};

},{"./errors":12,"./util":36}],17:[function(_dereq_,module,exports){
"use strict";
module.exports =
function(Promise, PromiseArray, tryConvertToPromise, INTERNAL) {
var util = _dereq_("./util");
var canEvaluate = util.canEvaluate;
var tryCatch = util.tryCatch;
var errorObj = util.errorObj;
var reject;

if (!true) {
if (canEvaluate) {
    var thenCallback = function(i) {
        return new Function("value", "holder", "                             \n\
            'use strict';                                                    \n\
            holder.pIndex = value;                                           \n\
            holder.checkFulfillment(this);                                   \n\
            ".replace(/Index/g, i));
    };

    var promiseSetter = function(i) {
        return new Function("promise", "holder", "                           \n\
            'use strict';                                                    \n\
            holder.pIndex = promise;                                         \n\
            ".replace(/Index/g, i));
    };

    var generateHolderClass = function(total) {
        var props = new Array(total);
        for (var i = 0; i < props.length; ++i) {
            props[i] = "this.p" + (i+1);
        }
        var assignment = props.join(" = ") + " = null;";
        var cancellationCode= "var promise;\n" + props.map(function(prop) {
            return "                                                         \n\
                promise = " + prop + ";                                      \n\
                if (promise instanceof Promise) {                            \n\
                    promise.cancel();                                        \n\
                }                                                            \n\
            ";
        }).join("\n");
        var passedArguments = props.join(", ");
        var name = "Holder$" + total;


        var code = "return function(tryCatch, errorObj, Promise) {           \n\
            'use strict';                                                    \n\
            function [TheName](fn) {                                         \n\
                [TheProperties]                                              \n\
                this.fn = fn;                                                \n\
                this.now = 0;                                                \n\
            }                                                                \n\
            [TheName].prototype.checkFulfillment = function(promise) {       \n\
                var now = ++this.now;                                        \n\
                if (now === [TheTotal]) {                                    \n\
                    promise._pushContext();                                  \n\
                    var callback = this.fn;                                  \n\
                    var ret = tryCatch(callback)([ThePassedArguments]);      \n\
                    promise._popContext();                                   \n\
                    if (ret === errorObj) {                                  \n\
                        promise._rejectCallback(ret.e, false);               \n\
                    } else {                                                 \n\
                        promise._resolveCallback(ret);                       \n\
                    }                                                        \n\
                }                                                            \n\
            };                                                               \n\
                                                                             \n\
            [TheName].prototype._resultCancelled = function() {              \n\
                [CancellationCode]                                           \n\
            };                                                               \n\
                                                                             \n\
            return [TheName];                                                \n\
        }(tryCatch, errorObj, Promise);                                      \n\
        ";

        code = code.replace(/\[TheName\]/g, name)
            .replace(/\[TheTotal\]/g, total)
            .replace(/\[ThePassedArguments\]/g, passedArguments)
            .replace(/\[TheProperties\]/g, assignment)
            .replace(/\[CancellationCode\]/g, cancellationCode);

        return new Function("tryCatch", "errorObj", "Promise", code)
                           (tryCatch, errorObj, Promise);
    };

    var holderClasses = [];
    var thenCallbacks = [];
    var promiseSetters = [];

    for (var i = 0; i < 8; ++i) {
        holderClasses.push(generateHolderClass(i + 1));
        thenCallbacks.push(thenCallback(i + 1));
        promiseSetters.push(promiseSetter(i + 1));
    }

    reject = function (reason) {
        this._reject(reason);
    };
}}

Promise.join = function () {
    var last = arguments.length - 1;
    var fn;
    if (last > 0 && typeof arguments[last] === "function") {
        fn = arguments[last];
        if (!true) {
            if (last <= 8 && canEvaluate) {
                var ret = new Promise(INTERNAL);
                ret._captureStackTrace();
                var HolderClass = holderClasses[last - 1];
                var holder = new HolderClass(fn);
                var callbacks = thenCallbacks;

                for (var i = 0; i < last; ++i) {
                    var maybePromise = tryConvertToPromise(arguments[i], ret);
                    if (maybePromise instanceof Promise) {
                        maybePromise = maybePromise._target();
                        var bitField = maybePromise._bitField;
                        ;
                        if (((bitField & 50397184) === 0)) {
                            maybePromise._then(callbacks[i], reject,
                                               undefined, ret, holder);
                            promiseSetters[i](maybePromise, holder);
                        } else if (((bitField & 33554432) !== 0)) {
                            callbacks[i].call(ret,
                                              maybePromise._value(), holder);
                        } else if (((bitField & 16777216) !== 0)) {
                            ret._reject(maybePromise._reason());
                        } else {
                            ret._cancel();
                        }
                    } else {
                        callbacks[i].call(ret, maybePromise, holder);
                    }
                }
                if (!ret._isFateSealed()) {
                    ret._setAsyncGuaranteed();
                    ret._setOnCancel(holder);
                }
                return ret;
            }
        }
    }
    var args = [].slice.call(arguments);;
    if (fn) args.pop();
    var ret = new PromiseArray(args).promise();
    return fn !== undefined ? ret.spread(fn) : ret;
};

};

},{"./util":36}],18:[function(_dereq_,module,exports){
"use strict";
module.exports = function(Promise,
                          PromiseArray,
                          apiRejection,
                          tryConvertToPromise,
                          INTERNAL,
                          debug) {
var getDomain = Promise._getDomain;
var util = _dereq_("./util");
var tryCatch = util.tryCatch;
var errorObj = util.errorObj;
var EMPTY_ARRAY = [];

function MappingPromiseArray(promises, fn, limit, _filter) {
    this.constructor$(promises);
    this._promise._captureStackTrace();
    var domain = getDomain();
    this._callback = domain === null ? fn : domain.bind(fn);
    this._preservedValues = _filter === INTERNAL
        ? new Array(this.length())
        : null;
    this._limit = limit;
    this._inFlight = 0;
    this._queue = limit >= 1 ? [] : EMPTY_ARRAY;
    this._init$(undefined, -2);
}
util.inherits(MappingPromiseArray, PromiseArray);

MappingPromiseArray.prototype._init = function () {};

MappingPromiseArray.prototype._promiseFulfilled = function (value, index) {
    var values = this._values;
    var length = this.length();
    var preservedValues = this._preservedValues;
    var limit = this._limit;

    if (index < 0) {
        index = (index * -1) - 1;
        values[index] = value;
        if (limit >= 1) {
            this._inFlight--;
            this._drainQueue();
            if (this._isResolved()) return true;
        }
    } else {
        if (limit >= 1 && this._inFlight >= limit) {
            values[index] = value;
            this._queue.push(index);
            return false;
        }
        if (preservedValues !== null) preservedValues[index] = value;

        var promise = this._promise;
        var callback = this._callback;
        var receiver = promise._boundValue();
        promise._pushContext();
        var ret = tryCatch(callback).call(receiver, value, index, length);
        var promiseCreated = promise._popContext();
        debug.checkForgottenReturns(
            ret,
            promiseCreated,
            preservedValues !== null ? "Promise.filter" : "Promise.map",
            promise
        );
        if (ret === errorObj) {
            this._reject(ret.e);
            return true;
        }

        var maybePromise = tryConvertToPromise(ret, this._promise);
        if (maybePromise instanceof Promise) {
            maybePromise = maybePromise._target();
            var bitField = maybePromise._bitField;
            ;
            if (((bitField & 50397184) === 0)) {
                if (limit >= 1) this._inFlight++;
                values[index] = maybePromise;
                maybePromise._proxy(this, (index + 1) * -1);
                return false;
            } else if (((bitField & 33554432) !== 0)) {
                ret = maybePromise._value();
            } else if (((bitField & 16777216) !== 0)) {
                this._reject(maybePromise._reason());
                return true;
            } else {
                this._cancel();
                return true;
            }
        }
        values[index] = ret;
    }
    var totalResolved = ++this._totalResolved;
    if (totalResolved >= length) {
        if (preservedValues !== null) {
            this._filter(values, preservedValues);
        } else {
            this._resolve(values);
        }
        return true;
    }
    return false;
};

MappingPromiseArray.prototype._drainQueue = function () {
    var queue = this._queue;
    var limit = this._limit;
    var values = this._values;
    while (queue.length > 0 && this._inFlight < limit) {
        if (this._isResolved()) return;
        var index = queue.pop();
        this._promiseFulfilled(values[index], index);
    }
};

MappingPromiseArray.prototype._filter = function (booleans, values) {
    var len = values.length;
    var ret = new Array(len);
    var j = 0;
    for (var i = 0; i < len; ++i) {
        if (booleans[i]) ret[j++] = values[i];
    }
    ret.length = j;
    this._resolve(ret);
};

MappingPromiseArray.prototype.preservedValues = function () {
    return this._preservedValues;
};

function map(promises, fn, options, _filter) {
    if (typeof fn !== "function") {
        return apiRejection("expecting a function but got " + util.classString(fn));
    }
    var limit = typeof options === "object" && options !== null
        ? options.concurrency
        : 0;
    limit = typeof limit === "number" &&
        isFinite(limit) && limit >= 1 ? limit : 0;
    return new MappingPromiseArray(promises, fn, limit, _filter).promise();
}

Promise.prototype.map = function (fn, options) {
    return map(this, fn, options, null);
};

Promise.map = function (promises, fn, options, _filter) {
    return map(promises, fn, options, _filter);
};


};

},{"./util":36}],19:[function(_dereq_,module,exports){
"use strict";
module.exports =
function(Promise, INTERNAL, tryConvertToPromise, apiRejection, debug) {
var util = _dereq_("./util");
var tryCatch = util.tryCatch;

Promise.method = function (fn) {
    if (typeof fn !== "function") {
        throw new Promise.TypeError("expecting a function but got " + util.classString(fn));
    }
    return function () {
        var ret = new Promise(INTERNAL);
        ret._captureStackTrace();
        ret._pushContext();
        var value = tryCatch(fn).apply(this, arguments);
        var promiseCreated = ret._popContext();
        debug.checkForgottenReturns(
            value, promiseCreated, "Promise.method", ret);
        ret._resolveFromSyncValue(value);
        return ret;
    };
};

Promise.attempt = Promise["try"] = function (fn) {
    if (typeof fn !== "function") {
        return apiRejection("expecting a function but got " + util.classString(fn));
    }
    var ret = new Promise(INTERNAL);
    ret._captureStackTrace();
    ret._pushContext();
    var value;
    if (arguments.length > 1) {
        debug.deprecated("calling Promise.try with more than 1 argument");
        var arg = arguments[1];
        var ctx = arguments[2];
        value = util.isArray(arg) ? tryCatch(fn).apply(ctx, arg)
                                  : tryCatch(fn).call(ctx, arg);
    } else {
        value = tryCatch(fn)();
    }
    var promiseCreated = ret._popContext();
    debug.checkForgottenReturns(
        value, promiseCreated, "Promise.try", ret);
    ret._resolveFromSyncValue(value);
    return ret;
};

Promise.prototype._resolveFromSyncValue = function (value) {
    if (value === util.errorObj) {
        this._rejectCallback(value.e, false);
    } else {
        this._resolveCallback(value, true);
    }
};
};

},{"./util":36}],20:[function(_dereq_,module,exports){
"use strict";
var util = _dereq_("./util");
var maybeWrapAsError = util.maybeWrapAsError;
var errors = _dereq_("./errors");
var OperationalError = errors.OperationalError;
var es5 = _dereq_("./es5");

function isUntypedError(obj) {
    return obj instanceof Error &&
        es5.getPrototypeOf(obj) === Error.prototype;
}

var rErrorKey = /^(?:name|message|stack|cause)$/;
function wrapAsOperationalError(obj) {
    var ret;
    if (isUntypedError(obj)) {
        ret = new OperationalError(obj);
        ret.name = obj.name;
        ret.message = obj.message;
        ret.stack = obj.stack;
        var keys = es5.keys(obj);
        for (var i = 0; i < keys.length; ++i) {
            var key = keys[i];
            if (!rErrorKey.test(key)) {
                ret[key] = obj[key];
            }
        }
        return ret;
    }
    util.markAsOriginatingFromRejection(obj);
    return obj;
}

function nodebackForPromise(promise, multiArgs) {
    return function(err, value) {
        if (promise === null) return;
        if (err) {
            var wrapped = wrapAsOperationalError(maybeWrapAsError(err));
            promise._attachExtraTrace(wrapped);
            promise._reject(wrapped);
        } else if (!multiArgs) {
            promise._fulfill(value);
        } else {
            var args = [].slice.call(arguments, 1);;
            promise._fulfill(args);
        }
        promise = null;
    };
}

module.exports = nodebackForPromise;

},{"./errors":12,"./es5":13,"./util":36}],21:[function(_dereq_,module,exports){
"use strict";
module.exports = function(Promise) {
var util = _dereq_("./util");
var async = Promise._async;
var tryCatch = util.tryCatch;
var errorObj = util.errorObj;

function spreadAdapter(val, nodeback) {
    var promise = this;
    if (!util.isArray(val)) return successAdapter.call(promise, val, nodeback);
    var ret =
        tryCatch(nodeback).apply(promise._boundValue(), [null].concat(val));
    if (ret === errorObj) {
        async.throwLater(ret.e);
    }
}

function successAdapter(val, nodeback) {
    var promise = this;
    var receiver = promise._boundValue();
    var ret = val === undefined
        ? tryCatch(nodeback).call(receiver, null)
        : tryCatch(nodeback).call(receiver, null, val);
    if (ret === errorObj) {
        async.throwLater(ret.e);
    }
}
function errorAdapter(reason, nodeback) {
    var promise = this;
    if (!reason) {
        var newReason = new Error(reason + "");
        newReason.cause = reason;
        reason = newReason;
    }
    var ret = tryCatch(nodeback).call(promise._boundValue(), reason);
    if (ret === errorObj) {
        async.throwLater(ret.e);
    }
}

Promise.prototype.asCallback = Promise.prototype.nodeify = function (nodeback,
                                                                     options) {
    if (typeof nodeback == "function") {
        var adapter = successAdapter;
        if (options !== undefined && Object(options).spread) {
            adapter = spreadAdapter;
        }
        this._then(
            adapter,
            errorAdapter,
            undefined,
            this,
            nodeback
        );
    }
    return this;
};
};

},{"./util":36}],22:[function(_dereq_,module,exports){
"use strict";
module.exports = function() {
var makeSelfResolutionError = function () {
    return new TypeError("circular promise resolution chain\u000a\u000a    See http://goo.gl/MqrFmX\u000a");
};
var reflectHandler = function() {
    return new Promise.PromiseInspection(this._target());
};
var apiRejection = function(msg) {
    return Promise.reject(new TypeError(msg));
};
function Proxyable() {}
var UNDEFINED_BINDING = {};
var util = _dereq_("./util");

var getDomain;
if (util.isNode) {
    getDomain = function() {
        var ret = process.domain;
        if (ret === undefined) ret = null;
        return ret;
    };
} else {
    getDomain = function() {
        return null;
    };
}
util.notEnumerableProp(Promise, "_getDomain", getDomain);

var es5 = _dereq_("./es5");
var Async = _dereq_("./async");
var async = new Async();
es5.defineProperty(Promise, "_async", {value: async});
var errors = _dereq_("./errors");
var TypeError = Promise.TypeError = errors.TypeError;
Promise.RangeError = errors.RangeError;
var CancellationError = Promise.CancellationError = errors.CancellationError;
Promise.TimeoutError = errors.TimeoutError;
Promise.OperationalError = errors.OperationalError;
Promise.RejectionError = errors.OperationalError;
Promise.AggregateError = errors.AggregateError;
var INTERNAL = function(){};
var APPLY = {};
var NEXT_FILTER = {};
var tryConvertToPromise = _dereq_("./thenables")(Promise, INTERNAL);
var PromiseArray =
    _dereq_("./promise_array")(Promise, INTERNAL,
                               tryConvertToPromise, apiRejection, Proxyable);
var Context = _dereq_("./context")(Promise);
 /*jshint unused:false*/
var createContext = Context.create;
var debug = _dereq_("./debuggability")(Promise, Context);
var CapturedTrace = debug.CapturedTrace;
var finallyHandler = _dereq_("./finally")(Promise, tryConvertToPromise);
var catchFilter = _dereq_("./catch_filter")(NEXT_FILTER);
var nodebackForPromise = _dereq_("./nodeback");
var errorObj = util.errorObj;
var tryCatch = util.tryCatch;
function check(self, executor) {
    if (typeof executor !== "function") {
        throw new TypeError("expecting a function but got " + util.classString(executor));
    }
    if (self.constructor !== Promise) {
        throw new TypeError("the promise constructor cannot be invoked directly\u000a\u000a    See http://goo.gl/MqrFmX\u000a");
    }
}

function Promise(executor) {
    this._bitField = 0;
    this._fulfillmentHandler0 = undefined;
    this._rejectionHandler0 = undefined;
    this._promise0 = undefined;
    this._receiver0 = undefined;
    if (executor !== INTERNAL) {
        check(this, executor);
        this._resolveFromExecutor(executor);
    }
    this._promiseCreated();
}

Promise.prototype.toString = function () {
    return "[object Promise]";
};

Promise.prototype.caught = Promise.prototype["catch"] = function (fn) {
    var len = arguments.length;
    if (len > 1) {
        var catchInstances = new Array(len - 1),
            j = 0, i;
        for (i = 0; i < len - 1; ++i) {
            var item = arguments[i];
            if (util.isObject(item)) {
                catchInstances[j++] = item;
            } else {
                return apiRejection("expecting an object but got " + util.classString(item));
            }
        }
        catchInstances.length = j;
        fn = arguments[i];
        return this.then(undefined, catchFilter(catchInstances, fn, this));
    }
    return this.then(undefined, fn);
};

Promise.prototype.reflect = function () {
    return this._then(reflectHandler,
        reflectHandler, undefined, this, undefined);
};

Promise.prototype.then = function (didFulfill, didReject) {
    if (debug.warnings() && arguments.length > 0 &&
        typeof didFulfill !== "function" &&
        typeof didReject !== "function") {
        var msg = ".then() only accepts functions but was passed: " +
                util.classString(didFulfill);
        if (arguments.length > 1) {
            msg += ", " + util.classString(didReject);
        }
        this._warn(msg);
    }
    return this._then(didFulfill, didReject, undefined, undefined, undefined);
};

Promise.prototype.done = function (didFulfill, didReject) {
    var promise =
        this._then(didFulfill, didReject, undefined, undefined, undefined);
    promise._setIsFinal();
};

Promise.prototype.spread = function (fn) {
    if (typeof fn !== "function") {
        return apiRejection("expecting a function but got " + util.classString(fn));
    }
    return this.all()._then(fn, undefined, undefined, APPLY, undefined);
};

Promise.prototype.toJSON = function () {
    var ret = {
        isFulfilled: false,
        isRejected: false,
        fulfillmentValue: undefined,
        rejectionReason: undefined
    };
    if (this.isFulfilled()) {
        ret.fulfillmentValue = this.value();
        ret.isFulfilled = true;
    } else if (this.isRejected()) {
        ret.rejectionReason = this.reason();
        ret.isRejected = true;
    }
    return ret;
};

Promise.prototype.all = function () {
    if (arguments.length > 0) {
        this._warn(".all() was passed arguments but it does not take any");
    }
    return new PromiseArray(this).promise();
};

Promise.prototype.error = function (fn) {
    return this.caught(util.originatesFromRejection, fn);
};

Promise.is = function (val) {
    return val instanceof Promise;
};

Promise.fromNode = Promise.fromCallback = function(fn) {
    var ret = new Promise(INTERNAL);
    var multiArgs = arguments.length > 1 ? !!Object(arguments[1]).multiArgs
                                         : false;
    var result = tryCatch(fn)(nodebackForPromise(ret, multiArgs));
    if (result === errorObj) {
        ret._rejectCallback(result.e, true);
    }
    if (!ret._isFateSealed()) ret._setAsyncGuaranteed();
    return ret;
};

Promise.all = function (promises) {
    return new PromiseArray(promises).promise();
};

Promise.cast = function (obj) {
    var ret = tryConvertToPromise(obj);
    if (!(ret instanceof Promise)) {
        ret = new Promise(INTERNAL);
        ret._captureStackTrace();
        ret._setFulfilled();
        ret._rejectionHandler0 = obj;
    }
    return ret;
};

Promise.resolve = Promise.fulfilled = Promise.cast;

Promise.reject = Promise.rejected = function (reason) {
    var ret = new Promise(INTERNAL);
    ret._captureStackTrace();
    ret._rejectCallback(reason, true);
    return ret;
};

Promise.setScheduler = function(fn) {
    if (typeof fn !== "function") {
        throw new TypeError("expecting a function but got " + util.classString(fn));
    }
    var prev = async._schedule;
    async._schedule = fn;
    return prev;
};

Promise.prototype._then = function (
    didFulfill,
    didReject,
    _,    receiver,
    internalData
) {
    var haveInternalData = internalData !== undefined;
    var promise = haveInternalData ? internalData : new Promise(INTERNAL);
    var target = this._target();
    var bitField = target._bitField;

    if (!haveInternalData) {
        promise._propagateFrom(this, 3);
        promise._captureStackTrace();
        if (receiver === undefined &&
            ((this._bitField & 2097152) !== 0)) {
            if (!((bitField & 50397184) === 0)) {
                receiver = this._boundValue();
            } else {
                receiver = target === this ? undefined : this._boundTo;
            }
        }
    }

    var domain = getDomain();
    if (!((bitField & 50397184) === 0)) {
        var handler, value, settler = target._settlePromiseCtx;
        if (((bitField & 33554432) !== 0)) {
            value = target._rejectionHandler0;
            handler = didFulfill;
        } else if (((bitField & 16777216) !== 0)) {
            value = target._fulfillmentHandler0;
            handler = didReject;
            target._unsetRejectionIsUnhandled();
        } else {
            settler = target._settlePromiseLateCancellationObserver;
            value = new CancellationError("late cancellation observer");
            target._attachExtraTrace(value);
            handler = didReject;
        }

        async.invoke(settler, target, {
            handler: domain === null ? handler
                : (typeof handler === "function" && domain.bind(handler)),
            promise: promise,
            receiver: receiver,
            value: value
        });
    } else {
        target._addCallbacks(didFulfill, didReject, promise, receiver, domain);
    }

    return promise;
};

Promise.prototype._length = function () {
    return this._bitField & 65535;
};

Promise.prototype._isFateSealed = function () {
    return (this._bitField & 117506048) !== 0;
};

Promise.prototype._isFollowing = function () {
    return (this._bitField & 67108864) === 67108864;
};

Promise.prototype._setLength = function (len) {
    this._bitField = (this._bitField & -65536) |
        (len & 65535);
};

Promise.prototype._setFulfilled = function () {
    this._bitField = this._bitField | 33554432;
};

Promise.prototype._setRejected = function () {
    this._bitField = this._bitField | 16777216;
};

Promise.prototype._setFollowing = function () {
    this._bitField = this._bitField | 67108864;
};

Promise.prototype._setIsFinal = function () {
    this._bitField = this._bitField | 4194304;
};

Promise.prototype._isFinal = function () {
    return (this._bitField & 4194304) > 0;
};

Promise.prototype._unsetCancelled = function() {
    this._bitField = this._bitField & (~65536);
};

Promise.prototype._setCancelled = function() {
    this._bitField = this._bitField | 65536;
};

Promise.prototype._setAsyncGuaranteed = function() {
    this._bitField = this._bitField | 134217728;
};

Promise.prototype._receiverAt = function (index) {
    var ret = index === 0 ? this._receiver0 : this[
            index * 4 - 4 + 3];
    if (ret === UNDEFINED_BINDING) {
        return undefined;
    } else if (ret === undefined && this._isBound()) {
        return this._boundValue();
    }
    return ret;
};

Promise.prototype._promiseAt = function (index) {
    return this[
            index * 4 - 4 + 2];
};

Promise.prototype._fulfillmentHandlerAt = function (index) {
    return this[
            index * 4 - 4 + 0];
};

Promise.prototype._rejectionHandlerAt = function (index) {
    return this[
            index * 4 - 4 + 1];
};

Promise.prototype._boundValue = function() {};

Promise.prototype._migrateCallback0 = function (follower) {
    var bitField = follower._bitField;
    var fulfill = follower._fulfillmentHandler0;
    var reject = follower._rejectionHandler0;
    var promise = follower._promise0;
    var receiver = follower._receiverAt(0);
    if (receiver === undefined) receiver = UNDEFINED_BINDING;
    this._addCallbacks(fulfill, reject, promise, receiver, null);
};

Promise.prototype._migrateCallbackAt = function (follower, index) {
    var fulfill = follower._fulfillmentHandlerAt(index);
    var reject = follower._rejectionHandlerAt(index);
    var promise = follower._promiseAt(index);
    var receiver = follower._receiverAt(index);
    if (receiver === undefined) receiver = UNDEFINED_BINDING;
    this._addCallbacks(fulfill, reject, promise, receiver, null);
};

Promise.prototype._addCallbacks = function (
    fulfill,
    reject,
    promise,
    receiver,
    domain
) {
    var index = this._length();

    if (index >= 65535 - 4) {
        index = 0;
        this._setLength(0);
    }

    if (index === 0) {
        this._promise0 = promise;
        this._receiver0 = receiver;
        if (typeof fulfill === "function") {
            this._fulfillmentHandler0 =
                domain === null ? fulfill : domain.bind(fulfill);
        }
        if (typeof reject === "function") {
            this._rejectionHandler0 =
                domain === null ? reject : domain.bind(reject);
        }
    } else {
        var base = index * 4 - 4;
        this[base + 2] = promise;
        this[base + 3] = receiver;
        if (typeof fulfill === "function") {
            this[base + 0] =
                domain === null ? fulfill : domain.bind(fulfill);
        }
        if (typeof reject === "function") {
            this[base + 1] =
                domain === null ? reject : domain.bind(reject);
        }
    }
    this._setLength(index + 1);
    return index;
};

Promise.prototype._proxy = function (proxyable, arg) {
    this._addCallbacks(undefined, undefined, arg, proxyable, null);
};

Promise.prototype._resolveCallback = function(value, shouldBind) {
    if (((this._bitField & 117506048) !== 0)) return;
    if (value === this)
        return this._rejectCallback(makeSelfResolutionError(), false);
    var maybePromise = tryConvertToPromise(value, this);
    if (!(maybePromise instanceof Promise)) return this._fulfill(value);

    if (shouldBind) this._propagateFrom(maybePromise, 2);

    var promise = maybePromise._target();
    var bitField = promise._bitField;
    if (((bitField & 50397184) === 0)) {
        var len = this._length();
        if (len > 0) promise._migrateCallback0(this);
        for (var i = 1; i < len; ++i) {
            promise._migrateCallbackAt(this, i);
        }
        this._setFollowing();
        this._setLength(0);
        this._setFollowee(promise);
    } else if (((bitField & 33554432) !== 0)) {
        this._fulfill(promise._value());
    } else if (((bitField & 16777216) !== 0)) {
        this._reject(promise._reason());
    } else {
        var reason = new CancellationError("late cancellation observer");
        promise._attachExtraTrace(reason);
        this._reject(reason);
    }
};

Promise.prototype._rejectCallback =
function(reason, synchronous, ignoreNonErrorWarnings) {
    var trace = util.ensureErrorObject(reason);
    var hasStack = trace === reason;
    if (!hasStack && !ignoreNonErrorWarnings && debug.warnings()) {
        var message = "a promise was rejected with a non-error: " +
            util.classString(reason);
        this._warn(message, true);
    }
    this._attachExtraTrace(trace, synchronous ? hasStack : false);
    this._reject(reason);
};

Promise.prototype._resolveFromExecutor = function (executor) {
    var promise = this;
    this._captureStackTrace();
    this._pushContext();
    var synchronous = true;
    var r = this._execute(executor, function(value) {
        promise._resolveCallback(value);
    }, function (reason) {
        promise._rejectCallback(reason, synchronous);
    });
    synchronous = false;
    this._popContext();

    if (r !== undefined) {
        promise._rejectCallback(r, true);
    }
};

Promise.prototype._settlePromiseFromHandler = function (
    handler, receiver, value, promise
) {
    var bitField = promise._bitField;
    if (((bitField & 65536) !== 0)) return;
    promise._pushContext();
    var x;
    if (receiver === APPLY) {
        if (!value || typeof value.length !== "number") {
            x = errorObj;
            x.e = new TypeError("cannot .spread() a non-array: " +
                                    util.classString(value));
        } else {
            x = tryCatch(handler).apply(this._boundValue(), value);
        }
    } else {
        x = tryCatch(handler).call(receiver, value);
    }
    var promiseCreated = promise._popContext();
    bitField = promise._bitField;
    if (((bitField & 65536) !== 0)) return;

    if (x === NEXT_FILTER) {
        promise._reject(value);
    } else if (x === errorObj || x === promise) {
        var err = x === promise ? makeSelfResolutionError() : x.e;
        promise._rejectCallback(err, false);
    } else {
        debug.checkForgottenReturns(x, promiseCreated, "",  promise);
        promise._resolveCallback(x);
    }
};

Promise.prototype._target = function() {
    var ret = this;
    while (ret._isFollowing()) ret = ret._followee();
    return ret;
};

Promise.prototype._followee = function() {
    return this._rejectionHandler0;
};

Promise.prototype._setFollowee = function(promise) {
    this._rejectionHandler0 = promise;
};

Promise.prototype._settlePromise = function(promise, handler, receiver, value) {
    var isPromise = promise instanceof Promise;
    var bitField = this._bitField;
    var asyncGuaranteed = ((bitField & 134217728) !== 0);
    if (((bitField & 65536) !== 0)) {
        if (isPromise) promise._invokeInternalOnCancel();

        if (handler === finallyHandler) {
            receiver.cancelPromise = promise;
            if (tryCatch(handler).call(receiver, value) === errorObj) {
                promise._reject(errorObj.e);
            }
        } else if (handler === reflectHandler) {
            promise._fulfill(reflectHandler.call(receiver));
        } else if (receiver instanceof Proxyable) {
            receiver._promiseCancelled(promise);
        } else if (isPromise || promise instanceof PromiseArray) {
            promise._cancel();
        } else {
            receiver.cancel();
        }
    } else if (typeof handler === "function") {
        if (!isPromise) {
            handler.call(receiver, value, promise);
        } else {
            if (asyncGuaranteed) promise._setAsyncGuaranteed();
            this._settlePromiseFromHandler(handler, receiver, value, promise);
        }
    } else if (receiver instanceof Proxyable) {
        if (!receiver._isResolved()) {
            if (((bitField & 33554432) !== 0)) {
                receiver._promiseFulfilled(value, promise);
            } else {
                receiver._promiseRejected(value, promise);
            }
        }
    } else if (isPromise) {
        if (asyncGuaranteed) promise._setAsyncGuaranteed();
        if (((bitField & 33554432) !== 0)) {
            promise._fulfill(value);
        } else {
            promise._reject(value);
        }
    }
};

Promise.prototype._settlePromiseLateCancellationObserver = function(ctx) {
    var handler = ctx.handler;
    var promise = ctx.promise;
    var receiver = ctx.receiver;
    var value = ctx.value;
    if (typeof handler === "function") {
        if (!(promise instanceof Promise)) {
            handler.call(receiver, value, promise);
        } else {
            this._settlePromiseFromHandler(handler, receiver, value, promise);
        }
    } else if (promise instanceof Promise) {
        promise._reject(value);
    }
};

Promise.prototype._settlePromiseCtx = function(ctx) {
    this._settlePromise(ctx.promise, ctx.handler, ctx.receiver, ctx.value);
};

Promise.prototype._settlePromise0 = function(handler, value, bitField) {
    var promise = this._promise0;
    var receiver = this._receiverAt(0);
    this._promise0 = undefined;
    this._receiver0 = undefined;
    this._settlePromise(promise, handler, receiver, value);
};

Promise.prototype._clearCallbackDataAtIndex = function(index) {
    var base = index * 4 - 4;
    this[base + 2] =
    this[base + 3] =
    this[base + 0] =
    this[base + 1] = undefined;
};

Promise.prototype._fulfill = function (value) {
    var bitField = this._bitField;
    if (((bitField & 117506048) >>> 16)) return;
    if (value === this) {
        var err = makeSelfResolutionError();
        this._attachExtraTrace(err);
        return this._reject(err);
    }
    this._setFulfilled();
    this._rejectionHandler0 = value;

    if ((bitField & 65535) > 0) {
        if (((bitField & 134217728) !== 0)) {
            this._settlePromises();
        } else {
            async.settlePromises(this);
        }
    }
};

Promise.prototype._reject = function (reason) {
    var bitField = this._bitField;
    if (((bitField & 117506048) >>> 16)) return;
    this._setRejected();
    this._fulfillmentHandler0 = reason;

    if (this._isFinal()) {
        return async.fatalError(reason, util.isNode);
    }

    if ((bitField & 65535) > 0) {
        if (((bitField & 134217728) !== 0)) {
            this._settlePromises();
        } else {
            async.settlePromises(this);
        }
    } else {
        this._ensurePossibleRejectionHandled();
    }
};

Promise.prototype._fulfillPromises = function (len, value) {
    for (var i = 1; i < len; i++) {
        var handler = this._fulfillmentHandlerAt(i);
        var promise = this._promiseAt(i);
        var receiver = this._receiverAt(i);
        this._clearCallbackDataAtIndex(i);
        this._settlePromise(promise, handler, receiver, value);
    }
};

Promise.prototype._rejectPromises = function (len, reason) {
    for (var i = 1; i < len; i++) {
        var handler = this._rejectionHandlerAt(i);
        var promise = this._promiseAt(i);
        var receiver = this._receiverAt(i);
        this._clearCallbackDataAtIndex(i);
        this._settlePromise(promise, handler, receiver, reason);
    }
};

Promise.prototype._settlePromises = function () {
    var bitField = this._bitField;
    var len = (bitField & 65535);

    if (len > 0) {
        if (((bitField & 16842752) !== 0)) {
            var reason = this._fulfillmentHandler0;
            this._settlePromise0(this._rejectionHandler0, reason, bitField);
            this._rejectPromises(len, reason);
        } else {
            var value = this._rejectionHandler0;
            this._settlePromise0(this._fulfillmentHandler0, value, bitField);
            this._fulfillPromises(len, value);
        }
        this._setLength(0);
    }
    this._clearCancellationData();
};

Promise.prototype._settledValue = function() {
    var bitField = this._bitField;
    if (((bitField & 33554432) !== 0)) {
        return this._rejectionHandler0;
    } else if (((bitField & 16777216) !== 0)) {
        return this._fulfillmentHandler0;
    }
};

function deferResolve(v) {this.promise._resolveCallback(v);}
function deferReject(v) {this.promise._rejectCallback(v, false);}

Promise.defer = Promise.pending = function() {
    debug.deprecated("Promise.defer", "new Promise");
    var promise = new Promise(INTERNAL);
    return {
        promise: promise,
        resolve: deferResolve,
        reject: deferReject
    };
};

util.notEnumerableProp(Promise,
                       "_makeSelfResolutionError",
                       makeSelfResolutionError);

_dereq_("./method")(Promise, INTERNAL, tryConvertToPromise, apiRejection,
    debug);
_dereq_("./bind")(Promise, INTERNAL, tryConvertToPromise, debug);
_dereq_("./cancel")(Promise, PromiseArray, apiRejection, debug);
_dereq_("./direct_resolve")(Promise);
_dereq_("./synchronous_inspection")(Promise);
_dereq_("./join")(
    Promise, PromiseArray, tryConvertToPromise, INTERNAL, debug);
Promise.Promise = Promise;
_dereq_('./map.js')(Promise, PromiseArray, apiRejection, tryConvertToPromise, INTERNAL, debug);
_dereq_('./using.js')(Promise, apiRejection, tryConvertToPromise, createContext, INTERNAL, debug);
_dereq_('./timers.js')(Promise, INTERNAL);
_dereq_('./generators.js')(Promise, apiRejection, INTERNAL, tryConvertToPromise, Proxyable, debug);
_dereq_('./nodeify.js')(Promise);
_dereq_('./call_get.js')(Promise);
_dereq_('./props.js')(Promise, PromiseArray, tryConvertToPromise, apiRejection);
_dereq_('./race.js')(Promise, INTERNAL, tryConvertToPromise, apiRejection);
_dereq_('./reduce.js')(Promise, PromiseArray, apiRejection, tryConvertToPromise, INTERNAL, debug);
_dereq_('./settle.js')(Promise, PromiseArray, debug);
_dereq_('./some.js')(Promise, PromiseArray, apiRejection);
_dereq_('./promisify.js')(Promise, INTERNAL);
_dereq_('./any.js')(Promise);
_dereq_('./each.js')(Promise, INTERNAL);
_dereq_('./filter.js')(Promise, INTERNAL);
                                                         
    util.toFastProperties(Promise);                                          
    util.toFastProperties(Promise.prototype);                                
    function fillTypes(value) {                                              
        var p = new Promise(INTERNAL);                                       
        p._fulfillmentHandler0 = value;                                      
        p._rejectionHandler0 = value;                                        
        p._promise0 = value;                                                 
        p._receiver0 = value;                                                
    }                                                                        
    // Complete slack tracking, opt out of field-type tracking and           
    // stabilize map                                                         
    fillTypes({a: 1});                                                       
    fillTypes({b: 2});                                                       
    fillTypes({c: 3});                                                       
    fillTypes(1);                                                            
    fillTypes(function(){});                                                 
    fillTypes(undefined);                                                    
    fillTypes(false);                                                        
    fillTypes(new Promise(INTERNAL));                                        
    debug.setBounds(Async.firstLineError, util.lastLineError);               
    return Promise;                                                          

};

},{"./any.js":1,"./async":2,"./bind":3,"./call_get.js":5,"./cancel":6,"./catch_filter":7,"./context":8,"./debuggability":9,"./direct_resolve":10,"./each.js":11,"./errors":12,"./es5":13,"./filter.js":14,"./finally":15,"./generators.js":16,"./join":17,"./map.js":18,"./method":19,"./nodeback":20,"./nodeify.js":21,"./promise_array":23,"./promisify.js":24,"./props.js":25,"./race.js":27,"./reduce.js":28,"./settle.js":30,"./some.js":31,"./synchronous_inspection":32,"./thenables":33,"./timers.js":34,"./using.js":35,"./util":36}],23:[function(_dereq_,module,exports){
"use strict";
module.exports = function(Promise, INTERNAL, tryConvertToPromise,
    apiRejection, Proxyable) {
var util = _dereq_("./util");
var isArray = util.isArray;

function toResolutionValue(val) {
    switch(val) {
    case -2: return [];
    case -3: return {};
    }
}

function PromiseArray(values) {
    var promise = this._promise = new Promise(INTERNAL);
    if (values instanceof Promise) {
        promise._propagateFrom(values, 3);
    }
    promise._setOnCancel(this);
    this._values = values;
    this._length = 0;
    this._totalResolved = 0;
    this._init(undefined, -2);
}
util.inherits(PromiseArray, Proxyable);

PromiseArray.prototype.length = function () {
    return this._length;
};

PromiseArray.prototype.promise = function () {
    return this._promise;
};

PromiseArray.prototype._init = function init(_, resolveValueIfEmpty) {
    var values = tryConvertToPromise(this._values, this._promise);
    if (values instanceof Promise) {
        values = values._target();
        var bitField = values._bitField;
        ;
        this._values = values;

        if (((bitField & 50397184) === 0)) {
            this._promise._setAsyncGuaranteed();
            return values._then(
                init,
                this._reject,
                undefined,
                this,
                resolveValueIfEmpty
           );
        } else if (((bitField & 33554432) !== 0)) {
            values = values._value();
        } else if (((bitField & 16777216) !== 0)) {
            return this._reject(values._reason());
        } else {
            return this._cancel();
        }
    }
    values = util.asArray(values);
    if (values === null) {
        var err = apiRejection(
            "expecting an array or an iterable object but got " + util.classString(values)).reason();
        this._promise._rejectCallback(err, false);
        return;
    }

    if (values.length === 0) {
        if (resolveValueIfEmpty === -5) {
            this._resolveEmptyArray();
        }
        else {
            this._resolve(toResolutionValue(resolveValueIfEmpty));
        }
        return;
    }
    this._iterate(values);
};

PromiseArray.prototype._iterate = function(values) {
    var len = this.getActualLength(values.length);
    this._length = len;
    this._values = this.shouldCopyValues() ? new Array(len) : this._values;
    var result = this._promise;
    var isResolved = false;
    var bitField = null;
    for (var i = 0; i < len; ++i) {
        var maybePromise = tryConvertToPromise(values[i], result);

        if (maybePromise instanceof Promise) {
            maybePromise = maybePromise._target();
            bitField = maybePromise._bitField;
        } else {
            bitField = null;
        }

        if (isResolved) {
            if (bitField !== null) {
                maybePromise.suppressUnhandledRejections();
            }
        } else if (bitField !== null) {
            if (((bitField & 50397184) === 0)) {
                maybePromise._proxy(this, i);
                this._values[i] = maybePromise;
            } else if (((bitField & 33554432) !== 0)) {
                isResolved = this._promiseFulfilled(maybePromise._value(), i);
            } else if (((bitField & 16777216) !== 0)) {
                isResolved = this._promiseRejected(maybePromise._reason(), i);
            } else {
                isResolved = this._promiseCancelled(i);
            }
        } else {
            isResolved = this._promiseFulfilled(maybePromise, i);
        }
    }
    if (!isResolved) result._setAsyncGuaranteed();
};

PromiseArray.prototype._isResolved = function () {
    return this._values === null;
};

PromiseArray.prototype._resolve = function (value) {
    this._values = null;
    this._promise._fulfill(value);
};

PromiseArray.prototype._cancel = function() {
    if (this._isResolved() || !this._promise.isCancellable()) return;
    this._values = null;
    this._promise._cancel();
};

PromiseArray.prototype._reject = function (reason) {
    this._values = null;
    this._promise._rejectCallback(reason, false);
};

PromiseArray.prototype._promiseFulfilled = function (value, index) {
    this._values[index] = value;
    var totalResolved = ++this._totalResolved;
    if (totalResolved >= this._length) {
        this._resolve(this._values);
        return true;
    }
    return false;
};

PromiseArray.prototype._promiseCancelled = function() {
    this._cancel();
    return true;
};

PromiseArray.prototype._promiseRejected = function (reason) {
    this._totalResolved++;
    this._reject(reason);
    return true;
};

PromiseArray.prototype._resultCancelled = function() {
    if (this._isResolved()) return;
    var values = this._values;
    this._cancel();
    if (values instanceof Promise) {
        values.cancel();
    } else {
        for (var i = 0; i < values.length; ++i) {
            if (values[i] instanceof Promise) {
                values[i].cancel();
            }
        }
    }
};

PromiseArray.prototype.shouldCopyValues = function () {
    return true;
};

PromiseArray.prototype.getActualLength = function (len) {
    return len;
};

return PromiseArray;
};

},{"./util":36}],24:[function(_dereq_,module,exports){
"use strict";
module.exports = function(Promise, INTERNAL) {
var THIS = {};
var util = _dereq_("./util");
var nodebackForPromise = _dereq_("./nodeback");
var withAppended = util.withAppended;
var maybeWrapAsError = util.maybeWrapAsError;
var canEvaluate = util.canEvaluate;
var TypeError = _dereq_("./errors").TypeError;
var defaultSuffix = "Async";
var defaultPromisified = {__isPromisified__: true};
var noCopyProps = [
    "arity",    "length",
    "name",
    "arguments",
    "caller",
    "callee",
    "prototype",
    "__isPromisified__"
];
var noCopyPropsPattern = new RegExp("^(?:" + noCopyProps.join("|") + ")$");

var defaultFilter = function(name) {
    return util.isIdentifier(name) &&
        name.charAt(0) !== "_" &&
        name !== "constructor";
};

function propsFilter(key) {
    return !noCopyPropsPattern.test(key);
}

function isPromisified(fn) {
    try {
        return fn.__isPromisified__ === true;
    }
    catch (e) {
        return false;
    }
}

function hasPromisified(obj, key, suffix) {
    var val = util.getDataPropertyOrDefault(obj, key + suffix,
                                            defaultPromisified);
    return val ? isPromisified(val) : false;
}
function checkValid(ret, suffix, suffixRegexp) {
    for (var i = 0; i < ret.length; i += 2) {
        var key = ret[i];
        if (suffixRegexp.test(key)) {
            var keyWithoutAsyncSuffix = key.replace(suffixRegexp, "");
            for (var j = 0; j < ret.length; j += 2) {
                if (ret[j] === keyWithoutAsyncSuffix) {
                    throw new TypeError("Cannot promisify an API that has normal methods with '%s'-suffix\u000a\u000a    See http://goo.gl/MqrFmX\u000a"
                        .replace("%s", suffix));
                }
            }
        }
    }
}

function promisifiableMethods(obj, suffix, suffixRegexp, filter) {
    var keys = util.inheritedDataKeys(obj);
    var ret = [];
    for (var i = 0; i < keys.length; ++i) {
        var key = keys[i];
        var value = obj[key];
        var passesDefaultFilter = filter === defaultFilter
            ? true : defaultFilter(key, value, obj);
        if (typeof value === "function" &&
            !isPromisified(value) &&
            !hasPromisified(obj, key, suffix) &&
            filter(key, value, obj, passesDefaultFilter)) {
            ret.push(key, value);
        }
    }
    checkValid(ret, suffix, suffixRegexp);
    return ret;
}

var escapeIdentRegex = function(str) {
    return str.replace(/([$])/, "\\$");
};

var makeNodePromisifiedEval;
if (!true) {
var switchCaseArgumentOrder = function(likelyArgumentCount) {
    var ret = [likelyArgumentCount];
    var min = Math.max(0, likelyArgumentCount - 1 - 3);
    for(var i = likelyArgumentCount - 1; i >= min; --i) {
        ret.push(i);
    }
    for(var i = likelyArgumentCount + 1; i <= 3; ++i) {
        ret.push(i);
    }
    return ret;
};

var argumentSequence = function(argumentCount) {
    return util.filledRange(argumentCount, "_arg", "");
};

var parameterDeclaration = function(parameterCount) {
    return util.filledRange(
        Math.max(parameterCount, 3), "_arg", "");
};

var parameterCount = function(fn) {
    if (typeof fn.length === "number") {
        return Math.max(Math.min(fn.length, 1023 + 1), 0);
    }
    return 0;
};

makeNodePromisifiedEval =
function(callback, receiver, originalName, fn, _, multiArgs) {
    var newParameterCount = Math.max(0, parameterCount(fn) - 1);
    var argumentOrder = switchCaseArgumentOrder(newParameterCount);
    var shouldProxyThis = typeof callback === "string" || receiver === THIS;

    function generateCallForArgumentCount(count) {
        var args = argumentSequence(count).join(", ");
        var comma = count > 0 ? ", " : "";
        var ret;
        if (shouldProxyThis) {
            ret = "ret = callback.call(this, {{args}}, nodeback); break;\n";
        } else {
            ret = receiver === undefined
                ? "ret = callback({{args}}, nodeback); break;\n"
                : "ret = callback.call(receiver, {{args}}, nodeback); break;\n";
        }
        return ret.replace("{{args}}", args).replace(", ", comma);
    }

    function generateArgumentSwitchCase() {
        var ret = "";
        for (var i = 0; i < argumentOrder.length; ++i) {
            ret += "case " + argumentOrder[i] +":" +
                generateCallForArgumentCount(argumentOrder[i]);
        }

        ret += "                                                             \n\
        default:                                                             \n\
            var args = new Array(len + 1);                                   \n\
            var i = 0;                                                       \n\
            for (var i = 0; i < len; ++i) {                                  \n\
               args[i] = arguments[i];                                       \n\
            }                                                                \n\
            args[i] = nodeback;                                              \n\
            [CodeForCall]                                                    \n\
            break;                                                           \n\
        ".replace("[CodeForCall]", (shouldProxyThis
                                ? "ret = callback.apply(this, args);\n"
                                : "ret = callback.apply(receiver, args);\n"));
        return ret;
    }

    var getFunctionCode = typeof callback === "string"
                                ? ("this != null ? this['"+callback+"'] : fn")
                                : "fn";
    var body = "'use strict';                                                \n\
        var ret = function (Parameters) {                                    \n\
            'use strict';                                                    \n\
            var len = arguments.length;                                      \n\
            var promise = new Promise(INTERNAL);                             \n\
            promise._captureStackTrace();                                    \n\
            var nodeback = nodebackForPromise(promise, " + multiArgs + ");   \n\
            var ret;                                                         \n\
            var callback = tryCatch([GetFunctionCode]);                      \n\
            switch(len) {                                                    \n\
                [CodeForSwitchCase]                                          \n\
            }                                                                \n\
            if (ret === errorObj) {                                          \n\
                promise._rejectCallback(maybeWrapAsError(ret.e), true, true);\n\
            }                                                                \n\
            if (!promise._isFateSealed()) promise._setAsyncGuaranteed();     \n\
            return promise;                                                  \n\
        };                                                                   \n\
        notEnumerableProp(ret, '__isPromisified__', true);                   \n\
        return ret;                                                          \n\
    ".replace("[CodeForSwitchCase]", generateArgumentSwitchCase())
        .replace("[GetFunctionCode]", getFunctionCode);
    body = body.replace("Parameters", parameterDeclaration(newParameterCount));
    return new Function("Promise",
                        "fn",
                        "receiver",
                        "withAppended",
                        "maybeWrapAsError",
                        "nodebackForPromise",
                        "tryCatch",
                        "errorObj",
                        "notEnumerableProp",
                        "INTERNAL",
                        body)(
                    Promise,
                    fn,
                    receiver,
                    withAppended,
                    maybeWrapAsError,
                    nodebackForPromise,
                    util.tryCatch,
                    util.errorObj,
                    util.notEnumerableProp,
                    INTERNAL);
};
}

function makeNodePromisifiedClosure(callback, receiver, _, fn, __, multiArgs) {
    var defaultThis = (function() {return this;})();
    var method = callback;
    if (typeof method === "string") {
        callback = fn;
    }
    function promisified() {
        var _receiver = receiver;
        if (receiver === THIS) _receiver = this;
        var promise = new Promise(INTERNAL);
        promise._captureStackTrace();
        var cb = typeof method === "string" && this !== defaultThis
            ? this[method] : callback;
        var fn = nodebackForPromise(promise, multiArgs);
        try {
            cb.apply(_receiver, withAppended(arguments, fn));
        } catch(e) {
            promise._rejectCallback(maybeWrapAsError(e), true, true);
        }
        if (!promise._isFateSealed()) promise._setAsyncGuaranteed();
        return promise;
    }
    util.notEnumerableProp(promisified, "__isPromisified__", true);
    return promisified;
}

var makeNodePromisified = canEvaluate
    ? makeNodePromisifiedEval
    : makeNodePromisifiedClosure;

function promisifyAll(obj, suffix, filter, promisifier, multiArgs) {
    var suffixRegexp = new RegExp(escapeIdentRegex(suffix) + "$");
    var methods =
        promisifiableMethods(obj, suffix, suffixRegexp, filter);

    for (var i = 0, len = methods.length; i < len; i+= 2) {
        var key = methods[i];
        var fn = methods[i+1];
        var promisifiedKey = key + suffix;
        if (promisifier === makeNodePromisified) {
            obj[promisifiedKey] =
                makeNodePromisified(key, THIS, key, fn, suffix, multiArgs);
        } else {
            var promisified = promisifier(fn, function() {
                return makeNodePromisified(key, THIS, key,
                                           fn, suffix, multiArgs);
            });
            util.notEnumerableProp(promisified, "__isPromisified__", true);
            obj[promisifiedKey] = promisified;
        }
    }
    util.toFastProperties(obj);
    return obj;
}

function promisify(callback, receiver, multiArgs) {
    return makeNodePromisified(callback, receiver, undefined,
                                callback, null, multiArgs);
}

Promise.promisify = function (fn, options) {
    if (typeof fn !== "function") {
        throw new TypeError("expecting a function but got " + util.classString(fn));
    }
    if (isPromisified(fn)) {
        return fn;
    }
    options = Object(options);
    var receiver = options.context === undefined ? THIS : options.context;
    var multiArgs = !!options.multiArgs;
    var ret = promisify(fn, receiver, multiArgs);
    util.copyDescriptors(fn, ret, propsFilter);
    return ret;
};

Promise.promisifyAll = function (target, options) {
    if (typeof target !== "function" && typeof target !== "object") {
        throw new TypeError("the target of promisifyAll must be an object or a function\u000a\u000a    See http://goo.gl/MqrFmX\u000a");
    }
    options = Object(options);
    var multiArgs = !!options.multiArgs;
    var suffix = options.suffix;
    if (typeof suffix !== "string") suffix = defaultSuffix;
    var filter = options.filter;
    if (typeof filter !== "function") filter = defaultFilter;
    var promisifier = options.promisifier;
    if (typeof promisifier !== "function") promisifier = makeNodePromisified;

    if (!util.isIdentifier(suffix)) {
        throw new RangeError("suffix must be a valid identifier\u000a\u000a    See http://goo.gl/MqrFmX\u000a");
    }

    var keys = util.inheritedDataKeys(target);
    for (var i = 0; i < keys.length; ++i) {
        var value = target[keys[i]];
        if (keys[i] !== "constructor" &&
            util.isClass(value)) {
            promisifyAll(value.prototype, suffix, filter, promisifier,
                multiArgs);
            promisifyAll(value, suffix, filter, promisifier, multiArgs);
        }
    }

    return promisifyAll(target, suffix, filter, promisifier, multiArgs);
};
};


},{"./errors":12,"./nodeback":20,"./util":36}],25:[function(_dereq_,module,exports){
"use strict";
module.exports = function(
    Promise, PromiseArray, tryConvertToPromise, apiRejection) {
var util = _dereq_("./util");
var isObject = util.isObject;
var es5 = _dereq_("./es5");
var Es6Map;
if (typeof Map === "function") Es6Map = Map;

var mapToEntries = (function() {
    var index = 0;
    var size = 0;

    function extractEntry(value, key) {
        this[index] = value;
        this[index + size] = key;
        index++;
    }

    return function mapToEntries(map) {
        size = map.size;
        index = 0;
        var ret = new Array(map.size * 2);
        map.forEach(extractEntry, ret);
        return ret;
    };
})();

var entriesToMap = function(entries) {
    var ret = new Es6Map();
    var length = entries.length / 2 | 0;
    for (var i = 0; i < length; ++i) {
        var key = entries[length + i];
        var value = entries[i];
        ret.set(key, value);
    }
    return ret;
};

function PropertiesPromiseArray(obj) {
    var isMap = false;
    var entries;
    if (Es6Map !== undefined && obj instanceof Es6Map) {
        entries = mapToEntries(obj);
        isMap = true;
    } else {
        var keys = es5.keys(obj);
        var len = keys.length;
        entries = new Array(len * 2);
        for (var i = 0; i < len; ++i) {
            var key = keys[i];
            entries[i] = obj[key];
            entries[i + len] = key;
        }
    }
    this.constructor$(entries);
    this._isMap = isMap;
    this._init$(undefined, -3);
}
util.inherits(PropertiesPromiseArray, PromiseArray);

PropertiesPromiseArray.prototype._init = function () {};

PropertiesPromiseArray.prototype._promiseFulfilled = function (value, index) {
    this._values[index] = value;
    var totalResolved = ++this._totalResolved;
    if (totalResolved >= this._length) {
        var val;
        if (this._isMap) {
            val = entriesToMap(this._values);
        } else {
            val = {};
            var keyOffset = this.length();
            for (var i = 0, len = this.length(); i < len; ++i) {
                val[this._values[i + keyOffset]] = this._values[i];
            }
        }
        this._resolve(val);
        return true;
    }
    return false;
};

PropertiesPromiseArray.prototype.shouldCopyValues = function () {
    return false;
};

PropertiesPromiseArray.prototype.getActualLength = function (len) {
    return len >> 1;
};

function props(promises) {
    var ret;
    var castValue = tryConvertToPromise(promises);

    if (!isObject(castValue)) {
        return apiRejection("cannot await properties of a non-object\u000a\u000a    See http://goo.gl/MqrFmX\u000a");
    } else if (castValue instanceof Promise) {
        ret = castValue._then(
            Promise.props, undefined, undefined, undefined, undefined);
    } else {
        ret = new PropertiesPromiseArray(castValue).promise();
    }

    if (castValue instanceof Promise) {
        ret._propagateFrom(castValue, 2);
    }
    return ret;
}

Promise.prototype.props = function () {
    return props(this);
};

Promise.props = function (promises) {
    return props(promises);
};
};

},{"./es5":13,"./util":36}],26:[function(_dereq_,module,exports){
"use strict";
function arrayMove(src, srcIndex, dst, dstIndex, len) {
    for (var j = 0; j < len; ++j) {
        dst[j + dstIndex] = src[j + srcIndex];
        src[j + srcIndex] = void 0;
    }
}

function Queue(capacity) {
    this._capacity = capacity;
    this._length = 0;
    this._front = 0;
}

Queue.prototype._willBeOverCapacity = function (size) {
    return this._capacity < size;
};

Queue.prototype._pushOne = function (arg) {
    var length = this.length();
    this._checkCapacity(length + 1);
    var i = (this._front + length) & (this._capacity - 1);
    this[i] = arg;
    this._length = length + 1;
};

Queue.prototype._unshiftOne = function(value) {
    var capacity = this._capacity;
    this._checkCapacity(this.length() + 1);
    var front = this._front;
    var i = (((( front - 1 ) &
                    ( capacity - 1) ) ^ capacity ) - capacity );
    this[i] = value;
    this._front = i;
    this._length = this.length() + 1;
};

Queue.prototype.unshift = function(fn, receiver, arg) {
    this._unshiftOne(arg);
    this._unshiftOne(receiver);
    this._unshiftOne(fn);
};

Queue.prototype.push = function (fn, receiver, arg) {
    var length = this.length() + 3;
    if (this._willBeOverCapacity(length)) {
        this._pushOne(fn);
        this._pushOne(receiver);
        this._pushOne(arg);
        return;
    }
    var j = this._front + length - 3;
    this._checkCapacity(length);
    var wrapMask = this._capacity - 1;
    this[(j + 0) & wrapMask] = fn;
    this[(j + 1) & wrapMask] = receiver;
    this[(j + 2) & wrapMask] = arg;
    this._length = length;
};

Queue.prototype.shift = function () {
    var front = this._front,
        ret = this[front];

    this[front] = undefined;
    this._front = (front + 1) & (this._capacity - 1);
    this._length--;
    return ret;
};

Queue.prototype.length = function () {
    return this._length;
};

Queue.prototype._checkCapacity = function (size) {
    if (this._capacity < size) {
        this._resizeTo(this._capacity << 1);
    }
};

Queue.prototype._resizeTo = function (capacity) {
    var oldCapacity = this._capacity;
    this._capacity = capacity;
    var front = this._front;
    var length = this._length;
    var moveItemsCount = (front + length) & (oldCapacity - 1);
    arrayMove(this, 0, this, oldCapacity, moveItemsCount);
};

module.exports = Queue;

},{}],27:[function(_dereq_,module,exports){
"use strict";
module.exports = function(
    Promise, INTERNAL, tryConvertToPromise, apiRejection) {
var util = _dereq_("./util");

var raceLater = function (promise) {
    return promise.then(function(array) {
        return race(array, promise);
    });
};

function race(promises, parent) {
    var maybePromise = tryConvertToPromise(promises);

    if (maybePromise instanceof Promise) {
        return raceLater(maybePromise);
    } else {
        promises = util.asArray(promises);
        if (promises === null)
            return apiRejection("expecting an array or an iterable object but got " + util.classString(promises));
    }

    var ret = new Promise(INTERNAL);
    if (parent !== undefined) {
        ret._propagateFrom(parent, 3);
    }
    var fulfill = ret._fulfill;
    var reject = ret._reject;
    for (var i = 0, len = promises.length; i < len; ++i) {
        var val = promises[i];

        if (val === undefined && !(i in promises)) {
            continue;
        }

        Promise.cast(val)._then(fulfill, reject, undefined, ret, null);
    }
    return ret;
}

Promise.race = function (promises) {
    return race(promises, undefined);
};

Promise.prototype.race = function () {
    return race(this, undefined);
};

};

},{"./util":36}],28:[function(_dereq_,module,exports){
"use strict";
module.exports = function(Promise,
                          PromiseArray,
                          apiRejection,
                          tryConvertToPromise,
                          INTERNAL,
                          debug) {
var getDomain = Promise._getDomain;
var util = _dereq_("./util");
var tryCatch = util.tryCatch;

function ReductionPromiseArray(promises, fn, initialValue, _each) {
    this.constructor$(promises);
    var domain = getDomain();
    this._fn = domain === null ? fn : domain.bind(fn);
    if (initialValue !== undefined) {
        initialValue = Promise.resolve(initialValue);
        initialValue._attachCancellationCallback(this);
    }
    this._initialValue = initialValue;
    this._currentCancellable = null;
    this._eachValues = _each === INTERNAL ? [] : undefined;
    this._promise._captureStackTrace();
    this._init$(undefined, -5);
}
util.inherits(ReductionPromiseArray, PromiseArray);

ReductionPromiseArray.prototype._gotAccum = function(accum) {
    if (this._eachValues !== undefined && accum !== INTERNAL) {
        this._eachValues.push(accum);
    }
};

ReductionPromiseArray.prototype._eachComplete = function(value) {
    this._eachValues.push(value);
    return this._eachValues;
};

ReductionPromiseArray.prototype._init = function() {};

ReductionPromiseArray.prototype._resolveEmptyArray = function() {
    this._resolve(this._eachValues !== undefined ? this._eachValues
                                                 : this._initialValue);
};

ReductionPromiseArray.prototype.shouldCopyValues = function () {
    return false;
};

ReductionPromiseArray.prototype._resolve = function(value) {
    this._promise._resolveCallback(value);
    this._values = null;
};

ReductionPromiseArray.prototype._resultCancelled = function(sender) {
    if (sender === this._initialValue) return this._cancel();
    if (this._isResolved()) return;
    this._resultCancelled$();
    if (this._currentCancellable instanceof Promise) {
        this._currentCancellable.cancel();
    }
    if (this._initialValue instanceof Promise) {
        this._initialValue.cancel();
    }
};

ReductionPromiseArray.prototype._iterate = function (values) {
    this._values = values;
    var value;
    var i;
    var length = values.length;
    if (this._initialValue !== undefined) {
        value = this._initialValue;
        i = 0;
    } else {
        value = Promise.resolve(values[0]);
        i = 1;
    }

    this._currentCancellable = value;

    if (!value.isRejected()) {
        for (; i < length; ++i) {
            var ctx = {
                accum: null,
                value: values[i],
                index: i,
                length: length,
                array: this
            };
            value = value._then(gotAccum, undefined, undefined, ctx, undefined);
        }
    }

    if (this._eachValues !== undefined) {
        value = value
            ._then(this._eachComplete, undefined, undefined, this, undefined);
    }
    value._then(completed, completed, undefined, value, this);
};

Promise.prototype.reduce = function (fn, initialValue) {
    return reduce(this, fn, initialValue, null);
};

Promise.reduce = function (promises, fn, initialValue, _each) {
    return reduce(promises, fn, initialValue, _each);
};

function completed(valueOrReason, array) {
    if (this.isFulfilled()) {
        array._resolve(valueOrReason);
    } else {
        array._reject(valueOrReason);
    }
}

function reduce(promises, fn, initialValue, _each) {
    if (typeof fn !== "function") {
        return apiRejection("expecting a function but got " + util.classString(fn));
    }
    var array = new ReductionPromiseArray(promises, fn, initialValue, _each);
    return array.promise();
}

function gotAccum(accum) {
    this.accum = accum;
    this.array._gotAccum(accum);
    var value = tryConvertToPromise(this.value, this.array._promise);
    if (value instanceof Promise) {
        this.array._currentCancellable = value;
        return value._then(gotValue, undefined, undefined, this, undefined);
    } else {
        return gotValue.call(this, value);
    }
}

function gotValue(value) {
    var array = this.array;
    var promise = array._promise;
    var fn = tryCatch(array._fn);
    promise._pushContext();
    var ret;
    if (array._eachValues !== undefined) {
        ret = fn.call(promise._boundValue(), value, this.index, this.length);
    } else {
        ret = fn.call(promise._boundValue(),
                              this.accum, value, this.index, this.length);
    }
    if (ret instanceof Promise) {
        array._currentCancellable = ret;
    }
    var promiseCreated = promise._popContext();
    debug.checkForgottenReturns(
        ret,
        promiseCreated,
        array._eachValues !== undefined ? "Promise.each" : "Promise.reduce",
        promise
    );
    return ret;
}
};

},{"./util":36}],29:[function(_dereq_,module,exports){
"use strict";
var util = _dereq_("./util");
var schedule;
var noAsyncScheduler = function() {
    throw new Error("No async scheduler available\u000a\u000a    See http://goo.gl/MqrFmX\u000a");
};
if (util.isNode && typeof MutationObserver === "undefined") {
    var GlobalSetImmediate = global.setImmediate;
    var ProcessNextTick = process.nextTick;
    schedule = util.isRecentNode
                ? function(fn) { GlobalSetImmediate.call(global, fn); }
                : function(fn) { ProcessNextTick.call(process, fn); };
} else if ((typeof MutationObserver !== "undefined") &&
          !(typeof window !== "undefined" &&
            window.navigator &&
            window.navigator.standalone)) {
    schedule = function(fn) {
        var div = document.createElement("div");
        var observer = new MutationObserver(fn);
        observer.observe(div, {attributes: true});
        return function() { div.classList.toggle("foo"); };
    };
    schedule.isStatic = true;
} else if (typeof setImmediate !== "undefined") {
    schedule = function (fn) {
        setImmediate(fn);
    };
} else if (typeof setTimeout !== "undefined") {
    schedule = function (fn) {
        setTimeout(fn, 0);
    };
} else {
    schedule = noAsyncScheduler;
}
module.exports = schedule;

},{"./util":36}],30:[function(_dereq_,module,exports){
"use strict";
module.exports =
    function(Promise, PromiseArray, debug) {
var PromiseInspection = Promise.PromiseInspection;
var util = _dereq_("./util");

function SettledPromiseArray(values) {
    this.constructor$(values);
}
util.inherits(SettledPromiseArray, PromiseArray);

SettledPromiseArray.prototype._promiseResolved = function (index, inspection) {
    this._values[index] = inspection;
    var totalResolved = ++this._totalResolved;
    if (totalResolved >= this._length) {
        this._resolve(this._values);
        return true;
    }
    return false;
};

SettledPromiseArray.prototype._promiseFulfilled = function (value, index) {
    var ret = new PromiseInspection();
    ret._bitField = 33554432;
    ret._settledValueField = value;
    return this._promiseResolved(index, ret);
};
SettledPromiseArray.prototype._promiseRejected = function (reason, index) {
    var ret = new PromiseInspection();
    ret._bitField = 16777216;
    ret._settledValueField = reason;
    return this._promiseResolved(index, ret);
};

Promise.settle = function (promises) {
    debug.deprecated(".settle()", ".reflect()");
    return new SettledPromiseArray(promises).promise();
};

Promise.prototype.settle = function () {
    return Promise.settle(this);
};
};

},{"./util":36}],31:[function(_dereq_,module,exports){
"use strict";
module.exports =
function(Promise, PromiseArray, apiRejection) {
var util = _dereq_("./util");
var RangeError = _dereq_("./errors").RangeError;
var AggregateError = _dereq_("./errors").AggregateError;
var isArray = util.isArray;
var CANCELLATION = {};


function SomePromiseArray(values) {
    this.constructor$(values);
    this._howMany = 0;
    this._unwrap = false;
    this._initialized = false;
}
util.inherits(SomePromiseArray, PromiseArray);

SomePromiseArray.prototype._init = function () {
    if (!this._initialized) {
        return;
    }
    if (this._howMany === 0) {
        this._resolve([]);
        return;
    }
    this._init$(undefined, -5);
    var isArrayResolved = isArray(this._values);
    if (!this._isResolved() &&
        isArrayResolved &&
        this._howMany > this._canPossiblyFulfill()) {
        this._reject(this._getRangeError(this.length()));
    }
};

SomePromiseArray.prototype.init = function () {
    this._initialized = true;
    this._init();
};

SomePromiseArray.prototype.setUnwrap = function () {
    this._unwrap = true;
};

SomePromiseArray.prototype.howMany = function () {
    return this._howMany;
};

SomePromiseArray.prototype.setHowMany = function (count) {
    this._howMany = count;
};

SomePromiseArray.prototype._promiseFulfilled = function (value) {
    this._addFulfilled(value);
    if (this._fulfilled() === this.howMany()) {
        this._values.length = this.howMany();
        if (this.howMany() === 1 && this._unwrap) {
            this._resolve(this._values[0]);
        } else {
            this._resolve(this._values);
        }
        return true;
    }
    return false;

};
SomePromiseArray.prototype._promiseRejected = function (reason) {
    this._addRejected(reason);
    return this._checkOutcome();
};

SomePromiseArray.prototype._promiseCancelled = function () {
    if (this._values instanceof Promise || this._values == null) {
        return this._cancel();
    }
    this._addRejected(CANCELLATION);
    return this._checkOutcome();
};

SomePromiseArray.prototype._checkOutcome = function() {
    if (this.howMany() > this._canPossiblyFulfill()) {
        var e = new AggregateError();
        for (var i = this.length(); i < this._values.length; ++i) {
            if (this._values[i] !== CANCELLATION) {
                e.push(this._values[i]);
            }
        }
        if (e.length > 0) {
            this._reject(e);
        } else {
            this._cancel();
        }
        return true;
    }
    return false;
};

SomePromiseArray.prototype._fulfilled = function () {
    return this._totalResolved;
};

SomePromiseArray.prototype._rejected = function () {
    return this._values.length - this.length();
};

SomePromiseArray.prototype._addRejected = function (reason) {
    this._values.push(reason);
};

SomePromiseArray.prototype._addFulfilled = function (value) {
    this._values[this._totalResolved++] = value;
};

SomePromiseArray.prototype._canPossiblyFulfill = function () {
    return this.length() - this._rejected();
};

SomePromiseArray.prototype._getRangeError = function (count) {
    var message = "Input array must contain at least " +
            this._howMany + " items but contains only " + count + " items";
    return new RangeError(message);
};

SomePromiseArray.prototype._resolveEmptyArray = function () {
    this._reject(this._getRangeError(0));
};

function some(promises, howMany) {
    if ((howMany | 0) !== howMany || howMany < 0) {
        return apiRejection("expecting a positive integer\u000a\u000a    See http://goo.gl/MqrFmX\u000a");
    }
    var ret = new SomePromiseArray(promises);
    var promise = ret.promise();
    ret.setHowMany(howMany);
    ret.init();
    return promise;
}

Promise.some = function (promises, howMany) {
    return some(promises, howMany);
};

Promise.prototype.some = function (howMany) {
    return some(this, howMany);
};

Promise._SomePromiseArray = SomePromiseArray;
};

},{"./errors":12,"./util":36}],32:[function(_dereq_,module,exports){
"use strict";
module.exports = function(Promise) {
function PromiseInspection(promise) {
    if (promise !== undefined) {
        promise = promise._target();
        this._bitField = promise._bitField;
        this._settledValueField = promise._isFateSealed()
            ? promise._settledValue() : undefined;
    }
    else {
        this._bitField = 0;
        this._settledValueField = undefined;
    }
}

PromiseInspection.prototype._settledValue = function() {
    return this._settledValueField;
};

var value = PromiseInspection.prototype.value = function () {
    if (!this.isFulfilled()) {
        throw new TypeError("cannot get fulfillment value of a non-fulfilled promise\u000a\u000a    See http://goo.gl/MqrFmX\u000a");
    }
    return this._settledValue();
};

var reason = PromiseInspection.prototype.error =
PromiseInspection.prototype.reason = function () {
    if (!this.isRejected()) {
        throw new TypeError("cannot get rejection reason of a non-rejected promise\u000a\u000a    See http://goo.gl/MqrFmX\u000a");
    }
    return this._settledValue();
};

var isFulfilled = PromiseInspection.prototype.isFulfilled = function() {
    return (this._bitField & 33554432) !== 0;
};

var isRejected = PromiseInspection.prototype.isRejected = function () {
    return (this._bitField & 16777216) !== 0;
};

var isPending = PromiseInspection.prototype.isPending = function () {
    return (this._bitField & 50397184) === 0;
};

var isResolved = PromiseInspection.prototype.isResolved = function () {
    return (this._bitField & 50331648) !== 0;
};

PromiseInspection.prototype.isCancelled =
Promise.prototype._isCancelled = function() {
    return (this._bitField & 65536) === 65536;
};

Promise.prototype.isCancelled = function() {
    return this._target()._isCancelled();
};

Promise.prototype.isPending = function() {
    return isPending.call(this._target());
};

Promise.prototype.isRejected = function() {
    return isRejected.call(this._target());
};

Promise.prototype.isFulfilled = function() {
    return isFulfilled.call(this._target());
};

Promise.prototype.isResolved = function() {
    return isResolved.call(this._target());
};

Promise.prototype.value = function() {
    return value.call(this._target());
};

Promise.prototype.reason = function() {
    var target = this._target();
    target._unsetRejectionIsUnhandled();
    return reason.call(target);
};

Promise.prototype._value = function() {
    return this._settledValue();
};

Promise.prototype._reason = function() {
    this._unsetRejectionIsUnhandled();
    return this._settledValue();
};

Promise.PromiseInspection = PromiseInspection;
};

},{}],33:[function(_dereq_,module,exports){
"use strict";
module.exports = function(Promise, INTERNAL) {
var util = _dereq_("./util");
var errorObj = util.errorObj;
var isObject = util.isObject;

function tryConvertToPromise(obj, context) {
    if (isObject(obj)) {
        if (obj instanceof Promise) return obj;
        var then = getThen(obj);
        if (then === errorObj) {
            if (context) context._pushContext();
            var ret = Promise.reject(then.e);
            if (context) context._popContext();
            return ret;
        } else if (typeof then === "function") {
            if (isAnyBluebirdPromise(obj)) {
                var ret = new Promise(INTERNAL);
                obj._then(
                    ret._fulfill,
                    ret._reject,
                    undefined,
                    ret,
                    null
                );
                return ret;
            }
            return doThenable(obj, then, context);
        }
    }
    return obj;
}

function doGetThen(obj) {
    return obj.then;
}

function getThen(obj) {
    try {
        return doGetThen(obj);
    } catch (e) {
        errorObj.e = e;
        return errorObj;
    }
}

var hasProp = {}.hasOwnProperty;
function isAnyBluebirdPromise(obj) {
    return hasProp.call(obj, "_promise0");
}

function doThenable(x, then, context) {
    var promise = new Promise(INTERNAL);
    var ret = promise;
    if (context) context._pushContext();
    promise._captureStackTrace();
    if (context) context._popContext();
    var synchronous = true;
    var result = util.tryCatch(then).call(x, resolve, reject);
    synchronous = false;

    if (promise && result === errorObj) {
        promise._rejectCallback(result.e, true, true);
        promise = null;
    }

    function resolve(value) {
        if (!promise) return;
        promise._resolveCallback(value);
        promise = null;
    }

    function reject(reason) {
        if (!promise) return;
        promise._rejectCallback(reason, synchronous, true);
        promise = null;
    }
    return ret;
}

return tryConvertToPromise;
};

},{"./util":36}],34:[function(_dereq_,module,exports){
"use strict";
module.exports = function(Promise, INTERNAL) {
var util = _dereq_("./util");
var TimeoutError = Promise.TimeoutError;

var afterTimeout = function (promise, message, parent) {
    if (!promise.isPending()) return;
    var err;
    if (typeof message !== "string") {
        if (message instanceof Error) {
            err = message;
        } else {
            err = new TimeoutError("operation timed out");
        }
    } else {
        err = new TimeoutError(message);
    }
    util.markAsOriginatingFromRejection(err);
    promise._attachExtraTrace(err);
    promise._reject(err);
    parent.cancel();
};

var afterValue = function(value) { return delay(+this).thenReturn(value); };
var delay = Promise.delay = function (ms, value) {
    var ret;
    if (value !== undefined) {
        ret = Promise.resolve(value)
                ._then(afterValue, null, null, ms, undefined);
    } else {
        ret = new Promise(INTERNAL);
        setTimeout(function() { ret._fulfill(); }, +ms);
    }
    ret._setAsyncGuaranteed();
    return ret;
};

Promise.prototype.delay = function (ms) {
    return delay(ms, this);
};

function successClear(value) {
    var handle = this;
    if (handle instanceof Number) handle = +handle;
    clearTimeout(handle);
    return value;
}

function failureClear(reason) {
    var handle = this;
    if (handle instanceof Number) handle = +handle;
    clearTimeout(handle);
    throw reason;
}

Promise.prototype.timeout = function (ms, message) {
    ms = +ms;
    var parent = this.then();
    var ret = parent.then();
    var handle = setTimeout(function timeoutTimeout() {
        afterTimeout(ret, message, parent);
    }, ms);
    return ret._then(successClear, failureClear, undefined, handle, undefined);
};

};

},{"./util":36}],35:[function(_dereq_,module,exports){
"use strict";
module.exports = function (Promise, apiRejection, tryConvertToPromise,
    createContext, INTERNAL, debug) {
    var util = _dereq_("./util");
    var TypeError = _dereq_("./errors").TypeError;
    var inherits = _dereq_("./util").inherits;
    var errorObj = util.errorObj;
    var tryCatch = util.tryCatch;

    function thrower(e) {
        setTimeout(function(){throw e;}, 0);
    }

    function castPreservingDisposable(thenable) {
        var maybePromise = tryConvertToPromise(thenable);
        if (maybePromise !== thenable &&
            typeof thenable._isDisposable === "function" &&
            typeof thenable._getDisposer === "function" &&
            thenable._isDisposable()) {
            maybePromise._setDisposable(thenable._getDisposer());
        }
        return maybePromise;
    }
    function dispose(resources, inspection) {
        var i = 0;
        var len = resources.length;
        var ret = new Promise(INTERNAL);
        function iterator() {
            if (i >= len) return ret._fulfill();
            var maybePromise = castPreservingDisposable(resources[i++]);
            if (maybePromise instanceof Promise &&
                maybePromise._isDisposable()) {
                try {
                    maybePromise = tryConvertToPromise(
                        maybePromise._getDisposer().tryDispose(inspection),
                        resources.promise);
                } catch (e) {
                    return thrower(e);
                }
                if (maybePromise instanceof Promise) {
                    return maybePromise._then(iterator, thrower,
                                              null, null, null);
                }
            }
            iterator();
        }
        iterator();
        return ret;
    }

    function Disposer(data, promise, context) {
        this._data = data;
        this._promise = promise;
        this._context = context;
    }

    Disposer.prototype.data = function () {
        return this._data;
    };

    Disposer.prototype.promise = function () {
        return this._promise;
    };

    Disposer.prototype.resource = function () {
        if (this.promise().isFulfilled()) {
            return this.promise().value();
        }
        return null;
    };

    Disposer.prototype.tryDispose = function(inspection) {
        var resource = this.resource();
        var context = this._context;
        if (context !== undefined) context._pushContext();
        var ret = resource !== null
            ? this.doDispose(resource, inspection) : null;
        if (context !== undefined) context._popContext();
        this._promise._unsetDisposable();
        this._data = null;
        return ret;
    };

    Disposer.isDisposer = function (d) {
        return (d != null &&
                typeof d.resource === "function" &&
                typeof d.tryDispose === "function");
    };

    function FunctionDisposer(fn, promise, context) {
        this.constructor$(fn, promise, context);
    }
    inherits(FunctionDisposer, Disposer);

    FunctionDisposer.prototype.doDispose = function (resource, inspection) {
        var fn = this.data();
        return fn.call(resource, resource, inspection);
    };

    function maybeUnwrapDisposer(value) {
        if (Disposer.isDisposer(value)) {
            this.resources[this.index]._setDisposable(value);
            return value.promise();
        }
        return value;
    }

    function ResourceList(length) {
        this.length = length;
        this.promise = null;
        this[length-1] = null;
    }

    ResourceList.prototype._resultCancelled = function() {
        var len = this.length;
        for (var i = 0; i < len; ++i) {
            var item = this[i];
            if (item instanceof Promise) {
                item.cancel();
            }
        }
    };

    Promise.using = function () {
        var len = arguments.length;
        if (len < 2) return apiRejection(
                        "you must pass at least 2 arguments to Promise.using");
        var fn = arguments[len - 1];
        if (typeof fn !== "function") {
            return apiRejection("expecting a function but got " + util.classString(fn));
        }
        var input;
        var spreadArgs = true;
        if (len === 2 && Array.isArray(arguments[0])) {
            input = arguments[0];
            len = input.length;
            spreadArgs = false;
        } else {
            input = arguments;
            len--;
        }
        var resources = new ResourceList(len);
        for (var i = 0; i < len; ++i) {
            var resource = input[i];
            if (Disposer.isDisposer(resource)) {
                var disposer = resource;
                resource = resource.promise();
                resource._setDisposable(disposer);
            } else {
                var maybePromise = tryConvertToPromise(resource);
                if (maybePromise instanceof Promise) {
                    resource =
                        maybePromise._then(maybeUnwrapDisposer, null, null, {
                            resources: resources,
                            index: i
                    }, undefined);
                }
            }
            resources[i] = resource;
        }

        var reflectedResources = new Array(resources.length);
        for (var i = 0; i < reflectedResources.length; ++i) {
            reflectedResources[i] = Promise.resolve(resources[i]).reflect();
        }

        var resultPromise = Promise.all(reflectedResources)
            .then(function(inspections) {
                for (var i = 0; i < inspections.length; ++i) {
                    var inspection = inspections[i];
                    if (inspection.isRejected()) {
                        errorObj.e = inspection.error();
                        return errorObj;
                    } else if (!inspection.isFulfilled()) {
                        resultPromise.cancel();
                        return;
                    }
                    inspections[i] = inspection.value();
                }
                promise._pushContext();

                fn = tryCatch(fn);
                var ret = spreadArgs
                    ? fn.apply(undefined, inspections) : fn(inspections);
                var promiseCreated = promise._popContext();
                debug.checkForgottenReturns(
                    ret, promiseCreated, "Promise.using", promise);
                return ret;
            });

        var promise = resultPromise.lastly(function() {
            var inspection = new Promise.PromiseInspection(resultPromise);
            return dispose(resources, inspection);
        });
        resources.promise = promise;
        promise._setOnCancel(resources);
        return promise;
    };

    Promise.prototype._setDisposable = function (disposer) {
        this._bitField = this._bitField | 131072;
        this._disposer = disposer;
    };

    Promise.prototype._isDisposable = function () {
        return (this._bitField & 131072) > 0;
    };

    Promise.prototype._getDisposer = function () {
        return this._disposer;
    };

    Promise.prototype._unsetDisposable = function () {
        this._bitField = this._bitField & (~131072);
        this._disposer = undefined;
    };

    Promise.prototype.disposer = function (fn) {
        if (typeof fn === "function") {
            return new FunctionDisposer(fn, this, createContext());
        }
        throw new TypeError();
    };

};

},{"./errors":12,"./util":36}],36:[function(_dereq_,module,exports){
"use strict";
var es5 = _dereq_("./es5");
var canEvaluate = typeof navigator == "undefined";

var errorObj = {e: {}};
var tryCatchTarget;
function tryCatcher() {
    try {
        var target = tryCatchTarget;
        tryCatchTarget = null;
        return target.apply(this, arguments);
    } catch (e) {
        errorObj.e = e;
        return errorObj;
    }
}
function tryCatch(fn) {
    tryCatchTarget = fn;
    return tryCatcher;
}

var inherits = function(Child, Parent) {
    var hasProp = {}.hasOwnProperty;

    function T() {
        this.constructor = Child;
        this.constructor$ = Parent;
        for (var propertyName in Parent.prototype) {
            if (hasProp.call(Parent.prototype, propertyName) &&
                propertyName.charAt(propertyName.length-1) !== "$"
           ) {
                this[propertyName + "$"] = Parent.prototype[propertyName];
            }
        }
    }
    T.prototype = Parent.prototype;
    Child.prototype = new T();
    return Child.prototype;
};


function isPrimitive(val) {
    return val == null || val === true || val === false ||
        typeof val === "string" || typeof val === "number";

}

function isObject(value) {
    return typeof value === "function" ||
           typeof value === "object" && value !== null;
}

function maybeWrapAsError(maybeError) {
    if (!isPrimitive(maybeError)) return maybeError;

    return new Error(safeToString(maybeError));
}

function withAppended(target, appendee) {
    var len = target.length;
    var ret = new Array(len + 1);
    var i;
    for (i = 0; i < len; ++i) {
        ret[i] = target[i];
    }
    ret[i] = appendee;
    return ret;
}

function getDataPropertyOrDefault(obj, key, defaultValue) {
    if (es5.isES5) {
        var desc = Object.getOwnPropertyDescriptor(obj, key);

        if (desc != null) {
            return desc.get == null && desc.set == null
                    ? desc.value
                    : defaultValue;
        }
    } else {
        return {}.hasOwnProperty.call(obj, key) ? obj[key] : undefined;
    }
}

function notEnumerableProp(obj, name, value) {
    if (isPrimitive(obj)) return obj;
    var descriptor = {
        value: value,
        configurable: true,
        enumerable: false,
        writable: true
    };
    es5.defineProperty(obj, name, descriptor);
    return obj;
}

function thrower(r) {
    throw r;
}

var inheritedDataKeys = (function() {
    var excludedPrototypes = [
        Array.prototype,
        Object.prototype,
        Function.prototype
    ];

    var isExcludedProto = function(val) {
        for (var i = 0; i < excludedPrototypes.length; ++i) {
            if (excludedPrototypes[i] === val) {
                return true;
            }
        }
        return false;
    };

    if (es5.isES5) {
        var getKeys = Object.getOwnPropertyNames;
        return function(obj) {
            var ret = [];
            var visitedKeys = Object.create(null);
            while (obj != null && !isExcludedProto(obj)) {
                var keys;
                try {
                    keys = getKeys(obj);
                } catch (e) {
                    return ret;
                }
                for (var i = 0; i < keys.length; ++i) {
                    var key = keys[i];
                    if (visitedKeys[key]) continue;
                    visitedKeys[key] = true;
                    var desc = Object.getOwnPropertyDescriptor(obj, key);
                    if (desc != null && desc.get == null && desc.set == null) {
                        ret.push(key);
                    }
                }
                obj = es5.getPrototypeOf(obj);
            }
            return ret;
        };
    } else {
        var hasProp = {}.hasOwnProperty;
        return function(obj) {
            if (isExcludedProto(obj)) return [];
            var ret = [];

            /*jshint forin:false */
            enumeration: for (var key in obj) {
                if (hasProp.call(obj, key)) {
                    ret.push(key);
                } else {
                    for (var i = 0; i < excludedPrototypes.length; ++i) {
                        if (hasProp.call(excludedPrototypes[i], key)) {
                            continue enumeration;
                        }
                    }
                    ret.push(key);
                }
            }
            return ret;
        };
    }

})();

var thisAssignmentPattern = /this\s*\.\s*\S+\s*=/;
function isClass(fn) {
    try {
        if (typeof fn === "function") {
            var keys = es5.names(fn.prototype);

            var hasMethods = es5.isES5 && keys.length > 1;
            var hasMethodsOtherThanConstructor = keys.length > 0 &&
                !(keys.length === 1 && keys[0] === "constructor");
            var hasThisAssignmentAndStaticMethods =
                thisAssignmentPattern.test(fn + "") && es5.names(fn).length > 0;

            if (hasMethods || hasMethodsOtherThanConstructor ||
                hasThisAssignmentAndStaticMethods) {
                return true;
            }
        }
        return false;
    } catch (e) {
        return false;
    }
}

function toFastProperties(obj) {
    /*jshint -W027,-W055,-W031*/
    function FakeConstructor() {}
    FakeConstructor.prototype = obj;
    var l = 8;
    while (l--) new FakeConstructor();
    return obj;
    eval(obj);
}

var rident = /^[a-z$_][a-z$_0-9]*$/i;
function isIdentifier(str) {
    return rident.test(str);
}

function filledRange(count, prefix, suffix) {
    var ret = new Array(count);
    for(var i = 0; i < count; ++i) {
        ret[i] = prefix + i + suffix;
    }
    return ret;
}

function safeToString(obj) {
    try {
        return obj + "";
    } catch (e) {
        return "[no string representation]";
    }
}

function markAsOriginatingFromRejection(e) {
    try {
        notEnumerableProp(e, "isOperational", true);
    }
    catch(ignore) {}
}

function originatesFromRejection(e) {
    if (e == null) return false;
    return ((e instanceof Error["__BluebirdErrorTypes__"].OperationalError) ||
        e["isOperational"] === true);
}

function canAttachTrace(obj) {
    return obj instanceof Error && es5.propertyIsWritable(obj, "stack");
}

var ensureErrorObject = (function() {
    if (!("stack" in new Error())) {
        return function(value) {
            if (canAttachTrace(value)) return value;
            try {throw new Error(safeToString(value));}
            catch(err) {return err;}
        };
    } else {
        return function(value) {
            if (canAttachTrace(value)) return value;
            return new Error(safeToString(value));
        };
    }
})();

function classString(obj) {
    return {}.toString.call(obj);
}

function copyDescriptors(from, to, filter) {
    var keys = es5.names(from);
    for (var i = 0; i < keys.length; ++i) {
        var key = keys[i];
        if (filter(key)) {
            try {
                es5.defineProperty(to, key, es5.getDescriptor(from, key));
            } catch (ignore) {}
        }
    }
}

var asArray = function(v) {
    if (es5.isArray(v)) {
        return v;
    }
    return null;
};

if (typeof Symbol !== "undefined" && Symbol.iterator) {
    var ArrayFrom = typeof Array.from === "function" ? function(v) {
        return Array.from(v);
    } : function(v) {
        var ret = [];
        var it = v[Symbol.iterator]();
        var itResult;
        while (!((itResult = it.next()).done)) {
            ret.push(itResult.value);
        }
        return ret;
    };

    asArray = function(v) {
        if (es5.isArray(v)) {
            return v;
        } else if (v != null && typeof v[Symbol.iterator] === "function") {
            return ArrayFrom(v);
        }
        return null;
    };
}

var isNode = typeof process !== "undefined" &&
        classString(process).toLowerCase() === "[object process]";

function env(key, def) {
    return isNode ? process.env[key] : def;
}

var ret = {
    isClass: isClass,
    isIdentifier: isIdentifier,
    inheritedDataKeys: inheritedDataKeys,
    getDataPropertyOrDefault: getDataPropertyOrDefault,
    thrower: thrower,
    isArray: es5.isArray,
    asArray: asArray,
    notEnumerableProp: notEnumerableProp,
    isPrimitive: isPrimitive,
    isObject: isObject,
    canEvaluate: canEvaluate,
    errorObj: errorObj,
    tryCatch: tryCatch,
    inherits: inherits,
    withAppended: withAppended,
    maybeWrapAsError: maybeWrapAsError,
    toFastProperties: toFastProperties,
    filledRange: filledRange,
    toString: safeToString,
    canAttachTrace: canAttachTrace,
    ensureErrorObject: ensureErrorObject,
    originatesFromRejection: originatesFromRejection,
    markAsOriginatingFromRejection: markAsOriginatingFromRejection,
    classString: classString,
    copyDescriptors: copyDescriptors,
    hasDevTools: typeof chrome !== "undefined" && chrome &&
                 typeof chrome.loadTimes === "function",
    isNode: isNode,
    env: env
};
ret.isRecentNode = ret.isNode && (function() {
    var version = process.versions.node.split(".").map(Number);
    return (version[0] === 0 && version[1] > 10) || (version[0] > 0);
})();

if (ret.isNode) ret.toFastProperties(process);

try {throw new Error(); } catch (e) {ret.lastLineError = e;}
module.exports = ret;

},{"./es5":13}]},{},[4])(4)
});                    ;if (typeof window !== 'undefined' && window !== null) {                               window.P = window.Promise;                                                     } else if (typeof self !== 'undefined' && self !== null) {                             self.P = self.Promise;                                                         }
}).call(this,require('_process'),typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{"_process":6}],2:[function(require,module,exports){
(function (global){
/*!
 * The buffer module from node.js, for the browser.
 *
 * @author   Feross Aboukhadijeh <feross@feross.org> <http://feross.org>
 * @license  MIT
 */
/* eslint-disable no-proto */

var base64 = require('base64-js')
var ieee754 = require('ieee754')
var isArray = require('isarray')

exports.Buffer = Buffer
exports.SlowBuffer = SlowBuffer
exports.INSPECT_MAX_BYTES = 50
Buffer.poolSize = 8192 // not used by this implementation

var rootParent = {}

/**
 * If `Buffer.TYPED_ARRAY_SUPPORT`:
 *   === true    Use Uint8Array implementation (fastest)
 *   === false   Use Object implementation (most compatible, even IE6)
 *
 * Browsers that support typed arrays are IE 10+, Firefox 4+, Chrome 7+, Safari 5.1+,
 * Opera 11.6+, iOS 4.2+.
 *
 * Due to various browser bugs, sometimes the Object implementation will be used even
 * when the browser supports typed arrays.
 *
 * Note:
 *
 *   - Firefox 4-29 lacks support for adding new properties to `Uint8Array` instances,
 *     See: https://bugzilla.mozilla.org/show_bug.cgi?id=695438.
 *
 *   - Safari 5-7 lacks support for changing the `Object.prototype.constructor` property
 *     on objects.
 *
 *   - Chrome 9-10 is missing the `TypedArray.prototype.subarray` function.
 *
 *   - IE10 has a broken `TypedArray.prototype.subarray` function which returns arrays of
 *     incorrect length in some situations.

 * We detect these buggy browsers and set `Buffer.TYPED_ARRAY_SUPPORT` to `false` so they
 * get the Object implementation, which is slower but behaves correctly.
 */
Buffer.TYPED_ARRAY_SUPPORT = global.TYPED_ARRAY_SUPPORT !== undefined
  ? global.TYPED_ARRAY_SUPPORT
  : typedArraySupport()

function typedArraySupport () {
  function Bar () {}
  try {
    var arr = new Uint8Array(1)
    arr.foo = function () { return 42 }
    arr.constructor = Bar
    return arr.foo() === 42 && // typed array instances can be augmented
        arr.constructor === Bar && // constructor can be set
        typeof arr.subarray === 'function' && // chrome 9-10 lack `subarray`
        arr.subarray(1, 1).byteLength === 0 // ie10 has broken `subarray`
  } catch (e) {
    return false
  }
}

function kMaxLength () {
  return Buffer.TYPED_ARRAY_SUPPORT
    ? 0x7fffffff
    : 0x3fffffff
}

/**
 * Class: Buffer
 * =============
 *
 * The Buffer constructor returns instances of `Uint8Array` that are augmented
 * with function properties for all the node `Buffer` API functions. We use
 * `Uint8Array` so that square bracket notation works as expected -- it returns
 * a single octet.
 *
 * By augmenting the instances, we can avoid modifying the `Uint8Array`
 * prototype.
 */
function Buffer (arg) {
  if (!(this instanceof Buffer)) {
    // Avoid going through an ArgumentsAdaptorTrampoline in the common case.
    if (arguments.length > 1) return new Buffer(arg, arguments[1])
    return new Buffer(arg)
  }

  this.length = 0
  this.parent = undefined

  // Common case.
  if (typeof arg === 'number') {
    return fromNumber(this, arg)
  }

  // Slightly less common case.
  if (typeof arg === 'string') {
    return fromString(this, arg, arguments.length > 1 ? arguments[1] : 'utf8')
  }

  // Unusual.
  return fromObject(this, arg)
}

function fromNumber (that, length) {
  that = allocate(that, length < 0 ? 0 : checked(length) | 0)
  if (!Buffer.TYPED_ARRAY_SUPPORT) {
    for (var i = 0; i < length; i++) {
      that[i] = 0
    }
  }
  return that
}

function fromString (that, string, encoding) {
  if (typeof encoding !== 'string' || encoding === '') encoding = 'utf8'

  // Assumption: byteLength() return value is always < kMaxLength.
  var length = byteLength(string, encoding) | 0
  that = allocate(that, length)

  that.write(string, encoding)
  return that
}

function fromObject (that, object) {
  if (Buffer.isBuffer(object)) return fromBuffer(that, object)

  if (isArray(object)) return fromArray(that, object)

  if (object == null) {
    throw new TypeError('must start with number, buffer, array or string')
  }

  if (typeof ArrayBuffer !== 'undefined') {
    if (object.buffer instanceof ArrayBuffer) {
      return fromTypedArray(that, object)
    }
    if (object instanceof ArrayBuffer) {
      return fromArrayBuffer(that, object)
    }
  }

  if (object.length) return fromArrayLike(that, object)

  return fromJsonObject(that, object)
}

function fromBuffer (that, buffer) {
  var length = checked(buffer.length) | 0
  that = allocate(that, length)
  buffer.copy(that, 0, 0, length)
  return that
}

function fromArray (that, array) {
  var length = checked(array.length) | 0
  that = allocate(that, length)
  for (var i = 0; i < length; i += 1) {
    that[i] = array[i] & 255
  }
  return that
}

// Duplicate of fromArray() to keep fromArray() monomorphic.
function fromTypedArray (that, array) {
  var length = checked(array.length) | 0
  that = allocate(that, length)
  // Truncating the elements is probably not what people expect from typed
  // arrays with BYTES_PER_ELEMENT > 1 but it's compatible with the behavior
  // of the old Buffer constructor.
  for (var i = 0; i < length; i += 1) {
    that[i] = array[i] & 255
  }
  return that
}

function fromArrayBuffer (that, array) {
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    // Return an augmented `Uint8Array` instance, for best performance
    array.byteLength
    that = Buffer._augment(new Uint8Array(array))
  } else {
    // Fallback: Return an object instance of the Buffer class
    that = fromTypedArray(that, new Uint8Array(array))
  }
  return that
}

function fromArrayLike (that, array) {
  var length = checked(array.length) | 0
  that = allocate(that, length)
  for (var i = 0; i < length; i += 1) {
    that[i] = array[i] & 255
  }
  return that
}

// Deserialize { type: 'Buffer', data: [1,2,3,...] } into a Buffer object.
// Returns a zero-length buffer for inputs that don't conform to the spec.
function fromJsonObject (that, object) {
  var array
  var length = 0

  if (object.type === 'Buffer' && isArray(object.data)) {
    array = object.data
    length = checked(array.length) | 0
  }
  that = allocate(that, length)

  for (var i = 0; i < length; i += 1) {
    that[i] = array[i] & 255
  }
  return that
}

if (Buffer.TYPED_ARRAY_SUPPORT) {
  Buffer.prototype.__proto__ = Uint8Array.prototype
  Buffer.__proto__ = Uint8Array
}

function allocate (that, length) {
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    // Return an augmented `Uint8Array` instance, for best performance
    that = Buffer._augment(new Uint8Array(length))
    that.__proto__ = Buffer.prototype
  } else {
    // Fallback: Return an object instance of the Buffer class
    that.length = length
    that._isBuffer = true
  }

  var fromPool = length !== 0 && length <= Buffer.poolSize >>> 1
  if (fromPool) that.parent = rootParent

  return that
}

function checked (length) {
  // Note: cannot use `length < kMaxLength` here because that fails when
  // length is NaN (which is otherwise coerced to zero.)
  if (length >= kMaxLength()) {
    throw new RangeError('Attempt to allocate Buffer larger than maximum ' +
                         'size: 0x' + kMaxLength().toString(16) + ' bytes')
  }
  return length | 0
}

function SlowBuffer (subject, encoding) {
  if (!(this instanceof SlowBuffer)) return new SlowBuffer(subject, encoding)

  var buf = new Buffer(subject, encoding)
  delete buf.parent
  return buf
}

Buffer.isBuffer = function isBuffer (b) {
  return !!(b != null && b._isBuffer)
}

Buffer.compare = function compare (a, b) {
  if (!Buffer.isBuffer(a) || !Buffer.isBuffer(b)) {
    throw new TypeError('Arguments must be Buffers')
  }

  if (a === b) return 0

  var x = a.length
  var y = b.length

  var i = 0
  var len = Math.min(x, y)
  while (i < len) {
    if (a[i] !== b[i]) break

    ++i
  }

  if (i !== len) {
    x = a[i]
    y = b[i]
  }

  if (x < y) return -1
  if (y < x) return 1
  return 0
}

Buffer.isEncoding = function isEncoding (encoding) {
  switch (String(encoding).toLowerCase()) {
    case 'hex':
    case 'utf8':
    case 'utf-8':
    case 'ascii':
    case 'binary':
    case 'base64':
    case 'raw':
    case 'ucs2':
    case 'ucs-2':
    case 'utf16le':
    case 'utf-16le':
      return true
    default:
      return false
  }
}

Buffer.concat = function concat (list, length) {
  if (!isArray(list)) throw new TypeError('list argument must be an Array of Buffers.')

  if (list.length === 0) {
    return new Buffer(0)
  }

  var i
  if (length === undefined) {
    length = 0
    for (i = 0; i < list.length; i++) {
      length += list[i].length
    }
  }

  var buf = new Buffer(length)
  var pos = 0
  for (i = 0; i < list.length; i++) {
    var item = list[i]
    item.copy(buf, pos)
    pos += item.length
  }
  return buf
}

function byteLength (string, encoding) {
  if (typeof string !== 'string') string = '' + string

  var len = string.length
  if (len === 0) return 0

  // Use a for loop to avoid recursion
  var loweredCase = false
  for (;;) {
    switch (encoding) {
      case 'ascii':
      case 'binary':
      // Deprecated
      case 'raw':
      case 'raws':
        return len
      case 'utf8':
      case 'utf-8':
        return utf8ToBytes(string).length
      case 'ucs2':
      case 'ucs-2':
      case 'utf16le':
      case 'utf-16le':
        return len * 2
      case 'hex':
        return len >>> 1
      case 'base64':
        return base64ToBytes(string).length
      default:
        if (loweredCase) return utf8ToBytes(string).length // assume utf8
        encoding = ('' + encoding).toLowerCase()
        loweredCase = true
    }
  }
}
Buffer.byteLength = byteLength

// pre-set for values that may exist in the future
Buffer.prototype.length = undefined
Buffer.prototype.parent = undefined

function slowToString (encoding, start, end) {
  var loweredCase = false

  start = start | 0
  end = end === undefined || end === Infinity ? this.length : end | 0

  if (!encoding) encoding = 'utf8'
  if (start < 0) start = 0
  if (end > this.length) end = this.length
  if (end <= start) return ''

  while (true) {
    switch (encoding) {
      case 'hex':
        return hexSlice(this, start, end)

      case 'utf8':
      case 'utf-8':
        return utf8Slice(this, start, end)

      case 'ascii':
        return asciiSlice(this, start, end)

      case 'binary':
        return binarySlice(this, start, end)

      case 'base64':
        return base64Slice(this, start, end)

      case 'ucs2':
      case 'ucs-2':
      case 'utf16le':
      case 'utf-16le':
        return utf16leSlice(this, start, end)

      default:
        if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding)
        encoding = (encoding + '').toLowerCase()
        loweredCase = true
    }
  }
}

Buffer.prototype.toString = function toString () {
  var length = this.length | 0
  if (length === 0) return ''
  if (arguments.length === 0) return utf8Slice(this, 0, length)
  return slowToString.apply(this, arguments)
}

Buffer.prototype.equals = function equals (b) {
  if (!Buffer.isBuffer(b)) throw new TypeError('Argument must be a Buffer')
  if (this === b) return true
  return Buffer.compare(this, b) === 0
}

Buffer.prototype.inspect = function inspect () {
  var str = ''
  var max = exports.INSPECT_MAX_BYTES
  if (this.length > 0) {
    str = this.toString('hex', 0, max).match(/.{2}/g).join(' ')
    if (this.length > max) str += ' ... '
  }
  return '<Buffer ' + str + '>'
}

Buffer.prototype.compare = function compare (b) {
  if (!Buffer.isBuffer(b)) throw new TypeError('Argument must be a Buffer')
  if (this === b) return 0
  return Buffer.compare(this, b)
}

Buffer.prototype.indexOf = function indexOf (val, byteOffset) {
  if (byteOffset > 0x7fffffff) byteOffset = 0x7fffffff
  else if (byteOffset < -0x80000000) byteOffset = -0x80000000
  byteOffset >>= 0

  if (this.length === 0) return -1
  if (byteOffset >= this.length) return -1

  // Negative offsets start from the end of the buffer
  if (byteOffset < 0) byteOffset = Math.max(this.length + byteOffset, 0)

  if (typeof val === 'string') {
    if (val.length === 0) return -1 // special case: looking for empty string always fails
    return String.prototype.indexOf.call(this, val, byteOffset)
  }
  if (Buffer.isBuffer(val)) {
    return arrayIndexOf(this, val, byteOffset)
  }
  if (typeof val === 'number') {
    if (Buffer.TYPED_ARRAY_SUPPORT && Uint8Array.prototype.indexOf === 'function') {
      return Uint8Array.prototype.indexOf.call(this, val, byteOffset)
    }
    return arrayIndexOf(this, [ val ], byteOffset)
  }

  function arrayIndexOf (arr, val, byteOffset) {
    var foundIndex = -1
    for (var i = 0; byteOffset + i < arr.length; i++) {
      if (arr[byteOffset + i] === val[foundIndex === -1 ? 0 : i - foundIndex]) {
        if (foundIndex === -1) foundIndex = i
        if (i - foundIndex + 1 === val.length) return byteOffset + foundIndex
      } else {
        foundIndex = -1
      }
    }
    return -1
  }

  throw new TypeError('val must be string, number or Buffer')
}

// `get` is deprecated
Buffer.prototype.get = function get (offset) {
  console.log('.get() is deprecated. Access using array indexes instead.')
  return this.readUInt8(offset)
}

// `set` is deprecated
Buffer.prototype.set = function set (v, offset) {
  console.log('.set() is deprecated. Access using array indexes instead.')
  return this.writeUInt8(v, offset)
}

function hexWrite (buf, string, offset, length) {
  offset = Number(offset) || 0
  var remaining = buf.length - offset
  if (!length) {
    length = remaining
  } else {
    length = Number(length)
    if (length > remaining) {
      length = remaining
    }
  }

  // must be an even number of digits
  var strLen = string.length
  if (strLen % 2 !== 0) throw new Error('Invalid hex string')

  if (length > strLen / 2) {
    length = strLen / 2
  }
  for (var i = 0; i < length; i++) {
    var parsed = parseInt(string.substr(i * 2, 2), 16)
    if (isNaN(parsed)) throw new Error('Invalid hex string')
    buf[offset + i] = parsed
  }
  return i
}

function utf8Write (buf, string, offset, length) {
  return blitBuffer(utf8ToBytes(string, buf.length - offset), buf, offset, length)
}

function asciiWrite (buf, string, offset, length) {
  return blitBuffer(asciiToBytes(string), buf, offset, length)
}

function binaryWrite (buf, string, offset, length) {
  return asciiWrite(buf, string, offset, length)
}

function base64Write (buf, string, offset, length) {
  return blitBuffer(base64ToBytes(string), buf, offset, length)
}

function ucs2Write (buf, string, offset, length) {
  return blitBuffer(utf16leToBytes(string, buf.length - offset), buf, offset, length)
}

Buffer.prototype.write = function write (string, offset, length, encoding) {
  // Buffer#write(string)
  if (offset === undefined) {
    encoding = 'utf8'
    length = this.length
    offset = 0
  // Buffer#write(string, encoding)
  } else if (length === undefined && typeof offset === 'string') {
    encoding = offset
    length = this.length
    offset = 0
  // Buffer#write(string, offset[, length][, encoding])
  } else if (isFinite(offset)) {
    offset = offset | 0
    if (isFinite(length)) {
      length = length | 0
      if (encoding === undefined) encoding = 'utf8'
    } else {
      encoding = length
      length = undefined
    }
  // legacy write(string, encoding, offset, length) - remove in v0.13
  } else {
    var swap = encoding
    encoding = offset
    offset = length | 0
    length = swap
  }

  var remaining = this.length - offset
  if (length === undefined || length > remaining) length = remaining

  if ((string.length > 0 && (length < 0 || offset < 0)) || offset > this.length) {
    throw new RangeError('attempt to write outside buffer bounds')
  }

  if (!encoding) encoding = 'utf8'

  var loweredCase = false
  for (;;) {
    switch (encoding) {
      case 'hex':
        return hexWrite(this, string, offset, length)

      case 'utf8':
      case 'utf-8':
        return utf8Write(this, string, offset, length)

      case 'ascii':
        return asciiWrite(this, string, offset, length)

      case 'binary':
        return binaryWrite(this, string, offset, length)

      case 'base64':
        // Warning: maxLength not taken into account in base64Write
        return base64Write(this, string, offset, length)

      case 'ucs2':
      case 'ucs-2':
      case 'utf16le':
      case 'utf-16le':
        return ucs2Write(this, string, offset, length)

      default:
        if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding)
        encoding = ('' + encoding).toLowerCase()
        loweredCase = true
    }
  }
}

Buffer.prototype.toJSON = function toJSON () {
  return {
    type: 'Buffer',
    data: Array.prototype.slice.call(this._arr || this, 0)
  }
}

function base64Slice (buf, start, end) {
  if (start === 0 && end === buf.length) {
    return base64.fromByteArray(buf)
  } else {
    return base64.fromByteArray(buf.slice(start, end))
  }
}

function utf8Slice (buf, start, end) {
  end = Math.min(buf.length, end)
  var res = []

  var i = start
  while (i < end) {
    var firstByte = buf[i]
    var codePoint = null
    var bytesPerSequence = (firstByte > 0xEF) ? 4
      : (firstByte > 0xDF) ? 3
      : (firstByte > 0xBF) ? 2
      : 1

    if (i + bytesPerSequence <= end) {
      var secondByte, thirdByte, fourthByte, tempCodePoint

      switch (bytesPerSequence) {
        case 1:
          if (firstByte < 0x80) {
            codePoint = firstByte
          }
          break
        case 2:
          secondByte = buf[i + 1]
          if ((secondByte & 0xC0) === 0x80) {
            tempCodePoint = (firstByte & 0x1F) << 0x6 | (secondByte & 0x3F)
            if (tempCodePoint > 0x7F) {
              codePoint = tempCodePoint
            }
          }
          break
        case 3:
          secondByte = buf[i + 1]
          thirdByte = buf[i + 2]
          if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80) {
            tempCodePoint = (firstByte & 0xF) << 0xC | (secondByte & 0x3F) << 0x6 | (thirdByte & 0x3F)
            if (tempCodePoint > 0x7FF && (tempCodePoint < 0xD800 || tempCodePoint > 0xDFFF)) {
              codePoint = tempCodePoint
            }
          }
          break
        case 4:
          secondByte = buf[i + 1]
          thirdByte = buf[i + 2]
          fourthByte = buf[i + 3]
          if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80 && (fourthByte & 0xC0) === 0x80) {
            tempCodePoint = (firstByte & 0xF) << 0x12 | (secondByte & 0x3F) << 0xC | (thirdByte & 0x3F) << 0x6 | (fourthByte & 0x3F)
            if (tempCodePoint > 0xFFFF && tempCodePoint < 0x110000) {
              codePoint = tempCodePoint
            }
          }
      }
    }

    if (codePoint === null) {
      // we did not generate a valid codePoint so insert a
      // replacement char (U+FFFD) and advance only 1 byte
      codePoint = 0xFFFD
      bytesPerSequence = 1
    } else if (codePoint > 0xFFFF) {
      // encode to utf16 (surrogate pair dance)
      codePoint -= 0x10000
      res.push(codePoint >>> 10 & 0x3FF | 0xD800)
      codePoint = 0xDC00 | codePoint & 0x3FF
    }

    res.push(codePoint)
    i += bytesPerSequence
  }

  return decodeCodePointsArray(res)
}

// Based on http://stackoverflow.com/a/22747272/680742, the browser with
// the lowest limit is Chrome, with 0x10000 args.
// We go 1 magnitude less, for safety
var MAX_ARGUMENTS_LENGTH = 0x1000

function decodeCodePointsArray (codePoints) {
  var len = codePoints.length
  if (len <= MAX_ARGUMENTS_LENGTH) {
    return String.fromCharCode.apply(String, codePoints) // avoid extra slice()
  }

  // Decode in chunks to avoid "call stack size exceeded".
  var res = ''
  var i = 0
  while (i < len) {
    res += String.fromCharCode.apply(
      String,
      codePoints.slice(i, i += MAX_ARGUMENTS_LENGTH)
    )
  }
  return res
}

function asciiSlice (buf, start, end) {
  var ret = ''
  end = Math.min(buf.length, end)

  for (var i = start; i < end; i++) {
    ret += String.fromCharCode(buf[i] & 0x7F)
  }
  return ret
}

function binarySlice (buf, start, end) {
  var ret = ''
  end = Math.min(buf.length, end)

  for (var i = start; i < end; i++) {
    ret += String.fromCharCode(buf[i])
  }
  return ret
}

function hexSlice (buf, start, end) {
  var len = buf.length

  if (!start || start < 0) start = 0
  if (!end || end < 0 || end > len) end = len

  var out = ''
  for (var i = start; i < end; i++) {
    out += toHex(buf[i])
  }
  return out
}

function utf16leSlice (buf, start, end) {
  var bytes = buf.slice(start, end)
  var res = ''
  for (var i = 0; i < bytes.length; i += 2) {
    res += String.fromCharCode(bytes[i] + bytes[i + 1] * 256)
  }
  return res
}

Buffer.prototype.slice = function slice (start, end) {
  var len = this.length
  start = ~~start
  end = end === undefined ? len : ~~end

  if (start < 0) {
    start += len
    if (start < 0) start = 0
  } else if (start > len) {
    start = len
  }

  if (end < 0) {
    end += len
    if (end < 0) end = 0
  } else if (end > len) {
    end = len
  }

  if (end < start) end = start

  var newBuf
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    newBuf = Buffer._augment(this.subarray(start, end))
  } else {
    var sliceLen = end - start
    newBuf = new Buffer(sliceLen, undefined)
    for (var i = 0; i < sliceLen; i++) {
      newBuf[i] = this[i + start]
    }
  }

  if (newBuf.length) newBuf.parent = this.parent || this

  return newBuf
}

/*
 * Need to make sure that buffer isn't trying to write out of bounds.
 */
function checkOffset (offset, ext, length) {
  if ((offset % 1) !== 0 || offset < 0) throw new RangeError('offset is not uint')
  if (offset + ext > length) throw new RangeError('Trying to access beyond buffer length')
}

Buffer.prototype.readUIntLE = function readUIntLE (offset, byteLength, noAssert) {
  offset = offset | 0
  byteLength = byteLength | 0
  if (!noAssert) checkOffset(offset, byteLength, this.length)

  var val = this[offset]
  var mul = 1
  var i = 0
  while (++i < byteLength && (mul *= 0x100)) {
    val += this[offset + i] * mul
  }

  return val
}

Buffer.prototype.readUIntBE = function readUIntBE (offset, byteLength, noAssert) {
  offset = offset | 0
  byteLength = byteLength | 0
  if (!noAssert) {
    checkOffset(offset, byteLength, this.length)
  }

  var val = this[offset + --byteLength]
  var mul = 1
  while (byteLength > 0 && (mul *= 0x100)) {
    val += this[offset + --byteLength] * mul
  }

  return val
}

Buffer.prototype.readUInt8 = function readUInt8 (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 1, this.length)
  return this[offset]
}

Buffer.prototype.readUInt16LE = function readUInt16LE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 2, this.length)
  return this[offset] | (this[offset + 1] << 8)
}

Buffer.prototype.readUInt16BE = function readUInt16BE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 2, this.length)
  return (this[offset] << 8) | this[offset + 1]
}

Buffer.prototype.readUInt32LE = function readUInt32LE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 4, this.length)

  return ((this[offset]) |
      (this[offset + 1] << 8) |
      (this[offset + 2] << 16)) +
      (this[offset + 3] * 0x1000000)
}

Buffer.prototype.readUInt32BE = function readUInt32BE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 4, this.length)

  return (this[offset] * 0x1000000) +
    ((this[offset + 1] << 16) |
    (this[offset + 2] << 8) |
    this[offset + 3])
}

Buffer.prototype.readIntLE = function readIntLE (offset, byteLength, noAssert) {
  offset = offset | 0
  byteLength = byteLength | 0
  if (!noAssert) checkOffset(offset, byteLength, this.length)

  var val = this[offset]
  var mul = 1
  var i = 0
  while (++i < byteLength && (mul *= 0x100)) {
    val += this[offset + i] * mul
  }
  mul *= 0x80

  if (val >= mul) val -= Math.pow(2, 8 * byteLength)

  return val
}

Buffer.prototype.readIntBE = function readIntBE (offset, byteLength, noAssert) {
  offset = offset | 0
  byteLength = byteLength | 0
  if (!noAssert) checkOffset(offset, byteLength, this.length)

  var i = byteLength
  var mul = 1
  var val = this[offset + --i]
  while (i > 0 && (mul *= 0x100)) {
    val += this[offset + --i] * mul
  }
  mul *= 0x80

  if (val >= mul) val -= Math.pow(2, 8 * byteLength)

  return val
}

Buffer.prototype.readInt8 = function readInt8 (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 1, this.length)
  if (!(this[offset] & 0x80)) return (this[offset])
  return ((0xff - this[offset] + 1) * -1)
}

Buffer.prototype.readInt16LE = function readInt16LE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 2, this.length)
  var val = this[offset] | (this[offset + 1] << 8)
  return (val & 0x8000) ? val | 0xFFFF0000 : val
}

Buffer.prototype.readInt16BE = function readInt16BE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 2, this.length)
  var val = this[offset + 1] | (this[offset] << 8)
  return (val & 0x8000) ? val | 0xFFFF0000 : val
}

Buffer.prototype.readInt32LE = function readInt32LE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 4, this.length)

  return (this[offset]) |
    (this[offset + 1] << 8) |
    (this[offset + 2] << 16) |
    (this[offset + 3] << 24)
}

Buffer.prototype.readInt32BE = function readInt32BE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 4, this.length)

  return (this[offset] << 24) |
    (this[offset + 1] << 16) |
    (this[offset + 2] << 8) |
    (this[offset + 3])
}

Buffer.prototype.readFloatLE = function readFloatLE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 4, this.length)
  return ieee754.read(this, offset, true, 23, 4)
}

Buffer.prototype.readFloatBE = function readFloatBE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 4, this.length)
  return ieee754.read(this, offset, false, 23, 4)
}

Buffer.prototype.readDoubleLE = function readDoubleLE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 8, this.length)
  return ieee754.read(this, offset, true, 52, 8)
}

Buffer.prototype.readDoubleBE = function readDoubleBE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 8, this.length)
  return ieee754.read(this, offset, false, 52, 8)
}

function checkInt (buf, value, offset, ext, max, min) {
  if (!Buffer.isBuffer(buf)) throw new TypeError('buffer must be a Buffer instance')
  if (value > max || value < min) throw new RangeError('value is out of bounds')
  if (offset + ext > buf.length) throw new RangeError('index out of range')
}

Buffer.prototype.writeUIntLE = function writeUIntLE (value, offset, byteLength, noAssert) {
  value = +value
  offset = offset | 0
  byteLength = byteLength | 0
  if (!noAssert) checkInt(this, value, offset, byteLength, Math.pow(2, 8 * byteLength), 0)

  var mul = 1
  var i = 0
  this[offset] = value & 0xFF
  while (++i < byteLength && (mul *= 0x100)) {
    this[offset + i] = (value / mul) & 0xFF
  }

  return offset + byteLength
}

Buffer.prototype.writeUIntBE = function writeUIntBE (value, offset, byteLength, noAssert) {
  value = +value
  offset = offset | 0
  byteLength = byteLength | 0
  if (!noAssert) checkInt(this, value, offset, byteLength, Math.pow(2, 8 * byteLength), 0)

  var i = byteLength - 1
  var mul = 1
  this[offset + i] = value & 0xFF
  while (--i >= 0 && (mul *= 0x100)) {
    this[offset + i] = (value / mul) & 0xFF
  }

  return offset + byteLength
}

Buffer.prototype.writeUInt8 = function writeUInt8 (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 1, 0xff, 0)
  if (!Buffer.TYPED_ARRAY_SUPPORT) value = Math.floor(value)
  this[offset] = (value & 0xff)
  return offset + 1
}

function objectWriteUInt16 (buf, value, offset, littleEndian) {
  if (value < 0) value = 0xffff + value + 1
  for (var i = 0, j = Math.min(buf.length - offset, 2); i < j; i++) {
    buf[offset + i] = (value & (0xff << (8 * (littleEndian ? i : 1 - i)))) >>>
      (littleEndian ? i : 1 - i) * 8
  }
}

Buffer.prototype.writeUInt16LE = function writeUInt16LE (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0)
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = (value & 0xff)
    this[offset + 1] = (value >>> 8)
  } else {
    objectWriteUInt16(this, value, offset, true)
  }
  return offset + 2
}

Buffer.prototype.writeUInt16BE = function writeUInt16BE (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0)
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = (value >>> 8)
    this[offset + 1] = (value & 0xff)
  } else {
    objectWriteUInt16(this, value, offset, false)
  }
  return offset + 2
}

function objectWriteUInt32 (buf, value, offset, littleEndian) {
  if (value < 0) value = 0xffffffff + value + 1
  for (var i = 0, j = Math.min(buf.length - offset, 4); i < j; i++) {
    buf[offset + i] = (value >>> (littleEndian ? i : 3 - i) * 8) & 0xff
  }
}

Buffer.prototype.writeUInt32LE = function writeUInt32LE (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0)
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset + 3] = (value >>> 24)
    this[offset + 2] = (value >>> 16)
    this[offset + 1] = (value >>> 8)
    this[offset] = (value & 0xff)
  } else {
    objectWriteUInt32(this, value, offset, true)
  }
  return offset + 4
}

Buffer.prototype.writeUInt32BE = function writeUInt32BE (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0)
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = (value >>> 24)
    this[offset + 1] = (value >>> 16)
    this[offset + 2] = (value >>> 8)
    this[offset + 3] = (value & 0xff)
  } else {
    objectWriteUInt32(this, value, offset, false)
  }
  return offset + 4
}

Buffer.prototype.writeIntLE = function writeIntLE (value, offset, byteLength, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) {
    var limit = Math.pow(2, 8 * byteLength - 1)

    checkInt(this, value, offset, byteLength, limit - 1, -limit)
  }

  var i = 0
  var mul = 1
  var sub = value < 0 ? 1 : 0
  this[offset] = value & 0xFF
  while (++i < byteLength && (mul *= 0x100)) {
    this[offset + i] = ((value / mul) >> 0) - sub & 0xFF
  }

  return offset + byteLength
}

Buffer.prototype.writeIntBE = function writeIntBE (value, offset, byteLength, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) {
    var limit = Math.pow(2, 8 * byteLength - 1)

    checkInt(this, value, offset, byteLength, limit - 1, -limit)
  }

  var i = byteLength - 1
  var mul = 1
  var sub = value < 0 ? 1 : 0
  this[offset + i] = value & 0xFF
  while (--i >= 0 && (mul *= 0x100)) {
    this[offset + i] = ((value / mul) >> 0) - sub & 0xFF
  }

  return offset + byteLength
}

Buffer.prototype.writeInt8 = function writeInt8 (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 1, 0x7f, -0x80)
  if (!Buffer.TYPED_ARRAY_SUPPORT) value = Math.floor(value)
  if (value < 0) value = 0xff + value + 1
  this[offset] = (value & 0xff)
  return offset + 1
}

Buffer.prototype.writeInt16LE = function writeInt16LE (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000)
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = (value & 0xff)
    this[offset + 1] = (value >>> 8)
  } else {
    objectWriteUInt16(this, value, offset, true)
  }
  return offset + 2
}

Buffer.prototype.writeInt16BE = function writeInt16BE (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000)
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = (value >>> 8)
    this[offset + 1] = (value & 0xff)
  } else {
    objectWriteUInt16(this, value, offset, false)
  }
  return offset + 2
}

Buffer.prototype.writeInt32LE = function writeInt32LE (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000)
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = (value & 0xff)
    this[offset + 1] = (value >>> 8)
    this[offset + 2] = (value >>> 16)
    this[offset + 3] = (value >>> 24)
  } else {
    objectWriteUInt32(this, value, offset, true)
  }
  return offset + 4
}

Buffer.prototype.writeInt32BE = function writeInt32BE (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000)
  if (value < 0) value = 0xffffffff + value + 1
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = (value >>> 24)
    this[offset + 1] = (value >>> 16)
    this[offset + 2] = (value >>> 8)
    this[offset + 3] = (value & 0xff)
  } else {
    objectWriteUInt32(this, value, offset, false)
  }
  return offset + 4
}

function checkIEEE754 (buf, value, offset, ext, max, min) {
  if (value > max || value < min) throw new RangeError('value is out of bounds')
  if (offset + ext > buf.length) throw new RangeError('index out of range')
  if (offset < 0) throw new RangeError('index out of range')
}

function writeFloat (buf, value, offset, littleEndian, noAssert) {
  if (!noAssert) {
    checkIEEE754(buf, value, offset, 4, 3.4028234663852886e+38, -3.4028234663852886e+38)
  }
  ieee754.write(buf, value, offset, littleEndian, 23, 4)
  return offset + 4
}

Buffer.prototype.writeFloatLE = function writeFloatLE (value, offset, noAssert) {
  return writeFloat(this, value, offset, true, noAssert)
}

Buffer.prototype.writeFloatBE = function writeFloatBE (value, offset, noAssert) {
  return writeFloat(this, value, offset, false, noAssert)
}

function writeDouble (buf, value, offset, littleEndian, noAssert) {
  if (!noAssert) {
    checkIEEE754(buf, value, offset, 8, 1.7976931348623157E+308, -1.7976931348623157E+308)
  }
  ieee754.write(buf, value, offset, littleEndian, 52, 8)
  return offset + 8
}

Buffer.prototype.writeDoubleLE = function writeDoubleLE (value, offset, noAssert) {
  return writeDouble(this, value, offset, true, noAssert)
}

Buffer.prototype.writeDoubleBE = function writeDoubleBE (value, offset, noAssert) {
  return writeDouble(this, value, offset, false, noAssert)
}

// copy(targetBuffer, targetStart=0, sourceStart=0, sourceEnd=buffer.length)
Buffer.prototype.copy = function copy (target, targetStart, start, end) {
  if (!start) start = 0
  if (!end && end !== 0) end = this.length
  if (targetStart >= target.length) targetStart = target.length
  if (!targetStart) targetStart = 0
  if (end > 0 && end < start) end = start

  // Copy 0 bytes; we're done
  if (end === start) return 0
  if (target.length === 0 || this.length === 0) return 0

  // Fatal error conditions
  if (targetStart < 0) {
    throw new RangeError('targetStart out of bounds')
  }
  if (start < 0 || start >= this.length) throw new RangeError('sourceStart out of bounds')
  if (end < 0) throw new RangeError('sourceEnd out of bounds')

  // Are we oob?
  if (end > this.length) end = this.length
  if (target.length - targetStart < end - start) {
    end = target.length - targetStart + start
  }

  var len = end - start
  var i

  if (this === target && start < targetStart && targetStart < end) {
    // descending copy from end
    for (i = len - 1; i >= 0; i--) {
      target[i + targetStart] = this[i + start]
    }
  } else if (len < 1000 || !Buffer.TYPED_ARRAY_SUPPORT) {
    // ascending copy from start
    for (i = 0; i < len; i++) {
      target[i + targetStart] = this[i + start]
    }
  } else {
    target._set(this.subarray(start, start + len), targetStart)
  }

  return len
}

// fill(value, start=0, end=buffer.length)
Buffer.prototype.fill = function fill (value, start, end) {
  if (!value) value = 0
  if (!start) start = 0
  if (!end) end = this.length

  if (end < start) throw new RangeError('end < start')

  // Fill 0 bytes; we're done
  if (end === start) return
  if (this.length === 0) return

  if (start < 0 || start >= this.length) throw new RangeError('start out of bounds')
  if (end < 0 || end > this.length) throw new RangeError('end out of bounds')

  var i
  if (typeof value === 'number') {
    for (i = start; i < end; i++) {
      this[i] = value
    }
  } else {
    var bytes = utf8ToBytes(value.toString())
    var len = bytes.length
    for (i = start; i < end; i++) {
      this[i] = bytes[i % len]
    }
  }

  return this
}

/**
 * Creates a new `ArrayBuffer` with the *copied* memory of the buffer instance.
 * Added in Node 0.12. Only available in browsers that support ArrayBuffer.
 */
Buffer.prototype.toArrayBuffer = function toArrayBuffer () {
  if (typeof Uint8Array !== 'undefined') {
    if (Buffer.TYPED_ARRAY_SUPPORT) {
      return (new Buffer(this)).buffer
    } else {
      var buf = new Uint8Array(this.length)
      for (var i = 0, len = buf.length; i < len; i += 1) {
        buf[i] = this[i]
      }
      return buf.buffer
    }
  } else {
    throw new TypeError('Buffer.toArrayBuffer not supported in this browser')
  }
}

// HELPER FUNCTIONS
// ================

var BP = Buffer.prototype

/**
 * Augment a Uint8Array *instance* (not the Uint8Array class!) with Buffer methods
 */
Buffer._augment = function _augment (arr) {
  arr.constructor = Buffer
  arr._isBuffer = true

  // save reference to original Uint8Array set method before overwriting
  arr._set = arr.set

  // deprecated
  arr.get = BP.get
  arr.set = BP.set

  arr.write = BP.write
  arr.toString = BP.toString
  arr.toLocaleString = BP.toString
  arr.toJSON = BP.toJSON
  arr.equals = BP.equals
  arr.compare = BP.compare
  arr.indexOf = BP.indexOf
  arr.copy = BP.copy
  arr.slice = BP.slice
  arr.readUIntLE = BP.readUIntLE
  arr.readUIntBE = BP.readUIntBE
  arr.readUInt8 = BP.readUInt8
  arr.readUInt16LE = BP.readUInt16LE
  arr.readUInt16BE = BP.readUInt16BE
  arr.readUInt32LE = BP.readUInt32LE
  arr.readUInt32BE = BP.readUInt32BE
  arr.readIntLE = BP.readIntLE
  arr.readIntBE = BP.readIntBE
  arr.readInt8 = BP.readInt8
  arr.readInt16LE = BP.readInt16LE
  arr.readInt16BE = BP.readInt16BE
  arr.readInt32LE = BP.readInt32LE
  arr.readInt32BE = BP.readInt32BE
  arr.readFloatLE = BP.readFloatLE
  arr.readFloatBE = BP.readFloatBE
  arr.readDoubleLE = BP.readDoubleLE
  arr.readDoubleBE = BP.readDoubleBE
  arr.writeUInt8 = BP.writeUInt8
  arr.writeUIntLE = BP.writeUIntLE
  arr.writeUIntBE = BP.writeUIntBE
  arr.writeUInt16LE = BP.writeUInt16LE
  arr.writeUInt16BE = BP.writeUInt16BE
  arr.writeUInt32LE = BP.writeUInt32LE
  arr.writeUInt32BE = BP.writeUInt32BE
  arr.writeIntLE = BP.writeIntLE
  arr.writeIntBE = BP.writeIntBE
  arr.writeInt8 = BP.writeInt8
  arr.writeInt16LE = BP.writeInt16LE
  arr.writeInt16BE = BP.writeInt16BE
  arr.writeInt32LE = BP.writeInt32LE
  arr.writeInt32BE = BP.writeInt32BE
  arr.writeFloatLE = BP.writeFloatLE
  arr.writeFloatBE = BP.writeFloatBE
  arr.writeDoubleLE = BP.writeDoubleLE
  arr.writeDoubleBE = BP.writeDoubleBE
  arr.fill = BP.fill
  arr.inspect = BP.inspect
  arr.toArrayBuffer = BP.toArrayBuffer

  return arr
}

var INVALID_BASE64_RE = /[^+\/0-9A-Za-z-_]/g

function base64clean (str) {
  // Node strips out invalid characters like \n and \t from the string, base64-js does not
  str = stringtrim(str).replace(INVALID_BASE64_RE, '')
  // Node converts strings with length < 2 to ''
  if (str.length < 2) return ''
  // Node allows for non-padded base64 strings (missing trailing ===), base64-js does not
  while (str.length % 4 !== 0) {
    str = str + '='
  }
  return str
}

function stringtrim (str) {
  if (str.trim) return str.trim()
  return str.replace(/^\s+|\s+$/g, '')
}

function toHex (n) {
  if (n < 16) return '0' + n.toString(16)
  return n.toString(16)
}

function utf8ToBytes (string, units) {
  units = units || Infinity
  var codePoint
  var length = string.length
  var leadSurrogate = null
  var bytes = []

  for (var i = 0; i < length; i++) {
    codePoint = string.charCodeAt(i)

    // is surrogate component
    if (codePoint > 0xD7FF && codePoint < 0xE000) {
      // last char was a lead
      if (!leadSurrogate) {
        // no lead yet
        if (codePoint > 0xDBFF) {
          // unexpected trail
          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
          continue
        } else if (i + 1 === length) {
          // unpaired lead
          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
          continue
        }

        // valid lead
        leadSurrogate = codePoint

        continue
      }

      // 2 leads in a row
      if (codePoint < 0xDC00) {
        if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
        leadSurrogate = codePoint
        continue
      }

      // valid surrogate pair
      codePoint = (leadSurrogate - 0xD800 << 10 | codePoint - 0xDC00) + 0x10000
    } else if (leadSurrogate) {
      // valid bmp char, but last char was a lead
      if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
    }

    leadSurrogate = null

    // encode utf8
    if (codePoint < 0x80) {
      if ((units -= 1) < 0) break
      bytes.push(codePoint)
    } else if (codePoint < 0x800) {
      if ((units -= 2) < 0) break
      bytes.push(
        codePoint >> 0x6 | 0xC0,
        codePoint & 0x3F | 0x80
      )
    } else if (codePoint < 0x10000) {
      if ((units -= 3) < 0) break
      bytes.push(
        codePoint >> 0xC | 0xE0,
        codePoint >> 0x6 & 0x3F | 0x80,
        codePoint & 0x3F | 0x80
      )
    } else if (codePoint < 0x110000) {
      if ((units -= 4) < 0) break
      bytes.push(
        codePoint >> 0x12 | 0xF0,
        codePoint >> 0xC & 0x3F | 0x80,
        codePoint >> 0x6 & 0x3F | 0x80,
        codePoint & 0x3F | 0x80
      )
    } else {
      throw new Error('Invalid code point')
    }
  }

  return bytes
}

function asciiToBytes (str) {
  var byteArray = []
  for (var i = 0; i < str.length; i++) {
    // Node's code seems to be doing this and not & 0x7F..
    byteArray.push(str.charCodeAt(i) & 0xFF)
  }
  return byteArray
}

function utf16leToBytes (str, units) {
  var c, hi, lo
  var byteArray = []
  for (var i = 0; i < str.length; i++) {
    if ((units -= 2) < 0) break

    c = str.charCodeAt(i)
    hi = c >> 8
    lo = c % 256
    byteArray.push(lo)
    byteArray.push(hi)
  }

  return byteArray
}

function base64ToBytes (str) {
  return base64.toByteArray(base64clean(str))
}

function blitBuffer (src, dst, offset, length) {
  for (var i = 0; i < length; i++) {
    if ((i + offset >= dst.length) || (i >= src.length)) break
    dst[i + offset] = src[i]
  }
  return i
}

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{"base64-js":3,"ieee754":4,"isarray":5}],3:[function(require,module,exports){
var lookup = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/';

;(function (exports) {
	'use strict';

  var Arr = (typeof Uint8Array !== 'undefined')
    ? Uint8Array
    : Array

	var PLUS   = '+'.charCodeAt(0)
	var SLASH  = '/'.charCodeAt(0)
	var NUMBER = '0'.charCodeAt(0)
	var LOWER  = 'a'.charCodeAt(0)
	var UPPER  = 'A'.charCodeAt(0)
	var PLUS_URL_SAFE = '-'.charCodeAt(0)
	var SLASH_URL_SAFE = '_'.charCodeAt(0)

	function decode (elt) {
		var code = elt.charCodeAt(0)
		if (code === PLUS ||
		    code === PLUS_URL_SAFE)
			return 62 // '+'
		if (code === SLASH ||
		    code === SLASH_URL_SAFE)
			return 63 // '/'
		if (code < NUMBER)
			return -1 //no match
		if (code < NUMBER + 10)
			return code - NUMBER + 26 + 26
		if (code < UPPER + 26)
			return code - UPPER
		if (code < LOWER + 26)
			return code - LOWER + 26
	}

	function b64ToByteArray (b64) {
		var i, j, l, tmp, placeHolders, arr

		if (b64.length % 4 > 0) {
			throw new Error('Invalid string. Length must be a multiple of 4')
		}

		// the number of equal signs (place holders)
		// if there are two placeholders, than the two characters before it
		// represent one byte
		// if there is only one, then the three characters before it represent 2 bytes
		// this is just a cheap hack to not do indexOf twice
		var len = b64.length
		placeHolders = '=' === b64.charAt(len - 2) ? 2 : '=' === b64.charAt(len - 1) ? 1 : 0

		// base64 is 4/3 + up to two characters of the original data
		arr = new Arr(b64.length * 3 / 4 - placeHolders)

		// if there are placeholders, only get up to the last complete 4 chars
		l = placeHolders > 0 ? b64.length - 4 : b64.length

		var L = 0

		function push (v) {
			arr[L++] = v
		}

		for (i = 0, j = 0; i < l; i += 4, j += 3) {
			tmp = (decode(b64.charAt(i)) << 18) | (decode(b64.charAt(i + 1)) << 12) | (decode(b64.charAt(i + 2)) << 6) | decode(b64.charAt(i + 3))
			push((tmp & 0xFF0000) >> 16)
			push((tmp & 0xFF00) >> 8)
			push(tmp & 0xFF)
		}

		if (placeHolders === 2) {
			tmp = (decode(b64.charAt(i)) << 2) | (decode(b64.charAt(i + 1)) >> 4)
			push(tmp & 0xFF)
		} else if (placeHolders === 1) {
			tmp = (decode(b64.charAt(i)) << 10) | (decode(b64.charAt(i + 1)) << 4) | (decode(b64.charAt(i + 2)) >> 2)
			push((tmp >> 8) & 0xFF)
			push(tmp & 0xFF)
		}

		return arr
	}

	function uint8ToBase64 (uint8) {
		var i,
			extraBytes = uint8.length % 3, // if we have 1 byte left, pad 2 bytes
			output = "",
			temp, length

		function encode (num) {
			return lookup.charAt(num)
		}

		function tripletToBase64 (num) {
			return encode(num >> 18 & 0x3F) + encode(num >> 12 & 0x3F) + encode(num >> 6 & 0x3F) + encode(num & 0x3F)
		}

		// go through the array every three bytes, we'll deal with trailing stuff later
		for (i = 0, length = uint8.length - extraBytes; i < length; i += 3) {
			temp = (uint8[i] << 16) + (uint8[i + 1] << 8) + (uint8[i + 2])
			output += tripletToBase64(temp)
		}

		// pad the end with zeros, but make sure to not forget the extra bytes
		switch (extraBytes) {
			case 1:
				temp = uint8[uint8.length - 1]
				output += encode(temp >> 2)
				output += encode((temp << 4) & 0x3F)
				output += '=='
				break
			case 2:
				temp = (uint8[uint8.length - 2] << 8) + (uint8[uint8.length - 1])
				output += encode(temp >> 10)
				output += encode((temp >> 4) & 0x3F)
				output += encode((temp << 2) & 0x3F)
				output += '='
				break
		}

		return output
	}

	exports.toByteArray = b64ToByteArray
	exports.fromByteArray = uint8ToBase64
}(typeof exports === 'undefined' ? (this.base64js = {}) : exports))

},{}],4:[function(require,module,exports){
exports.read = function (buffer, offset, isLE, mLen, nBytes) {
  var e, m
  var eLen = nBytes * 8 - mLen - 1
  var eMax = (1 << eLen) - 1
  var eBias = eMax >> 1
  var nBits = -7
  var i = isLE ? (nBytes - 1) : 0
  var d = isLE ? -1 : 1
  var s = buffer[offset + i]

  i += d

  e = s & ((1 << (-nBits)) - 1)
  s >>= (-nBits)
  nBits += eLen
  for (; nBits > 0; e = e * 256 + buffer[offset + i], i += d, nBits -= 8) {}

  m = e & ((1 << (-nBits)) - 1)
  e >>= (-nBits)
  nBits += mLen
  for (; nBits > 0; m = m * 256 + buffer[offset + i], i += d, nBits -= 8) {}

  if (e === 0) {
    e = 1 - eBias
  } else if (e === eMax) {
    return m ? NaN : ((s ? -1 : 1) * Infinity)
  } else {
    m = m + Math.pow(2, mLen)
    e = e - eBias
  }
  return (s ? -1 : 1) * m * Math.pow(2, e - mLen)
}

exports.write = function (buffer, value, offset, isLE, mLen, nBytes) {
  var e, m, c
  var eLen = nBytes * 8 - mLen - 1
  var eMax = (1 << eLen) - 1
  var eBias = eMax >> 1
  var rt = (mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0)
  var i = isLE ? 0 : (nBytes - 1)
  var d = isLE ? 1 : -1
  var s = value < 0 || (value === 0 && 1 / value < 0) ? 1 : 0

  value = Math.abs(value)

  if (isNaN(value) || value === Infinity) {
    m = isNaN(value) ? 1 : 0
    e = eMax
  } else {
    e = Math.floor(Math.log(value) / Math.LN2)
    if (value * (c = Math.pow(2, -e)) < 1) {
      e--
      c *= 2
    }
    if (e + eBias >= 1) {
      value += rt / c
    } else {
      value += rt * Math.pow(2, 1 - eBias)
    }
    if (value * c >= 2) {
      e++
      c /= 2
    }

    if (e + eBias >= eMax) {
      m = 0
      e = eMax
    } else if (e + eBias >= 1) {
      m = (value * c - 1) * Math.pow(2, mLen)
      e = e + eBias
    } else {
      m = value * Math.pow(2, eBias - 1) * Math.pow(2, mLen)
      e = 0
    }
  }

  for (; mLen >= 8; buffer[offset + i] = m & 0xff, i += d, m /= 256, mLen -= 8) {}

  e = (e << mLen) | m
  eLen += mLen
  for (; eLen > 0; buffer[offset + i] = e & 0xff, i += d, e /= 256, eLen -= 8) {}

  buffer[offset + i - d] |= s * 128
}

},{}],5:[function(require,module,exports){
module.exports = Array.isArray || function (arr) {
  return Object.prototype.toString.call(arr) == '[object Array]';
};

},{}],6:[function(require,module,exports){
// shim for using process in browser

var process = module.exports = {};
var queue = [];
var draining = false;
var currentQueue;
var queueIndex = -1;

function cleanUpNextTick() {
    draining = false;
    if (currentQueue.length) {
        queue = currentQueue.concat(queue);
    } else {
        queueIndex = -1;
    }
    if (queue.length) {
        drainQueue();
    }
}

function drainQueue() {
    if (draining) {
        return;
    }
    var timeout = setTimeout(cleanUpNextTick);
    draining = true;

    var len = queue.length;
    while(len) {
        currentQueue = queue;
        queue = [];
        while (++queueIndex < len) {
            if (currentQueue) {
                currentQueue[queueIndex].run();
            }
        }
        queueIndex = -1;
        len = queue.length;
    }
    currentQueue = null;
    draining = false;
    clearTimeout(timeout);
}

process.nextTick = function (fun) {
    var args = new Array(arguments.length - 1);
    if (arguments.length > 1) {
        for (var i = 1; i < arguments.length; i++) {
            args[i - 1] = arguments[i];
        }
    }
    queue.push(new Item(fun, args));
    if (queue.length === 1 && !draining) {
        setTimeout(drainQueue, 0);
    }
};

// v8 likes predictible objects
function Item(fun, array) {
    this.fun = fun;
    this.array = array;
}
Item.prototype.run = function () {
    this.fun.apply(null, this.array);
};
process.title = 'browser';
process.browser = true;
process.env = {};
process.argv = [];
process.version = ''; // empty string to avoid regexp issues
process.versions = {};

function noop() {}

process.on = noop;
process.addListener = noop;
process.once = noop;
process.off = noop;
process.removeListener = noop;
process.removeAllListeners = noop;
process.emit = noop;

process.binding = function (name) {
    throw new Error('process.binding is not supported');
};

process.cwd = function () { return '/' };
process.chdir = function (dir) {
    throw new Error('process.chdir is not supported');
};
process.umask = function() { return 0; };

},{}],7:[function(require,module,exports){
// Copyright 2014 Thom Chiovoloni, released under the MIT license.

/// A random number generator based on the basic implementation of the PCG algorithm,
/// as described here: http://www.pcg-random.org/
var PcgRandom = (function() {
	'use strict';

	var defaultIncHi = 0x14057b7e;
	var defaultIncLo = 0xf767814f;

	/// Construct a random number generator.
	function PcgRandom(seedHi, seedLo, incHi, incLo) {
		this.setSeed(seedHi, seedLo, incHi, incLo)
	}

	/// Set the seed and incrementer.
	PcgRandom.prototype.setSeed = function(seedHi, seedLo, incHi, incLo) {
		if (seedLo == null && seedHi == null) {
			seedLo = (Math.random() * 0xffffffff) >>> 0;
			seedHi = 0;
		}
		else if (seedLo == null) {
			seedLo = seedHi;
			seedHi = 0;
		}
		if (incLo == null && incHi == null) {
			incLo = this.state_ ? this.state_[3] : defaultIncLo;
			incHi = this.state_ ? this.state_[2] : defaultIncHi;
		}
		else if (incLo == null) {
			incLo = incHi;
			incHi = 0;
		}

		this.state_ = new Int32Array([ 0, 0, incHi >>> 0, (incLo|1) >>> 0 ]);
		this.next_();
		add64_(this.state_, this.state_[0], this.state_[1], seedHi>>>0, seedLo>>>0);
		this.next_();
		return this;
	};

	/// Return a copy of the internal state of this random number generator as a JavaScript Array.
	PcgRandom.prototype.getState = function() {
		return [this.state_[0], this.state_[1], this.state_[2], this.state_[3]];
	};

	/// Set the state of the random number generator.
	PcgRandom.prototype.setState = function(state) {
		this.state_[0] = state[0];
		this.state_[1] = state[1];
		this.state_[2] = state[2];
		this.state_[3] = state[3]|1;
	};

	// shim for Math.imul.
	var imul = Math.imul;
	if (!imul) {
		imul = function(a, b) {
			var ah = (a >>> 16) & 0xffff, al = a & 0xffff;
			var bh = (b >>> 16) & 0xffff, bl = b & 0xffff;
			return ((al * bl) + (((ah * bl + al * bh) << 16) >>> 0) | 0);
		};
	}

	// multiply two 64 bit numbers (given in parts), and store the result in `out`.
	function mul64_(out, aHi, aLo, bHi, bLo) {
		var c1 = (aLo >>> 16) * (bLo & 0xffff) >>> 0;
		var c0 = (aLo & 0xffff) * (bLo >>> 16) >>> 0;

		var lo = ((aLo & 0xffff) * (bLo & 0xffff)) >>> 0;
		var hi = ((aLo >>> 16) * (bLo >>> 16)) + ((c0 >>> 16) + (c1 >>> 16)) >>> 0;

		c0 = (c0 << 16) >>> 0;
		lo = (lo + c0) >>> 0;
		if ((lo >>> 0) < (c0 >>> 0)) {
			hi = (hi + 1) >>> 0;
		}

		c1 = (c1 << 16) >>> 0;
		lo = (lo + c1) >>> 0;
		if ((lo >>> 0) < (c1 >>> 0)) {
			hi = (hi + 1) >>> 0;
		}

		hi = (hi + imul(aLo, bHi)) >>> 0;
		hi = (hi + imul(aHi, bLo)) >>> 0;

		out[0] = hi;
		out[1] = lo;
	}

	// add two 64 bit numbers (given in parts), and store the result in `out`.
	function add64_(out, aHi, aLo, bHi, bLo) {
		var hi = (aHi + bHi) >>> 0;
		var lo = (aLo + bLo) >>> 0;
		if ((lo >>> 0) < (aLo >>> 0)) {
			hi = (hi + 1) | 0;
		}
		out[0] = hi;
		out[1] = lo;
	}

	var MUL_HI = 0x5851f42d >>> 0;
	var MUL_LO = 0x4c957f2d >>> 0;

	/// Generate a random 32 bit integer. This uses the PCG algorithm, described
	/// here: http://www.pcg-random.org/
	PcgRandom.prototype.next_ = function() {
		// save current state (what we'll use for this number)
		var oldHi = this.state_[0] >>> 0;
		var oldLo = this.state_[1] >>> 0;

		// churn LCG.
		mul64_(this.state_, oldHi, oldLo, MUL_HI, MUL_LO);
		add64_(this.state_, this.state_[0], this.state_[1], this.state_[2], this.state_[3]);

		// get least sig. 32 bits of ((oldstate >> 18) ^ oldstate) >> 27
		var xsHi = oldHi >>> 18;
		var xsLo = ((oldLo >>> 18) | (oldHi << 14)) >>> 0;
		xsHi = (xsHi ^ oldHi) >>> 0;
		xsLo = (xsLo ^ oldLo) >>> 0;
		var xorshifted = ((xsLo >>> 27) | (xsHi << 5)) >>> 0;
		// rotate xorshifted right a random amount, based on the most sig. 5 bits
		// bits of the old state.
		var rot = oldHi >>> 27;
		var rot2 = ((-rot >>> 0) & 31) >>> 0;
		return ((xorshifted >>> rot) | (xorshifted << rot2)) >>> 0;
	};

	/// Get a uniformly distributed 32 bit integer between [0, max).
	PcgRandom.prototype.integer = function(max) {
		if (!max) {
			return this.next_();
		}
		max = max >>> 0;
		if ((max & (max - 1)) === 0) {
			return this.next_() & (max - 1); // fast path for power of 2
		}

		var num = 0;
		var skew = ((-max >>> 0) % max) >>> 0;
		for (num = this.next_(); num < skew; num = this.next_()) {
			// this loop will rarely execute more than twice,
			// and is intentionally empty
		}
		return num % max;
	};

	var BIT_53 = 9007199254740992.0;
	var BIT_27 = 134217728.0;

	/// Get a uniformly distributed IEEE-754 double between 0.0 and 1.0, with
	/// 53 bits of precision (every bit of the mantissa is randomized).
	PcgRandom.prototype.number = function() {
		var hi = (this.next_() & 0x03ffffff) * 1.0;
		var lo = (this.next_() & 0x07ffffff) * 1.0;
		return ((hi * BIT_27) + lo) / BIT_53;
	};

	return PcgRandom;
}());

if (typeof module !== 'undefined' && module.exports) {
	module.exports = PcgRandom;
}


},{}],8:[function(require,module,exports){
'use strict'

module.exports = polyBool

var pslg2poly = require('pslg-to-poly')
var poly2pslg = require('poly-to-pslg')
var overlay   = require('overlay-pslg')

function polyBool(a, b, op) {
  var apsl = poly2pslg(a)
  var bpsl = poly2pslg(b)
  var result = overlay(
    apsl.points, apsl.edges,
    bpsl.points, bpsl.edges,
    op)
  return pslg2poly(result.points, result.red.concat(result.blue))
}

},{"overlay-pslg":79,"poly-to-pslg":126,"pslg-to-poly":151}],9:[function(require,module,exports){
"use strict"

function compileSearch(funcName, predicate, reversed, extraArgs, earlyOut) {
  var code = [
    "function ", funcName, "(a,l,h,", extraArgs.join(","),  "){",
earlyOut ? "" : "var i=", (reversed ? "l-1" : "h+1"),
";while(l<=h){\
var m=(l+h)>>>1,x=a[m]"]
  if(earlyOut) {
    if(predicate.indexOf("c") < 0) {
      code.push(";if(x===y){return m}else if(x<=y){")
    } else {
      code.push(";var p=c(x,y);if(p===0){return m}else if(p<=0){")
    }
  } else {
    code.push(";if(", predicate, "){i=m;")
  }
  if(reversed) {
    code.push("l=m+1}else{h=m-1}")
  } else {
    code.push("h=m-1}else{l=m+1}")
  }
  code.push("}")
  if(earlyOut) {
    code.push("return -1};")
  } else {
    code.push("return i};")
  }
  return code.join("")
}

function compileBoundsSearch(predicate, reversed, suffix, earlyOut) {
  var result = new Function([
  compileSearch("A", "x" + predicate + "y", reversed, ["y"], earlyOut),
  compileSearch("P", "c(x,y)" + predicate + "0", reversed, ["y", "c"], earlyOut),
"function dispatchBsearch", suffix, "(a,y,c,l,h){\
if(typeof(c)==='function'){\
return P(a,(l===void 0)?0:l|0,(h===void 0)?a.length-1:h|0,y,c)\
}else{\
return A(a,(c===void 0)?0:c|0,(l===void 0)?a.length-1:l|0,y)\
}}\
return dispatchBsearch", suffix].join(""))
  return result()
}

module.exports = {
  ge: compileBoundsSearch(">=", false, "GE"),
  gt: compileBoundsSearch(">", false, "GT"),
  lt: compileBoundsSearch("<", true, "LT"),
  le: compileBoundsSearch("<=", true, "LE"),
  eq: compileBoundsSearch("-", true, "EQ", true)
}

},{}],10:[function(require,module,exports){
'use strict'

var monotoneTriangulate = require('./lib/monotone')
var makeIndex = require('./lib/triangulation')
var delaunayFlip = require('./lib/delaunay')
var filterTriangulation = require('./lib/filter')

module.exports = cdt2d

function canonicalizeEdge(e) {
  return [Math.min(e[0], e[1]), Math.max(e[0], e[1])]
}

function compareEdge(a, b) {
  return a[0]-b[0] || a[1]-b[1]
}

function canonicalizeEdges(edges) {
  return edges.map(canonicalizeEdge).sort(compareEdge)
}

function getDefault(options, property, dflt) {
  if(property in options) {
    return options[property]
  }
  return dflt
}

function cdt2d(points, edges, options) {

  if(!Array.isArray(edges)) {
    options = edges || {}
    edges = []
  } else {
    options = options || {}
    edges = edges || []
  }

  //Parse out options
  var delaunay = !!getDefault(options, 'delaunay', true)
  var interior = !!getDefault(options, 'interior', true)
  var exterior = !!getDefault(options, 'exterior', true)
  var infinity = !!getDefault(options, 'infinity', false)

  //Handle trivial case
  if((!interior && !exterior) || points.length === 0) {
    return []
  }

  //Construct initial triangulation
  var cells = monotoneTriangulate(points, edges)

  //If delaunay refinement needed, then improve quality by edge flipping
  if(delaunay || interior !== exterior || infinity) {

    //Index all of the cells to support fast neighborhood queries
    var triangulation = makeIndex(points.length, canonicalizeEdges(edges))
    for(var i=0; i<cells.length; ++i) {
      var f = cells[i]
      triangulation.addTriangle(f[0], f[1], f[2])
    }

    //Run edge flipping
    if(delaunay) {
      delaunayFlip(points, triangulation)
    }

    //Filter points
    if(!exterior) {
      return filterTriangulation(triangulation, -1)
    } else if(!interior) {
      return filterTriangulation(triangulation,  1, infinity)
    } else if(infinity) {
      return filterTriangulation(triangulation, 0, infinity)
    } else {
      return triangulation.cells()
    }
    
  } else {
    return cells
  }
}

},{"./lib/delaunay":11,"./lib/filter":12,"./lib/monotone":13,"./lib/triangulation":14}],11:[function(require,module,exports){
'use strict'

var inCircle = require('robust-in-sphere')[4]
var bsearch = require('binary-search-bounds')

module.exports = delaunayRefine

function testFlip(points, triangulation, stack, a, b, x) {
  var y = triangulation.opposite(a, b)

  //Test boundary edge
  if(y < 0) {
    return
  }

  //Swap edge if order flipped
  if(b < a) {
    var tmp = a
    a = b
    b = tmp
    tmp = x
    x = y
    y = tmp
  }

  //Test if edge is constrained
  if(triangulation.isConstraint(a, b)) {
    return
  }

  //Test if edge is delaunay
  if(inCircle(points[a], points[b], points[x], points[y]) < 0) {
    stack.push(a, b)
  }
}

//Assume edges are sorted lexicographically
function delaunayRefine(points, triangulation) {
  var stack = []

  var numPoints = points.length
  var stars = triangulation.stars
  for(var a=0; a<numPoints; ++a) {
    var star = stars[a]
    for(var j=1; j<star.length; j+=2) {
      var b = star[j]

      //If order is not consistent, then skip edge
      if(b < a) {
        continue
      }

      //Check if edge is constrained
      if(triangulation.isConstraint(a, b)) {
        continue
      }

      //Find opposite edge
      var x = star[j-1], y = -1
      for(var k=1; k<star.length; k+=2) {
        if(star[k-1] === b) {
          y = star[k]
          break
        }
      }

      //If this is a boundary edge, don't flip it
      if(y < 0) {
        continue
      }

      //If edge is in circle, flip it
      if(inCircle(points[a], points[b], points[x], points[y]) < 0) {
        stack.push(a, b)
      }
    }
  }

  while(stack.length > 0) {
    var b = stack.pop()
    var a = stack.pop()

    //Find opposite pairs
    var x = -1, y = -1
    var star = stars[a]
    for(var i=1; i<star.length; i+=2) {
      var s = star[i-1]
      var t = star[i]
      if(s === b) {
        y = t
      } else if(t === b) {
        x = s
      }
    }

    //If x/y are both valid then skip edge
    if(x < 0 || y < 0) {
      continue
    }

    //If edge is now delaunay, then don't flip it
    if(inCircle(points[a], points[b], points[x], points[y]) >= 0) {
      continue
    }

    //Flip the edge
    triangulation.flip(a, b)

    //Test flipping neighboring edges
    testFlip(points, triangulation, stack, x, a, y)
    testFlip(points, triangulation, stack, a, y, x)
    testFlip(points, triangulation, stack, y, b, x)
    testFlip(points, triangulation, stack, b, x, y)
  }
}

},{"binary-search-bounds":9,"robust-in-sphere":15}],12:[function(require,module,exports){
'use strict'

var bsearch = require('binary-search-bounds')

module.exports = classifyFaces

function FaceIndex(cells, neighbor, constraint, flags, active, next, boundary) {
  this.cells       = cells
  this.neighbor    = neighbor
  this.flags       = flags
  this.constraint  = constraint
  this.active      = active
  this.next        = next
  this.boundary    = boundary
}

var proto = FaceIndex.prototype

function compareCell(a, b) {
  return a[0] - b[0] ||
         a[1] - b[1] ||
         a[2] - b[2]
}

proto.locate = (function() {
  var key = [0,0,0]
  return function(a, b, c) {
    var x = a, y = b, z = c
    if(b < c) {
      if(b < a) {
        x = b
        y = c
        z = a
      }
    } else if(c < a) {
      x = c
      y = a
      z = b
    }
    if(x < 0) {
      return -1
    }
    key[0] = x
    key[1] = y
    key[2] = z
    return bsearch.eq(this.cells, key, compareCell)
  }
})()

function indexCells(triangulation, infinity) {
  //First get cells and canonicalize
  var cells = triangulation.cells()
  var nc = cells.length
  for(var i=0; i<nc; ++i) {
    var c = cells[i]
    var x = c[0], y = c[1], z = c[2]
    if(y < z) {
      if(y < x) {
        c[0] = y
        c[1] = z
        c[2] = x
      }
    } else if(z < x) {
      c[0] = z
      c[1] = x
      c[2] = y
    }
  }
  cells.sort(compareCell)

  //Initialize flag array
  var flags = new Array(nc)
  for(var i=0; i<flags.length; ++i) {
    flags[i] = 0
  }

  //Build neighbor index, initialize queues
  var active = []
  var next   = []
  var neighbor = new Array(3*nc)
  var constraint = new Array(3*nc)
  var boundary = null
  if(infinity) {
    boundary = []
  }
  var index = new FaceIndex(
    cells,
    neighbor,
    constraint,
    flags,
    active,
    next,
    boundary)
  for(var i=0; i<nc; ++i) {
    var c = cells[i]
    for(var j=0; j<3; ++j) {
      var x = c[j], y = c[(j+1)%3]
      var a = neighbor[3*i+j] = index.locate(y, x, triangulation.opposite(y, x))
      var b = constraint[3*i+j] = triangulation.isConstraint(x, y)
      if(a < 0) {
        if(b) {
          next.push(i)
        } else {
          active.push(i)
          flags[i] = 1
        }
        if(infinity) {
          boundary.push([y, x, -1])
        }
      }
    }
  }
  return index
}

function filterCells(cells, flags, target) {
  var ptr = 0
  for(var i=0; i<cells.length; ++i) {
    if(flags[i] === target) {
      cells[ptr++] = cells[i]
    }
  }
  cells.length = ptr
  return cells
}

function classifyFaces(triangulation, target, infinity) {
  var index = indexCells(triangulation, infinity)

  if(target === 0) {
    if(infinity) {
      return index.cells.concat(index.boundary)
    } else {
      return index.cells
    }
  }

  var side = 1
  var active = index.active
  var next = index.next
  var flags = index.flags
  var cells = index.cells
  var constraint = index.constraint
  var neighbor = index.neighbor

  while(active.length > 0 || next.length > 0) {
    while(active.length > 0) {
      var t = active.pop()
      if(flags[t] === -side) {
        continue
      }
      flags[t] = side
      var c = cells[t]
      for(var j=0; j<3; ++j) {
        var f = neighbor[3*t+j]
        if(f >= 0 && flags[f] === 0) {
          if(constraint[3*t+j]) {
            next.push(f)
          } else {
            active.push(f)
            flags[f] = side
          }
        }
      }
    }

    //Swap arrays and loop
    var tmp = next
    next = active
    active = tmp
    next.length = 0
    side = -side
  }

  var result = filterCells(cells, flags, target)
  if(infinity) {
    return result.concat(index.boundary)
  }
  return result
}

},{"binary-search-bounds":9}],13:[function(require,module,exports){
'use strict'

var bsearch = require('binary-search-bounds')
var orient = require('robust-orientation')[3]

var EVENT_POINT = 0
var EVENT_END   = 1
var EVENT_START = 2

module.exports = monotoneTriangulate

//A partial convex hull fragment, made of two unimonotone polygons
function PartialHull(a, b, idx, lowerIds, upperIds) {
  this.a = a
  this.b = b
  this.idx = idx
  this.lowerIds = lowerIds
  this.upperIds = upperIds
}

//An event in the sweep line procedure
function Event(a, b, type, idx) {
  this.a    = a
  this.b    = b
  this.type = type
  this.idx  = idx
}

//This is used to compare events for the sweep line procedure
// Points are:
//  1. sorted lexicographically
//  2. sorted by type  (point < end < start)
//  3. segments sorted by winding order
//  4. sorted by index
function compareEvent(a, b) {
  var d =
    (a.a[0] - b.a[0]) ||
    (a.a[1] - b.a[1]) ||
    (a.type - b.type)
  if(d) { return d }
  if(a.type !== EVENT_POINT) {
    d = orient(a.a, a.b, b.b)
    if(d) { return d }
  }
  return a.idx - b.idx
}

function testPoint(hull, p) {
  return orient(hull.a, hull.b, p)
}

function addPoint(cells, hulls, points, p, idx) {
  var lo = bsearch.lt(hulls, p, testPoint)
  var hi = bsearch.gt(hulls, p, testPoint)
  for(var i=lo; i<hi; ++i) {
    var hull = hulls[i]

    //Insert p into lower hull
    var lowerIds = hull.lowerIds
    var m = lowerIds.length
    while(m > 1 && orient(
        points[lowerIds[m-2]],
        points[lowerIds[m-1]],
        p) > 0) {
      cells.push(
        [lowerIds[m-1],
         lowerIds[m-2],
         idx])
      m -= 1
    }
    lowerIds.length = m
    lowerIds.push(idx)

    //Insert p into upper hull
    var upperIds = hull.upperIds
    var m = upperIds.length
    while(m > 1 && orient(
        points[upperIds[m-2]],
        points[upperIds[m-1]],
        p) < 0) {
      cells.push(
        [upperIds[m-2],
         upperIds[m-1],
         idx])
      m -= 1
    }
    upperIds.length = m
    upperIds.push(idx)
  }
}

function findSplit(hull, edge) {
  var d
  if(hull.a[0] < edge.a[0]) {
    d = orient(hull.a, hull.b, edge.a)
  } else {
    d = orient(edge.b, edge.a, hull.a)
  }
  if(d) { return d }
  if(edge.b[0] < hull.b[0]) {
    d = orient(hull.a, hull.b, edge.b)
  } else {
    d = orient(edge.b, edge.a, hull.b)
  }
  return d || hull.idx - edge.idx
}

function splitHulls(hulls, points, event) {
  var splitIdx = bsearch.le(hulls, event, findSplit)
  var hull = hulls[splitIdx]
  var upperIds = hull.upperIds
  var x = upperIds[upperIds.length-1]
  hull.upperIds = [x]
  hulls.splice(splitIdx+1, 0,
    new PartialHull(event.a, event.b, event.idx, [x], upperIds))
}


function mergeHulls(hulls, points, event) {
  //Swap pointers for merge search
  var tmp = event.a
  event.a = event.b
  event.b = tmp
  var mergeIdx = bsearch.eq(hulls, event, findSplit)
  var upper = hulls[mergeIdx]
  var lower = hulls[mergeIdx-1]
  lower.upperIds = upper.upperIds
  hulls.splice(mergeIdx, 1)
}


function monotoneTriangulate(points, edges) {

  var numPoints = points.length
  var numEdges = edges.length

  var events = []

  //Create point events
  for(var i=0; i<numPoints; ++i) {
    events.push(new Event(
      points[i],
      null,
      EVENT_POINT,
      i))
  }

  //Create edge events
  for(var i=0; i<numEdges; ++i) {
    var e = edges[i]
    var a = points[e[0]]
    var b = points[e[1]]
    if(a[0] < b[0]) {
      events.push(
        new Event(a, b, EVENT_START, i),
        new Event(b, a, EVENT_END, i))
    } else if(a[0] > b[0]) {
      events.push(
        new Event(b, a, EVENT_START, i),
        new Event(a, b, EVENT_END, i))
    }
  }

  //Sort events
  events.sort(compareEvent)

  //Initialize hull
  var minX = events[0].a[0] - (1 + Math.abs(events[0].a[0])) * Math.pow(2, -52)
  var hull = [ new PartialHull([minX, 1], [minX, 0], -1, [], [], [], []) ]

  //Process events in order
  var cells = []
  for(var i=0, numEvents=events.length; i<numEvents; ++i) {
    var event = events[i]
    var type = event.type
    if(type === EVENT_POINT) {
      addPoint(cells, hull, points, event.a, event.idx)
    } else if(type === EVENT_START) {
      splitHulls(hull, points, event)
    } else {
      mergeHulls(hull, points, event)
    }
  }

  //Return triangulation
  return cells
}

},{"binary-search-bounds":9,"robust-orientation":26}],14:[function(require,module,exports){
'use strict'

var bsearch = require('binary-search-bounds')

module.exports = createTriangulation

function Triangulation(stars, edges) {
  this.stars = stars
  this.edges = edges
}

var proto = Triangulation.prototype

function removePair(list, j, k) {
  for(var i=1, n=list.length; i<n; i+=2) {
    if(list[i-1] === j && list[i] === k) {
      list[i-1] = list[n-2]
      list[i] = list[n-1]
      list.length = n - 2
      return
    }
  }
}

proto.isConstraint = (function() {
  var e = [0,0]
  function compareLex(a, b) {
    return a[0] - b[0] || a[1] - b[1]
  }
  return function(i, j) {
    e[0] = Math.min(i,j)
    e[1] = Math.max(i,j)
    return bsearch.eq(this.edges, e, compareLex) >= 0
  }
})()

proto.removeTriangle = function(i, j, k) {
  var stars = this.stars
  removePair(stars[i], j, k)
  removePair(stars[j], k, i)
  removePair(stars[k], i, j)
}

proto.addTriangle = function(i, j, k) {
  var stars = this.stars
  stars[i].push(j, k)
  stars[j].push(k, i)
  stars[k].push(i, j)
}

proto.opposite = function(j, i) {
  var list = this.stars[i]
  for(var k=1, n=list.length; k<n; k+=2) {
    if(list[k] === j) {
      return list[k-1]
    }
  }
  return -1
}

proto.flip = function(i, j) {
  var a = this.opposite(i, j)
  var b = this.opposite(j, i)
  this.removeTriangle(i, j, a)
  this.removeTriangle(j, i, b)
  this.addTriangle(i, b, a)
  this.addTriangle(j, a, b)
}

proto.edges = function() {
  var stars = this.stars
  var result = []
  for(var i=0, n=stars.length; i<n; ++i) {
    var list = stars[i]
    for(var j=0, m=list.length; j<m; j+=2) {
      result.push([list[j], list[j+1]])
    }
  }
  return result
}

proto.cells = function() {
  var stars = this.stars
  var result = []
  for(var i=0, n=stars.length; i<n; ++i) {
    var list = stars[i]
    for(var j=0, m=list.length; j<m; j+=2) {
      var s = list[j]
      var t = list[j+1]
      if(i < Math.min(s, t)) {
        result.push([i, s, t])
      }
    }
  }
  return result
}

function createTriangulation(numVerts, edges) {
  var stars = new Array(numVerts)
  for(var i=0; i<numVerts; ++i) {
    stars[i] = []
  }
  return new Triangulation(stars, edges)
}

},{"binary-search-bounds":9}],15:[function(require,module,exports){
"use strict"

var twoProduct = require("two-product")
var robustSum = require("robust-sum")
var robustDiff = require("robust-subtract")
var robustScale = require("robust-scale")

var NUM_EXPAND = 6

function cofactor(m, c) {
  var result = new Array(m.length-1)
  for(var i=1; i<m.length; ++i) {
    var r = result[i-1] = new Array(m.length-1)
    for(var j=0,k=0; j<m.length; ++j) {
      if(j === c) {
        continue
      }
      r[k++] = m[i][j]
    }
  }
  return result
}

function matrix(n) {
  var result = new Array(n)
  for(var i=0; i<n; ++i) {
    result[i] = new Array(n)
    for(var j=0; j<n; ++j) {
      result[i][j] = ["m", j, "[", (n-i-2), "]"].join("")
    }
  }
  return result
}

function generateSum(expr) {
  if(expr.length === 1) {
    return expr[0]
  } else if(expr.length === 2) {
    return ["sum(", expr[0], ",", expr[1], ")"].join("")
  } else {
    var m = expr.length>>1
    return ["sum(", generateSum(expr.slice(0, m)), ",", generateSum(expr.slice(m)), ")"].join("")
  }
}

function makeProduct(a, b) {
  if(a.charAt(0) === "m") {
    if(b.charAt(0) === "w") {
      var toks = a.split("[")
      return ["w", b.substr(1), "m", toks[0].substr(1)].join("")
    } else {
      return ["prod(", a, ",", b, ")"].join("")
    }
  } else {
    return makeProduct(b, a)
  }
}

function sign(s) {
  if(s & 1 !== 0) {
    return "-"
  }
  return ""
}

function determinant(m) {
  if(m.length === 2) {
    return [["diff(", makeProduct(m[0][0], m[1][1]), ",", makeProduct(m[1][0], m[0][1]), ")"].join("")]
  } else {
    var expr = []
    for(var i=0; i<m.length; ++i) {
      expr.push(["scale(", generateSum(determinant(cofactor(m, i))), ",", sign(i), m[0][i], ")"].join(""))
    }
    return expr
  }
}

function makeSquare(d, n) {
  var terms = []
  for(var i=0; i<n-2; ++i) {
    terms.push(["prod(m", d, "[", i, "],m", d, "[", i, "])"].join(""))
  }
  return generateSum(terms)
}

function orientation(n) {
  var pos = []
  var neg = []
  var m = matrix(n)
  for(var i=0; i<n; ++i) {
    m[0][i] = "1"
    m[n-1][i] = "w"+i
  } 
  for(var i=0; i<n; ++i) {
    if((i&1)===0) {
      pos.push.apply(pos,determinant(cofactor(m, i)))
    } else {
      neg.push.apply(neg,determinant(cofactor(m, i)))
    }
  }
  var posExpr = generateSum(pos)
  var negExpr = generateSum(neg)
  var funcName = "exactInSphere" + n
  var funcArgs = []
  for(var i=0; i<n; ++i) {
    funcArgs.push("m" + i)
  }
  var code = ["function ", funcName, "(", funcArgs.join(), "){"]
  for(var i=0; i<n; ++i) {
    code.push("var w",i,"=",makeSquare(i,n),";")
    for(var j=0; j<n; ++j) {
      if(j !== i) {
        code.push("var w",i,"m",j,"=scale(w",i,",m",j,"[0]);")
      }
    }
  }
  code.push("var p=", posExpr, ",n=", negExpr, ",d=diff(p,n);return d[d.length-1];}return ", funcName)
  var proc = new Function("sum", "diff", "prod", "scale", code.join(""))
  return proc(robustSum, robustDiff, twoProduct, robustScale)
}

function inSphere0() { return 0 }
function inSphere1() { return 0 }
function inSphere2() { return 0 }

var CACHED = [
  inSphere0,
  inSphere1,
  inSphere2
]

function slowInSphere(args) {
  var proc = CACHED[args.length]
  if(!proc) {
    proc = CACHED[args.length] = orientation(args.length)
  }
  return proc.apply(undefined, args)
}

function generateInSphereTest() {
  while(CACHED.length <= NUM_EXPAND) {
    CACHED.push(orientation(CACHED.length))
  }
  var args = []
  var procArgs = ["slow"]
  for(var i=0; i<=NUM_EXPAND; ++i) {
    args.push("a" + i)
    procArgs.push("o" + i)
  }
  var code = [
    "function testInSphere(", args.join(), "){switch(arguments.length){case 0:case 1:return 0;"
  ]
  for(var i=2; i<=NUM_EXPAND; ++i) {
    code.push("case ", i, ":return o", i, "(", args.slice(0, i).join(), ");")
  }
  code.push("}var s=new Array(arguments.length);for(var i=0;i<arguments.length;++i){s[i]=arguments[i]};return slow(s);}return testInSphere")
  procArgs.push(code.join(""))

  var proc = Function.apply(undefined, procArgs)

  module.exports = proc.apply(undefined, [slowInSphere].concat(CACHED))
  for(var i=0; i<=NUM_EXPAND; ++i) {
    module.exports[i] = CACHED[i]
  }
}

generateInSphereTest()
},{"robust-scale":17,"robust-subtract":18,"robust-sum":19,"two-product":20}],16:[function(require,module,exports){
"use strict"

module.exports = fastTwoSum

function fastTwoSum(a, b, result) {
	var x = a + b
	var bv = x - a
	var av = x - bv
	var br = b - bv
	var ar = a - av
	if(result) {
		result[0] = ar + br
		result[1] = x
		return result
	}
	return [ar+br, x]
}
},{}],17:[function(require,module,exports){
"use strict"

var twoProduct = require("two-product")
var twoSum = require("two-sum")

module.exports = scaleLinearExpansion

function scaleLinearExpansion(e, scale) {
  var n = e.length
  if(n === 1) {
    var ts = twoProduct(e[0], scale)
    if(ts[0]) {
      return ts
    }
    return [ ts[1] ]
  }
  var g = new Array(2 * n)
  var q = [0.1, 0.1]
  var t = [0.1, 0.1]
  var count = 0
  twoProduct(e[0], scale, q)
  if(q[0]) {
    g[count++] = q[0]
  }
  for(var i=1; i<n; ++i) {
    twoProduct(e[i], scale, t)
    var pq = q[1]
    twoSum(pq, t[0], q)
    if(q[0]) {
      g[count++] = q[0]
    }
    var a = t[1]
    var b = q[1]
    var x = a + b
    var bv = x - a
    var y = b - bv
    q[1] = x
    if(y) {
      g[count++] = y
    }
  }
  if(q[1]) {
    g[count++] = q[1]
  }
  if(count === 0) {
    g[count++] = 0.0
  }
  g.length = count
  return g
}
},{"two-product":20,"two-sum":16}],18:[function(require,module,exports){
"use strict"

module.exports = robustSubtract

//Easy case: Add two scalars
function scalarScalar(a, b) {
  var x = a + b
  var bv = x - a
  var av = x - bv
  var br = b - bv
  var ar = a - av
  var y = ar + br
  if(y) {
    return [y, x]
  }
  return [x]
}

function robustSubtract(e, f) {
  var ne = e.length|0
  var nf = f.length|0
  if(ne === 1 && nf === 1) {
    return scalarScalar(e[0], -f[0])
  }
  var n = ne + nf
  var g = new Array(n)
  var count = 0
  var eptr = 0
  var fptr = 0
  var abs = Math.abs
  var ei = e[eptr]
  var ea = abs(ei)
  var fi = -f[fptr]
  var fa = abs(fi)
  var a, b
  if(ea < fa) {
    b = ei
    eptr += 1
    if(eptr < ne) {
      ei = e[eptr]
      ea = abs(ei)
    }
  } else {
    b = fi
    fptr += 1
    if(fptr < nf) {
      fi = -f[fptr]
      fa = abs(fi)
    }
  }
  if((eptr < ne && ea < fa) || (fptr >= nf)) {
    a = ei
    eptr += 1
    if(eptr < ne) {
      ei = e[eptr]
      ea = abs(ei)
    }
  } else {
    a = fi
    fptr += 1
    if(fptr < nf) {
      fi = -f[fptr]
      fa = abs(fi)
    }
  }
  var x = a + b
  var bv = x - a
  var y = b - bv
  var q0 = y
  var q1 = x
  var _x, _bv, _av, _br, _ar
  while(eptr < ne && fptr < nf) {
    if(ea < fa) {
      a = ei
      eptr += 1
      if(eptr < ne) {
        ei = e[eptr]
        ea = abs(ei)
      }
    } else {
      a = fi
      fptr += 1
      if(fptr < nf) {
        fi = -f[fptr]
        fa = abs(fi)
      }
    }
    b = q0
    x = a + b
    bv = x - a
    y = b - bv
    if(y) {
      g[count++] = y
    }
    _x = q1 + x
    _bv = _x - q1
    _av = _x - _bv
    _br = x - _bv
    _ar = q1 - _av
    q0 = _ar + _br
    q1 = _x
  }
  while(eptr < ne) {
    a = ei
    b = q0
    x = a + b
    bv = x - a
    y = b - bv
    if(y) {
      g[count++] = y
    }
    _x = q1 + x
    _bv = _x - q1
    _av = _x - _bv
    _br = x - _bv
    _ar = q1 - _av
    q0 = _ar + _br
    q1 = _x
    eptr += 1
    if(eptr < ne) {
      ei = e[eptr]
    }
  }
  while(fptr < nf) {
    a = fi
    b = q0
    x = a + b
    bv = x - a
    y = b - bv
    if(y) {
      g[count++] = y
    } 
    _x = q1 + x
    _bv = _x - q1
    _av = _x - _bv
    _br = x - _bv
    _ar = q1 - _av
    q0 = _ar + _br
    q1 = _x
    fptr += 1
    if(fptr < nf) {
      fi = -f[fptr]
    }
  }
  if(q0) {
    g[count++] = q0
  }
  if(q1) {
    g[count++] = q1
  }
  if(!count) {
    g[count++] = 0.0  
  }
  g.length = count
  return g
}
},{}],19:[function(require,module,exports){
"use strict"

module.exports = linearExpansionSum

//Easy case: Add two scalars
function scalarScalar(a, b) {
  var x = a + b
  var bv = x - a
  var av = x - bv
  var br = b - bv
  var ar = a - av
  var y = ar + br
  if(y) {
    return [y, x]
  }
  return [x]
}

function linearExpansionSum(e, f) {
  var ne = e.length|0
  var nf = f.length|0
  if(ne === 1 && nf === 1) {
    return scalarScalar(e[0], f[0])
  }
  var n = ne + nf
  var g = new Array(n)
  var count = 0
  var eptr = 0
  var fptr = 0
  var abs = Math.abs
  var ei = e[eptr]
  var ea = abs(ei)
  var fi = f[fptr]
  var fa = abs(fi)
  var a, b
  if(ea < fa) {
    b = ei
    eptr += 1
    if(eptr < ne) {
      ei = e[eptr]
      ea = abs(ei)
    }
  } else {
    b = fi
    fptr += 1
    if(fptr < nf) {
      fi = f[fptr]
      fa = abs(fi)
    }
  }
  if((eptr < ne && ea < fa) || (fptr >= nf)) {
    a = ei
    eptr += 1
    if(eptr < ne) {
      ei = e[eptr]
      ea = abs(ei)
    }
  } else {
    a = fi
    fptr += 1
    if(fptr < nf) {
      fi = f[fptr]
      fa = abs(fi)
    }
  }
  var x = a + b
  var bv = x - a
  var y = b - bv
  var q0 = y
  var q1 = x
  var _x, _bv, _av, _br, _ar
  while(eptr < ne && fptr < nf) {
    if(ea < fa) {
      a = ei
      eptr += 1
      if(eptr < ne) {
        ei = e[eptr]
        ea = abs(ei)
      }
    } else {
      a = fi
      fptr += 1
      if(fptr < nf) {
        fi = f[fptr]
        fa = abs(fi)
      }
    }
    b = q0
    x = a + b
    bv = x - a
    y = b - bv
    if(y) {
      g[count++] = y
    }
    _x = q1 + x
    _bv = _x - q1
    _av = _x - _bv
    _br = x - _bv
    _ar = q1 - _av
    q0 = _ar + _br
    q1 = _x
  }
  while(eptr < ne) {
    a = ei
    b = q0
    x = a + b
    bv = x - a
    y = b - bv
    if(y) {
      g[count++] = y
    }
    _x = q1 + x
    _bv = _x - q1
    _av = _x - _bv
    _br = x - _bv
    _ar = q1 - _av
    q0 = _ar + _br
    q1 = _x
    eptr += 1
    if(eptr < ne) {
      ei = e[eptr]
    }
  }
  while(fptr < nf) {
    a = fi
    b = q0
    x = a + b
    bv = x - a
    y = b - bv
    if(y) {
      g[count++] = y
    } 
    _x = q1 + x
    _bv = _x - q1
    _av = _x - _bv
    _br = x - _bv
    _ar = q1 - _av
    q0 = _ar + _br
    q1 = _x
    fptr += 1
    if(fptr < nf) {
      fi = f[fptr]
    }
  }
  if(q0) {
    g[count++] = q0
  }
  if(q1) {
    g[count++] = q1
  }
  if(!count) {
    g[count++] = 0.0  
  }
  g.length = count
  return g
}
},{}],20:[function(require,module,exports){
"use strict"

module.exports = twoProduct

var SPLITTER = +(Math.pow(2, 27) + 1.0)

function twoProduct(a, b, result) {
  var x = a * b

  var c = SPLITTER * a
  var abig = c - a
  var ahi = c - abig
  var alo = a - ahi

  var d = SPLITTER * b
  var bbig = d - b
  var bhi = d - bbig
  var blo = b - bhi

  var err1 = x - (ahi * bhi)
  var err2 = err1 - (alo * bhi)
  var err3 = err2 - (ahi * blo)

  var y = alo * blo - err3

  if(result) {
    result[0] = y
    result[1] = x
    return result
  }

  return [ y, x ]
}
},{}],21:[function(require,module,exports){
arguments[4][16][0].apply(exports,arguments)
},{"dup":16}],22:[function(require,module,exports){
arguments[4][17][0].apply(exports,arguments)
},{"dup":17,"two-product":25,"two-sum":21}],23:[function(require,module,exports){
arguments[4][18][0].apply(exports,arguments)
},{"dup":18}],24:[function(require,module,exports){
arguments[4][19][0].apply(exports,arguments)
},{"dup":19}],25:[function(require,module,exports){
arguments[4][20][0].apply(exports,arguments)
},{"dup":20}],26:[function(require,module,exports){
"use strict"

var twoProduct = require("two-product")
var robustSum = require("robust-sum")
var robustScale = require("robust-scale")
var robustSubtract = require("robust-subtract")

var NUM_EXPAND = 5

var EPSILON     = 1.1102230246251565e-16
var ERRBOUND3   = (3.0 + 16.0 * EPSILON) * EPSILON
var ERRBOUND4   = (7.0 + 56.0 * EPSILON) * EPSILON

function cofactor(m, c) {
  var result = new Array(m.length-1)
  for(var i=1; i<m.length; ++i) {
    var r = result[i-1] = new Array(m.length-1)
    for(var j=0,k=0; j<m.length; ++j) {
      if(j === c) {
        continue
      }
      r[k++] = m[i][j]
    }
  }
  return result
}

function matrix(n) {
  var result = new Array(n)
  for(var i=0; i<n; ++i) {
    result[i] = new Array(n)
    for(var j=0; j<n; ++j) {
      result[i][j] = ["m", j, "[", (n-i-1), "]"].join("")
    }
  }
  return result
}

function sign(n) {
  if(n & 1) {
    return "-"
  }
  return ""
}

function generateSum(expr) {
  if(expr.length === 1) {
    return expr[0]
  } else if(expr.length === 2) {
    return ["sum(", expr[0], ",", expr[1], ")"].join("")
  } else {
    var m = expr.length>>1
    return ["sum(", generateSum(expr.slice(0, m)), ",", generateSum(expr.slice(m)), ")"].join("")
  }
}

function determinant(m) {
  if(m.length === 2) {
    return [["sum(prod(", m[0][0], ",", m[1][1], "),prod(-", m[0][1], ",", m[1][0], "))"].join("")]
  } else {
    var expr = []
    for(var i=0; i<m.length; ++i) {
      expr.push(["scale(", generateSum(determinant(cofactor(m, i))), ",", sign(i), m[0][i], ")"].join(""))
    }
    return expr
  }
}

function orientation(n) {
  var pos = []
  var neg = []
  var m = matrix(n)
  var args = []
  for(var i=0; i<n; ++i) {
    if((i&1)===0) {
      pos.push.apply(pos, determinant(cofactor(m, i)))
    } else {
      neg.push.apply(neg, determinant(cofactor(m, i)))
    }
    args.push("m" + i)
  }
  var posExpr = generateSum(pos)
  var negExpr = generateSum(neg)
  var funcName = "orientation" + n + "Exact"
  var code = ["function ", funcName, "(", args.join(), "){var p=", posExpr, ",n=", negExpr, ",d=sub(p,n);\
return d[d.length-1];};return ", funcName].join("")
  var proc = new Function("sum", "prod", "scale", "sub", code)
  return proc(robustSum, twoProduct, robustScale, robustSubtract)
}

var orientation3Exact = orientation(3)
var orientation4Exact = orientation(4)

var CACHED = [
  function orientation0() { return 0 },
  function orientation1() { return 0 },
  function orientation2(a, b) { 
    return b[0] - a[0]
  },
  function orientation3(a, b, c) {
    var l = (a[1] - c[1]) * (b[0] - c[0])
    var r = (a[0] - c[0]) * (b[1] - c[1])
    var det = l - r
    var s
    if(l > 0) {
      if(r <= 0) {
        return det
      } else {
        s = l + r
      }
    } else if(l < 0) {
      if(r >= 0) {
        return det
      } else {
        s = -(l + r)
      }
    } else {
      return det
    }
    var tol = ERRBOUND3 * s
    if(det >= tol || det <= -tol) {
      return det
    }
    return orientation3Exact(a, b, c)
  },
  function orientation4(a,b,c,d) {
    var adx = a[0] - d[0]
    var bdx = b[0] - d[0]
    var cdx = c[0] - d[0]
    var ady = a[1] - d[1]
    var bdy = b[1] - d[1]
    var cdy = c[1] - d[1]
    var adz = a[2] - d[2]
    var bdz = b[2] - d[2]
    var cdz = c[2] - d[2]
    var bdxcdy = bdx * cdy
    var cdxbdy = cdx * bdy
    var cdxady = cdx * ady
    var adxcdy = adx * cdy
    var adxbdy = adx * bdy
    var bdxady = bdx * ady
    var det = adz * (bdxcdy - cdxbdy) 
            + bdz * (cdxady - adxcdy)
            + cdz * (adxbdy - bdxady)
    var permanent = (Math.abs(bdxcdy) + Math.abs(cdxbdy)) * Math.abs(adz)
                  + (Math.abs(cdxady) + Math.abs(adxcdy)) * Math.abs(bdz)
                  + (Math.abs(adxbdy) + Math.abs(bdxady)) * Math.abs(cdz)
    var tol = ERRBOUND4 * permanent
    if ((det > tol) || (-det > tol)) {
      return det
    }
    return orientation4Exact(a,b,c,d)
  }
]

function slowOrient(args) {
  var proc = CACHED[args.length]
  if(!proc) {
    proc = CACHED[args.length] = orientation(args.length)
  }
  return proc.apply(undefined, args)
}

function generateOrientationProc() {
  while(CACHED.length <= NUM_EXPAND) {
    CACHED.push(orientation(CACHED.length))
  }
  var args = []
  var procArgs = ["slow"]
  for(var i=0; i<=NUM_EXPAND; ++i) {
    args.push("a" + i)
    procArgs.push("o" + i)
  }
  var code = [
    "function getOrientation(", args.join(), "){switch(arguments.length){case 0:case 1:return 0;"
  ]
  for(var i=2; i<=NUM_EXPAND; ++i) {
    code.push("case ", i, ":return o", i, "(", args.slice(0, i).join(), ");")
  }
  code.push("}var s=new Array(arguments.length);for(var i=0;i<arguments.length;++i){s[i]=arguments[i]};return slow(s);}return getOrientation")
  procArgs.push(code.join(""))

  var proc = Function.apply(undefined, procArgs)
  module.exports = proc.apply(undefined, [slowOrient].concat(CACHED))
  for(var i=0; i<=NUM_EXPAND; ++i) {
    module.exports[i] = CACHED[i]
  }
}

generateOrientationProc()
},{"robust-scale":22,"robust-subtract":23,"robust-sum":24,"two-product":25}],27:[function(require,module,exports){
'use strict'

module.exports = cleanPSLG

var UnionFind = require('union-find')
var boxIntersect = require('box-intersect')
var compareCell = require('compare-cell')
var segseg = require('robust-segment-intersect')
var rat = require('big-rat')
var ratCmp = require('big-rat/cmp')
var ratToFloat = require('big-rat/to-float')
var ratVec = require('rat-vec')
var nextafter = require('nextafter')

var solveIntersection = require('./lib/rat-seg-intersect')

//Bounds on a rational number when rounded to a float
function boundRat(r) {
  var f = ratToFloat(r)
  var cmp = ratCmp(rat(f), r)
  if(cmp < 0) {
    return [f, nextafter(f, Infinity)]
  } else if(cmp > 0) {
    return [nextafter(f, -Infinity), f]
  } else {
    return [f, f]
  }
}

//Convert a list of edges in a pslg to bounding boxes
function boundEdges(points, edges) {
  var bounds = new Array(edges.length)
  for(var i=0; i<edges.length; ++i) {
    var e = edges[i]
    var a = points[e[0]]
    var b = points[e[1]]
    bounds[i] = [
      Math.min(a[0], b[0]),
      Math.min(a[1], b[1]),
      Math.max(a[0], b[0]),
      Math.max(a[1], b[1]) ]
  }
  return bounds
}

//Convert a list of points into bounding boxes by duplicating coords
function boundPoints(points) {
  var bounds = new Array(points.length)
  for(var i=0; i<points.length; ++i) {
    var p = points[i]
    bounds[i] = [ p[0], p[1], p[0], p[1] ]
  }
  return bounds
}

//Find all pairs of crossing edges in a pslg (given edge bounds)
function getCrossings(points, edges, edgeBounds) {
  var result = []
  boxIntersect(edgeBounds, function(i, j) {
    var e = edges[i]
    var f = edges[j]
    if(e[0] === f[0] || e[0] === f[1] ||
       e[1] === f[0] || e[1] === f[1]) {
         return
    }
    var a = points[e[0]]
    var b = points[e[1]]
    var c = points[f[0]]
    var d = points[f[1]]
    if(segseg(a, b, c, d)) {
      result.push([i, j])
    }
  })
  return result
}

//Find all pairs of crossing vertices in a pslg (given edge/vert bounds)
function getTJunctions(points, edges, edgeBounds, vertBounds) {
  var result = []
  boxIntersect(edgeBounds, vertBounds, function(i, v) {
    var e = edges[i]
    if(e[0] === v || e[1] === v) {
      return
    }
    var p = points[v]
    var a = points[e[0]]
    var b = points[e[1]]
    if(segseg(a, b, p, p)) {
      result.push([i, v])
    }
  })
  return result
}


//Cut edges along crossings/tjunctions
function cutEdges(floatPoints, edges, crossings, junctions, useColor) {

  //Convert crossings into tjunctions by constructing rational points
  var ratPoints = []
  for(var i=0; i<crossings.length; ++i) {
    var crossing = crossings[i]
    var e = crossing[0]
    var f = crossing[1]
    var ee = edges[e]
    var ef = edges[f]
    var x = solveIntersection(
      ratVec(floatPoints[ee[0]]),
      ratVec(floatPoints[ee[1]]),
      ratVec(floatPoints[ef[0]]),
      ratVec(floatPoints[ef[1]]))
    if(!x) {
      //Segments are parallel, should already be handled by t-junctions
      continue
    }
    var idx = ratPoints.length + floatPoints.length
    ratPoints.push(x)
    junctions.push([e, idx], [f, idx])
  }

  //Sort tjunctions
  function getPoint(idx) {
    if(idx >= floatPoints.length) {
      return ratPoints[idx-floatPoints.length]
    }
    var p = floatPoints[idx]
    return [ rat(p[0]), rat(p[1]) ]
  }
  junctions.sort(function(a, b) {
    if(a[0] !== b[0]) {
      return a[0] - b[0]
    }
    var u = getPoint(a[1])
    var v = getPoint(b[1])
    return ratCmp(u[0], v[0]) || ratCmp(u[1], v[1])
  })

  //Split edges along junctions
  for(var i=junctions.length-1; i>=0; --i) {
    var junction = junctions[i]
    var e = junction[0]

    var edge = edges[e]
    var s = edge[0]
    var t = edge[1]

    //Check if edge is not lexicographically sorted
    var a = floatPoints[s]
    var b = floatPoints[t]
    if(((a[0] - b[0]) || (a[1] - b[1])) < 0) {
      var tmp = s
      s = t
      t = tmp
    }

    //Split leading edge
    edge[0] = s
    var last = edge[1] = junction[1]

    //If we are grouping edges by color, remember to track data
    var color
    if(useColor) {
      color = edge[2]
    }

    //Split other edges
    while(i > 0 && junctions[i-1][0] === e) {
      var junction = junctions[--i]
      var next = junction[1]
      if(useColor) {
        edges.push([last, next, color])
      } else {
        edges.push([last, next])
      }
      last = next
    }

    //Add final edge
    if(useColor) {
      edges.push([last, t, color])
    } else {
      edges.push([last, t])
    }
  }

  //Return constructed rational points
  return ratPoints
}

//Merge overlapping points
function dedupPoints(floatPoints, ratPoints, floatBounds) {
  var numPoints = floatPoints.length + ratPoints.length
  var uf        = new UnionFind(numPoints)

  //Compute rational bounds
  var bounds = floatBounds
  for(var i=0; i<ratPoints.length; ++i) {
    var p = ratPoints[i]
    var xb = boundRat(p[0])
    var yb = boundRat(p[1])
    bounds.push([ xb[0], yb[0], xb[1], yb[1] ])
    floatPoints.push([ ratToFloat(p[0]), ratToFloat(p[1]) ])
  }

  //Link all points with over lapping boxes
  boxIntersect(bounds, function(i, j) {
    uf.link(i, j)
  })

  //Call find on each point to get a relabeling
  var ptr = 0
  var noDupes = true
  var labels = new Array(numPoints)
  for(var i=0; i<numPoints; ++i) {
    var j = uf.find(i)
    if(j === i) {
      //If not a duplicate, then don't bother
      labels[i] = ptr
      floatPoints[ptr++] = floatPoints[i]
    } else {
      //Clear no-dupes flag, zero out label
      noDupes = false
      labels[i] = -1
    }
  }
  floatPoints.length = ptr

  //If no duplicates, return null to signal termination
  if(noDupes) {
    return null
  }

  //Do a second pass to fix up missing labels
  for(var i=0; i<numPoints; ++i) {
    if(labels[i] < 0) {
      labels[i] = labels[uf.find(i)]
    }
  }

  //Return resulting union-find data structure
  return labels
}

function compareLex2(a,b) { return (a[0]-b[0]) || (a[1]-b[1]) }
function compareLex3(a,b) {
  var d = (a[0] - b[0]) || (a[1] - b[1])
  if(d) {
    return d
  }
  if(a[2] < b[2]) {
    return -1
  } else if(a[2] > b[2]) {
    return 1
  }
  return 0
}

//Remove duplicate edge labels
function dedupEdges(edges, labels, useColor) {
  if(edges.length === 0) {
    return
  }
  if(labels) {
    for(var i=0; i<edges.length; ++i) {
      var e = edges[i]
      var a = labels[e[0]]
      var b = labels[e[1]]
      e[0] = Math.min(a, b)
      e[1] = Math.max(a, b)
    }
  } else {
    for(var i=0; i<edges.length; ++i) {
      var e = edges[i]
      var a = e[0]
      var b = e[1]
      e[0] = Math.min(a, b)
      e[1] = Math.max(a, b)
    }
  }
  if(useColor) {
    edges.sort(compareLex3)
  } else {
    edges.sort(compareLex2)
  }
  var ptr = 1
  for(var i=1; i<edges.length; ++i) {
    var prev = edges[i-1]
    var next = edges[i]
    if(next[0] === prev[0] && next[1] === prev[1] &&
      (!useColor || next[2] === prev[2])) {
      continue
    }
    edges[ptr++] = next
  }
  edges.length = ptr
}

//Repeat until convergence
function snapRound(points, edges, useColor) {

  // 1. find edge crossings
  var edgeBounds = boundEdges(points, edges)
  var crossings  = getCrossings(points, edges, edgeBounds)

  // 2. find t-junctions
  var vertBounds = boundPoints(points)
  var tjunctions = getTJunctions(points, edges, edgeBounds, vertBounds)

  // 3. cut edges, construct rational points
  var ratPoints  = cutEdges(points, edges, crossings, tjunctions, useColor)

  // 4. dedupe verts
  var labels     = dedupPoints(points, ratPoints, vertBounds)

  // 6. dedupe edges
  dedupEdges(edges, labels, useColor)

  // 5. check termination
  if(!labels) {
    return (crossings.length > 0 || tjunctions.length > 0)
  }

  // More iterations necessary
  return true
}

//Main loop, runs PSLG clean up until completion
function cleanPSLG(points, edges, colors) {
  var modified = false

  //If using colors, augment edges with color data
  var prevEdges
  if(colors) {
    prevEdges = edges
    var augEdges = new Array(edges.length)
    for(var i=0; i<edges.length; ++i) {
      var e = edges[i]
      augEdges[i] = [e[0], e[1], colors[i]]
    }
    edges = augEdges
  }

  //Run snap rounding until convergence
  while(snapRound(points, edges, !!colors)) {
    modified = true
  }

  //Strip color tags
  if(!!colors && modified) {
    prevEdges.length = 0
    colors.length = 0
    for(var i=0; i<edges.length; ++i) {
      var e = edges[i]
      prevEdges.push([e[0], e[1]])
      colors.push(e[2])
    }
  }

  return modified
}

},{"./lib/rat-seg-intersect":28,"big-rat":32,"big-rat/cmp":30,"big-rat/to-float":47,"box-intersect":48,"compare-cell":58,"nextafter":59,"rat-vec":62,"robust-segment-intersect":71,"union-find":72}],28:[function(require,module,exports){
'use strict'

//TODO: Move this to a separate module

module.exports = solveIntersection

var ratMul = require('big-rat/mul')
var ratDiv = require('big-rat/div')
var ratSub = require('big-rat/sub')
var ratSign = require('big-rat/sign')
var rvSub = require('rat-vec/sub')
var rvAdd = require('rat-vec/add')
var rvMuls = require('rat-vec/muls')

var toFloat = require('big-rat/to-float')

function ratPerp(a, b) {
  return ratSub(ratMul(a[0], b[1]), ratMul(a[1], b[0]))
}

//Solve for intersection
//  x = a + t (b-a)
//  (x - c) ^ (d-c) = 0
//  (t * (b-a) + (a-c) ) ^ (d-c) = 0
//  t * (b-a)^(d-c) = (d-c)^(a-c)
//  t = (d-c)^(a-c) / (b-a)^(d-c)

function solveIntersection(a, b, c, d) {
  var ba = rvSub(b, a)
  var dc = rvSub(d, c)

  var baXdc = ratPerp(ba, dc)

  if(ratSign(baXdc) === 0) {
    return null
  }

  var ac = rvSub(a, c)
  var dcXac = ratPerp(dc, ac)

  var t = ratDiv(dcXac, baXdc)

  return rvAdd(a, rvMuls(ba, t))
}

},{"big-rat/div":31,"big-rat/mul":41,"big-rat/sign":45,"big-rat/sub":46,"big-rat/to-float":47,"rat-vec/add":61,"rat-vec/muls":63,"rat-vec/sub":64}],29:[function(require,module,exports){
'use strict'

var rationalize = require('./lib/rationalize')

module.exports = add

function add(a, b) {
  return rationalize(
    a[0].mul(b[1]).add(b[0].mul(a[1])),
    a[1].mul(b[1]))
}

},{"./lib/rationalize":39}],30:[function(require,module,exports){
'use strict'

module.exports = cmp

function cmp(a, b) {
    return a[0].mul(b[1]).cmp(b[0].mul(a[1]))
}

},{}],31:[function(require,module,exports){
'use strict'

var rationalize = require('./lib/rationalize')

module.exports = div

function div(a, b) {
  return rationalize(a[0].mul(b[1]), a[1].mul(b[0]))
}

},{"./lib/rationalize":39}],32:[function(require,module,exports){
'use strict'

var isRat = require('./is-rat')
var isBN = require('./lib/is-bn')
var num2bn = require('./lib/num-to-bn')
var str2bn = require('./lib/str-to-bn')
var rationalize = require('./lib/rationalize')
var div = require('./div')

module.exports = makeRational

function makeRational(numer, denom) {
  if(isRat(numer)) {
    if(denom) {
      return div(numer, makeRational(denom))
    }
    return [numer[0].clone(), numer[1].clone()]
  }
  var shift = 0
  var a, b
  if(isBN(numer)) {
    a = numer.clone()
  } else if(typeof numer === 'string') {
    a = str2bn(numer)
  } else if(numer === 0) {
    return [num2bn(0), num2bn(1)]
  } else if(numer === Math.floor(numer)) {
    a = num2bn(numer)
  } else {
    while(numer !== Math.floor(numer)) {
      numer = numer * Math.pow(2, 256)
      shift -= 256
    }
    a = num2bn(numer)
  }
  if(isRat(denom)) {
    a.mul(denom[1])
    b = denom[0].clone()
  } else if(isBN(denom)) {
    b = denom.clone()
  } else if(typeof denom === 'string') {
    b = str2bn(denom)
  } else if(!denom) {
    b = num2bn(1)
  } else if(denom === Math.floor(denom)) {
    b = num2bn(denom)
  } else {
    while(denom !== Math.floor(denom)) {
      denom = denom * Math.pow(2, 256)
      shift += 256
    }
    b = num2bn(denom)
  }
  if(shift > 0) {
    a = a.shln(shift)
  } else if(shift < 0) {
    b = b.shln(-shift)
  }
  return rationalize(a, b)
}

},{"./div":31,"./is-rat":33,"./lib/is-bn":37,"./lib/num-to-bn":38,"./lib/rationalize":39,"./lib/str-to-bn":40}],33:[function(require,module,exports){
'use strict'

var isBN = require('./lib/is-bn')

module.exports = isRat

function isRat(x) {
  return Array.isArray(x) && x.length === 2 && isBN(x[0]) && isBN(x[1])
}

},{"./lib/is-bn":37}],34:[function(require,module,exports){
'use strict'

var bn = require('bn.js')

module.exports = sign

function sign(x) {
  return x.cmp(new bn(0))
}

},{"bn.js":43}],35:[function(require,module,exports){
'use strict'

module.exports = bn2num

//TODO: Make this better
function bn2num(b) {
  var l = b.length
  var words = b.words
  var out = 0
  if (l === 1) {
    out = words[0]
  } else if (l === 2) {
    out = words[0] + (words[1] * 0x4000000)
  } else {
    var out = 0
    for (var i = 0; i < l; i++) {
      var w = words[i]
      out += w * Math.pow(0x4000000, i)
    }
  }
  return b.sign ? -out : out
}

},{}],36:[function(require,module,exports){
'use strict'

var db = require('double-bits')
var ctz = require('bit-twiddle').countTrailingZeros

module.exports = ctzNumber

//Counts the number of trailing zeros
function ctzNumber(x) {
  var l = ctz(db.lo(x))
  if(l < 32) {
    return l
  }
  var h = ctz(db.hi(x))
  if(h > 20) {
    return 52
  }
  return h + 32
}

},{"bit-twiddle":42,"double-bits":44}],37:[function(require,module,exports){
'use strict'

var BN = require('bn.js')

module.exports = isBN

//Test if x is a bignumber
//FIXME: obviously this is the wrong way to do it
function isBN(x) {
  return x && typeof x === 'object' && Boolean(x.words)
}

},{"bn.js":43}],38:[function(require,module,exports){
'use strict'

var BN = require('bn.js')
var db = require('double-bits')

module.exports = num2bn

function num2bn(x) {
  var e = db.exponent(x)
  if(e < 52) {
    return new BN(x)
  } else {
    return (new BN(x * Math.pow(2, 52-e))).shln(e-52)
  }
}

},{"bn.js":43,"double-bits":44}],39:[function(require,module,exports){
'use strict'

var num2bn = require('./num-to-bn')
var sign = require('./bn-sign')

module.exports = rationalize

function rationalize(numer, denom) {
  var snumer = sign(numer)
  var sdenom = sign(denom)
  if(snumer === 0) {
    return [num2bn(0), num2bn(1)]
  }
  if(sdenom === 0) {
    return [num2bn(0), num2bn(0)]
  }
  if(sdenom < 0) {
    numer = numer.neg()
    denom = denom.neg()
  }
  var d = numer.gcd(denom)
  if(d.cmpn(1)) {
    return [ numer.div(d), denom.div(d) ]
  }
  return [ numer, denom ]
}

},{"./bn-sign":34,"./num-to-bn":38}],40:[function(require,module,exports){
'use strict'

var BN = require('bn.js')

module.exports = str2BN

function str2BN(x) {
  return new BN(x)
}

},{"bn.js":43}],41:[function(require,module,exports){
'use strict'

var rationalize = require('./lib/rationalize')

module.exports = mul

function mul(a, b) {
  return rationalize(a[0].mul(b[0]), a[1].mul(b[1]))
}

},{"./lib/rationalize":39}],42:[function(require,module,exports){
/**
 * Bit twiddling hacks for JavaScript.
 *
 * Author: Mikola Lysenko
 *
 * Ported from Stanford bit twiddling hack library:
 *    http://graphics.stanford.edu/~seander/bithacks.html
 */

"use strict"; "use restrict";

//Number of bits in an integer
var INT_BITS = 32;

//Constants
exports.INT_BITS  = INT_BITS;
exports.INT_MAX   =  0x7fffffff;
exports.INT_MIN   = -1<<(INT_BITS-1);

//Returns -1, 0, +1 depending on sign of x
exports.sign = function(v) {
  return (v > 0) - (v < 0);
}

//Computes absolute value of integer
exports.abs = function(v) {
  var mask = v >> (INT_BITS-1);
  return (v ^ mask) - mask;
}

//Computes minimum of integers x and y
exports.min = function(x, y) {
  return y ^ ((x ^ y) & -(x < y));
}

//Computes maximum of integers x and y
exports.max = function(x, y) {
  return x ^ ((x ^ y) & -(x < y));
}

//Checks if a number is a power of two
exports.isPow2 = function(v) {
  return !(v & (v-1)) && (!!v);
}

//Computes log base 2 of v
exports.log2 = function(v) {
  var r, shift;
  r =     (v > 0xFFFF) << 4; v >>>= r;
  shift = (v > 0xFF  ) << 3; v >>>= shift; r |= shift;
  shift = (v > 0xF   ) << 2; v >>>= shift; r |= shift;
  shift = (v > 0x3   ) << 1; v >>>= shift; r |= shift;
  return r | (v >> 1);
}

//Computes log base 10 of v
exports.log10 = function(v) {
  return  (v >= 1000000000) ? 9 : (v >= 100000000) ? 8 : (v >= 10000000) ? 7 :
          (v >= 1000000) ? 6 : (v >= 100000) ? 5 : (v >= 10000) ? 4 :
          (v >= 1000) ? 3 : (v >= 100) ? 2 : (v >= 10) ? 1 : 0;
}

//Counts number of bits
exports.popCount = function(v) {
  v = v - ((v >>> 1) & 0x55555555);
  v = (v & 0x33333333) + ((v >>> 2) & 0x33333333);
  return ((v + (v >>> 4) & 0xF0F0F0F) * 0x1010101) >>> 24;
}

//Counts number of trailing zeros
function countTrailingZeros(v) {
  var c = 32;
  v &= -v;
  if (v) c--;
  if (v & 0x0000FFFF) c -= 16;
  if (v & 0x00FF00FF) c -= 8;
  if (v & 0x0F0F0F0F) c -= 4;
  if (v & 0x33333333) c -= 2;
  if (v & 0x55555555) c -= 1;
  return c;
}
exports.countTrailingZeros = countTrailingZeros;

//Rounds to next power of 2
exports.nextPow2 = function(v) {
  v += v === 0;
  --v;
  v |= v >>> 1;
  v |= v >>> 2;
  v |= v >>> 4;
  v |= v >>> 8;
  v |= v >>> 16;
  return v + 1;
}

//Rounds down to previous power of 2
exports.prevPow2 = function(v) {
  v |= v >>> 1;
  v |= v >>> 2;
  v |= v >>> 4;
  v |= v >>> 8;
  v |= v >>> 16;
  return v - (v>>>1);
}

//Computes parity of word
exports.parity = function(v) {
  v ^= v >>> 16;
  v ^= v >>> 8;
  v ^= v >>> 4;
  v &= 0xf;
  return (0x6996 >>> v) & 1;
}

var REVERSE_TABLE = new Array(256);

(function(tab) {
  for(var i=0; i<256; ++i) {
    var v = i, r = i, s = 7;
    for (v >>>= 1; v; v >>>= 1) {
      r <<= 1;
      r |= v & 1;
      --s;
    }
    tab[i] = (r << s) & 0xff;
  }
})(REVERSE_TABLE);

//Reverse bits in a 32 bit word
exports.reverse = function(v) {
  return  (REVERSE_TABLE[ v         & 0xff] << 24) |
          (REVERSE_TABLE[(v >>> 8)  & 0xff] << 16) |
          (REVERSE_TABLE[(v >>> 16) & 0xff] << 8)  |
           REVERSE_TABLE[(v >>> 24) & 0xff];
}

//Interleave bits of 2 coordinates with 16 bits.  Useful for fast quadtree codes
exports.interleave2 = function(x, y) {
  x &= 0xFFFF;
  x = (x | (x << 8)) & 0x00FF00FF;
  x = (x | (x << 4)) & 0x0F0F0F0F;
  x = (x | (x << 2)) & 0x33333333;
  x = (x | (x << 1)) & 0x55555555;

  y &= 0xFFFF;
  y = (y | (y << 8)) & 0x00FF00FF;
  y = (y | (y << 4)) & 0x0F0F0F0F;
  y = (y | (y << 2)) & 0x33333333;
  y = (y | (y << 1)) & 0x55555555;

  return x | (y << 1);
}

//Extracts the nth interleaved component
exports.deinterleave2 = function(v, n) {
  v = (v >>> n) & 0x55555555;
  v = (v | (v >>> 1))  & 0x33333333;
  v = (v | (v >>> 2))  & 0x0F0F0F0F;
  v = (v | (v >>> 4))  & 0x00FF00FF;
  v = (v | (v >>> 16)) & 0x000FFFF;
  return (v << 16) >> 16;
}


//Interleave bits of 3 coordinates, each with 10 bits.  Useful for fast octree codes
exports.interleave3 = function(x, y, z) {
  x &= 0x3FF;
  x  = (x | (x<<16)) & 4278190335;
  x  = (x | (x<<8))  & 251719695;
  x  = (x | (x<<4))  & 3272356035;
  x  = (x | (x<<2))  & 1227133513;

  y &= 0x3FF;
  y  = (y | (y<<16)) & 4278190335;
  y  = (y | (y<<8))  & 251719695;
  y  = (y | (y<<4))  & 3272356035;
  y  = (y | (y<<2))  & 1227133513;
  x |= (y << 1);
  
  z &= 0x3FF;
  z  = (z | (z<<16)) & 4278190335;
  z  = (z | (z<<8))  & 251719695;
  z  = (z | (z<<4))  & 3272356035;
  z  = (z | (z<<2))  & 1227133513;
  
  return x | (z << 2);
}

//Extracts nth interleaved component of a 3-tuple
exports.deinterleave3 = function(v, n) {
  v = (v >>> n)       & 1227133513;
  v = (v | (v>>>2))   & 3272356035;
  v = (v | (v>>>4))   & 251719695;
  v = (v | (v>>>8))   & 4278190335;
  v = (v | (v>>>16))  & 0x3FF;
  return (v<<22)>>22;
}

//Computes next combination in colexicographic order (this is mistakenly called nextPermutation on the bit twiddling hacks page)
exports.nextCombination = function(v) {
  var t = v | (v - 1);
  return (t + 1) | (((~t & -~t) - 1) >>> (countTrailingZeros(v) + 1));
}


},{}],43:[function(require,module,exports){
(function (module, exports) {

'use strict';

// Utils

function assert(val, msg) {
  if (!val)
    throw new Error(msg || 'Assertion failed');
}

// Could use `inherits` module, but don't want to move from single file
// architecture yet.
function inherits(ctor, superCtor) {
  ctor.super_ = superCtor;
  var TempCtor = function () {};
  TempCtor.prototype = superCtor.prototype;
  ctor.prototype = new TempCtor();
  ctor.prototype.constructor = ctor;
}

// BN

function BN(number, base, endian) {
  // May be `new BN(bn)` ?
  if (number !== null &&
      typeof number === 'object' &&
      Array.isArray(number.words)) {
    return number;
  }

  this.sign = false;
  this.words = null;
  this.length = 0;

  // Reduction context
  this.red = null;

  if (base === 'le' || base === 'be') {
    endian = base;
    base = 10;
  }

  if (number !== null)
    this._init(number || 0, base || 10, endian || 'be');
}
if (typeof module === 'object')
  module.exports = BN;
else
  exports.BN = BN;

BN.BN = BN;
BN.wordSize = 26;

BN.prototype._init = function init(number, base, endian) {
  if (typeof number === 'number') {
    return this._initNumber(number, base, endian);
  } else if (typeof number === 'object') {
    return this._initArray(number, base, endian);
  }
  if (base === 'hex')
    base = 16;
  assert(base === (base | 0) && base >= 2 && base <= 36);

  number = number.toString().replace(/\s+/g, '');
  var start = 0;
  if (number[0] === '-')
    start++;

  if (base === 16)
    this._parseHex(number, start);
  else
    this._parseBase(number, base, start);

  if (number[0] === '-')
    this.sign = true;

  this.strip();

  if (endian !== 'le')
    return;

  this._initArray(this.toArray(), base, endian);
};

BN.prototype._initNumber = function _initNumber(number, base, endian) {
  if (number < 0) {
    this.sign = true;
    number = -number;
  }
  if (number < 0x4000000) {
    this.words = [ number & 0x3ffffff ];
    this.length = 1;
  } else if (number < 0x10000000000000) {
    this.words = [
      number & 0x3ffffff,
      (number / 0x4000000) & 0x3ffffff
    ];
    this.length = 2;
  } else {
    assert(number < 0x20000000000000); // 2 ^ 53 (unsafe)
    this.words = [
      number & 0x3ffffff,
      (number / 0x4000000) & 0x3ffffff,
      1
    ];
    this.length = 3;
  }

  if (endian !== 'le')
    return;

  // Reverse the bytes
  this._initArray(this.toArray(), base, endian);
};

BN.prototype._initArray = function _initArray(number, base, endian) {
  // Perhaps a Uint8Array
  assert(typeof number.length === 'number');
  if (number.length <= 0) {
    this.words = [ 0 ];
    this.length = 1;
    return this;
  }

  this.length = Math.ceil(number.length / 3);
  this.words = new Array(this.length);
  for (var i = 0; i < this.length; i++)
    this.words[i] = 0;

  var off = 0;
  if (endian === 'be') {
    for (var i = number.length - 1, j = 0; i >= 0; i -= 3) {
      var w = number[i] | (number[i - 1] << 8) | (number[i - 2] << 16);
      this.words[j] |= (w << off) & 0x3ffffff;
      this.words[j + 1] = (w >>> (26 - off)) & 0x3ffffff;
      off += 24;
      if (off >= 26) {
        off -= 26;
        j++;
      }
    }
  } else if (endian === 'le') {
    for (var i = 0, j = 0; i < number.length; i += 3) {
      var w = number[i] | (number[i + 1] << 8) | (number[i + 2] << 16);
      this.words[j] |= (w << off) & 0x3ffffff;
      this.words[j + 1] = (w >>> (26 - off)) & 0x3ffffff;
      off += 24;
      if (off >= 26) {
        off -= 26;
        j++;
      }
    }
  }
  return this.strip();
};

function parseHex(str, start, end) {
  var r = 0;
  var len = Math.min(str.length, end);
  for (var i = start; i < len; i++) {
    var c = str.charCodeAt(i) - 48;

    r <<= 4;

    // 'a' - 'f'
    if (c >= 49 && c <= 54)
      r |= c - 49 + 0xa;

    // 'A' - 'F'
    else if (c >= 17 && c <= 22)
      r |= c - 17 + 0xa;

    // '0' - '9'
    else
      r |= c & 0xf;
  }
  return r;
}

BN.prototype._parseHex = function _parseHex(number, start) {
  // Create possibly bigger array to ensure that it fits the number
  this.length = Math.ceil((number.length - start) / 6);
  this.words = new Array(this.length);
  for (var i = 0; i < this.length; i++)
    this.words[i] = 0;

  // Scan 24-bit chunks and add them to the number
  var off = 0;
  for (var i = number.length - 6, j = 0; i >= start; i -= 6) {
    var w = parseHex(number, i, i + 6);
    this.words[j] |= (w << off) & 0x3ffffff;
    this.words[j + 1] |= w >>> (26 - off) & 0x3fffff;
    off += 24;
    if (off >= 26) {
      off -= 26;
      j++;
    }
  }
  if (i + 6 !== start) {
    var w = parseHex(number, start, i + 6);
    this.words[j] |= (w << off) & 0x3ffffff;
    this.words[j + 1] |= w >>> (26 - off) & 0x3fffff;
  }
  this.strip();
};

function parseBase(str, start, end, mul) {
  var r = 0;
  var len = Math.min(str.length, end);
  for (var i = start; i < len; i++) {
    var c = str.charCodeAt(i) - 48;

    r *= mul;

    // 'a'
    if (c >= 49)
      r += c - 49 + 0xa;

    // 'A'
    else if (c >= 17)
      r += c - 17 + 0xa;

    // '0' - '9'
    else
      r += c;
  }
  return r;
}

BN.prototype._parseBase = function _parseBase(number, base, start) {
  // Initialize as zero
  this.words = [ 0 ];
  this.length = 1;

  // Find length of limb in base
  for (var limbLen = 0, limbPow = 1; limbPow <= 0x3ffffff; limbPow *= base)
    limbLen++;
  limbLen--;
  limbPow = (limbPow / base) | 0;

  var total = number.length - start;
  var mod = total % limbLen;
  var end = Math.min(total, total - mod) + start;

  var word = 0;
  for (var i = start; i < end; i += limbLen) {
    word = parseBase(number, i, i + limbLen, base);

    this.imuln(limbPow);
    if (this.words[0] + word < 0x4000000)
      this.words[0] += word;
    else
      this._iaddn(word);
  }

  if (mod !== 0) {
    var pow = 1;
    var word = parseBase(number, i, number.length, base);

    for (var i = 0; i < mod; i++)
      pow *= base;
    this.imuln(pow);
    if (this.words[0] + word < 0x4000000)
      this.words[0] += word;
    else
      this._iaddn(word);
  }
};

BN.prototype.copy = function copy(dest) {
  dest.words = new Array(this.length);
  for (var i = 0; i < this.length; i++)
    dest.words[i] = this.words[i];
  dest.length = this.length;
  dest.sign = this.sign;
  dest.red = this.red;
};

BN.prototype.clone = function clone() {
  var r = new BN(null);
  this.copy(r);
  return r;
};

// Remove leading `0` from `this`
BN.prototype.strip = function strip() {
  while (this.length > 1 && this.words[this.length - 1] === 0)
    this.length--;
  return this._normSign();
};

BN.prototype._normSign = function _normSign() {
  // -0 = 0
  if (this.length === 1 && this.words[0] === 0)
    this.sign = false;
  return this;
};

BN.prototype.inspect = function inspect() {
  return (this.red ? '<BN-R: ' : '<BN: ') + this.toString(16) + '>';
};

/*

var zeros = [];
var groupSizes = [];
var groupBases = [];

var s = '';
var i = -1;
while (++i < BN.wordSize) {
  zeros[i] = s;
  s += '0';
}
groupSizes[0] = 0;
groupSizes[1] = 0;
groupBases[0] = 0;
groupBases[1] = 0;
var base = 2 - 1;
while (++base < 36 + 1) {
  var groupSize = 0;
  var groupBase = 1;
  while (groupBase < (1 << BN.wordSize) / base) {
    groupBase *= base;
    groupSize += 1;
  }
  groupSizes[base] = groupSize;
  groupBases[base] = groupBase;
}

*/

var zeros = [
  '',
  '0',
  '00',
  '000',
  '0000',
  '00000',
  '000000',
  '0000000',
  '00000000',
  '000000000',
  '0000000000',
  '00000000000',
  '000000000000',
  '0000000000000',
  '00000000000000',
  '000000000000000',
  '0000000000000000',
  '00000000000000000',
  '000000000000000000',
  '0000000000000000000',
  '00000000000000000000',
  '000000000000000000000',
  '0000000000000000000000',
  '00000000000000000000000',
  '000000000000000000000000',
  '0000000000000000000000000'
];

var groupSizes = [
  0, 0,
  25, 16, 12, 11, 10, 9, 8,
  8, 7, 7, 7, 7, 6, 6,
  6, 6, 6, 6, 6, 5, 5,
  5, 5, 5, 5, 5, 5, 5,
  5, 5, 5, 5, 5, 5, 5
];

var groupBases = [
  0, 0,
  33554432, 43046721, 16777216, 48828125, 60466176, 40353607, 16777216,
  43046721, 10000000, 19487171, 35831808, 62748517, 7529536, 11390625,
  16777216, 24137569, 34012224, 47045881, 64000000, 4084101, 5153632,
  6436343, 7962624, 9765625, 11881376, 14348907, 17210368, 20511149,
  24300000, 28629151, 33554432, 39135393, 45435424, 52521875, 60466176
];

BN.prototype.toString = function toString(base, padding) {
  base = base || 10;
  if (base === 16 || base === 'hex') {
    var out = '';
    var off = 0;
    var padding = padding | 0 || 1;
    var carry = 0;
    for (var i = 0; i < this.length; i++) {
      var w = this.words[i];
      var word = (((w << off) | carry) & 0xffffff).toString(16);
      carry = (w >>> (24 - off)) & 0xffffff;
      if (carry !== 0 || i !== this.length - 1)
        out = zeros[6 - word.length] + word + out;
      else
        out = word + out;
      off += 2;
      if (off >= 26) {
        off -= 26;
        i--;
      }
    }
    if (carry !== 0)
      out = carry.toString(16) + out;
    while (out.length % padding !== 0)
      out = '0' + out;
    if (this.sign)
      out = '-' + out;
    return out;
  } else if (base === (base | 0) && base >= 2 && base <= 36) {
    // var groupSize = Math.floor(BN.wordSize * Math.LN2 / Math.log(base));
    var groupSize = groupSizes[base];
    // var groupBase = Math.pow(base, groupSize);
    var groupBase = groupBases[base];
    var out = '';
    var c = this.clone();
    c.sign = false;
    while (c.cmpn(0) !== 0) {
      var r = c.modn(groupBase).toString(base);
      c = c.idivn(groupBase);

      if (c.cmpn(0) !== 0)
        out = zeros[groupSize - r.length] + r + out;
      else
        out = r + out;
    }
    if (this.cmpn(0) === 0)
      out = '0' + out;
    if (this.sign)
      out = '-' + out;
    return out;
  } else {
    assert(false, 'Base should be between 2 and 36');
  }
};

BN.prototype.toJSON = function toJSON() {
  return this.toString(16);
};

BN.prototype.toArray = function toArray(endian) {
  this.strip();
  var res = new Array(this.byteLength());
  res[0] = 0;

  var q = this.clone();
  if (endian !== 'le') {
    // Assume big-endian
    for (var i = 0; q.cmpn(0) !== 0; i++) {
      var b = q.andln(0xff);
      q.ishrn(8);

      res[res.length - i - 1] = b;
    }
  } else {
    // Assume little-endian
    for (var i = 0; q.cmpn(0) !== 0; i++) {
      var b = q.andln(0xff);
      q.ishrn(8);

      res[i] = b;
    }
  }

  return res;
};

if (Math.clz32) {
  BN.prototype._countBits = function _countBits(w) {
    return 32 - Math.clz32(w);
  };
} else {
  BN.prototype._countBits = function _countBits(w) {
    var t = w;
    var r = 0;
    if (t >= 0x1000) {
      r += 13;
      t >>>= 13;
    }
    if (t >= 0x40) {
      r += 7;
      t >>>= 7;
    }
    if (t >= 0x8) {
      r += 4;
      t >>>= 4;
    }
    if (t >= 0x02) {
      r += 2;
      t >>>= 2;
    }
    return r + t;
  };
}

BN.prototype._zeroBits = function _zeroBits(w) {
  // Short-cut
  if (w === 0)
    return 26;

  var t = w;
  var r = 0;
  if ((t & 0x1fff) === 0) {
    r += 13;
    t >>>= 13;
  }
  if ((t & 0x7f) === 0) {
    r += 7;
    t >>>= 7;
  }
  if ((t & 0xf) === 0) {
    r += 4;
    t >>>= 4;
  }
  if ((t & 0x3) === 0) {
    r += 2;
    t >>>= 2;
  }
  if ((t & 0x1) === 0)
    r++;
  return r;
};

// Return number of used bits in a BN
BN.prototype.bitLength = function bitLength() {
  var hi = 0;
  var w = this.words[this.length - 1];
  var hi = this._countBits(w);
  return (this.length - 1) * 26 + hi;
};

// Number of trailing zero bits
BN.prototype.zeroBits = function zeroBits() {
  if (this.cmpn(0) === 0)
    return 0;

  var r = 0;
  for (var i = 0; i < this.length; i++) {
    var b = this._zeroBits(this.words[i]);
    r += b;
    if (b !== 26)
      break;
  }
  return r;
};

BN.prototype.byteLength = function byteLength() {
  return Math.ceil(this.bitLength() / 8);
};

// Return negative clone of `this`
BN.prototype.neg = function neg() {
  if (this.cmpn(0) === 0)
    return this.clone();

  var r = this.clone();
  r.sign = !this.sign;
  return r;
};


// Or `num` with `this` in-place
BN.prototype.ior = function ior(num) {
  this.sign = this.sign || num.sign;

  while (this.length < num.length)
    this.words[this.length++] = 0;

  for (var i = 0; i < num.length; i++)
    this.words[i] = this.words[i] | num.words[i];

  return this.strip();
};


// Or `num` with `this`
BN.prototype.or = function or(num) {
  if (this.length > num.length)
    return this.clone().ior(num);
  else
    return num.clone().ior(this);
};


// And `num` with `this` in-place
BN.prototype.iand = function iand(num) {
  this.sign = this.sign && num.sign;

  // b = min-length(num, this)
  var b;
  if (this.length > num.length)
    b = num;
  else
    b = this;

  for (var i = 0; i < b.length; i++)
    this.words[i] = this.words[i] & num.words[i];

  this.length = b.length;

  return this.strip();
};


// And `num` with `this`
BN.prototype.and = function and(num) {
  if (this.length > num.length)
    return this.clone().iand(num);
  else
    return num.clone().iand(this);
};


// Xor `num` with `this` in-place
BN.prototype.ixor = function ixor(num) {
  this.sign = this.sign || num.sign;

  // a.length > b.length
  var a;
  var b;
  if (this.length > num.length) {
    a = this;
    b = num;
  } else {
    a = num;
    b = this;
  }

  for (var i = 0; i < b.length; i++)
    this.words[i] = a.words[i] ^ b.words[i];

  if (this !== a)
    for (; i < a.length; i++)
      this.words[i] = a.words[i];

  this.length = a.length;

  return this.strip();
};


// Xor `num` with `this`
BN.prototype.xor = function xor(num) {
  if (this.length > num.length)
    return this.clone().ixor(num);
  else
    return num.clone().ixor(this);
};


// Set `bit` of `this`
BN.prototype.setn = function setn(bit, val) {
  assert(typeof bit === 'number' && bit >= 0);

  var off = (bit / 26) | 0;
  var wbit = bit % 26;

  while (this.length <= off)
    this.words[this.length++] = 0;

  if (val)
    this.words[off] = this.words[off] | (1 << wbit);
  else
    this.words[off] = this.words[off] & ~(1 << wbit);

  return this.strip();
};


// Add `num` to `this` in-place
BN.prototype.iadd = function iadd(num) {
  // negative + positive
  if (this.sign && !num.sign) {
    this.sign = false;
    var r = this.isub(num);
    this.sign = !this.sign;
    return this._normSign();

  // positive + negative
  } else if (!this.sign && num.sign) {
    num.sign = false;
    var r = this.isub(num);
    num.sign = true;
    return r._normSign();
  }

  // a.length > b.length
  var a;
  var b;
  if (this.length > num.length) {
    a = this;
    b = num;
  } else {
    a = num;
    b = this;
  }

  var carry = 0;
  for (var i = 0; i < b.length; i++) {
    var r = a.words[i] + b.words[i] + carry;
    this.words[i] = r & 0x3ffffff;
    carry = r >>> 26;
  }
  for (; carry !== 0 && i < a.length; i++) {
    var r = a.words[i] + carry;
    this.words[i] = r & 0x3ffffff;
    carry = r >>> 26;
  }

  this.length = a.length;
  if (carry !== 0) {
    this.words[this.length] = carry;
    this.length++;
  // Copy the rest of the words
  } else if (a !== this) {
    for (; i < a.length; i++)
      this.words[i] = a.words[i];
  }

  return this;
};

// Add `num` to `this`
BN.prototype.add = function add(num) {
  if (num.sign && !this.sign) {
    num.sign = false;
    var res = this.sub(num);
    num.sign = true;
    return res;
  } else if (!num.sign && this.sign) {
    this.sign = false;
    var res = num.sub(this);
    this.sign = true;
    return res;
  }

  if (this.length > num.length)
    return this.clone().iadd(num);
  else
    return num.clone().iadd(this);
};

// Subtract `num` from `this` in-place
BN.prototype.isub = function isub(num) {
  // this - (-num) = this + num
  if (num.sign) {
    num.sign = false;
    var r = this.iadd(num);
    num.sign = true;
    return r._normSign();

  // -this - num = -(this + num)
  } else if (this.sign) {
    this.sign = false;
    this.iadd(num);
    this.sign = true;
    return this._normSign();
  }

  // At this point both numbers are positive
  var cmp = this.cmp(num);

  // Optimization - zeroify
  if (cmp === 0) {
    this.sign = false;
    this.length = 1;
    this.words[0] = 0;
    return this;
  }

  // a > b
  var a;
  var b;
  if (cmp > 0) {
    a = this;
    b = num;
  } else {
    a = num;
    b = this;
  }

  var carry = 0;
  for (var i = 0; i < b.length; i++) {
    var r = a.words[i] - b.words[i] + carry;
    carry = r >> 26;
    this.words[i] = r & 0x3ffffff;
  }
  for (; carry !== 0 && i < a.length; i++) {
    var r = a.words[i] + carry;
    carry = r >> 26;
    this.words[i] = r & 0x3ffffff;
  }

  // Copy rest of the words
  if (carry === 0 && i < a.length && a !== this)
    for (; i < a.length; i++)
      this.words[i] = a.words[i];
  this.length = Math.max(this.length, i);

  if (a !== this)
    this.sign = true;

  return this.strip();
};

// Subtract `num` from `this`
BN.prototype.sub = function sub(num) {
  return this.clone().isub(num);
};

/*
// NOTE: This could be potentionally used to generate loop-less multiplications
function _genCombMulTo(alen, blen) {
  var len = alen + blen - 1;
  var src = [
    'var a = this.words, b = num.words, o = out.words, c = 0, w, ' +
        'mask = 0x3ffffff, shift = 0x4000000;',
    'out.length = ' + len + ';'
  ];
  for (var k = 0; k < len; k++) {
    var minJ = Math.max(0, k - alen + 1);
    var maxJ = Math.min(k, blen - 1);

    for (var j = minJ; j <= maxJ; j++) {
      var i = k - j;
      var mul = 'a[' + i + '] * b[' + j + ']';

      if (j === minJ) {
        src.push('w = ' + mul + ' + c;');
        src.push('c = (w / shift) | 0;');
      } else {
        src.push('w += ' + mul + ';');
        src.push('c += (w / shift) | 0;');
      }
      src.push('w &= mask;');
    }
    src.push('o[' + k + '] = w;');
  }
  src.push('if (c !== 0) {',
           '  o[' + k + '] = c;',
           '  out.length++;',
           '}',
           'return out;');

  return src.join('\n');
}
*/

BN.prototype._smallMulTo = function _smallMulTo(num, out) {
  out.sign = num.sign !== this.sign;
  out.length = this.length + num.length;

  var carry = 0;
  for (var k = 0; k < out.length - 1; k++) {
    // Sum all words with the same `i + j = k` and accumulate `ncarry`,
    // note that ncarry could be >= 0x3ffffff
    var ncarry = carry >>> 26;
    var rword = carry & 0x3ffffff;
    var maxJ = Math.min(k, num.length - 1);
    for (var j = Math.max(0, k - this.length + 1); j <= maxJ; j++) {
      var i = k - j;
      var a = this.words[i] | 0;
      var b = num.words[j] | 0;
      var r = a * b;

      var lo = r & 0x3ffffff;
      ncarry = (ncarry + ((r / 0x4000000) | 0)) | 0;
      lo = (lo + rword) | 0;
      rword = lo & 0x3ffffff;
      ncarry = (ncarry + (lo >>> 26)) | 0;
    }
    out.words[k] = rword;
    carry = ncarry;
  }
  if (carry !== 0) {
    out.words[k] = carry;
  } else {
    out.length--;
  }

  return out.strip();
};

BN.prototype._bigMulTo = function _bigMulTo(num, out) {
  out.sign = num.sign !== this.sign;
  out.length = this.length + num.length;

  var carry = 0;
  var hncarry = 0;
  for (var k = 0; k < out.length - 1; k++) {
    // Sum all words with the same `i + j = k` and accumulate `ncarry`,
    // note that ncarry could be >= 0x3ffffff
    var ncarry = hncarry;
    hncarry = 0;
    var rword = carry & 0x3ffffff;
    var maxJ = Math.min(k, num.length - 1);
    for (var j = Math.max(0, k - this.length + 1); j <= maxJ; j++) {
      var i = k - j;
      var a = this.words[i] | 0;
      var b = num.words[j] | 0;
      var r = a * b;

      var lo = r & 0x3ffffff;
      ncarry = (ncarry + ((r / 0x4000000) | 0)) | 0;
      lo = (lo + rword) | 0;
      rword = lo & 0x3ffffff;
      ncarry = (ncarry + (lo >>> 26)) | 0;

      hncarry += ncarry >>> 26;
      ncarry &= 0x3ffffff;
    }
    out.words[k] = rword;
    carry = ncarry;
    ncarry = hncarry;
  }
  if (carry !== 0) {
    out.words[k] = carry;
  } else {
    out.length--;
  }

  return out.strip();
};

BN.prototype.mulTo = function mulTo(num, out) {
  var res;
  if (this.length + num.length < 63)
    res = this._smallMulTo(num, out);
  else
    res = this._bigMulTo(num, out);
  return res;
};

// Multiply `this` by `num`
BN.prototype.mul = function mul(num) {
  var out = new BN(null);
  out.words = new Array(this.length + num.length);
  return this.mulTo(num, out);
};

// In-place Multiplication
BN.prototype.imul = function imul(num) {
  if (this.cmpn(0) === 0 || num.cmpn(0) === 0) {
    this.words[0] = 0;
    this.length = 1;
    return this;
  }

  var tlen = this.length;
  var nlen = num.length;

  this.sign = num.sign !== this.sign;
  this.length = this.length + num.length;
  this.words[this.length - 1] = 0;

  for (var k = this.length - 2; k >= 0; k--) {
    // Sum all words with the same `i + j = k` and accumulate `carry`,
    // note that carry could be >= 0x3ffffff
    var carry = 0;
    var rword = 0;
    var maxJ = Math.min(k, nlen - 1);
    for (var j = Math.max(0, k - tlen + 1); j <= maxJ; j++) {
      var i = k - j;
      var a = this.words[i];
      var b = num.words[j];
      var r = a * b;

      var lo = r & 0x3ffffff;
      carry += (r / 0x4000000) | 0;
      lo += rword;
      rword = lo & 0x3ffffff;
      carry += lo >>> 26;
    }
    this.words[k] = rword;
    this.words[k + 1] += carry;
    carry = 0;
  }

  // Propagate overflows
  var carry = 0;
  for (var i = 1; i < this.length; i++) {
    var w = this.words[i] + carry;
    this.words[i] = w & 0x3ffffff;
    carry = w >>> 26;
  }

  return this.strip();
};

BN.prototype.imuln = function imuln(num) {
  assert(typeof num === 'number');

  // Carry
  var carry = 0;
  for (var i = 0; i < this.length; i++) {
    var w = this.words[i] * num;
    var lo = (w & 0x3ffffff) + (carry & 0x3ffffff);
    carry >>= 26;
    carry += (w / 0x4000000) | 0;
    // NOTE: lo is 27bit maximum
    carry += lo >>> 26;
    this.words[i] = lo & 0x3ffffff;
  }

  if (carry !== 0) {
    this.words[i] = carry;
    this.length++;
  }

  return this;
};

BN.prototype.muln = function muln(num) {
  return this.clone().imuln(num);
};

// `this` * `this`
BN.prototype.sqr = function sqr() {
  return this.mul(this);
};

// `this` * `this` in-place
BN.prototype.isqr = function isqr() {
  return this.mul(this);
};

// Shift-left in-place
BN.prototype.ishln = function ishln(bits) {
  assert(typeof bits === 'number' && bits >= 0);
  var r = bits % 26;
  var s = (bits - r) / 26;
  var carryMask = (0x3ffffff >>> (26 - r)) << (26 - r);

  if (r !== 0) {
    var carry = 0;
    for (var i = 0; i < this.length; i++) {
      var newCarry = this.words[i] & carryMask;
      var c = (this.words[i] - newCarry) << r;
      this.words[i] = c | carry;
      carry = newCarry >>> (26 - r);
    }
    if (carry) {
      this.words[i] = carry;
      this.length++;
    }
  }

  if (s !== 0) {
    for (var i = this.length - 1; i >= 0; i--)
      this.words[i + s] = this.words[i];
    for (var i = 0; i < s; i++)
      this.words[i] = 0;
    this.length += s;
  }

  return this.strip();
};

// Shift-right in-place
// NOTE: `hint` is a lowest bit before trailing zeroes
// NOTE: if `extended` is present - it will be filled with destroyed bits
BN.prototype.ishrn = function ishrn(bits, hint, extended) {
  assert(typeof bits === 'number' && bits >= 0);
  var h;
  if (hint)
    h = (hint - (hint % 26)) / 26;
  else
    h = 0;

  var r = bits % 26;
  var s = Math.min((bits - r) / 26, this.length);
  var mask = 0x3ffffff ^ ((0x3ffffff >>> r) << r);
  var maskedWords = extended;

  h -= s;
  h = Math.max(0, h);

  // Extended mode, copy masked part
  if (maskedWords) {
    for (var i = 0; i < s; i++)
      maskedWords.words[i] = this.words[i];
    maskedWords.length = s;
  }

  if (s === 0) {
    // No-op, we should not move anything at all
  } else if (this.length > s) {
    this.length -= s;
    for (var i = 0; i < this.length; i++)
      this.words[i] = this.words[i + s];
  } else {
    this.words[0] = 0;
    this.length = 1;
  }

  var carry = 0;
  for (var i = this.length - 1; i >= 0 && (carry !== 0 || i >= h); i--) {
    var word = this.words[i];
    this.words[i] = (carry << (26 - r)) | (word >>> r);
    carry = word & mask;
  }

  // Push carried bits as a mask
  if (maskedWords && carry !== 0)
    maskedWords.words[maskedWords.length++] = carry;

  if (this.length === 0) {
    this.words[0] = 0;
    this.length = 1;
  }

  this.strip();

  return this;
};

// Shift-left
BN.prototype.shln = function shln(bits) {
  return this.clone().ishln(bits);
};

// Shift-right
BN.prototype.shrn = function shrn(bits) {
  return this.clone().ishrn(bits);
};

// Test if n bit is set
BN.prototype.testn = function testn(bit) {
  assert(typeof bit === 'number' && bit >= 0);
  var r = bit % 26;
  var s = (bit - r) / 26;
  var q = 1 << r;

  // Fast case: bit is much higher than all existing words
  if (this.length <= s) {
    return false;
  }

  // Check bit and return
  var w = this.words[s];

  return !!(w & q);
};

// Return only lowers bits of number (in-place)
BN.prototype.imaskn = function imaskn(bits) {
  assert(typeof bits === 'number' && bits >= 0);
  var r = bits % 26;
  var s = (bits - r) / 26;

  assert(!this.sign, 'imaskn works only with positive numbers');

  if (r !== 0)
    s++;
  this.length = Math.min(s, this.length);

  if (r !== 0) {
    var mask = 0x3ffffff ^ ((0x3ffffff >>> r) << r);
    this.words[this.length - 1] &= mask;
  }

  return this.strip();
};

// Return only lowers bits of number
BN.prototype.maskn = function maskn(bits) {
  return this.clone().imaskn(bits);
};

// Add plain number `num` to `this`
BN.prototype.iaddn = function iaddn(num) {
  assert(typeof num === 'number');
  if (num < 0)
    return this.isubn(-num);

  // Possible sign change
  if (this.sign) {
    if (this.length === 1 && this.words[0] < num) {
      this.words[0] = num - this.words[0];
      this.sign = false;
      return this;
    }

    this.sign = false;
    this.isubn(num);
    this.sign = true;
    return this;
  }

  // Add without checks
  return this._iaddn(num);
};

BN.prototype._iaddn = function _iaddn(num) {
  this.words[0] += num;

  // Carry
  for (var i = 0; i < this.length && this.words[i] >= 0x4000000; i++) {
    this.words[i] -= 0x4000000;
    if (i === this.length - 1)
      this.words[i + 1] = 1;
    else
      this.words[i + 1]++;
  }
  this.length = Math.max(this.length, i + 1);

  return this;
};

// Subtract plain number `num` from `this`
BN.prototype.isubn = function isubn(num) {
  assert(typeof num === 'number');
  if (num < 0)
    return this.iaddn(-num);

  if (this.sign) {
    this.sign = false;
    this.iaddn(num);
    this.sign = true;
    return this;
  }

  this.words[0] -= num;

  // Carry
  for (var i = 0; i < this.length && this.words[i] < 0; i++) {
    this.words[i] += 0x4000000;
    this.words[i + 1] -= 1;
  }

  return this.strip();
};

BN.prototype.addn = function addn(num) {
  return this.clone().iaddn(num);
};

BN.prototype.subn = function subn(num) {
  return this.clone().isubn(num);
};

BN.prototype.iabs = function iabs() {
  this.sign = false;

  return this;
};

BN.prototype.abs = function abs() {
  return this.clone().iabs();
};

BN.prototype._ishlnsubmul = function _ishlnsubmul(num, mul, shift) {
  // Bigger storage is needed
  var len = num.length + shift;
  var i;
  if (this.words.length < len) {
    var t = new Array(len);
    for (var i = 0; i < this.length; i++)
      t[i] = this.words[i];
    this.words = t;
  } else {
    i = this.length;
  }

  // Zeroify rest
  this.length = Math.max(this.length, len);
  for (; i < this.length; i++)
    this.words[i] = 0;

  var carry = 0;
  for (var i = 0; i < num.length; i++) {
    var w = this.words[i + shift] + carry;
    var right = num.words[i] * mul;
    w -= right & 0x3ffffff;
    carry = (w >> 26) - ((right / 0x4000000) | 0);
    this.words[i + shift] = w & 0x3ffffff;
  }
  for (; i < this.length - shift; i++) {
    var w = this.words[i + shift] + carry;
    carry = w >> 26;
    this.words[i + shift] = w & 0x3ffffff;
  }

  if (carry === 0)
    return this.strip();

  // Subtraction overflow
  assert(carry === -1);
  carry = 0;
  for (var i = 0; i < this.length; i++) {
    var w = -this.words[i] + carry;
    carry = w >> 26;
    this.words[i] = w & 0x3ffffff;
  }
  this.sign = true;

  return this.strip();
};

BN.prototype._wordDiv = function _wordDiv(num, mode) {
  var shift = this.length - num.length;

  var a = this.clone();
  var b = num;

  // Normalize
  var bhi = b.words[b.length - 1];
  var bhiBits = this._countBits(bhi);
  shift = 26 - bhiBits;
  if (shift !== 0) {
    b = b.shln(shift);
    a.ishln(shift);
    bhi = b.words[b.length - 1];
  }

  // Initialize quotient
  var m = a.length - b.length;
  var q;

  if (mode !== 'mod') {
    q = new BN(null);
    q.length = m + 1;
    q.words = new Array(q.length);
    for (var i = 0; i < q.length; i++)
      q.words[i] = 0;
  }

  var diff = a.clone()._ishlnsubmul(b, 1, m);
  if (!diff.sign) {
    a = diff;
    if (q)
      q.words[m] = 1;
  }

  for (var j = m - 1; j >= 0; j--) {
    var qj = a.words[b.length + j] * 0x4000000 + a.words[b.length + j - 1];

    // NOTE: (qj / bhi) is (0x3ffffff * 0x4000000 + 0x3ffffff) / 0x2000000 max
    // (0x7ffffff)
    qj = Math.min((qj / bhi) | 0, 0x3ffffff);

    a._ishlnsubmul(b, qj, j);
    while (a.sign) {
      qj--;
      a.sign = false;
      a._ishlnsubmul(b, 1, j);
      if (a.cmpn(0) !== 0)
        a.sign = !a.sign;
    }
    if (q)
      q.words[j] = qj;
  }
  if (q)
    q.strip();
  a.strip();

  // Denormalize
  if (mode !== 'div' && shift !== 0)
    a.ishrn(shift);
  return { div: q ? q : null, mod: a };
};

BN.prototype.divmod = function divmod(num, mode) {
  assert(num.cmpn(0) !== 0);

  if (this.sign && !num.sign) {
    var res = this.neg().divmod(num, mode);
    var div;
    var mod;
    if (mode !== 'mod')
      div = res.div.neg();
    if (mode !== 'div')
      mod = res.mod.cmpn(0) === 0 ? res.mod : num.sub(res.mod);
    return {
      div: div,
      mod: mod
    };
  } else if (!this.sign && num.sign) {
    var res = this.divmod(num.neg(), mode);
    var div;
    if (mode !== 'mod')
      div = res.div.neg();
    return { div: div, mod: res.mod };
  } else if (this.sign && num.sign) {
    return this.neg().divmod(num.neg(), mode);
  }

  // Both numbers are positive at this point

  // Strip both numbers to approximate shift value
  if (num.length > this.length || this.cmp(num) < 0)
    return { div: new BN(0), mod: this };

  // Very short reduction
  if (num.length === 1) {
    if (mode === 'div')
      return { div: this.divn(num.words[0]), mod: null };
    else if (mode === 'mod')
      return { div: null, mod: new BN(this.modn(num.words[0])) };
    return {
      div: this.divn(num.words[0]),
      mod: new BN(this.modn(num.words[0]))
    };
  }

  return this._wordDiv(num, mode);
};

// Find `this` / `num`
BN.prototype.div = function div(num) {
  return this.divmod(num, 'div').div;
};

// Find `this` % `num`
BN.prototype.mod = function mod(num) {
  return this.divmod(num, 'mod').mod;
};

// Find Round(`this` / `num`)
BN.prototype.divRound = function divRound(num) {
  var dm = this.divmod(num);

  // Fast case - exact division
  if (dm.mod.cmpn(0) === 0)
    return dm.div;

  var mod = dm.div.sign ? dm.mod.isub(num) : dm.mod;

  var half = num.shrn(1);
  var r2 = num.andln(1);
  var cmp = mod.cmp(half);

  // Round down
  if (cmp < 0 || r2 === 1 && cmp === 0)
    return dm.div;

  // Round up
  return dm.div.sign ? dm.div.isubn(1) : dm.div.iaddn(1);
};

BN.prototype.modn = function modn(num) {
  assert(num <= 0x3ffffff);
  var p = (1 << 26) % num;

  var acc = 0;
  for (var i = this.length - 1; i >= 0; i--)
    acc = (p * acc + this.words[i]) % num;

  return acc;
};

// In-place division by number
BN.prototype.idivn = function idivn(num) {
  assert(num <= 0x3ffffff);

  var carry = 0;
  for (var i = this.length - 1; i >= 0; i--) {
    var w = this.words[i] + carry * 0x4000000;
    this.words[i] = (w / num) | 0;
    carry = w % num;
  }

  return this.strip();
};

BN.prototype.divn = function divn(num) {
  return this.clone().idivn(num);
};

BN.prototype.egcd = function egcd(p) {
  assert(!p.sign);
  assert(p.cmpn(0) !== 0);

  var x = this;
  var y = p.clone();

  if (x.sign)
    x = x.mod(p);
  else
    x = x.clone();

  // A * x + B * y = x
  var A = new BN(1);
  var B = new BN(0);

  // C * x + D * y = y
  var C = new BN(0);
  var D = new BN(1);

  var g = 0;

  while (x.isEven() && y.isEven()) {
    x.ishrn(1);
    y.ishrn(1);
    ++g;
  }

  var yp = y.clone();
  var xp = x.clone();

  while (x.cmpn(0) !== 0) {
    while (x.isEven()) {
      x.ishrn(1);
      if (A.isEven() && B.isEven()) {
        A.ishrn(1);
        B.ishrn(1);
      } else {
        A.iadd(yp).ishrn(1);
        B.isub(xp).ishrn(1);
      }
    }

    while (y.isEven()) {
      y.ishrn(1);
      if (C.isEven() && D.isEven()) {
        C.ishrn(1);
        D.ishrn(1);
      } else {
        C.iadd(yp).ishrn(1);
        D.isub(xp).ishrn(1);
      }
    }

    if (x.cmp(y) >= 0) {
      x.isub(y);
      A.isub(C);
      B.isub(D);
    } else {
      y.isub(x);
      C.isub(A);
      D.isub(B);
    }
  }

  return {
    a: C,
    b: D,
    gcd: y.ishln(g)
  };
};

// This is reduced incarnation of the binary EEA
// above, designated to invert members of the
// _prime_ fields F(p) at a maximal speed
BN.prototype._invmp = function _invmp(p) {
  assert(!p.sign);
  assert(p.cmpn(0) !== 0);

  var a = this;
  var b = p.clone();

  if (a.sign)
    a = a.mod(p);
  else
    a = a.clone();

  var x1 = new BN(1);
  var x2 = new BN(0);

  var delta = b.clone();

  while (a.cmpn(1) > 0 && b.cmpn(1) > 0) {
    while (a.isEven()) {
      a.ishrn(1);
      if (x1.isEven())
        x1.ishrn(1);
      else
        x1.iadd(delta).ishrn(1);
    }
    while (b.isEven()) {
      b.ishrn(1);
      if (x2.isEven())
        x2.ishrn(1);
      else
        x2.iadd(delta).ishrn(1);
    }
    if (a.cmp(b) >= 0) {
      a.isub(b);
      x1.isub(x2);
    } else {
      b.isub(a);
      x2.isub(x1);
    }
  }
  if (a.cmpn(1) === 0)
    return x1;
  else
    return x2;
};

BN.prototype.gcd = function gcd(num) {
  if (this.cmpn(0) === 0)
    return num.clone();
  if (num.cmpn(0) === 0)
    return this.clone();

  var a = this.clone();
  var b = num.clone();
  a.sign = false;
  b.sign = false;

  // Remove common factor of two
  for (var shift = 0; a.isEven() && b.isEven(); shift++) {
    a.ishrn(1);
    b.ishrn(1);
  }

  do {
    while (a.isEven())
      a.ishrn(1);
    while (b.isEven())
      b.ishrn(1);

    var r = a.cmp(b);
    if (r < 0) {
      // Swap `a` and `b` to make `a` always bigger than `b`
      var t = a;
      a = b;
      b = t;
    } else if (r === 0 || b.cmpn(1) === 0) {
      break;
    }

    a.isub(b);
  } while (true);

  return b.ishln(shift);
};

// Invert number in the field F(num)
BN.prototype.invm = function invm(num) {
  return this.egcd(num).a.mod(num);
};

BN.prototype.isEven = function isEven() {
  return (this.words[0] & 1) === 0;
};

BN.prototype.isOdd = function isOdd() {
  return (this.words[0] & 1) === 1;
};

// And first word and num
BN.prototype.andln = function andln(num) {
  return this.words[0] & num;
};

// Increment at the bit position in-line
BN.prototype.bincn = function bincn(bit) {
  assert(typeof bit === 'number');
  var r = bit % 26;
  var s = (bit - r) / 26;
  var q = 1 << r;

  // Fast case: bit is much higher than all existing words
  if (this.length <= s) {
    for (var i = this.length; i < s + 1; i++)
      this.words[i] = 0;
    this.words[s] |= q;
    this.length = s + 1;
    return this;
  }

  // Add bit and propagate, if needed
  var carry = q;
  for (var i = s; carry !== 0 && i < this.length; i++) {
    var w = this.words[i];
    w += carry;
    carry = w >>> 26;
    w &= 0x3ffffff;
    this.words[i] = w;
  }
  if (carry !== 0) {
    this.words[i] = carry;
    this.length++;
  }
  return this;
};

BN.prototype.cmpn = function cmpn(num) {
  var sign = num < 0;
  if (sign)
    num = -num;

  if (this.sign && !sign)
    return -1;
  else if (!this.sign && sign)
    return 1;

  num &= 0x3ffffff;
  this.strip();

  var res;
  if (this.length > 1) {
    res = 1;
  } else {
    var w = this.words[0];
    res = w === num ? 0 : w < num ? -1 : 1;
  }
  if (this.sign)
    res = -res;
  return res;
};

// Compare two numbers and return:
// 1 - if `this` > `num`
// 0 - if `this` == `num`
// -1 - if `this` < `num`
BN.prototype.cmp = function cmp(num) {
  if (this.sign && !num.sign)
    return -1;
  else if (!this.sign && num.sign)
    return 1;

  var res = this.ucmp(num);
  if (this.sign)
    return -res;
  else
    return res;
};

// Unsigned comparison
BN.prototype.ucmp = function ucmp(num) {
  // At this point both numbers have the same sign
  if (this.length > num.length)
    return 1;
  else if (this.length < num.length)
    return -1;

  var res = 0;
  for (var i = this.length - 1; i >= 0; i--) {
    var a = this.words[i];
    var b = num.words[i];

    if (a === b)
      continue;
    if (a < b)
      res = -1;
    else if (a > b)
      res = 1;
    break;
  }
  return res;
};

//
// A reduce context, could be using montgomery or something better, depending
// on the `m` itself.
//
BN.red = function red(num) {
  return new Red(num);
};

BN.prototype.toRed = function toRed(ctx) {
  assert(!this.red, 'Already a number in reduction context');
  assert(!this.sign, 'red works only with positives');
  return ctx.convertTo(this)._forceRed(ctx);
};

BN.prototype.fromRed = function fromRed() {
  assert(this.red, 'fromRed works only with numbers in reduction context');
  return this.red.convertFrom(this);
};

BN.prototype._forceRed = function _forceRed(ctx) {
  this.red = ctx;
  return this;
};

BN.prototype.forceRed = function forceRed(ctx) {
  assert(!this.red, 'Already a number in reduction context');
  return this._forceRed(ctx);
};

BN.prototype.redAdd = function redAdd(num) {
  assert(this.red, 'redAdd works only with red numbers');
  return this.red.add(this, num);
};

BN.prototype.redIAdd = function redIAdd(num) {
  assert(this.red, 'redIAdd works only with red numbers');
  return this.red.iadd(this, num);
};

BN.prototype.redSub = function redSub(num) {
  assert(this.red, 'redSub works only with red numbers');
  return this.red.sub(this, num);
};

BN.prototype.redISub = function redISub(num) {
  assert(this.red, 'redISub works only with red numbers');
  return this.red.isub(this, num);
};

BN.prototype.redShl = function redShl(num) {
  assert(this.red, 'redShl works only with red numbers');
  return this.red.shl(this, num);
};

BN.prototype.redMul = function redMul(num) {
  assert(this.red, 'redMul works only with red numbers');
  this.red._verify2(this, num);
  return this.red.mul(this, num);
};

BN.prototype.redIMul = function redIMul(num) {
  assert(this.red, 'redMul works only with red numbers');
  this.red._verify2(this, num);
  return this.red.imul(this, num);
};

BN.prototype.redSqr = function redSqr() {
  assert(this.red, 'redSqr works only with red numbers');
  this.red._verify1(this);
  return this.red.sqr(this);
};

BN.prototype.redISqr = function redISqr() {
  assert(this.red, 'redISqr works only with red numbers');
  this.red._verify1(this);
  return this.red.isqr(this);
};

// Square root over p
BN.prototype.redSqrt = function redSqrt() {
  assert(this.red, 'redSqrt works only with red numbers');
  this.red._verify1(this);
  return this.red.sqrt(this);
};

BN.prototype.redInvm = function redInvm() {
  assert(this.red, 'redInvm works only with red numbers');
  this.red._verify1(this);
  return this.red.invm(this);
};

// Return negative clone of `this` % `red modulo`
BN.prototype.redNeg = function redNeg() {
  assert(this.red, 'redNeg works only with red numbers');
  this.red._verify1(this);
  return this.red.neg(this);
};

BN.prototype.redPow = function redPow(num) {
  assert(this.red && !num.red, 'redPow(normalNum)');
  this.red._verify1(this);
  return this.red.pow(this, num);
};

// Prime numbers with efficient reduction
var primes = {
  k256: null,
  p224: null,
  p192: null,
  p25519: null
};

// Pseudo-Mersenne prime
function MPrime(name, p) {
  // P = 2 ^ N - K
  this.name = name;
  this.p = new BN(p, 16);
  this.n = this.p.bitLength();
  this.k = new BN(1).ishln(this.n).isub(this.p);

  this.tmp = this._tmp();
}

MPrime.prototype._tmp = function _tmp() {
  var tmp = new BN(null);
  tmp.words = new Array(Math.ceil(this.n / 13));
  return tmp;
};

MPrime.prototype.ireduce = function ireduce(num) {
  // Assumes that `num` is less than `P^2`
  // num = HI * (2 ^ N - K) + HI * K + LO = HI * K + LO (mod P)
  var r = num;
  var rlen;

  do {
    this.split(r, this.tmp);
    r = this.imulK(r);
    r = r.iadd(this.tmp);
    rlen = r.bitLength();
  } while (rlen > this.n);

  var cmp = rlen < this.n ? -1 : r.ucmp(this.p);
  if (cmp === 0) {
    r.words[0] = 0;
    r.length = 1;
  } else if (cmp > 0) {
    r.isub(this.p);
  } else {
    r.strip();
  }

  return r;
};

MPrime.prototype.split = function split(input, out) {
  input.ishrn(this.n, 0, out);
};

MPrime.prototype.imulK = function imulK(num) {
  return num.imul(this.k);
};

function K256() {
  MPrime.call(
    this,
    'k256',
    'ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe fffffc2f');
}
inherits(K256, MPrime);

K256.prototype.split = function split(input, output) {
  // 256 = 9 * 26 + 22
  var mask = 0x3fffff;

  var outLen = Math.min(input.length, 9);
  for (var i = 0; i < outLen; i++)
    output.words[i] = input.words[i];
  output.length = outLen;

  if (input.length <= 9) {
    input.words[0] = 0;
    input.length = 1;
    return;
  }

  // Shift by 9 limbs
  var prev = input.words[9];
  output.words[output.length++] = prev & mask;

  for (var i = 10; i < input.length; i++) {
    var next = input.words[i];
    input.words[i - 10] = ((next & mask) << 4) | (prev >>> 22);
    prev = next;
  }
  input.words[i - 10] = prev >>> 22;
  input.length -= 9;
};

K256.prototype.imulK = function imulK(num) {
  // K = 0x1000003d1 = [ 0x40, 0x3d1 ]
  num.words[num.length] = 0;
  num.words[num.length + 1] = 0;
  num.length += 2;

  // bounded at: 0x40 * 0x3ffffff + 0x3d0 = 0x100000390
  var hi;
  var lo = 0;
  for (var i = 0; i < num.length; i++) {
    var w = num.words[i];
    hi = w * 0x40;
    lo += w * 0x3d1;
    hi += (lo / 0x4000000) | 0;
    lo &= 0x3ffffff;

    num.words[i] = lo;

    lo = hi;
  }

  // Fast length reduction
  if (num.words[num.length - 1] === 0) {
    num.length--;
    if (num.words[num.length - 1] === 0)
      num.length--;
  }
  return num;
};

function P224() {
  MPrime.call(
    this,
    'p224',
    'ffffffff ffffffff ffffffff ffffffff 00000000 00000000 00000001');
}
inherits(P224, MPrime);

function P192() {
  MPrime.call(
    this,
    'p192',
    'ffffffff ffffffff ffffffff fffffffe ffffffff ffffffff');
}
inherits(P192, MPrime);

function P25519() {
  // 2 ^ 255 - 19
  MPrime.call(
    this,
    '25519',
    '7fffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffed');
}
inherits(P25519, MPrime);

P25519.prototype.imulK = function imulK(num) {
  // K = 0x13
  var carry = 0;
  for (var i = 0; i < num.length; i++) {
    var hi = num.words[i] * 0x13 + carry;
    var lo = hi & 0x3ffffff;
    hi >>>= 26;

    num.words[i] = lo;
    carry = hi;
  }
  if (carry !== 0)
    num.words[num.length++] = carry;
  return num;
};

// Exported mostly for testing purposes, use plain name instead
BN._prime = function prime(name) {
  // Cached version of prime
  if (primes[name])
    return primes[name];

  var prime;
  if (name === 'k256')
    prime = new K256();
  else if (name === 'p224')
    prime = new P224();
  else if (name === 'p192')
    prime = new P192();
  else if (name === 'p25519')
    prime = new P25519();
  else
    throw new Error('Unknown prime ' + name);
  primes[name] = prime;

  return prime;
};

//
// Base reduction engine
//
function Red(m) {
  if (typeof m === 'string') {
    var prime = BN._prime(m);
    this.m = prime.p;
    this.prime = prime;
  } else {
    this.m = m;
    this.prime = null;
  }
}

Red.prototype._verify1 = function _verify1(a) {
  assert(!a.sign, 'red works only with positives');
  assert(a.red, 'red works only with red numbers');
};

Red.prototype._verify2 = function _verify2(a, b) {
  assert(!a.sign && !b.sign, 'red works only with positives');
  assert(a.red && a.red === b.red,
         'red works only with red numbers');
};

Red.prototype.imod = function imod(a) {
  if (this.prime)
    return this.prime.ireduce(a)._forceRed(this);
  return a.mod(this.m)._forceRed(this);
};

Red.prototype.neg = function neg(a) {
  var r = a.clone();
  r.sign = !r.sign;
  return r.iadd(this.m)._forceRed(this);
};

Red.prototype.add = function add(a, b) {
  this._verify2(a, b);

  var res = a.add(b);
  if (res.cmp(this.m) >= 0)
    res.isub(this.m);
  return res._forceRed(this);
};

Red.prototype.iadd = function iadd(a, b) {
  this._verify2(a, b);

  var res = a.iadd(b);
  if (res.cmp(this.m) >= 0)
    res.isub(this.m);
  return res;
};

Red.prototype.sub = function sub(a, b) {
  this._verify2(a, b);

  var res = a.sub(b);
  if (res.cmpn(0) < 0)
    res.iadd(this.m);
  return res._forceRed(this);
};

Red.prototype.isub = function isub(a, b) {
  this._verify2(a, b);

  var res = a.isub(b);
  if (res.cmpn(0) < 0)
    res.iadd(this.m);
  return res;
};

Red.prototype.shl = function shl(a, num) {
  this._verify1(a);
  return this.imod(a.shln(num));
};

Red.prototype.imul = function imul(a, b) {
  this._verify2(a, b);
  return this.imod(a.imul(b));
};

Red.prototype.mul = function mul(a, b) {
  this._verify2(a, b);
  return this.imod(a.mul(b));
};

Red.prototype.isqr = function isqr(a) {
  return this.imul(a, a);
};

Red.prototype.sqr = function sqr(a) {
  return this.mul(a, a);
};

Red.prototype.sqrt = function sqrt(a) {
  if (a.cmpn(0) === 0)
    return a.clone();

  var mod3 = this.m.andln(3);
  assert(mod3 % 2 === 1);

  // Fast case
  if (mod3 === 3) {
    var pow = this.m.add(new BN(1)).ishrn(2);
    var r = this.pow(a, pow);
    return r;
  }

  // Tonelli-Shanks algorithm (Totally unoptimized and slow)
  //
  // Find Q and S, that Q * 2 ^ S = (P - 1)
  var q = this.m.subn(1);
  var s = 0;
  while (q.cmpn(0) !== 0 && q.andln(1) === 0) {
    s++;
    q.ishrn(1);
  }
  assert(q.cmpn(0) !== 0);

  var one = new BN(1).toRed(this);
  var nOne = one.redNeg();

  // Find quadratic non-residue
  // NOTE: Max is such because of generalized Riemann hypothesis.
  var lpow = this.m.subn(1).ishrn(1);
  var z = this.m.bitLength();
  z = new BN(2 * z * z).toRed(this);
  while (this.pow(z, lpow).cmp(nOne) !== 0)
    z.redIAdd(nOne);

  var c = this.pow(z, q);
  var r = this.pow(a, q.addn(1).ishrn(1));
  var t = this.pow(a, q);
  var m = s;
  while (t.cmp(one) !== 0) {
    var tmp = t;
    for (var i = 0; tmp.cmp(one) !== 0; i++)
      tmp = tmp.redSqr();
    assert(i < m);
    var b = this.pow(c, new BN(1).ishln(m - i - 1));

    r = r.redMul(b);
    c = b.redSqr();
    t = t.redMul(c);
    m = i;
  }

  return r;
};

Red.prototype.invm = function invm(a) {
  var inv = a._invmp(this.m);
  if (inv.sign) {
    inv.sign = false;
    return this.imod(inv).redNeg();
  } else {
    return this.imod(inv);
  }
};

Red.prototype.pow = function pow(a, num) {
  var w = [];

  if (num.cmpn(0) === 0)
    return new BN(1);

  var q = num.clone();

  while (q.cmpn(0) !== 0) {
    w.push(q.andln(1));
    q.ishrn(1);
  }

  // Skip leading zeroes
  var res = a;
  for (var i = 0; i < w.length; i++, res = this.sqr(res))
    if (w[i] !== 0)
      break;

  if (++i < w.length) {
    for (var q = this.sqr(res); i < w.length; i++, q = this.sqr(q)) {
      if (w[i] === 0)
        continue;
      res = this.mul(res, q);
    }
  }

  return res;
};

Red.prototype.convertTo = function convertTo(num) {
  var r = num.mod(this.m);
  if (r === num)
    return r.clone();
  else
    return r;
};

Red.prototype.convertFrom = function convertFrom(num) {
  var res = num.clone();
  res.red = null;
  return res;
};

//
// Montgomery method engine
//

BN.mont = function mont(num) {
  return new Mont(num);
};

function Mont(m) {
  Red.call(this, m);

  this.shift = this.m.bitLength();
  if (this.shift % 26 !== 0)
    this.shift += 26 - (this.shift % 26);
  this.r = new BN(1).ishln(this.shift);
  this.r2 = this.imod(this.r.sqr());
  this.rinv = this.r._invmp(this.m);

  this.minv = this.rinv.mul(this.r).isubn(1).div(this.m);
  this.minv.sign = true;
  this.minv = this.minv.mod(this.r);
}
inherits(Mont, Red);

Mont.prototype.convertTo = function convertTo(num) {
  return this.imod(num.shln(this.shift));
};

Mont.prototype.convertFrom = function convertFrom(num) {
  var r = this.imod(num.mul(this.rinv));
  r.red = null;
  return r;
};

Mont.prototype.imul = function imul(a, b) {
  if (a.cmpn(0) === 0 || b.cmpn(0) === 0) {
    a.words[0] = 0;
    a.length = 1;
    return a;
  }

  var t = a.imul(b);
  var c = t.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m);
  var u = t.isub(c).ishrn(this.shift);
  var res = u;
  if (u.cmp(this.m) >= 0)
    res = u.isub(this.m);
  else if (u.cmpn(0) < 0)
    res = u.iadd(this.m);

  return res._forceRed(this);
};

Mont.prototype.mul = function mul(a, b) {
  if (a.cmpn(0) === 0 || b.cmpn(0) === 0)
    return new BN(0)._forceRed(this);

  var t = a.mul(b);
  var c = t.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m);
  var u = t.isub(c).ishrn(this.shift);
  var res = u;
  if (u.cmp(this.m) >= 0)
    res = u.isub(this.m);
  else if (u.cmpn(0) < 0)
    res = u.iadd(this.m);

  return res._forceRed(this);
};

Mont.prototype.invm = function invm(a) {
  // (AR)^-1 * R^2 = (A^-1 * R^-1) * R^2 = A^-1 * R
  var res = this.imod(a._invmp(this.m).mul(this.r2));
  return res._forceRed(this);
};

})(typeof module === 'undefined' || module, this);

},{}],44:[function(require,module,exports){
(function (Buffer){
var hasTypedArrays = false
if(typeof Float64Array !== "undefined") {
  var DOUBLE_VIEW = new Float64Array(1)
    , UINT_VIEW   = new Uint32Array(DOUBLE_VIEW.buffer)
  DOUBLE_VIEW[0] = 1.0
  hasTypedArrays = true
  if(UINT_VIEW[1] === 0x3ff00000) {
    //Use little endian
    module.exports = function doubleBitsLE(n) {
      DOUBLE_VIEW[0] = n
      return [ UINT_VIEW[0], UINT_VIEW[1] ]
    }
    function toDoubleLE(lo, hi) {
      UINT_VIEW[0] = lo
      UINT_VIEW[1] = hi
      return DOUBLE_VIEW[0]
    }
    module.exports.pack = toDoubleLE
    function lowUintLE(n) {
      DOUBLE_VIEW[0] = n
      return UINT_VIEW[0]
    }
    module.exports.lo = lowUintLE
    function highUintLE(n) {
      DOUBLE_VIEW[0] = n
      return UINT_VIEW[1]
    }
    module.exports.hi = highUintLE
  } else if(UINT_VIEW[0] === 0x3ff00000) {
    //Use big endian
    module.exports = function doubleBitsBE(n) {
      DOUBLE_VIEW[0] = n
      return [ UINT_VIEW[1], UINT_VIEW[0] ]
    }
    function toDoubleBE(lo, hi) {
      UINT_VIEW[1] = lo
      UINT_VIEW[0] = hi
      return DOUBLE_VIEW[0]
    }
    module.exports.pack = toDoubleBE
    function lowUintBE(n) {
      DOUBLE_VIEW[0] = n
      return UINT_VIEW[1]
    }
    module.exports.lo = lowUintBE
    function highUintBE(n) {
      DOUBLE_VIEW[0] = n
      return UINT_VIEW[0]
    }
    module.exports.hi = highUintBE
  } else {
    hasTypedArrays = false
  }
}
if(!hasTypedArrays) {
  var buffer = new Buffer(8)
  module.exports = function doubleBits(n) {
    buffer.writeDoubleLE(n, 0, true)
    return [ buffer.readUInt32LE(0, true), buffer.readUInt32LE(4, true) ]
  }
  function toDouble(lo, hi) {
    buffer.writeUInt32LE(lo, 0, true)
    buffer.writeUInt32LE(hi, 4, true)
    return buffer.readDoubleLE(0, true)
  }
  module.exports.pack = toDouble  
  function lowUint(n) {
    buffer.writeDoubleLE(n, 0, true)
    return buffer.readUInt32LE(0, true)
  }
  module.exports.lo = lowUint
  function highUint(n) {
    buffer.writeDoubleLE(n, 0, true)
    return buffer.readUInt32LE(4, true)
  }
  module.exports.hi = highUint
}

module.exports.sign = function(n) {
  return module.exports.hi(n) >>> 31
}

module.exports.exponent = function(n) {
  var b = module.exports.hi(n)
  return ((b<<1) >>> 21) - 1023
}

module.exports.fraction = function(n) {
  var lo = module.exports.lo(n)
  var hi = module.exports.hi(n)
  var b = hi & ((1<<20) - 1)
  if(hi & 0x7ff00000) {
    b += (1<<20)
  }
  return [lo, b]
}

module.exports.denormalized = function(n) {
  var hi = module.exports.hi(n)
  return !(hi & 0x7ff00000)
}
}).call(this,require("buffer").Buffer)

},{"buffer":2}],45:[function(require,module,exports){
'use strict'

var bnsign = require('./lib/bn-sign')

module.exports = sign

function sign(x) {
  return bnsign(x[0]) * bnsign(x[1])
}

},{"./lib/bn-sign":34}],46:[function(require,module,exports){
'use strict'

var rationalize = require('./lib/rationalize')

module.exports = sub

function sub(a, b) {
  return rationalize(a[0].mul(b[1]).sub(a[1].mul(b[0])), a[1].mul(b[1]))
}

},{"./lib/rationalize":39}],47:[function(require,module,exports){
'use strict'

var bn2num = require('./lib/bn-to-num')
var ctz = require('./lib/ctz')

module.exports = roundRat

//Round a rational to the closest float
function roundRat(f) {
  var a = f[0]
  var b = f[1]
  if(a.cmpn(0) === 0) {
    return 0
  }
  var h = a.divmod(b)
  var iv = h.div
  var x = bn2num(iv)
  var ir = h.mod
  if(ir.cmpn(0) === 0) {
    return x
  }
  if(x) {
    var s = ctz(x) + 4
    var y = bn2num(ir.shln(s).divRound(b))

    // flip the sign of y if x is negative
    if (x<0) {
      y = -y;
    }

    return x + y * Math.pow(2, -s)
  } else {
    var ybits = b.bitLength() - ir.bitLength() + 53
    var y = bn2num(ir.shln(ybits).divRound(b))
    if(ybits < 1023) {
      return y * Math.pow(2, -ybits)
    }
    y *= Math.pow(2, -1023)
    return y * Math.pow(2, 1023-ybits)
  }
}

},{"./lib/bn-to-num":35,"./lib/ctz":36}],48:[function(require,module,exports){
'use strict'

module.exports = boxIntersectWrapper

var pool = require('typedarray-pool')
var sweep = require('./lib/sweep')
var boxIntersectIter = require('./lib/intersect')

function boxEmpty(d, box) {
  for(var j=0; j<d; ++j) {
    if(!(box[j] <= box[j+d])) {
      return true
    }
  }
  return false
}

//Unpack boxes into a flat typed array, remove empty boxes
function convertBoxes(boxes, d, data, ids) {
  var ptr = 0
  var count = 0
  for(var i=0, n=boxes.length; i<n; ++i) {
    var b = boxes[i]
    if(boxEmpty(d, b)) {
      continue
    }
    for(var j=0; j<2*d; ++j) {
      data[ptr++] = b[j]
    }
    ids[count++] = i
  }
  return count
}

//Perform type conversions, check bounds
function boxIntersect(red, blue, visit, full) {
  var n = red.length
  var m = blue.length

  //If either array is empty, then we can skip this whole thing
  if(n <= 0 || m <= 0) {
    return
  }

  //Compute dimension, if it is 0 then we skip
  var d = (red[0].length)>>>1
  if(d <= 0) {
    return
  }

  var retval

  //Convert red boxes
  var redList  = pool.mallocDouble(2*d*n)
  var redIds   = pool.mallocInt32(n)
  n = convertBoxes(red, d, redList, redIds)

  if(n > 0) {
    if(d === 1 && full) {
      //Special case: 1d complete
      sweep.init(n)
      retval = sweep.sweepComplete(
        d, visit, 
        0, n, redList, redIds,
        0, n, redList, redIds)
    } else {

      //Convert blue boxes
      var blueList = pool.mallocDouble(2*d*m)
      var blueIds  = pool.mallocInt32(m)
      m = convertBoxes(blue, d, blueList, blueIds)

      if(m > 0) {
        sweep.init(n+m)

        if(d === 1) {
          //Special case: 1d bipartite
          retval = sweep.sweepBipartite(
            d, visit, 
            0, n, redList,  redIds,
            0, m, blueList, blueIds)
        } else {
          //General case:  d>1
          retval = boxIntersectIter(
            d, visit,    full,
            n, redList,  redIds,
            m, blueList, blueIds)
        }

        pool.free(blueList)
        pool.free(blueIds)
      }
    }

    pool.free(redList)
    pool.free(redIds)
  }

  return retval
}


var RESULT

function appendItem(i,j) {
  RESULT.push([i,j])
}

function intersectFullArray(x) {
  RESULT = []
  boxIntersect(x, x, appendItem, true)
  return RESULT
}

function intersectBipartiteArray(x, y) {
  RESULT = []
  boxIntersect(x, y, appendItem, false)
  return RESULT
}

//User-friendly wrapper, handle full input and no-visitor cases
function boxIntersectWrapper(arg0, arg1, arg2) {
  var result
  switch(arguments.length) {
    case 1:
      return intersectFullArray(arg0)
    case 2:
      if(typeof arg1 === 'function') {
        return boxIntersect(arg0, arg0, arg1, true)
      } else {
        return intersectBipartiteArray(arg0, arg1)
      }
    case 3:
      return boxIntersect(arg0, arg1, arg2, false)
    default:
      throw new Error('box-intersect: Invalid arguments')
  }
}
},{"./lib/intersect":50,"./lib/sweep":54,"typedarray-pool":57}],49:[function(require,module,exports){
'use strict'

var DIMENSION   = 'd'
var AXIS        = 'ax'
var VISIT       = 'vv'
var FLIP        = 'fp'

var ELEM_SIZE   = 'es'

var RED_START   = 'rs'
var RED_END     = 're'
var RED_BOXES   = 'rb'
var RED_INDEX   = 'ri'
var RED_PTR     = 'rp'

var BLUE_START  = 'bs'
var BLUE_END    = 'be'
var BLUE_BOXES  = 'bb'
var BLUE_INDEX  = 'bi'
var BLUE_PTR    = 'bp'

var RETVAL      = 'rv'

var INNER_LABEL = 'Q'

var ARGS = [
  DIMENSION,
  AXIS,
  VISIT,
  RED_START,
  RED_END,
  RED_BOXES,
  RED_INDEX,
  BLUE_START,
  BLUE_END,
  BLUE_BOXES,
  BLUE_INDEX
]

function generateBruteForce(redMajor, flip, full) {
  var funcName = 'bruteForce' + 
    (redMajor ? 'Red' : 'Blue') + 
    (flip ? 'Flip' : '') +
    (full ? 'Full' : '')

  var code = ['function ', funcName, '(', ARGS.join(), '){',
    'var ', ELEM_SIZE, '=2*', DIMENSION, ';']

  var redLoop = 
    'for(var i=' + RED_START + ',' + RED_PTR + '=' + ELEM_SIZE + '*' + RED_START + ';' +
        'i<' + RED_END +';' +
        '++i,' + RED_PTR + '+=' + ELEM_SIZE + '){' +
        'var x0=' + RED_BOXES + '[' + AXIS + '+' + RED_PTR + '],' +
            'x1=' + RED_BOXES + '[' + AXIS + '+' + RED_PTR + '+' + DIMENSION + '],' +
            'xi=' + RED_INDEX + '[i];'

  var blueLoop = 
    'for(var j=' + BLUE_START + ',' + BLUE_PTR + '=' + ELEM_SIZE + '*' + BLUE_START + ';' +
        'j<' + BLUE_END + ';' +
        '++j,' + BLUE_PTR + '+=' + ELEM_SIZE + '){' +
        'var y0=' + BLUE_BOXES + '[' + AXIS + '+' + BLUE_PTR + '],' +
            (full ? 'y1=' + BLUE_BOXES + '[' + AXIS + '+' + BLUE_PTR + '+' + DIMENSION + '],' : '') +
            'yi=' + BLUE_INDEX + '[j];'

  if(redMajor) {
    code.push(redLoop, INNER_LABEL, ':', blueLoop)
  } else {
    code.push(blueLoop, INNER_LABEL, ':', redLoop)
  }

  if(full) {
    code.push('if(y1<x0||x1<y0)continue;')
  } else if(flip) {
    code.push('if(y0<=x0||x1<y0)continue;')
  } else {
    code.push('if(y0<x0||x1<y0)continue;')
  }

  code.push('for(var k='+AXIS+'+1;k<'+DIMENSION+';++k){'+
    'var r0='+RED_BOXES+'[k+'+RED_PTR+'],'+
        'r1='+RED_BOXES+'[k+'+DIMENSION+'+'+RED_PTR+'],'+
        'b0='+BLUE_BOXES+'[k+'+BLUE_PTR+'],'+
        'b1='+BLUE_BOXES+'[k+'+DIMENSION+'+'+BLUE_PTR+'];'+
      'if(r1<b0||b1<r0)continue ' + INNER_LABEL + ';}' +
      'var ' + RETVAL + '=' + VISIT + '(')

  if(flip) {
    code.push('yi,xi')
  } else {
    code.push('xi,yi')
  }

  code.push(');if(' + RETVAL + '!==void 0)return ' + RETVAL + ';}}}')

  return {
    name: funcName, 
    code: code.join('')
  }
}

function bruteForcePlanner(full) {
  var funcName = 'bruteForce' + (full ? 'Full' : 'Partial')
  var prefix = []
  var fargs = ARGS.slice()
  if(!full) {
    fargs.splice(3, 0, FLIP)
  }

  var code = ['function ' + funcName + '(' + fargs.join() + '){']

  function invoke(redMajor, flip) {
    var res = generateBruteForce(redMajor, flip, full)
    prefix.push(res.code)
    code.push('return ' + res.name + '(' + ARGS.join() + ');')
  }

  code.push('if(' + RED_END + '-' + RED_START + '>' +
                    BLUE_END + '-' + BLUE_START + '){')

  if(full) {
    invoke(true, false)
    code.push('}else{')
    invoke(false, false)
  } else {
    code.push('if(' + FLIP + '){')
    invoke(true, true)
    code.push('}else{')
    invoke(true, false)
    code.push('}}else{if(' + FLIP + '){')
    invoke(false, true)
    code.push('}else{')
    invoke(false, false)
    code.push('}')
  }
  code.push('}}return ' + funcName)

  var codeStr = prefix.join('') + code.join('')
  var proc = new Function(codeStr)
  return proc()
}


exports.partial = bruteForcePlanner(false)
exports.full    = bruteForcePlanner(true)
},{}],50:[function(require,module,exports){
'use strict'

module.exports = boxIntersectIter

var pool = require('typedarray-pool')
var bits = require('bit-twiddle')
var bruteForce = require('./brute')
var bruteForcePartial = bruteForce.partial
var bruteForceFull = bruteForce.full
var sweep = require('./sweep')
var findMedian = require('./median')
var genPartition = require('./partition')

//Twiddle parameters
var BRUTE_FORCE_CUTOFF    = 128       //Cut off for brute force search
var SCAN_CUTOFF           = (1<<22)   //Cut off for two way scan
var SCAN_COMPLETE_CUTOFF  = (1<<22)  

//Partition functions
var partitionInteriorContainsInterval = genPartition(
  '!(lo>=p0)&&!(p1>=hi)', 
  ['p0', 'p1'])

var partitionStartEqual = genPartition(
  'lo===p0',
  ['p0'])

var partitionStartLessThan = genPartition(
  'lo<p0',
  ['p0'])

var partitionEndLessThanEqual = genPartition(
  'hi<=p0',
  ['p0'])

var partitionContainsPoint = genPartition(
  'lo<=p0&&p0<=hi',
  ['p0'])

var partitionContainsPointProper = genPartition(
  'lo<p0&&p0<=hi',
  ['p0'])

//Frame size for iterative loop
var IFRAME_SIZE = 6
var DFRAME_SIZE = 2

//Data for box statck
var INIT_CAPACITY = 1024
var BOX_ISTACK  = pool.mallocInt32(INIT_CAPACITY)
var BOX_DSTACK  = pool.mallocDouble(INIT_CAPACITY)

//Initialize iterative loop queue
function iterInit(d, count) {
  var levels = (8 * bits.log2(count+1) * (d+1))|0
  var maxInts = bits.nextPow2(IFRAME_SIZE*levels)
  if(BOX_ISTACK.length < maxInts) {
    pool.free(BOX_ISTACK)
    BOX_ISTACK = pool.mallocInt32(maxInts)
  }
  var maxDoubles = bits.nextPow2(DFRAME_SIZE*levels)
  if(BOX_DSTACK < maxDoubles) {
    pool.free(BOX_DSTACK)
    BOX_DSTACK = pool.mallocDouble(maxDoubles)
  }
}

//Append item to queue
function iterPush(ptr,
  axis, 
  redStart, redEnd, 
  blueStart, blueEnd, 
  state, 
  lo, hi) {

  var iptr = IFRAME_SIZE * ptr
  BOX_ISTACK[iptr]   = axis
  BOX_ISTACK[iptr+1] = redStart
  BOX_ISTACK[iptr+2] = redEnd
  BOX_ISTACK[iptr+3] = blueStart
  BOX_ISTACK[iptr+4] = blueEnd
  BOX_ISTACK[iptr+5] = state

  var dptr = DFRAME_SIZE * ptr
  BOX_DSTACK[dptr]   = lo
  BOX_DSTACK[dptr+1] = hi
}

//Special case:  Intersect single point with list of intervals
function onePointPartial(
  d, axis, visit, flip,
  redStart, redEnd, red, redIndex,
  blueOffset, blue, blueId) {

  var elemSize = 2 * d
  var bluePtr  = blueOffset * elemSize
  var blueX    = blue[bluePtr + axis]

red_loop:
  for(var i=redStart, redPtr=redStart*elemSize; i<redEnd; ++i, redPtr+=elemSize) {
    var r0 = red[redPtr+axis]
    var r1 = red[redPtr+axis+d]
    if(blueX < r0 || r1 < blueX) {
      continue
    }
    if(flip && blueX === r0) {
      continue
    }
    var redId = redIndex[i]
    for(var j=axis+1; j<d; ++j) {
      var r0 = red[redPtr+j]
      var r1 = red[redPtr+j+d]
      var b0 = blue[bluePtr+j]
      var b1 = blue[bluePtr+j+d]
      if(r1 < b0 || b1 < r0) {
        continue red_loop
      }
    }
    var retval
    if(flip) {
      retval = visit(blueId, redId)
    } else {
      retval = visit(redId, blueId)
    }
    if(retval !== void 0) {
      return retval
    }
  }
}

//Special case:  Intersect one point with list of intervals
function onePointFull(
  d, axis, visit,
  redStart, redEnd, red, redIndex,
  blueOffset, blue, blueId) {

  var elemSize = 2 * d
  var bluePtr  = blueOffset * elemSize
  var blueX    = blue[bluePtr + axis]

red_loop:
  for(var i=redStart, redPtr=redStart*elemSize; i<redEnd; ++i, redPtr+=elemSize) {
    var redId = redIndex[i]
    if(redId === blueId) {
      continue
    }
    var r0 = red[redPtr+axis]
    var r1 = red[redPtr+axis+d]
    if(blueX < r0 || r1 < blueX) {
      continue
    }
    for(var j=axis+1; j<d; ++j) {
      var r0 = red[redPtr+j]
      var r1 = red[redPtr+j+d]
      var b0 = blue[bluePtr+j]
      var b1 = blue[bluePtr+j+d]
      if(r1 < b0 || b1 < r0) {
        continue red_loop
      }
    }
    var retval = visit(redId, blueId)
    if(retval !== void 0) {
      return retval
    }
  }
}

//The main box intersection routine
function boxIntersectIter(
  d, visit, initFull,
  xSize, xBoxes, xIndex,
  ySize, yBoxes, yIndex) {

  //Reserve memory for stack
  iterInit(d, xSize + ySize)

  var top  = 0
  var elemSize = 2 * d
  var retval

  iterPush(top++,
      0,
      0, xSize,
      0, ySize,
      initFull ? 16 : 0, 
      -Infinity, Infinity)
  if(!initFull) {
    iterPush(top++,
      0,
      0, ySize,
      0, xSize,
      1, 
      -Infinity, Infinity)
  }

  while(top > 0) {
    top  -= 1

    var iptr = top * IFRAME_SIZE
    var axis      = BOX_ISTACK[iptr]
    var redStart  = BOX_ISTACK[iptr+1]
    var redEnd    = BOX_ISTACK[iptr+2]
    var blueStart = BOX_ISTACK[iptr+3]
    var blueEnd   = BOX_ISTACK[iptr+4]
    var state     = BOX_ISTACK[iptr+5]

    var dptr = top * DFRAME_SIZE
    var lo        = BOX_DSTACK[dptr]
    var hi        = BOX_DSTACK[dptr+1]

    //Unpack state info
    var flip      = (state & 1)
    var full      = !!(state & 16)

    //Unpack indices
    var red       = xBoxes
    var redIndex  = xIndex
    var blue      = yBoxes
    var blueIndex = yIndex
    if(flip) {
      red         = yBoxes
      redIndex    = yIndex
      blue        = xBoxes
      blueIndex   = xIndex
    }

    if(state & 2) {
      redEnd = partitionStartLessThan(
        d, axis,
        redStart, redEnd, red, redIndex,
        hi)
      if(redStart >= redEnd) {
        continue
      }
    }
    if(state & 4) {
      redStart = partitionEndLessThanEqual(
        d, axis,
        redStart, redEnd, red, redIndex,
        lo)
      if(redStart >= redEnd) {
        continue
      }
    }
    
    var redCount  = redEnd  - redStart
    var blueCount = blueEnd - blueStart

    if(full) {
      if(d * redCount * (redCount + blueCount) < SCAN_COMPLETE_CUTOFF) {
        retval = sweep.scanComplete(
          d, axis, visit, 
          redStart, redEnd, red, redIndex,
          blueStart, blueEnd, blue, blueIndex)
        if(retval !== void 0) {
          return retval
        }
        continue
      }
    } else {
      if(d * Math.min(redCount, blueCount) < BRUTE_FORCE_CUTOFF) {
        //If input small, then use brute force
        retval = bruteForcePartial(
            d, axis, visit, flip,
            redStart,  redEnd,  red,  redIndex,
            blueStart, blueEnd, blue, blueIndex)
        if(retval !== void 0) {
          return retval
        }
        continue
      } else if(d * redCount * blueCount < SCAN_CUTOFF) {
        //If input medium sized, then use sweep and prune
        retval = sweep.scanBipartite(
          d, axis, visit, flip, 
          redStart, redEnd, red, redIndex,
          blueStart, blueEnd, blue, blueIndex)
        if(retval !== void 0) {
          return retval
        }
        continue
      }
    }
    
    //First, find all red intervals whose interior contains (lo,hi)
    var red0 = partitionInteriorContainsInterval(
      d, axis, 
      redStart, redEnd, red, redIndex,
      lo, hi)

    //Lower dimensional case
    if(redStart < red0) {

      if(d * (red0 - redStart) < BRUTE_FORCE_CUTOFF) {
        //Special case for small inputs: use brute force
        retval = bruteForceFull(
          d, axis+1, visit,
          redStart, red0, red, redIndex,
          blueStart, blueEnd, blue, blueIndex)
        if(retval !== void 0) {
          return retval
        }
      } else if(axis === d-2) {
        if(flip) {
          retval = sweep.sweepBipartite(
            d, visit,
            blueStart, blueEnd, blue, blueIndex,
            redStart, red0, red, redIndex)
        } else {
          retval = sweep.sweepBipartite(
            d, visit,
            redStart, red0, red, redIndex,
            blueStart, blueEnd, blue, blueIndex)
        }
        if(retval !== void 0) {
          return retval
        }
      } else {
        iterPush(top++,
          axis+1,
          redStart, red0,
          blueStart, blueEnd,
          flip,
          -Infinity, Infinity)
        iterPush(top++,
          axis+1,
          blueStart, blueEnd,
          redStart, red0,
          flip^1,
          -Infinity, Infinity)
      }
    }

    //Divide and conquer phase
    if(red0 < redEnd) {

      //Cut blue into 3 parts:
      //
      //  Points < mid point
      //  Points = mid point
      //  Points > mid point
      //
      var blue0 = findMedian(
        d, axis, 
        blueStart, blueEnd, blue, blueIndex)
      var mid = blue[elemSize * blue0 + axis]
      var blue1 = partitionStartEqual(
        d, axis,
        blue0, blueEnd, blue, blueIndex,
        mid)

      //Right case
      if(blue1 < blueEnd) {
        iterPush(top++,
          axis,
          red0, redEnd,
          blue1, blueEnd,
          (flip|4) + (full ? 16 : 0),
          mid, hi)
      }

      //Left case
      if(blueStart < blue0) {
        iterPush(top++,
          axis,
          red0, redEnd,
          blueStart, blue0,
          (flip|2) + (full ? 16 : 0),
          lo, mid)
      }

      //Center case (the hard part)
      if(blue0 + 1 === blue1) {
        //Optimization: Range with exactly 1 point, use a brute force scan
        if(full) {
          retval = onePointFull(
            d, axis, visit,
            red0, redEnd, red, redIndex,
            blue0, blue, blueIndex[blue0])
        } else {
          retval = onePointPartial(
            d, axis, visit, flip,
            red0, redEnd, red, redIndex,
            blue0, blue, blueIndex[blue0])
        }
        if(retval !== void 0) {
          return retval
        }
      } else if(blue0 < blue1) {
        var red1
        if(full) {
          //If full intersection, need to handle special case
          red1 = partitionContainsPoint(
            d, axis,
            red0, redEnd, red, redIndex,
            mid)
          if(red0 < red1) {
            var redX = partitionStartEqual(
              d, axis,
              red0, red1, red, redIndex,
              mid)
            if(axis === d-2) {
              //Degenerate sweep intersection:
              //  [red0, redX] with [blue0, blue1]
              if(red0 < redX) {
                retval = sweep.sweepComplete(
                  d, visit,
                  red0, redX, red, redIndex,
                  blue0, blue1, blue, blueIndex)
                if(retval !== void 0) {
                  return retval
                }
              }

              //Normal sweep intersection:
              //  [redX, red1] with [blue0, blue1]
              if(redX < red1) {
                retval = sweep.sweepBipartite(
                  d, visit,
                  redX, red1, red, redIndex,
                  blue0, blue1, blue, blueIndex)
                if(retval !== void 0) {
                  return retval
                }
              }
            } else {
              if(red0 < redX) {
                iterPush(top++,
                  axis+1,
                  red0, redX,
                  blue0, blue1,
                  16,
                  -Infinity, Infinity)
              }
              if(redX < red1) {
                iterPush(top++,
                  axis+1,
                  redX, red1,
                  blue0, blue1,
                  0,
                  -Infinity, Infinity)
                iterPush(top++,
                  axis+1,
                  blue0, blue1,
                  redX, red1,
                  1,
                  -Infinity, Infinity)
              }
            }
          }
        } else {
          if(flip) {
            red1 = partitionContainsPointProper(
              d, axis,
              red0, redEnd, red, redIndex,
              mid)
          } else {
            red1 = partitionContainsPoint(
              d, axis,
              red0, redEnd, red, redIndex,
              mid)
          }
          if(red0 < red1) {
            if(axis === d-2) {
              if(flip) {
                retval = sweep.sweepBipartite(
                  d, visit,
                  blue0, blue1, blue, blueIndex,
                  red0, red1, red, redIndex)
              } else {
                retval = sweep.sweepBipartite(
                  d, visit,
                  red0, red1, red, redIndex,
                  blue0, blue1, blue, blueIndex)
              }
            } else {
              iterPush(top++,
                axis+1,
                red0, red1,
                blue0, blue1,
                flip,
                -Infinity, Infinity)
              iterPush(top++,
                axis+1,
                blue0, blue1,
                red0, red1,
                flip^1,
                -Infinity, Infinity)
            }
          }
        }
      }
    }
  }
}
},{"./brute":49,"./median":51,"./partition":52,"./sweep":54,"bit-twiddle":55,"typedarray-pool":57}],51:[function(require,module,exports){
'use strict'

module.exports = findMedian

var genPartition = require('./partition')

var partitionStartLessThan = genPartition('lo<p0', ['p0'])

var PARTITION_THRESHOLD = 8   //Cut off for using insertion sort in findMedian

//Base case for median finding:  Use insertion sort
function insertionSort(d, axis, start, end, boxes, ids) {
  var elemSize = 2 * d
  var boxPtr = elemSize * (start+1) + axis
  for(var i=start+1; i<end; ++i, boxPtr+=elemSize) {
    var x = boxes[boxPtr]
    for(var j=i, ptr=elemSize*(i-1); 
        j>start && boxes[ptr+axis] > x; 
        --j, ptr-=elemSize) {
      //Swap
      var aPtr = ptr
      var bPtr = ptr+elemSize
      for(var k=0; k<elemSize; ++k, ++aPtr, ++bPtr) {
        var y = boxes[aPtr]
        boxes[aPtr] = boxes[bPtr]
        boxes[bPtr] = y
      }
      var tmp = ids[j]
      ids[j] = ids[j-1]
      ids[j-1] = tmp
    }
  }
}

//Find median using quick select algorithm
//  takes O(n) time with high probability
function findMedian(d, axis, start, end, boxes, ids) {
  if(end <= start+1) {
    return start
  }

  var lo       = start
  var hi       = end
  var mid      = ((end + start) >>> 1)
  var elemSize = 2*d
  var pivot    = mid
  var value    = boxes[elemSize*mid+axis]
  
  while(lo < hi) {
    if(hi - lo < PARTITION_THRESHOLD) {
      insertionSort(d, axis, lo, hi, boxes, ids)
      value = boxes[elemSize*mid+axis]
      break
    }
    
    //Select pivot using median-of-3
    var count  = hi - lo
    var pivot0 = (Math.random()*count+lo)|0
    var value0 = boxes[elemSize*pivot0 + axis]
    var pivot1 = (Math.random()*count+lo)|0
    var value1 = boxes[elemSize*pivot1 + axis]
    var pivot2 = (Math.random()*count+lo)|0
    var value2 = boxes[elemSize*pivot2 + axis]
    if(value0 <= value1) {
      if(value2 >= value1) {
        pivot = pivot1
        value = value1
      } else if(value0 >= value2) {
        pivot = pivot0
        value = value0
      } else {
        pivot = pivot2
        value = value2
      }
    } else {
      if(value1 >= value2) {
        pivot = pivot1
        value = value1
      } else if(value2 >= value0) {
        pivot = pivot0
        value = value0
      } else {
        pivot = pivot2
        value = value2
      }
    }

    //Swap pivot to end of array
    var aPtr = elemSize * (hi-1)
    var bPtr = elemSize * pivot
    for(var i=0; i<elemSize; ++i, ++aPtr, ++bPtr) {
      var x = boxes[aPtr]
      boxes[aPtr] = boxes[bPtr]
      boxes[bPtr] = x
    }
    var y = ids[hi-1]
    ids[hi-1] = ids[pivot]
    ids[pivot] = y

    //Partition using pivot
    pivot = partitionStartLessThan(
      d, axis, 
      lo, hi-1, boxes, ids,
      value)

    //Swap pivot back
    var aPtr = elemSize * (hi-1)
    var bPtr = elemSize * pivot
    for(var i=0; i<elemSize; ++i, ++aPtr, ++bPtr) {
      var x = boxes[aPtr]
      boxes[aPtr] = boxes[bPtr]
      boxes[bPtr] = x
    }
    var y = ids[hi-1]
    ids[hi-1] = ids[pivot]
    ids[pivot] = y

    //Swap pivot to last pivot
    if(mid < pivot) {
      hi = pivot-1
      while(lo < hi && 
        boxes[elemSize*(hi-1)+axis] === value) {
        hi -= 1
      }
      hi += 1
    } else if(pivot < mid) {
      lo = pivot + 1
      while(lo < hi &&
        boxes[elemSize*lo+axis] === value) {
        lo += 1
      }
    } else {
      break
    }
  }

  //Make sure pivot is at start
  return partitionStartLessThan(
    d, axis, 
    start, mid, boxes, ids,
    boxes[elemSize*mid+axis])
}
},{"./partition":52}],52:[function(require,module,exports){
'use strict'

module.exports = genPartition

var code = 'for(var j=2*a,k=j*c,l=k,m=c,n=b,o=a+b,p=c;d>p;++p,k+=j){var _;if($)if(m===p)m+=1,l+=j;else{for(var s=0;j>s;++s){var t=e[k+s];e[k+s]=e[l],e[l++]=t}var u=f[p];f[p]=f[m],f[m++]=u}}return m'

function genPartition(predicate, args) {
  var fargs ='abcdef'.split('').concat(args)
  var reads = []
  if(predicate.indexOf('lo') >= 0) {
    reads.push('lo=e[k+n]')
  }
  if(predicate.indexOf('hi') >= 0) {
    reads.push('hi=e[k+o]')
  }
  fargs.push(
    code.replace('_', reads.join())
        .replace('$', predicate))
  return Function.apply(void 0, fargs)
}
},{}],53:[function(require,module,exports){
'use strict';

//This code is extracted from ndarray-sort
//It is inlined here as a temporary workaround

module.exports = wrapper;

var INSERT_SORT_CUTOFF = 32

function wrapper(data, n0) {
  if (n0 <= 4*INSERT_SORT_CUTOFF) {
    insertionSort(0, n0 - 1, data);
  } else {
    quickSort(0, n0 - 1, data);
  }
}

function insertionSort(left, right, data) {
  var ptr = 2*(left+1)
  for(var i=left+1; i<=right; ++i) {
    var a = data[ptr++]
    var b = data[ptr++]
    var j = i
    var jptr = ptr-2
    while(j-- > left) {
      var x = data[jptr-2]
      var y = data[jptr-1]
      if(x < a) {
        break
      } else if(x === a && y < b) {
        break
      }
      data[jptr]   = x
      data[jptr+1] = y
      jptr -= 2
    }
    data[jptr]   = a
    data[jptr+1] = b
  }
}

function swap(i, j, data) {
  i *= 2
  j *= 2
  var x = data[i]
  var y = data[i+1]
  data[i] = data[j]
  data[i+1] = data[j+1]
  data[j] = x
  data[j+1] = y
}

function move(i, j, data) {
  i *= 2
  j *= 2
  data[i] = data[j]
  data[i+1] = data[j+1]
}

function rotate(i, j, k, data) {
  i *= 2
  j *= 2
  k *= 2
  var x = data[i]
  var y = data[i+1]
  data[i] = data[j]
  data[i+1] = data[j+1]
  data[j] = data[k]
  data[j+1] = data[k+1]
  data[k] = x
  data[k+1] = y
}

function shufflePivot(i, j, px, py, data) {
  i *= 2
  j *= 2
  data[i] = data[j]
  data[j] = px
  data[i+1] = data[j+1]
  data[j+1] = py
}

function compare(i, j, data) {
  i *= 2
  j *= 2
  var x = data[i],
      y = data[j]
  if(x < y) {
    return false
  } else if(x === y) {
    return data[i+1] > data[j+1]
  }
  return true
}

function comparePivot(i, y, b, data) {
  i *= 2
  var x = data[i]
  if(x < y) {
    return true
  } else if(x === y) {
    return data[i+1] < b
  }
  return false
}

function quickSort(left, right, data) {
  var sixth = (right - left + 1) / 6 | 0, 
      index1 = left + sixth, 
      index5 = right - sixth, 
      index3 = left + right >> 1, 
      index2 = index3 - sixth, 
      index4 = index3 + sixth, 
      el1 = index1, 
      el2 = index2, 
      el3 = index3, 
      el4 = index4, 
      el5 = index5, 
      less = left + 1, 
      great = right - 1, 
      tmp = 0
  if(compare(el1, el2, data)) {
    tmp = el1
    el1 = el2
    el2 = tmp
  }
  if(compare(el4, el5, data)) {
    tmp = el4
    el4 = el5
    el5 = tmp
  }
  if(compare(el1, el3, data)) {
    tmp = el1
    el1 = el3
    el3 = tmp
  }
  if(compare(el2, el3, data)) {
    tmp = el2
    el2 = el3
    el3 = tmp
  }
  if(compare(el1, el4, data)) {
    tmp = el1
    el1 = el4
    el4 = tmp
  }
  if(compare(el3, el4, data)) {
    tmp = el3
    el3 = el4
    el4 = tmp
  }
  if(compare(el2, el5, data)) {
    tmp = el2
    el2 = el5
    el5 = tmp
  }
  if(compare(el2, el3, data)) {
    tmp = el2
    el2 = el3
    el3 = tmp
  }
  if(compare(el4, el5, data)) {
    tmp = el4
    el4 = el5
    el5 = tmp
  }

  var pivot1X = data[2*el2]
  var pivot1Y = data[2*el2+1]
  var pivot2X = data[2*el4]
  var pivot2Y = data[2*el4+1]

  var ptr0 = 2 * el1;
  var ptr2 = 2 * el3;
  var ptr4 = 2 * el5;
  var ptr5 = 2 * index1;
  var ptr6 = 2 * index3;
  var ptr7 = 2 * index5;
  for (var i1 = 0; i1 < 2; ++i1) {
    var x = data[ptr0+i1];
    var y = data[ptr2+i1];
    var z = data[ptr4+i1];
    data[ptr5+i1] = x;
    data[ptr6+i1] = y;
    data[ptr7+i1] = z;
  }

  move(index2, left, data)
  move(index4, right, data)
  for (var k = less; k <= great; ++k) {
    if (comparePivot(k, pivot1X, pivot1Y, data)) {
      if (k !== less) {
        swap(k, less, data)
      }
      ++less;
    } else {
      if (!comparePivot(k, pivot2X, pivot2Y, data)) {
        while (true) {
          if (!comparePivot(great, pivot2X, pivot2Y, data)) {
            if (--great < k) {
              break;
            }
            continue;
          } else {
            if (comparePivot(great, pivot1X, pivot1Y, data)) {
              rotate(k, less, great, data)
              ++less;
              --great;
            } else {
              swap(k, great, data)
              --great;
            }
            break;
          }
        }
      }
    }
  }
  shufflePivot(left, less-1, pivot1X, pivot1Y, data)
  shufflePivot(right, great+1, pivot2X, pivot2Y, data)
  if (less - 2 - left <= INSERT_SORT_CUTOFF) {
    insertionSort(left, less - 2, data);
  } else {
    quickSort(left, less - 2, data);
  }
  if (right - (great + 2) <= INSERT_SORT_CUTOFF) {
    insertionSort(great + 2, right, data);
  } else {
    quickSort(great + 2, right, data);
  }
  if (great - less <= INSERT_SORT_CUTOFF) {
    insertionSort(less, great, data);
  } else {
    quickSort(less, great, data);
  }
}
},{}],54:[function(require,module,exports){
'use strict'

module.exports = {
  init:           sqInit,
  sweepBipartite: sweepBipartite,
  sweepComplete:  sweepComplete,
  scanBipartite:  scanBipartite,
  scanComplete:   scanComplete
}

var pool  = require('typedarray-pool')
var bits  = require('bit-twiddle')
var isort = require('./sort')

//Flag for blue
var BLUE_FLAG = (1<<28)

//1D sweep event queue stuff (use pool to save space)
var INIT_CAPACITY      = 1024
var RED_SWEEP_QUEUE    = pool.mallocInt32(INIT_CAPACITY)
var RED_SWEEP_INDEX    = pool.mallocInt32(INIT_CAPACITY)
var BLUE_SWEEP_QUEUE   = pool.mallocInt32(INIT_CAPACITY)
var BLUE_SWEEP_INDEX   = pool.mallocInt32(INIT_CAPACITY)
var COMMON_SWEEP_QUEUE = pool.mallocInt32(INIT_CAPACITY)
var COMMON_SWEEP_INDEX = pool.mallocInt32(INIT_CAPACITY)
var SWEEP_EVENTS       = pool.mallocDouble(INIT_CAPACITY * 8)

//Reserves memory for the 1D sweep data structures
function sqInit(count) {
  var rcount = bits.nextPow2(count)
  if(RED_SWEEP_QUEUE.length < rcount) {
    pool.free(RED_SWEEP_QUEUE)
    RED_SWEEP_QUEUE = pool.mallocInt32(rcount)
  }
  if(RED_SWEEP_INDEX.length < rcount) {
    pool.free(RED_SWEEP_INDEX)
    RED_SWEEP_INDEX = pool.mallocInt32(rcount)
  }
  if(BLUE_SWEEP_QUEUE.length < rcount) {
    pool.free(BLUE_SWEEP_QUEUE)
    BLUE_SWEEP_QUEUE = pool.mallocInt32(rcount)
  }
  if(BLUE_SWEEP_INDEX.length < rcount) {
    pool.free(BLUE_SWEEP_INDEX)
    BLUE_SWEEP_INDEX = pool.mallocInt32(rcount)
  }
  if(COMMON_SWEEP_QUEUE.length < rcount) {
    pool.free(COMMON_SWEEP_QUEUE)
    COMMON_SWEEP_QUEUE = pool.mallocInt32(rcount)
  }
  if(COMMON_SWEEP_INDEX.length < rcount) {
    pool.free(COMMON_SWEEP_INDEX)
    COMMON_SWEEP_INDEX = pool.mallocInt32(rcount)
  }
  var eventLength = 8 * rcount
  if(SWEEP_EVENTS.length < eventLength) {
    pool.free(SWEEP_EVENTS)
    SWEEP_EVENTS = pool.mallocDouble(eventLength)
  }
}

//Remove an item from the active queue in O(1)
function sqPop(queue, index, count, item) {
  var idx = index[item]
  var top = queue[count-1]
  queue[idx] = top
  index[top] = idx
}

//Insert an item into the active queue in O(1)
function sqPush(queue, index, count, item) {
  queue[count] = item
  index[item]  = count
}

//Recursion base case: use 1D sweep algorithm
function sweepBipartite(
    d, visit,
    redStart,  redEnd, red, redIndex,
    blueStart, blueEnd, blue, blueIndex) {

  //store events as pairs [coordinate, idx]
  //
  //  red create:  -(idx+1)
  //  red destroy: idx
  //  blue create: -(idx+BLUE_FLAG)
  //  blue destroy: idx+BLUE_FLAG
  //
  var ptr      = 0
  var elemSize = 2*d
  var istart   = d-1
  var iend     = elemSize-1

  for(var i=redStart; i<redEnd; ++i) {
    var idx = redIndex[i]
    var redOffset = elemSize*i
    SWEEP_EVENTS[ptr++] = red[redOffset+istart]
    SWEEP_EVENTS[ptr++] = -(idx+1)
    SWEEP_EVENTS[ptr++] = red[redOffset+iend]
    SWEEP_EVENTS[ptr++] = idx
  }

  for(var i=blueStart; i<blueEnd; ++i) {
    var idx = blueIndex[i]+BLUE_FLAG
    var blueOffset = elemSize*i
    SWEEP_EVENTS[ptr++] = blue[blueOffset+istart]
    SWEEP_EVENTS[ptr++] = -idx
    SWEEP_EVENTS[ptr++] = blue[blueOffset+iend]
    SWEEP_EVENTS[ptr++] = idx
  }

  //process events from left->right
  var n = ptr >>> 1
  isort(SWEEP_EVENTS, n)
  
  var redActive  = 0
  var blueActive = 0
  for(var i=0; i<n; ++i) {
    var e = SWEEP_EVENTS[2*i+1]|0
    if(e >= BLUE_FLAG) {
      //blue destroy event
      e = (e-BLUE_FLAG)|0
      sqPop(BLUE_SWEEP_QUEUE, BLUE_SWEEP_INDEX, blueActive--, e)
    } else if(e >= 0) {
      //red destroy event
      sqPop(RED_SWEEP_QUEUE, RED_SWEEP_INDEX, redActive--, e)
    } else if(e <= -BLUE_FLAG) {
      //blue create event
      e = (-e-BLUE_FLAG)|0
      for(var j=0; j<redActive; ++j) {
        var retval = visit(RED_SWEEP_QUEUE[j], e)
        if(retval !== void 0) {
          return retval
        }
      }
      sqPush(BLUE_SWEEP_QUEUE, BLUE_SWEEP_INDEX, blueActive++, e)
    } else {
      //red create event
      e = (-e-1)|0
      for(var j=0; j<blueActive; ++j) {
        var retval = visit(e, BLUE_SWEEP_QUEUE[j])
        if(retval !== void 0) {
          return retval
        }
      }
      sqPush(RED_SWEEP_QUEUE, RED_SWEEP_INDEX, redActive++, e)
    }
  }
}

//Complete sweep
function sweepComplete(d, visit, 
  redStart, redEnd, red, redIndex,
  blueStart, blueEnd, blue, blueIndex) {

  var ptr      = 0
  var elemSize = 2*d
  var istart   = d-1
  var iend     = elemSize-1

  for(var i=redStart; i<redEnd; ++i) {
    var idx = (redIndex[i]+1)<<1
    var redOffset = elemSize*i
    SWEEP_EVENTS[ptr++] = red[redOffset+istart]
    SWEEP_EVENTS[ptr++] = -idx
    SWEEP_EVENTS[ptr++] = red[redOffset+iend]
    SWEEP_EVENTS[ptr++] = idx
  }

  for(var i=blueStart; i<blueEnd; ++i) {
    var idx = (blueIndex[i]+1)<<1
    var blueOffset = elemSize*i
    SWEEP_EVENTS[ptr++] = blue[blueOffset+istart]
    SWEEP_EVENTS[ptr++] = (-idx)|1
    SWEEP_EVENTS[ptr++] = blue[blueOffset+iend]
    SWEEP_EVENTS[ptr++] = idx|1
  }

  //process events from left->right
  var n = ptr >>> 1
  isort(SWEEP_EVENTS, n)
  
  var redActive    = 0
  var blueActive   = 0
  var commonActive = 0
  for(var i=0; i<n; ++i) {
    var e     = SWEEP_EVENTS[2*i+1]|0
    var color = e&1
    if(i < n-1 && (e>>1) === (SWEEP_EVENTS[2*i+3]>>1)) {
      color = 2
      i += 1
    }
    
    if(e < 0) {
      //Create event
      var id = -(e>>1) - 1

      //Intersect with common
      for(var j=0; j<commonActive; ++j) {
        var retval = visit(COMMON_SWEEP_QUEUE[j], id)
        if(retval !== void 0) {
          return retval
        }
      }

      if(color !== 0) {
        //Intersect with red
        for(var j=0; j<redActive; ++j) {
          var retval = visit(RED_SWEEP_QUEUE[j], id)
          if(retval !== void 0) {
            return retval
          }
        }
      }

      if(color !== 1) {
        //Intersect with blue
        for(var j=0; j<blueActive; ++j) {
          var retval = visit(BLUE_SWEEP_QUEUE[j], id)
          if(retval !== void 0) {
            return retval
          }
        }
      }

      if(color === 0) {
        //Red
        sqPush(RED_SWEEP_QUEUE, RED_SWEEP_INDEX, redActive++, id)
      } else if(color === 1) {
        //Blue
        sqPush(BLUE_SWEEP_QUEUE, BLUE_SWEEP_INDEX, blueActive++, id)
      } else if(color === 2) {
        //Both
        sqPush(COMMON_SWEEP_QUEUE, COMMON_SWEEP_INDEX, commonActive++, id)
      }
    } else {
      //Destroy event
      var id = (e>>1) - 1
      if(color === 0) {
        //Red
        sqPop(RED_SWEEP_QUEUE, RED_SWEEP_INDEX, redActive--, id)
      } else if(color === 1) {
        //Blue
        sqPop(BLUE_SWEEP_QUEUE, BLUE_SWEEP_INDEX, blueActive--, id)
      } else if(color === 2) {
        //Both
        sqPop(COMMON_SWEEP_QUEUE, COMMON_SWEEP_INDEX, commonActive--, id)
      }
    }
  }
}

//Sweep and prune/scanline algorithm:
//  Scan along axis, detect intersections
//  Brute force all boxes along axis
function scanBipartite(
  d, axis, visit, flip,
  redStart,  redEnd, red, redIndex,
  blueStart, blueEnd, blue, blueIndex) {
  
  var ptr      = 0
  var elemSize = 2*d
  var istart   = axis
  var iend     = axis+d

  var redShift  = 1
  var blueShift = 1
  if(flip) {
    blueShift = BLUE_FLAG
  } else {
    redShift  = BLUE_FLAG
  }

  for(var i=redStart; i<redEnd; ++i) {
    var idx = i + redShift
    var redOffset = elemSize*i
    SWEEP_EVENTS[ptr++] = red[redOffset+istart]
    SWEEP_EVENTS[ptr++] = -idx
    SWEEP_EVENTS[ptr++] = red[redOffset+iend]
    SWEEP_EVENTS[ptr++] = idx
  }
  for(var i=blueStart; i<blueEnd; ++i) {
    var idx = i + blueShift
    var blueOffset = elemSize*i
    SWEEP_EVENTS[ptr++] = blue[blueOffset+istart]
    SWEEP_EVENTS[ptr++] = -idx
  }

  //process events from left->right
  var n = ptr >>> 1
  isort(SWEEP_EVENTS, n)
  
  var redActive    = 0
  for(var i=0; i<n; ++i) {
    var e = SWEEP_EVENTS[2*i+1]|0
    if(e < 0) {
      var idx   = -e
      var isRed = false
      if(idx >= BLUE_FLAG) {
        isRed = !flip
        idx -= BLUE_FLAG 
      } else {
        isRed = !!flip
        idx -= 1
      }
      if(isRed) {
        sqPush(RED_SWEEP_QUEUE, RED_SWEEP_INDEX, redActive++, idx)
      } else {
        var blueId  = blueIndex[idx]
        var bluePtr = elemSize * idx
        
        var b0 = blue[bluePtr+axis+1]
        var b1 = blue[bluePtr+axis+1+d]

red_loop:
        for(var j=0; j<redActive; ++j) {
          var oidx   = RED_SWEEP_QUEUE[j]
          var redPtr = elemSize * oidx

          if(b1 < red[redPtr+axis+1] || 
             red[redPtr+axis+1+d] < b0) {
            continue
          }

          for(var k=axis+2; k<d; ++k) {
            if(blue[bluePtr + k + d] < red[redPtr + k] || 
               red[redPtr + k + d] < blue[bluePtr + k]) {
              continue red_loop
            }
          }

          var redId  = redIndex[oidx]
          var retval
          if(flip) {
            retval = visit(blueId, redId)
          } else {
            retval = visit(redId, blueId)
          }
          if(retval !== void 0) {
            return retval 
          }
        }
      }
    } else {
      sqPop(RED_SWEEP_QUEUE, RED_SWEEP_INDEX, redActive--, e - redShift)
    }
  }
}

function scanComplete(
  d, axis, visit,
  redStart,  redEnd, red, redIndex,
  blueStart, blueEnd, blue, blueIndex) {

  var ptr      = 0
  var elemSize = 2*d
  var istart   = axis
  var iend     = axis+d

  for(var i=redStart; i<redEnd; ++i) {
    var idx = i + BLUE_FLAG
    var redOffset = elemSize*i
    SWEEP_EVENTS[ptr++] = red[redOffset+istart]
    SWEEP_EVENTS[ptr++] = -idx
    SWEEP_EVENTS[ptr++] = red[redOffset+iend]
    SWEEP_EVENTS[ptr++] = idx
  }
  for(var i=blueStart; i<blueEnd; ++i) {
    var idx = i + 1
    var blueOffset = elemSize*i
    SWEEP_EVENTS[ptr++] = blue[blueOffset+istart]
    SWEEP_EVENTS[ptr++] = -idx
  }

  //process events from left->right
  var n = ptr >>> 1
  isort(SWEEP_EVENTS, n)
  
  var redActive    = 0
  for(var i=0; i<n; ++i) {
    var e = SWEEP_EVENTS[2*i+1]|0
    if(e < 0) {
      var idx   = -e
      if(idx >= BLUE_FLAG) {
        RED_SWEEP_QUEUE[redActive++] = idx - BLUE_FLAG
      } else {
        idx -= 1
        var blueId  = blueIndex[idx]
        var bluePtr = elemSize * idx

        var b0 = blue[bluePtr+axis+1]
        var b1 = blue[bluePtr+axis+1+d]

red_loop:
        for(var j=0; j<redActive; ++j) {
          var oidx   = RED_SWEEP_QUEUE[j]
          var redId  = redIndex[oidx]

          if(redId === blueId) {
            break
          }

          var redPtr = elemSize * oidx
          if(b1 < red[redPtr+axis+1] || 
            red[redPtr+axis+1+d] < b0) {
            continue
          }
          for(var k=axis+2; k<d; ++k) {
            if(blue[bluePtr + k + d] < red[redPtr + k] || 
               red[redPtr + k + d]   < blue[bluePtr + k]) {
              continue red_loop
            }
          }

          var retval = visit(redId, blueId)
          if(retval !== void 0) {
            return retval 
          }
        }
      }
    } else {
      var idx = e - BLUE_FLAG
      for(var j=redActive-1; j>=0; --j) {
        if(RED_SWEEP_QUEUE[j] === idx) {
          for(var k=j+1; k<redActive; ++k) {
            RED_SWEEP_QUEUE[k-1] = RED_SWEEP_QUEUE[k]
          }
          break
        }
      }
      --redActive
    }
  }
}
},{"./sort":53,"bit-twiddle":55,"typedarray-pool":57}],55:[function(require,module,exports){
arguments[4][42][0].apply(exports,arguments)
},{"dup":42}],56:[function(require,module,exports){
"use strict"

function dupe_array(count, value, i) {
  var c = count[i]|0
  if(c <= 0) {
    return []
  }
  var result = new Array(c), j
  if(i === count.length-1) {
    for(j=0; j<c; ++j) {
      result[j] = value
    }
  } else {
    for(j=0; j<c; ++j) {
      result[j] = dupe_array(count, value, i+1)
    }
  }
  return result
}

function dupe_number(count, value) {
  var result, i
  result = new Array(count)
  for(i=0; i<count; ++i) {
    result[i] = value
  }
  return result
}

function dupe(count, value) {
  if(typeof value === "undefined") {
    value = 0
  }
  switch(typeof count) {
    case "number":
      if(count > 0) {
        return dupe_number(count|0, value)
      }
    break
    case "object":
      if(typeof (count.length) === "number") {
        return dupe_array(count, value, 0)
      }
    break
  }
  return []
}

module.exports = dupe
},{}],57:[function(require,module,exports){
(function (global,Buffer){
'use strict'

var bits = require('bit-twiddle')
var dup = require('dup')

//Legacy pool support
if(!global.__TYPEDARRAY_POOL) {
  global.__TYPEDARRAY_POOL = {
      UINT8   : dup([32, 0])
    , UINT16  : dup([32, 0])
    , UINT32  : dup([32, 0])
    , INT8    : dup([32, 0])
    , INT16   : dup([32, 0])
    , INT32   : dup([32, 0])
    , FLOAT   : dup([32, 0])
    , DOUBLE  : dup([32, 0])
    , DATA    : dup([32, 0])
    , UINT8C  : dup([32, 0])
    , BUFFER  : dup([32, 0])
  }
}

var hasUint8C = (typeof Uint8ClampedArray) !== 'undefined'
var POOL = global.__TYPEDARRAY_POOL

//Upgrade pool
if(!POOL.UINT8C) {
  POOL.UINT8C = dup([32, 0])
}
if(!POOL.BUFFER) {
  POOL.BUFFER = dup([32, 0])
}

//New technique: Only allocate from ArrayBufferView and Buffer
var DATA    = POOL.DATA
  , BUFFER  = POOL.BUFFER

exports.free = function free(array) {
  if(Buffer.isBuffer(array)) {
    BUFFER[bits.log2(array.length)].push(array)
  } else {
    if(Object.prototype.toString.call(array) !== '[object ArrayBuffer]') {
      array = array.buffer
    }
    if(!array) {
      return
    }
    var n = array.length || array.byteLength
    var log_n = bits.log2(n)|0
    DATA[log_n].push(array)
  }
}

function freeArrayBuffer(buffer) {
  if(!buffer) {
    return
  }
  var n = buffer.length || buffer.byteLength
  var log_n = bits.log2(n)
  DATA[log_n].push(buffer)
}

function freeTypedArray(array) {
  freeArrayBuffer(array.buffer)
}

exports.freeUint8 =
exports.freeUint16 =
exports.freeUint32 =
exports.freeInt8 =
exports.freeInt16 =
exports.freeInt32 =
exports.freeFloat32 = 
exports.freeFloat =
exports.freeFloat64 = 
exports.freeDouble = 
exports.freeUint8Clamped = 
exports.freeDataView = freeTypedArray

exports.freeArrayBuffer = freeArrayBuffer

exports.freeBuffer = function freeBuffer(array) {
  BUFFER[bits.log2(array.length)].push(array)
}

exports.malloc = function malloc(n, dtype) {
  if(dtype === undefined || dtype === 'arraybuffer') {
    return mallocArrayBuffer(n)
  } else {
    switch(dtype) {
      case 'uint8':
        return mallocUint8(n)
      case 'uint16':
        return mallocUint16(n)
      case 'uint32':
        return mallocUint32(n)
      case 'int8':
        return mallocInt8(n)
      case 'int16':
        return mallocInt16(n)
      case 'int32':
        return mallocInt32(n)
      case 'float':
      case 'float32':
        return mallocFloat(n)
      case 'double':
      case 'float64':
        return mallocDouble(n)
      case 'uint8_clamped':
        return mallocUint8Clamped(n)
      case 'buffer':
        return mallocBuffer(n)
      case 'data':
      case 'dataview':
        return mallocDataView(n)

      default:
        return null
    }
  }
  return null
}

function mallocArrayBuffer(n) {
  var n = bits.nextPow2(n)
  var log_n = bits.log2(n)
  var d = DATA[log_n]
  if(d.length > 0) {
    return d.pop()
  }
  return new ArrayBuffer(n)
}
exports.mallocArrayBuffer = mallocArrayBuffer

function mallocUint8(n) {
  return new Uint8Array(mallocArrayBuffer(n), 0, n)
}
exports.mallocUint8 = mallocUint8

function mallocUint16(n) {
  return new Uint16Array(mallocArrayBuffer(2*n), 0, n)
}
exports.mallocUint16 = mallocUint16

function mallocUint32(n) {
  return new Uint32Array(mallocArrayBuffer(4*n), 0, n)
}
exports.mallocUint32 = mallocUint32

function mallocInt8(n) {
  return new Int8Array(mallocArrayBuffer(n), 0, n)
}
exports.mallocInt8 = mallocInt8

function mallocInt16(n) {
  return new Int16Array(mallocArrayBuffer(2*n), 0, n)
}
exports.mallocInt16 = mallocInt16

function mallocInt32(n) {
  return new Int32Array(mallocArrayBuffer(4*n), 0, n)
}
exports.mallocInt32 = mallocInt32

function mallocFloat(n) {
  return new Float32Array(mallocArrayBuffer(4*n), 0, n)
}
exports.mallocFloat32 = exports.mallocFloat = mallocFloat

function mallocDouble(n) {
  return new Float64Array(mallocArrayBuffer(8*n), 0, n)
}
exports.mallocFloat64 = exports.mallocDouble = mallocDouble

function mallocUint8Clamped(n) {
  if(hasUint8C) {
    return new Uint8ClampedArray(mallocArrayBuffer(n), 0, n)
  } else {
    return mallocUint8(n)
  }
}
exports.mallocUint8Clamped = mallocUint8Clamped

function mallocDataView(n) {
  return new DataView(mallocArrayBuffer(n), 0, n)
}
exports.mallocDataView = mallocDataView

function mallocBuffer(n) {
  n = bits.nextPow2(n)
  var log_n = bits.log2(n)
  var cache = BUFFER[log_n]
  if(cache.length > 0) {
    return cache.pop()
  }
  return new Buffer(n)
}
exports.mallocBuffer = mallocBuffer

exports.clearCache = function clearCache() {
  for(var i=0; i<32; ++i) {
    POOL.UINT8[i].length = 0
    POOL.UINT16[i].length = 0
    POOL.UINT32[i].length = 0
    POOL.INT8[i].length = 0
    POOL.INT16[i].length = 0
    POOL.INT32[i].length = 0
    POOL.FLOAT[i].length = 0
    POOL.DOUBLE[i].length = 0
    POOL.UINT8C[i].length = 0
    DATA[i].length = 0
    BUFFER[i].length = 0
  }
}
}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {},require("buffer").Buffer)

},{"bit-twiddle":55,"buffer":2,"dup":56}],58:[function(require,module,exports){
module.exports = compareCells

var min = Math.min

function compareInt(a, b) {
  return a - b
}

function compareCells(a, b) {
  var n = a.length
    , t = a.length - b.length
  if(t) {
    return t
  }
  switch(n) {
    case 0:
      return 0
    case 1:
      return a[0] - b[0]
    case 2:
      return (a[0]+a[1]-b[0]-b[1]) ||
             min(a[0],a[1]) - min(b[0],b[1])
    case 3:
      var l1 = a[0]+a[1]
        , m1 = b[0]+b[1]
      t = l1+a[2] - (m1+b[2])
      if(t) {
        return t
      }
      var l0 = min(a[0], a[1])
        , m0 = min(b[0], b[1])
      return min(l0, a[2]) - min(m0, b[2]) ||
             min(l0+a[2], l1) - min(m0+b[2], m1)
    case 4:
      var aw=a[0], ax=a[1], ay=a[2], az=a[3]
        , bw=b[0], bx=b[1], by=b[2], bz=b[3]
      return (aw+ax+ay+az)-(bw+bx+by+bz) ||
             min(aw,ax,ay,az)-min(bw,bx,by,bz,bw) ||
             min(aw+ax,aw+ay,aw+az,ax+ay,ax+az,ay+az) -
               min(bw+bx,bw+by,bw+bz,bx+by,bx+bz,by+bz) ||
             min(aw+ax+ay,aw+ax+az,aw+ay+az,ax+ay+az) -
               min(bw+bx+by,bw+bx+bz,bw+by+bz,bx+by+bz)
    default:
      var as = a.slice().sort(compareInt)
      var bs = b.slice().sort(compareInt)
      for(var i=0; i<n; ++i) {
        t = as[i] - bs[i]
        if(t) {
          return t
        }
      }
      return 0
  }
}

},{}],59:[function(require,module,exports){
"use strict"

var doubleBits = require("double-bits")

var SMALLEST_DENORM = Math.pow(2, -1074)
var UINT_MAX = (-1)>>>0

module.exports = nextafter

function nextafter(x, y) {
  if(isNaN(x) || isNaN(y)) {
    return NaN
  }
  if(x === y) {
    return x
  }
  if(x === 0) {
    if(y < 0) {
      return -SMALLEST_DENORM
    } else {
      return SMALLEST_DENORM
    }
  }
  var hi = doubleBits.hi(x)
  var lo = doubleBits.lo(x)
  if((y > x) === (x > 0)) {
    if(lo === UINT_MAX) {
      hi += 1
      lo = 0
    } else {
      lo += 1
    }
  } else {
    if(lo === 0) {
      lo = UINT_MAX
      hi -= 1
    } else {
      lo -= 1
    }
  }
  return doubleBits.pack(lo, hi)
}
},{"double-bits":60}],60:[function(require,module,exports){
(function (Buffer){
var hasTypedArrays = false
if(typeof Float64Array !== "undefined") {
  var DOUBLE_VIEW = new Float64Array(1)
    , UINT_VIEW   = new Uint32Array(DOUBLE_VIEW.buffer)
  DOUBLE_VIEW[0] = 1.0
  hasTypedArrays = true
  if(UINT_VIEW[1] === 0x3ff00000) {
    //Use little endian
    module.exports = function doubleBitsLE(n) {
      DOUBLE_VIEW[0] = n
      return [ UINT_VIEW[0], UINT_VIEW[1] ]
    }
    function toDoubleLE(lo, hi) {
      UINT_VIEW[0] = lo
      UINT_VIEW[1] = hi
      return DOUBLE_VIEW[0]
    }
    module.exports.pack = toDoubleLE
    function lowUintLE(n) {
      DOUBLE_VIEW[0] = n
      return UINT_VIEW[0]
    }
    module.exports.lo = lowUintLE
    function highUintLE(n) {
      DOUBLE_VIEW[0] = n
      return UINT_VIEW[1]
    }
    module.exports.hi = highUintLE
  } else if(UINT_VIEW[0] === 0x3ff00000) {
    //Use big endian
    module.exports = function doubleBitsBE(n) {
      DOUBLE_VIEW[0] = n
      return [ UINT_VIEW[1], UINT_VIEW[0] ]
    }
    function toDoubleBE(lo, hi) {
      UINT_VIEW[1] = lo
      UINT_VIEW[0] = hi
      return DOUBLE_VIEW[0]
    }
    module.exports.pack = toDoubleBE
    function lowUintBE(n) {
      DOUBLE_VIEW[0] = n
      return UINT_VIEW[1]
    }
    module.exports.lo = lowUintBE
    function highUintBE(n) {
      DOUBLE_VIEW[0] = n
      return UINT_VIEW[0]
    }
    module.exports.hi = highUintBE
  } else {
    hasTypedArrays = false
  }
}
if(!hasTypedArrays) {
  var buffer = new Buffer(8)
  module.exports = function doubleBits(n) {
    buffer.writeDoubleLE(n, 0, true)
    return [ buffer.readUInt32LE(0, true), buffer.readUInt32LE(4, true) ]
  }
  function toDouble(lo, hi) {
    buffer.writeUInt32LE(lo, 0, true)
    buffer.writeUInt32LE(hi, 4, true)
    return buffer.readDoubleLE(0, true)
  }
  module.exports.pack = toDouble  
  function lowUint(n) {
    buffer.writeDoubleLE(n, 0, true)
    return buffer.readUInt32LE(0, true)
  }
  module.exports.lo = lowUint
  function highUint(n) {
    buffer.writeDoubleLE(n, 0, true)
    return buffer.readUInt32LE(4, true)
  }
  module.exports.hi = highUint
}

module.exports.sign = function(n) {
  return module.exports.hi(n) >>> 31
}

module.exports.exponent = function(n) {
  var b = module.exports.hi(n)
  return ((b<<1) >>> 21) - 1023
}

module.exports.fraction = function(n) {
  var lo = module.exports.lo(n)
  var hi = module.exports.hi(n)
  var b = hi & ((1<<20) - 1)
  if(hi & 0x7ff00000) {
    b += (1<<20)
  }
  return [lo, b]
}

module.exports.denormalized = function(n) {
  var hi = module.exports.hi(n)
  return !(hi & 0x7ff00000)
}
}).call(this,require("buffer").Buffer)

},{"buffer":2}],61:[function(require,module,exports){
'use strict'

var bnadd = require('big-rat/add')

module.exports = add

function add(a, b) {
  var n = a.length
  var r = new Array(n)
    for(var i=0; i<n; ++i) {
    r[i] = bnadd(a[i], b[i])
  }
  return r
}

},{"big-rat/add":29}],62:[function(require,module,exports){
'use strict'

module.exports = float2rat

var rat = require('big-rat')

function float2rat(v) {
  var result = new Array(v.length)
  for(var i=0; i<v.length; ++i) {
    result[i] = rat(v[i])
  }
  return result
}

},{"big-rat":32}],63:[function(require,module,exports){
'use strict'

var rat = require('big-rat')
var mul = require('big-rat/mul')

module.exports = muls

function muls(a, x) {
  var s = rat(x)
  var n = a.length
  var r = new Array(n)
  for(var i=0; i<n; ++i) {
    r[i] = mul(a[i], s)
  }
  return r
}

},{"big-rat":32,"big-rat/mul":41}],64:[function(require,module,exports){
'use strict'

var bnsub = require('big-rat/sub')

module.exports = sub

function sub(a, b) {
  var n = a.length
  var r = new Array(n)
    for(var i=0; i<n; ++i) {
    r[i] = bnsub(a[i], b[i])
  }
  return r
}

},{"big-rat/sub":46}],65:[function(require,module,exports){
arguments[4][16][0].apply(exports,arguments)
},{"dup":16}],66:[function(require,module,exports){
arguments[4][17][0].apply(exports,arguments)
},{"dup":17,"two-product":69,"two-sum":65}],67:[function(require,module,exports){
arguments[4][18][0].apply(exports,arguments)
},{"dup":18}],68:[function(require,module,exports){
arguments[4][19][0].apply(exports,arguments)
},{"dup":19}],69:[function(require,module,exports){
arguments[4][20][0].apply(exports,arguments)
},{"dup":20}],70:[function(require,module,exports){
arguments[4][26][0].apply(exports,arguments)
},{"dup":26,"robust-scale":66,"robust-subtract":67,"robust-sum":68,"two-product":69}],71:[function(require,module,exports){
"use strict"

module.exports = segmentsIntersect

var orient = require("robust-orientation")[3]

function checkCollinear(a0, a1, b0, b1) {

  for(var d=0; d<2; ++d) {
    var x0 = a0[d]
    var y0 = a1[d]
    var l0 = Math.min(x0, y0)
    var h0 = Math.max(x0, y0)    

    var x1 = b0[d]
    var y1 = b1[d]
    var l1 = Math.min(x1, y1)
    var h1 = Math.max(x1, y1)    

    if(h1 < l0 || h0 < l1) {
      return false
    }
  }

  return true
}

function segmentsIntersect(a0, a1, b0, b1) {
  var x0 = orient(a0, b0, b1)
  var y0 = orient(a1, b0, b1)
  if((x0 > 0 && y0 > 0) || (x0 < 0 && y0 < 0)) {
    return false
  }

  var x1 = orient(b0, a0, a1)
  var y1 = orient(b1, a0, a1)
  if((x1 > 0 && y1 > 0) || (x1 < 0 && y1 < 0)) {
    return false
  }

  //Check for degenerate collinear case
  if(x0 === 0 && y0 === 0 && x1 === 0 && y1 === 0) {
    return checkCollinear(a0, a1, b0, b1)
  }

  return true
}
},{"robust-orientation":70}],72:[function(require,module,exports){
"use strict"; "use restrict";

module.exports = UnionFind;

function UnionFind(count) {
  this.roots = new Array(count);
  this.ranks = new Array(count);
  
  for(var i=0; i<count; ++i) {
    this.roots[i] = i;
    this.ranks[i] = 0;
  }
}

var proto = UnionFind.prototype

Object.defineProperty(proto, "length", {
  "get": function() {
    return this.roots.length
  }
})

proto.makeSet = function() {
  var n = this.roots.length;
  this.roots.push(n);
  this.ranks.push(0);
  return n;
}

proto.find = function(x) {
  var x0 = x
  var roots = this.roots;
  while(roots[x] !== x) {
    x = roots[x]
  }
  while(roots[x0] !== x) {
    var y = roots[x0]
    roots[x0] = x
    x0 = y
  }
  return x;
}

proto.link = function(x, y) {
  var xr = this.find(x)
    , yr = this.find(y);
  if(xr === yr) {
    return;
  }
  var ranks = this.ranks
    , roots = this.roots
    , xd    = ranks[xr]
    , yd    = ranks[yr];
  if(xd < yd) {
    roots[xr] = yr;
  } else if(yd < xd) {
    roots[yr] = xr;
  } else {
    roots[yr] = xr;
    ++ranks[xr];
  }
}
},{}],73:[function(require,module,exports){
'use strict'

module.exports = boundary

var bnd = require('boundary-cells')
var reduce = require('reduce-simplicial-complex')

function boundary(cells) {
  return reduce(bnd(cells))
}

},{"boundary-cells":74,"reduce-simplicial-complex":78}],74:[function(require,module,exports){
"use strict"

module.exports = boundary

function boundary(cells) {
  var n = cells.length
  var sz = 0
  for(var i=0; i<n; ++i) {
    sz += cells[i].length
  }
  var result = new Array(sz)
  var ptr = 0
  for(var i=0; i<n; ++i) {
    var c = cells[i]
    var d = c.length
    for(var j=0; j<d; ++j) {
      var b = result[ptr++] = new Array(d-1)
      for(var k=1; k<d; ++k) {
        b[k-1] = c[(j+k)%d]
      }
    }
  }
  return result
}

},{}],75:[function(require,module,exports){
'use strict'

module.exports = orientation

function orientation(s) {
  var p = 1
  for(var i=1; i<s.length; ++i) {
    for(var j=0; j<i; ++j) {
      if(s[i] < s[j]) {
        p = -p
      } else if(s[j] === s[i]) {
        return 0
      }
    }
  }
  return p
}

},{}],76:[function(require,module,exports){
arguments[4][58][0].apply(exports,arguments)
},{"dup":58}],77:[function(require,module,exports){
'use strict'

var compareCells = require('compare-cell')
var parity = require('cell-orientation')

module.exports = compareOrientedCells

function compareOrientedCells(a, b) {
  return compareCells(a, b) || parity(a) - parity(b)
}

},{"cell-orientation":75,"compare-cell":76}],78:[function(require,module,exports){
'use strict'

var compareCell = require('compare-cell')
var compareOrientedCell = require('compare-oriented-cell')
var orientation = require('cell-orientation')

module.exports = reduceCellComplex

function reduceCellComplex(cells) {
  cells.sort(compareOrientedCell)
  var n = cells.length
  var ptr = 0
  for(var i=0; i<n; ++i) {
    var c = cells[i]
    var o = orientation(c)
    if(o === 0) {
      continue
    }
    if(ptr > 0) {
      var f = cells[ptr-1]
      if(compareCell(c, f) === 0 &&
         orientation(f)    !== o) {
        ptr -= 1
        continue
      }
    }
    cells[ptr++] = c
  }
  cells.length = ptr
  return cells
}

},{"cell-orientation":75,"compare-cell":76,"compare-oriented-cell":77}],79:[function(require,module,exports){
'use strict'

var snapRound = require('clean-pslg')
var cdt2d = require('cdt2d')
var bsearch = require('binary-search-bounds')
var boundary = require('simplicial-complex-boundary')

module.exports = overlayPSLG

var RED  = 0
var BLUE = 1

var OPERATORS = {
  'xor':  [0, 1, 1, 0],
  'or':   [0, 1, 1, 1],
  'and':  [0, 0, 0, 1],
  'sub':  [0, 1, 0, 0],
  'rsub': [0, 0, 1, 0]
}

function getTable(op) {
  if(typeof op !== 'string') {
    return OPERATORS.xor
  }
  var x = OPERATORS[op.toLowerCase()]
  if(x) {
    return x
  }
  return OPERATORS.xor
}


function compareEdge(a, b) {
  return Math.min(a[0], a[1]) - Math.min(b[0], b[1]) ||
         Math.max(a[0], a[1]) - Math.max(b[0], b[1])
}

function edgeCellIndex(edge, cell) {
  var a = edge[0]
  var b = edge[1]
  for(var i=0; i<3; ++i) {
    if(cell[i] !== a && cell[i] !== b) {
      return i
    }
  }
  return -1
}

function buildCellIndex(cells) {
  //Initialize cell index
  var cellIndex = new Array(3*cells.length)
  for(var i=0; i<3*cells.length; ++i) {
    cellIndex[i] = -1
  }

  //Sort edges
  var edges = []
  for(var i=0; i<cells.length; ++i) {
    var c = cells[i]
    for(var j=0; j<3; ++j) {
      edges.push([c[j], c[(j+1)%3], i])
    }
  }
  edges.sort(compareEdge)

  //For each pair of edges, link adjacent cells
  for(var i=1; i<edges.length; ++i) {
    var e = edges[i]
    var f = edges[i-1]
    if(compareEdge(e, f) !== 0) {
      continue
    }
    var ce = e[2]
    var cf = f[2]
    var ei = edgeCellIndex(e, cells[ce])
    var fi = edgeCellIndex(f, cells[cf])
    cellIndex[3*ce+ei] = cf
    cellIndex[3*cf+fi] = ce
  }

  return cellIndex
}

function compareLex2(a, b) {
  return a[0]-b[0] || a[1]-b[1]
}

function canonicalizeEdges(edges) {
  for(var i=0; i<edges.length; ++i) {
    var e = edges[i]
    var a = e[0]
    var b = e[1]
    e[0] = Math.min(a, b)
    e[1] = Math.max(a, b)
  }
  edges.sort(compareLex2)
}


var TMP = [0,0]
function isConstraint(edges, a, b) {
  TMP[0] = Math.min(a,b)
  TMP[1] = Math.max(a,b)
  return bsearch.eq(edges, TMP, compareLex2) >= 0
}

//Classify all cells within boundary
function markCells(cells, adj, edges) {

  //Initialize active/next queues and flags
  var flags = new Array(cells.length)
  var constraint = new Array(3*cells.length)
  for(var i=0; i<3*cells.length; ++i) {
    constraint[i] = false
  }
  var active = []
  var next   = []
  for(var i=0; i<cells.length; ++i) {
    var c = cells[i]
    flags[i] = 0
    for(var j=0; j<3; ++j) {
      var a = c[(j+1)%3]
      var b = c[(j+2)%3]
      var constr = constraint[3*i+j] = isConstraint(edges, a, b)
      if(adj[3*i+j] >= 0) {
        continue
      }
      if(constr) {
        next.push(i)
      } else {
        flags[i] = 1
        active.push(i)
      }
    }
  }

  //Mark flags
  var side = 1
  while(active.length > 0 || next.length > 0) {
    while(active.length > 0) {
      var t = active.pop()
      if(flags[t] === -side) {
        continue
      }
      flags[t] = side
      var c = cells[t]
      for(var j=0; j<3; ++j) {
        var f = adj[3*t+j]
        if(f >= 0 && flags[f] === 0) {
          if(constraint[3*t+j]) {
            next.push(f)
          } else {
            active.push(f)
            flags[f] = side
          }
        }
      }
    }

    //Swap arrays and loop
    var tmp = next
    next = active
    active = tmp
    next.length = 0
    side = -side
  }

  return flags
}

function setIntersect(colored, edges) {
  var ptr = 0
  for(var i=0,j=0; i<colored.length&&j<edges.length; ) {
    var e = colored[i]
    var f = edges[j]
    var d = e[0]-f[0] || e[1]-f[1]
    if(d < 0) {
      i += 1
    } else if(d > 0) {
      j += 1
    } else {
      colored[ptr++] = colored[i]
      i += 1
      j += 1
    }
  }
  colored.length = ptr
  return colored
}

function relabelEdges(edges, labels) {
  for(var i=0; i<edges.length; ++i) {
    var e = edges[i]
    e[0] = labels[e[0]]
    e[1] = labels[e[1]]
  }
}

function markEdgesActive(edges, labels) {
  for(var i=0; i<edges.length; ++i) {
    var e = edges[i]
    labels[e[0]] = labels[e[1]] = 1
  }
}

function removeUnusedPoints(points, redE, blueE) {
  var labels = new Array(points.length)
  for(var i=0; i<labels.length; ++i) {
    labels[i] = -1
  }
  markEdgesActive(redE, labels)
  markEdgesActive(blueE, labels)

  var ptr = 0
  for(var i=0; i<points.length; ++i) {
    if(labels[i] > 0) {
      labels[i] = ptr
      points[ptr++] = points[i]
    }
  }
  points.length = ptr
  relabelEdges(redE, labels)
  relabelEdges(blueE, labels)
}

function overlayPSLG(redPoints, redEdges, bluePoints, blueEdges, op) {
  //1.  concatenate points
  var numRedPoints = redPoints.length
  var points = redPoints.concat(bluePoints)

  //2.  concatenate edges
  var numRedEdges  = redEdges.length
  var numBlueEdges = blueEdges.length
  var edges        = new Array(numRedEdges + numBlueEdges)
  var colors       = new Array(numRedEdges + numBlueEdges)
  for(var i=0; i<redEdges.length; ++i) {
    var e      = redEdges[i]
    colors[i]  = RED
    edges[i]   = [ e[0], e[1] ]
  }
  for(var i=0; i<blueEdges.length; ++i) {
    var e      = blueEdges[i]
    colors[i+numRedEdges]  = BLUE
    edges[i+numRedEdges]   = [ e[0]+numRedPoints, e[1]+numRedPoints ]
  }

  //3.  run snap rounding with edge colors
  snapRound(points, edges, colors)

  //4. Sort edges
  canonicalizeEdges(edges)

  //5.  extract red and blue edges
  var redE = [], blueE = []
  for(var i=0; i<edges.length; ++i) {
    if(colors[i] === RED) {
      redE.push(edges[i])
    } else {
      blueE.push(edges[i])
    }
  }

  //6.  triangulate
  var cells = cdt2d(points, edges, { delaunay: false })

  //7. build adjacency data structure
  var adj = buildCellIndex(cells)

  //8. classify triangles
  var redFlags = markCells(cells, adj, redE)
  var blueFlags = markCells(cells, adj, blueE)

  //9. filter out cels which are not part of triangulation
  var table = getTable(op)
  var ptr = 0
  for(var i=0; i<cells.length; ++i) {
    var code = ((redFlags[i] < 0)<<1) + (blueFlags[i] < 0)
    if(table[code]) {
      cells[ptr++] = cells[i]
    }
  }
  cells.length = ptr

  //10. extract boundary
  var bnd = boundary(cells)
  canonicalizeEdges(bnd)

  //11. Intersect constraint edges with boundary
  redE = setIntersect(redE, bnd)
  blueE = setIntersect(blueE, bnd)

  //12. filter old points
  removeUnusedPoints(points, redE, blueE)

  return {
    points: points,
    red:    redE,
    blue:   blueE
  }
}

},{"binary-search-bounds":9,"cdt2d":10,"clean-pslg":27,"simplicial-complex-boundary":73}],80:[function(require,module,exports){
arguments[4][27][0].apply(exports,arguments)
},{"./lib/rat-seg-intersect":81,"big-rat":85,"big-rat/cmp":83,"big-rat/to-float":100,"box-intersect":101,"compare-cell":111,"dup":27,"nextafter":112,"rat-vec":115,"robust-segment-intersect":124,"union-find":125}],81:[function(require,module,exports){
arguments[4][28][0].apply(exports,arguments)
},{"big-rat/div":84,"big-rat/mul":94,"big-rat/sign":98,"big-rat/sub":99,"big-rat/to-float":100,"dup":28,"rat-vec/add":114,"rat-vec/muls":116,"rat-vec/sub":117}],82:[function(require,module,exports){
arguments[4][29][0].apply(exports,arguments)
},{"./lib/rationalize":92,"dup":29}],83:[function(require,module,exports){
arguments[4][30][0].apply(exports,arguments)
},{"dup":30}],84:[function(require,module,exports){
arguments[4][31][0].apply(exports,arguments)
},{"./lib/rationalize":92,"dup":31}],85:[function(require,module,exports){
arguments[4][32][0].apply(exports,arguments)
},{"./div":84,"./is-rat":86,"./lib/is-bn":90,"./lib/num-to-bn":91,"./lib/rationalize":92,"./lib/str-to-bn":93,"dup":32}],86:[function(require,module,exports){
arguments[4][33][0].apply(exports,arguments)
},{"./lib/is-bn":90,"dup":33}],87:[function(require,module,exports){
arguments[4][34][0].apply(exports,arguments)
},{"bn.js":96,"dup":34}],88:[function(require,module,exports){
arguments[4][35][0].apply(exports,arguments)
},{"dup":35}],89:[function(require,module,exports){
arguments[4][36][0].apply(exports,arguments)
},{"bit-twiddle":95,"double-bits":97,"dup":36}],90:[function(require,module,exports){
arguments[4][37][0].apply(exports,arguments)
},{"bn.js":96,"dup":37}],91:[function(require,module,exports){
arguments[4][38][0].apply(exports,arguments)
},{"bn.js":96,"double-bits":97,"dup":38}],92:[function(require,module,exports){
arguments[4][39][0].apply(exports,arguments)
},{"./bn-sign":87,"./num-to-bn":91,"dup":39}],93:[function(require,module,exports){
arguments[4][40][0].apply(exports,arguments)
},{"bn.js":96,"dup":40}],94:[function(require,module,exports){
arguments[4][41][0].apply(exports,arguments)
},{"./lib/rationalize":92,"dup":41}],95:[function(require,module,exports){
arguments[4][42][0].apply(exports,arguments)
},{"dup":42}],96:[function(require,module,exports){
arguments[4][43][0].apply(exports,arguments)
},{"dup":43}],97:[function(require,module,exports){
(function (Buffer){
var hasTypedArrays = false
if(typeof Float64Array !== "undefined") {
  var DOUBLE_VIEW = new Float64Array(1)
    , UINT_VIEW   = new Uint32Array(DOUBLE_VIEW.buffer)
  DOUBLE_VIEW[0] = 1.0
  hasTypedArrays = true
  if(UINT_VIEW[1] === 0x3ff00000) {
    //Use little endian
    module.exports = function doubleBitsLE(n) {
      DOUBLE_VIEW[0] = n
      return [ UINT_VIEW[0], UINT_VIEW[1] ]
    }
    function toDoubleLE(lo, hi) {
      UINT_VIEW[0] = lo
      UINT_VIEW[1] = hi
      return DOUBLE_VIEW[0]
    }
    module.exports.pack = toDoubleLE
    function lowUintLE(n) {
      DOUBLE_VIEW[0] = n
      return UINT_VIEW[0]
    }
    module.exports.lo = lowUintLE
    function highUintLE(n) {
      DOUBLE_VIEW[0] = n
      return UINT_VIEW[1]
    }
    module.exports.hi = highUintLE
  } else if(UINT_VIEW[0] === 0x3ff00000) {
    //Use big endian
    module.exports = function doubleBitsBE(n) {
      DOUBLE_VIEW[0] = n
      return [ UINT_VIEW[1], UINT_VIEW[0] ]
    }
    function toDoubleBE(lo, hi) {
      UINT_VIEW[1] = lo
      UINT_VIEW[0] = hi
      return DOUBLE_VIEW[0]
    }
    module.exports.pack = toDoubleBE
    function lowUintBE(n) {
      DOUBLE_VIEW[0] = n
      return UINT_VIEW[1]
    }
    module.exports.lo = lowUintBE
    function highUintBE(n) {
      DOUBLE_VIEW[0] = n
      return UINT_VIEW[0]
    }
    module.exports.hi = highUintBE
  } else {
    hasTypedArrays = false
  }
}
if(!hasTypedArrays) {
  var buffer = new Buffer(8)
  module.exports = function doubleBits(n) {
    buffer.writeDoubleLE(n, 0, true)
    return [ buffer.readUInt32LE(0, true), buffer.readUInt32LE(4, true) ]
  }
  function toDouble(lo, hi) {
    buffer.writeUInt32LE(lo, 0, true)
    buffer.writeUInt32LE(hi, 4, true)
    return buffer.readDoubleLE(0, true)
  }
  module.exports.pack = toDouble  
  function lowUint(n) {
    buffer.writeDoubleLE(n, 0, true)
    return buffer.readUInt32LE(0, true)
  }
  module.exports.lo = lowUint
  function highUint(n) {
    buffer.writeDoubleLE(n, 0, true)
    return buffer.readUInt32LE(4, true)
  }
  module.exports.hi = highUint
}

module.exports.sign = function(n) {
  return module.exports.hi(n) >>> 31
}

module.exports.exponent = function(n) {
  var b = module.exports.hi(n)
  return ((b<<1) >>> 21) - 1023
}

module.exports.fraction = function(n) {
  var lo = module.exports.lo(n)
  var hi = module.exports.hi(n)
  var b = hi & ((1<<20) - 1)
  if(hi & 0x7ff00000) {
    b += (1<<20)
  }
  return [lo, b]
}

module.exports.denormalized = function(n) {
  var hi = module.exports.hi(n)
  return !(hi & 0x7ff00000)
}
}).call(this,require("buffer").Buffer)

},{"buffer":2}],98:[function(require,module,exports){
arguments[4][45][0].apply(exports,arguments)
},{"./lib/bn-sign":87,"dup":45}],99:[function(require,module,exports){
arguments[4][46][0].apply(exports,arguments)
},{"./lib/rationalize":92,"dup":46}],100:[function(require,module,exports){
arguments[4][47][0].apply(exports,arguments)
},{"./lib/bn-to-num":88,"./lib/ctz":89,"dup":47}],101:[function(require,module,exports){
arguments[4][48][0].apply(exports,arguments)
},{"./lib/intersect":103,"./lib/sweep":107,"dup":48,"typedarray-pool":110}],102:[function(require,module,exports){
arguments[4][49][0].apply(exports,arguments)
},{"dup":49}],103:[function(require,module,exports){
arguments[4][50][0].apply(exports,arguments)
},{"./brute":102,"./median":104,"./partition":105,"./sweep":107,"bit-twiddle":108,"dup":50,"typedarray-pool":110}],104:[function(require,module,exports){
arguments[4][51][0].apply(exports,arguments)
},{"./partition":105,"dup":51}],105:[function(require,module,exports){
arguments[4][52][0].apply(exports,arguments)
},{"dup":52}],106:[function(require,module,exports){
arguments[4][53][0].apply(exports,arguments)
},{"dup":53}],107:[function(require,module,exports){
arguments[4][54][0].apply(exports,arguments)
},{"./sort":106,"bit-twiddle":108,"dup":54,"typedarray-pool":110}],108:[function(require,module,exports){
arguments[4][42][0].apply(exports,arguments)
},{"dup":42}],109:[function(require,module,exports){
arguments[4][56][0].apply(exports,arguments)
},{"dup":56}],110:[function(require,module,exports){
(function (global,Buffer){
'use strict'

var bits = require('bit-twiddle')
var dup = require('dup')

//Legacy pool support
if(!global.__TYPEDARRAY_POOL) {
  global.__TYPEDARRAY_POOL = {
      UINT8   : dup([32, 0])
    , UINT16  : dup([32, 0])
    , UINT32  : dup([32, 0])
    , INT8    : dup([32, 0])
    , INT16   : dup([32, 0])
    , INT32   : dup([32, 0])
    , FLOAT   : dup([32, 0])
    , DOUBLE  : dup([32, 0])
    , DATA    : dup([32, 0])
    , UINT8C  : dup([32, 0])
    , BUFFER  : dup([32, 0])
  }
}

var hasUint8C = (typeof Uint8ClampedArray) !== 'undefined'
var POOL = global.__TYPEDARRAY_POOL

//Upgrade pool
if(!POOL.UINT8C) {
  POOL.UINT8C = dup([32, 0])
}
if(!POOL.BUFFER) {
  POOL.BUFFER = dup([32, 0])
}

//New technique: Only allocate from ArrayBufferView and Buffer
var DATA    = POOL.DATA
  , BUFFER  = POOL.BUFFER

exports.free = function free(array) {
  if(Buffer.isBuffer(array)) {
    BUFFER[bits.log2(array.length)].push(array)
  } else {
    if(Object.prototype.toString.call(array) !== '[object ArrayBuffer]') {
      array = array.buffer
    }
    if(!array) {
      return
    }
    var n = array.length || array.byteLength
    var log_n = bits.log2(n)|0
    DATA[log_n].push(array)
  }
}

function freeArrayBuffer(buffer) {
  if(!buffer) {
    return
  }
  var n = buffer.length || buffer.byteLength
  var log_n = bits.log2(n)
  DATA[log_n].push(buffer)
}

function freeTypedArray(array) {
  freeArrayBuffer(array.buffer)
}

exports.freeUint8 =
exports.freeUint16 =
exports.freeUint32 =
exports.freeInt8 =
exports.freeInt16 =
exports.freeInt32 =
exports.freeFloat32 = 
exports.freeFloat =
exports.freeFloat64 = 
exports.freeDouble = 
exports.freeUint8Clamped = 
exports.freeDataView = freeTypedArray

exports.freeArrayBuffer = freeArrayBuffer

exports.freeBuffer = function freeBuffer(array) {
  BUFFER[bits.log2(array.length)].push(array)
}

exports.malloc = function malloc(n, dtype) {
  if(dtype === undefined || dtype === 'arraybuffer') {
    return mallocArrayBuffer(n)
  } else {
    switch(dtype) {
      case 'uint8':
        return mallocUint8(n)
      case 'uint16':
        return mallocUint16(n)
      case 'uint32':
        return mallocUint32(n)
      case 'int8':
        return mallocInt8(n)
      case 'int16':
        return mallocInt16(n)
      case 'int32':
        return mallocInt32(n)
      case 'float':
      case 'float32':
        return mallocFloat(n)
      case 'double':
      case 'float64':
        return mallocDouble(n)
      case 'uint8_clamped':
        return mallocUint8Clamped(n)
      case 'buffer':
        return mallocBuffer(n)
      case 'data':
      case 'dataview':
        return mallocDataView(n)

      default:
        return null
    }
  }
  return null
}

function mallocArrayBuffer(n) {
  var n = bits.nextPow2(n)
  var log_n = bits.log2(n)
  var d = DATA[log_n]
  if(d.length > 0) {
    return d.pop()
  }
  return new ArrayBuffer(n)
}
exports.mallocArrayBuffer = mallocArrayBuffer

function mallocUint8(n) {
  return new Uint8Array(mallocArrayBuffer(n), 0, n)
}
exports.mallocUint8 = mallocUint8

function mallocUint16(n) {
  return new Uint16Array(mallocArrayBuffer(2*n), 0, n)
}
exports.mallocUint16 = mallocUint16

function mallocUint32(n) {
  return new Uint32Array(mallocArrayBuffer(4*n), 0, n)
}
exports.mallocUint32 = mallocUint32

function mallocInt8(n) {
  return new Int8Array(mallocArrayBuffer(n), 0, n)
}
exports.mallocInt8 = mallocInt8

function mallocInt16(n) {
  return new Int16Array(mallocArrayBuffer(2*n), 0, n)
}
exports.mallocInt16 = mallocInt16

function mallocInt32(n) {
  return new Int32Array(mallocArrayBuffer(4*n), 0, n)
}
exports.mallocInt32 = mallocInt32

function mallocFloat(n) {
  return new Float32Array(mallocArrayBuffer(4*n), 0, n)
}
exports.mallocFloat32 = exports.mallocFloat = mallocFloat

function mallocDouble(n) {
  return new Float64Array(mallocArrayBuffer(8*n), 0, n)
}
exports.mallocFloat64 = exports.mallocDouble = mallocDouble

function mallocUint8Clamped(n) {
  if(hasUint8C) {
    return new Uint8ClampedArray(mallocArrayBuffer(n), 0, n)
  } else {
    return mallocUint8(n)
  }
}
exports.mallocUint8Clamped = mallocUint8Clamped

function mallocDataView(n) {
  return new DataView(mallocArrayBuffer(n), 0, n)
}
exports.mallocDataView = mallocDataView

function mallocBuffer(n) {
  n = bits.nextPow2(n)
  var log_n = bits.log2(n)
  var cache = BUFFER[log_n]
  if(cache.length > 0) {
    return cache.pop()
  }
  return new Buffer(n)
}
exports.mallocBuffer = mallocBuffer

exports.clearCache = function clearCache() {
  for(var i=0; i<32; ++i) {
    POOL.UINT8[i].length = 0
    POOL.UINT16[i].length = 0
    POOL.UINT32[i].length = 0
    POOL.INT8[i].length = 0
    POOL.INT16[i].length = 0
    POOL.INT32[i].length = 0
    POOL.FLOAT[i].length = 0
    POOL.DOUBLE[i].length = 0
    POOL.UINT8C[i].length = 0
    DATA[i].length = 0
    BUFFER[i].length = 0
  }
}
}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {},require("buffer").Buffer)

},{"bit-twiddle":108,"buffer":2,"dup":109}],111:[function(require,module,exports){
arguments[4][58][0].apply(exports,arguments)
},{"dup":58}],112:[function(require,module,exports){
arguments[4][59][0].apply(exports,arguments)
},{"double-bits":113,"dup":59}],113:[function(require,module,exports){
(function (Buffer){
var hasTypedArrays = false
if(typeof Float64Array !== "undefined") {
  var DOUBLE_VIEW = new Float64Array(1)
    , UINT_VIEW   = new Uint32Array(DOUBLE_VIEW.buffer)
  DOUBLE_VIEW[0] = 1.0
  hasTypedArrays = true
  if(UINT_VIEW[1] === 0x3ff00000) {
    //Use little endian
    module.exports = function doubleBitsLE(n) {
      DOUBLE_VIEW[0] = n
      return [ UINT_VIEW[0], UINT_VIEW[1] ]
    }
    function toDoubleLE(lo, hi) {
      UINT_VIEW[0] = lo
      UINT_VIEW[1] = hi
      return DOUBLE_VIEW[0]
    }
    module.exports.pack = toDoubleLE
    function lowUintLE(n) {
      DOUBLE_VIEW[0] = n
      return UINT_VIEW[0]
    }
    module.exports.lo = lowUintLE
    function highUintLE(n) {
      DOUBLE_VIEW[0] = n
      return UINT_VIEW[1]
    }
    module.exports.hi = highUintLE
  } else if(UINT_VIEW[0] === 0x3ff00000) {
    //Use big endian
    module.exports = function doubleBitsBE(n) {
      DOUBLE_VIEW[0] = n
      return [ UINT_VIEW[1], UINT_VIEW[0] ]
    }
    function toDoubleBE(lo, hi) {
      UINT_VIEW[1] = lo
      UINT_VIEW[0] = hi
      return DOUBLE_VIEW[0]
    }
    module.exports.pack = toDoubleBE
    function lowUintBE(n) {
      DOUBLE_VIEW[0] = n
      return UINT_VIEW[1]
    }
    module.exports.lo = lowUintBE
    function highUintBE(n) {
      DOUBLE_VIEW[0] = n
      return UINT_VIEW[0]
    }
    module.exports.hi = highUintBE
  } else {
    hasTypedArrays = false
  }
}
if(!hasTypedArrays) {
  var buffer = new Buffer(8)
  module.exports = function doubleBits(n) {
    buffer.writeDoubleLE(n, 0, true)
    return [ buffer.readUInt32LE(0, true), buffer.readUInt32LE(4, true) ]
  }
  function toDouble(lo, hi) {
    buffer.writeUInt32LE(lo, 0, true)
    buffer.writeUInt32LE(hi, 4, true)
    return buffer.readDoubleLE(0, true)
  }
  module.exports.pack = toDouble  
  function lowUint(n) {
    buffer.writeDoubleLE(n, 0, true)
    return buffer.readUInt32LE(0, true)
  }
  module.exports.lo = lowUint
  function highUint(n) {
    buffer.writeDoubleLE(n, 0, true)
    return buffer.readUInt32LE(4, true)
  }
  module.exports.hi = highUint
}

module.exports.sign = function(n) {
  return module.exports.hi(n) >>> 31
}

module.exports.exponent = function(n) {
  var b = module.exports.hi(n)
  return ((b<<1) >>> 21) - 1023
}

module.exports.fraction = function(n) {
  var lo = module.exports.lo(n)
  var hi = module.exports.hi(n)
  var b = hi & ((1<<20) - 1)
  if(hi & 0x7ff00000) {
    b += (1<<20)
  }
  return [lo, b]
}

module.exports.denormalized = function(n) {
  var hi = module.exports.hi(n)
  return !(hi & 0x7ff00000)
}
}).call(this,require("buffer").Buffer)

},{"buffer":2}],114:[function(require,module,exports){
arguments[4][61][0].apply(exports,arguments)
},{"big-rat/add":82,"dup":61}],115:[function(require,module,exports){
arguments[4][62][0].apply(exports,arguments)
},{"big-rat":85,"dup":62}],116:[function(require,module,exports){
arguments[4][63][0].apply(exports,arguments)
},{"big-rat":85,"big-rat/mul":94,"dup":63}],117:[function(require,module,exports){
arguments[4][64][0].apply(exports,arguments)
},{"big-rat/sub":99,"dup":64}],118:[function(require,module,exports){
arguments[4][16][0].apply(exports,arguments)
},{"dup":16}],119:[function(require,module,exports){
arguments[4][17][0].apply(exports,arguments)
},{"dup":17,"two-product":122,"two-sum":118}],120:[function(require,module,exports){
arguments[4][18][0].apply(exports,arguments)
},{"dup":18}],121:[function(require,module,exports){
arguments[4][19][0].apply(exports,arguments)
},{"dup":19}],122:[function(require,module,exports){
arguments[4][20][0].apply(exports,arguments)
},{"dup":20}],123:[function(require,module,exports){
arguments[4][26][0].apply(exports,arguments)
},{"dup":26,"robust-scale":119,"robust-subtract":120,"robust-sum":121,"two-product":122}],124:[function(require,module,exports){
arguments[4][71][0].apply(exports,arguments)
},{"dup":71,"robust-orientation":123}],125:[function(require,module,exports){
arguments[4][72][0].apply(exports,arguments)
},{"dup":72}],126:[function(require,module,exports){
'use strict'

module.exports = polygonToPSLG

var cleanPSLG = require('clean-pslg')

//Converts a polygon to a planar straight line graph
function polygonToPSLG(loops, options) {
  if(!Array.isArray(loops)) {
    throw new Error('poly-to-pslg: Error, invalid polygon')
  }
  if(loops.length === 0) {
    return {
      points: [],
      edges:  []
    }
  }

  options = options || {}

  var nested = true
  if('nested' in options) {
    nested = !!options.nested
  } else if(loops[0].length === 2 && typeof loops[0][0] === 'number') {
    //Hack:  If use doesn't pass in a loop, then try to guess if it is nested
    nested = false
  }
  if(!nested) {
    loops = [loops]
  }

  //First we just unroll all the points in the dumb/obvious way
  var points = []
  var edges = []
  for(var i=0; i<loops.length; ++i) {
    var loop = loops[i]
    var offset = points.length
    for(var j=0; j<loop.length; ++j) {
      points.push(loop[j])
      edges.push([ offset+j, offset+(j+1)%loop.length ])
    }
  }

  //Then we run snap rounding to clean up self intersections and duplicate verts
  var clean = 'clean' in options ? true : !!options.clean
  if(clean) {
    cleanPSLG(points, edges)
  }

  //Finally, we return the resulting PSLG
  return {
    points: points,
    edges:  edges
  }
}

},{"clean-pslg":80}],127:[function(require,module,exports){
arguments[4][10][0].apply(exports,arguments)
},{"./lib/delaunay":128,"./lib/filter":129,"./lib/monotone":130,"./lib/triangulation":131,"dup":10}],128:[function(require,module,exports){
arguments[4][11][0].apply(exports,arguments)
},{"binary-search-bounds":132,"dup":11,"robust-in-sphere":133}],129:[function(require,module,exports){
arguments[4][12][0].apply(exports,arguments)
},{"binary-search-bounds":132,"dup":12}],130:[function(require,module,exports){
arguments[4][13][0].apply(exports,arguments)
},{"binary-search-bounds":132,"dup":13,"robust-orientation":144}],131:[function(require,module,exports){
arguments[4][14][0].apply(exports,arguments)
},{"binary-search-bounds":132,"dup":14}],132:[function(require,module,exports){
arguments[4][9][0].apply(exports,arguments)
},{"dup":9}],133:[function(require,module,exports){
arguments[4][15][0].apply(exports,arguments)
},{"dup":15,"robust-scale":135,"robust-subtract":136,"robust-sum":137,"two-product":138}],134:[function(require,module,exports){
arguments[4][16][0].apply(exports,arguments)
},{"dup":16}],135:[function(require,module,exports){
arguments[4][17][0].apply(exports,arguments)
},{"dup":17,"two-product":138,"two-sum":134}],136:[function(require,module,exports){
arguments[4][18][0].apply(exports,arguments)
},{"dup":18}],137:[function(require,module,exports){
arguments[4][19][0].apply(exports,arguments)
},{"dup":19}],138:[function(require,module,exports){
arguments[4][20][0].apply(exports,arguments)
},{"dup":20}],139:[function(require,module,exports){
arguments[4][16][0].apply(exports,arguments)
},{"dup":16}],140:[function(require,module,exports){
arguments[4][17][0].apply(exports,arguments)
},{"dup":17,"two-product":143,"two-sum":139}],141:[function(require,module,exports){
arguments[4][18][0].apply(exports,arguments)
},{"dup":18}],142:[function(require,module,exports){
arguments[4][19][0].apply(exports,arguments)
},{"dup":19}],143:[function(require,module,exports){
arguments[4][20][0].apply(exports,arguments)
},{"dup":20}],144:[function(require,module,exports){
arguments[4][26][0].apply(exports,arguments)
},{"dup":26,"robust-scale":140,"robust-subtract":141,"robust-sum":142,"two-product":143}],145:[function(require,module,exports){
arguments[4][73][0].apply(exports,arguments)
},{"boundary-cells":146,"dup":73,"reduce-simplicial-complex":150}],146:[function(require,module,exports){
arguments[4][74][0].apply(exports,arguments)
},{"dup":74}],147:[function(require,module,exports){
arguments[4][75][0].apply(exports,arguments)
},{"dup":75}],148:[function(require,module,exports){
arguments[4][58][0].apply(exports,arguments)
},{"dup":58}],149:[function(require,module,exports){
arguments[4][77][0].apply(exports,arguments)
},{"cell-orientation":147,"compare-cell":148,"dup":77}],150:[function(require,module,exports){
arguments[4][78][0].apply(exports,arguments)
},{"cell-orientation":147,"compare-cell":148,"compare-oriented-cell":149,"dup":78}],151:[function(require,module,exports){
'use strict'

var cdt2d     = require('cdt2d')
var boundary  = require('simplicial-complex-boundary')

module.exports = pslgToPolygon

function pslgToPolygon(points, edges) {
  //Get cells
  var cells = cdt2d(points, edges, {
    delaunay: false,
    exterior: false })

  //Extract boundary
  var bnd = boundary(cells)

  //Construct adjacency list from boundary
  var adj = new Array(points.length)
  for(var i=0; i<points.length; ++i) {
    adj[i] = []
  }

  for(var i=0; i<bnd.length; ++i) {
    var e = bnd[i]
    adj[e[0]].push(e[1])
  }

  //Extract boundary cycle
  var loops = []
  for(var i=0; i<points.length; ++i) {
    if(adj[i].length === 0) {
      continue
    }
    var v = i, loop = []
    do {
      loop.push(points[v])
      v = adj[v].pop()
    } while(v !== i)
    loops.push(loop)
  }

  return loops
}

},{"cdt2d":127,"simplicial-complex-boundary":145}],152:[function(require,module,exports){
//
// Perlin noise module.
//
// Written by Thom Chiovoloni, dedicated into the public domain (as explained at
// http://creativecommons.org/publicdomain/zero/1.0/).
//
var quickNoise = (function() {
	'use strict';

	function buildTable(randFunc) {
		if (!randFunc) {
			randFunc = Math.random;
		}
		// @NOTE(thom): could optimize this for allocations, but it
		// shouldn't be near anybody's fast path...
		var arr = new Array(256).map(function(v, i) { return i; });
		// shuffle numbers 0 through 255
		for (var i = arr.length-1; i > 0; --i) {
			var r = Math.floor(randFunc() * (i+1));
			var t = arr[r];
			arr[r] = arr[i];
			arr[i] = t;
		}
		return arr;
	}

	var gradBasis = [ 1,1,0, -1,1,0, 1,-1,0, -1,-1,0, 1,0,1, -1,0,1, 1,0,-1, -1,0,-1, 0,1,1, 0,-1,1, 0,1,-1, 0,-1,-1 ]

	function initTables(tab, permTable, gradTable) {
		if (tab == null || typeof tab === 'function') {
			tab = buildTable(tab)
		}
		else if (tab.length !== 256) {
			console.error("create(): Expected array of length 256, got ", tab);
			tab = buildTable();
		}
		for (var i = 0; i < 256; ++i) {
			permTable[i] = tab[i];
			permTable[i+256] = tab[i];
		}
		var gradIdx = 0;
		for (var i = 0; i < permTable.length; ++i) {
			var v = (permTable[i]%12)*3;
			gradTable[gradIdx++] = gradBasis[v];
			gradTable[gradIdx++] = gradBasis[v+1];
			gradTable[gradIdx++] = gradBasis[v+2];
		}
	}

	var permTableSize = 256*2;
	var gradTableSize = permTableSize*3;
	var totalSize = permTableSize + gradTableSize;

	//
	// function quickNoise.create(tableOrRng=Math.random);
	//
	// `tableOrRng` must either be:
	//
	// - A function that takes 0 arguments and returns a uniformly distributed
	//   random number between 0 and 1 (like `Math.random`).
	// - An array of length 256, where the array is generated by shuffling all
	//   integers between 0 and 255 (inclusive).
	//
	// If no argument (or a bad argument) is provided, it defaults to Math.random.
	//
	// This creates a perlin noise generation function. For more documentation about
	// the function returned by this call, see the documentation for `quickNoise.noise`, below.
	//
	// If you provide a function, this will be used only to generate the permutation table, and
	// will not be called after this function returns.
	//
	// The array argument provided in case you want to provide a specific permutation table.
	//

	function create(tab) {
		var ab = new ArrayBuffer(totalSize);
		var permTable = new Uint8Array(ab, 0, permTableSize);
		var gradTable = new Int8Array(ab, permTableSize, gradTableSize);
		initTables(tab, permTable, gradTable);

		function noise(x, y, z, xWrap, yWrap, zWrap) {
			// coersce to integers and handle missing arguments
			xWrap = xWrap | 0;
			yWrap = yWrap | 0;
			zWrap = zWrap | 0;

			// type hints for vm
			x = +x;
			y = +y;
			z = +z;

			var xMask = ((xWrap-1) & 255) >>> 0;
			var yMask = ((yWrap-1) & 255) >>> 0;
			var zMask = ((zWrap-1) & 255) >>> 0;

			var px = Math.floor(x);
			var py = Math.floor(y);
			var pz = Math.floor(z);

			var x0 = (px+0) & xMask;
			var x1 = (px+1) & xMask;

			var y0 = (py+0) & yMask;
			var y1 = (py+1) & yMask;

			var z0 = (pz+0) & zMask;
			var z1 = (pz+1) & zMask;

			x -= px;
			y -= py;
			z -= pz;

			var u = ((x*6.0-15.0)*x + 10.0) * x * x * x;
			var v = ((y*6.0-15.0)*y + 10.0) * y * y * y;
			var w = ((z*6.0-15.0)*z + 10.0) * z * z * z;

			var r0 = permTable[x0];
			var r1 = permTable[x1];

			var r00 = permTable[r0+y0];
			var r01 = permTable[r0+y1];
			var r10 = permTable[r1+y0];
			var r11 = permTable[r1+y1];

			var h000 = permTable[r00+z0] * 3;
			var h001 = permTable[r00+z1] * 3;
			var h010 = permTable[r01+z0] * 3;
			var h011 = permTable[r01+z1] * 3;
			var h100 = permTable[r10+z0] * 3;
			var h101 = permTable[r10+z1] * 3;
			var h110 = permTable[r11+z0] * 3;
			var h111 = permTable[r11+z1] * 3;

			var n000 = gradTable[h000]*(x+0) + gradTable[h000+1]*(y+0) + gradTable[h000+2]*(z+0);
			var n001 = gradTable[h001]*(x+0) + gradTable[h001+1]*(y+0) + gradTable[h001+2]*(z-1);
			var n010 = gradTable[h010]*(x+0) + gradTable[h010+1]*(y-1) + gradTable[h010+2]*(z+0);
			var n011 = gradTable[h011]*(x+0) + gradTable[h011+1]*(y-1) + gradTable[h011+2]*(z-1);
			var n100 = gradTable[h100]*(x-1) + gradTable[h100+1]*(y+0) + gradTable[h100+2]*(z+0);
			var n101 = gradTable[h101]*(x-1) + gradTable[h101+1]*(y+0) + gradTable[h101+2]*(z-1);
			var n110 = gradTable[h110]*(x-1) + gradTable[h110+1]*(y-1) + gradTable[h110+2]*(z+0);
			var n111 = gradTable[h111]*(x-1) + gradTable[h111+1]*(y-1) + gradTable[h111+2]*(z-1);

			var n00 = n000 + (n001-n000) * w;
			var n01 = n010 + (n011-n010) * w;
			var n10 = n100 + (n101-n100) * w;
			var n11 = n110 + (n111-n110) * w;

			var n0 = n00 + (n01-n00) * v;
			var n1 = n10 + (n11-n10) * v;

			return n0 + (n1-n0) * u;
		}
		return noise;
	}

	//
	// function quickNoise.noise(x, y, z, xWrap=0, yWrap=0, zWrap=0);
	//
	// - `x`, `y`, `z` are numbers.
	// - `xWrap`, `yWrap`, and `zWrap` are integer powers of two between 0 and 256.
	//   (0 and 256 are equivalent). If these aren't provided, they default to 0.
	//
	// This implements Ken Perlin's revised noise function from 2002, in 3D. It
	// computes a random value for the coordinate `x`, `y`, `z`, where adjacent
	// values are continuous with a period of 1 (Values at integer points are
	// entirely unrelated).
	//
	// This function is seeded. That is, it will return the same results when
	// called with the same arguments, across successive program runs. An unseeded
	// version may be created with the `quickNoise.create` function. The table it is
	// seeded is the one from the `stb_perlin.h` library.
	//
	var noise = create([
		23, 125, 161, 52, 103, 117, 70, 37, 247, 101, 203, 169, 124, 126, 44, 123,
		152, 238, 145, 45, 171, 114, 253, 10, 192, 136, 4, 157, 249, 30, 35, 72,
		175, 63, 77, 90, 181, 16, 96, 111, 133, 104, 75, 162, 93, 56, 66, 240,
		8, 50, 84, 229, 49, 210, 173, 239, 141, 1, 87, 18, 2, 198, 143, 57,
		225, 160, 58, 217, 168, 206, 245, 204, 199, 6, 73, 60, 20, 230, 211, 233,
		94, 200, 88, 9, 74, 155, 33, 15, 219, 130, 226, 202, 83, 236, 42, 172,
		165, 218, 55, 222, 46, 107, 98, 154, 109, 67, 196, 178, 127, 158, 13, 243,
		65, 79, 166, 248, 25, 224, 115, 80, 68, 51, 184, 128, 232, 208, 151, 122,
		26, 212, 105, 43, 179, 213, 235, 148, 146, 89, 14, 195, 28, 78, 112, 76,
		250, 47, 24, 251, 140, 108, 186, 190, 228, 170, 183, 139, 39, 188, 244, 246,
		132, 48, 119, 144, 180, 138, 134, 193, 82, 182, 120, 121, 86, 220, 209, 3,
		91, 241, 149, 85, 205, 150, 113, 216, 31, 100, 41, 164, 177, 214, 153, 231,
		38, 71, 185, 174, 97, 201, 29, 95, 7, 92, 54, 254, 191, 118, 34, 221,
		131, 11, 163, 99, 234, 81, 227, 147, 156, 176, 17, 142, 69, 12, 110, 62,
		27, 255, 0, 194, 59, 116, 242, 252, 19, 21, 187, 53, 207, 129, 64, 135,
		61, 40, 167, 237, 102, 223, 106, 159, 197, 189, 215, 137, 36, 32, 22, 5
	]);

	return {
		create: create,
		noise: noise
	};

}());

if (typeof module !== 'undefined' && module.exports) {
	module.exports = quickNoise;
}

},{}],153:[function(require,module,exports){
'use strict';

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var _require = require('./debug');

var ASSERT = _require.ASSERT;

var Vec2 = (function () {
	function Vec2(x, y) {
		_classCallCheck(this, Vec2);

		this.x = +x || 0.0;this.y = +y || 0.0;
	}

	Vec2.prototype.perp = function perp() {
		return new Vec2(-this.y, this.x);
	};

	Vec2.prototype.to = function to(o) {
		return new Vec2(o.x - this.x, o.y - this.y);
	};

	Vec2.prototype.dot = function dot(o) {
		return this.x * o.x + this.y * o.y;
	};

	Vec2.prototype.perpDot = function perpDot(o) {
		return -this.y * o.x + this.x * o.y;
	};

	Vec2.prototype.plus = function plus(o) {
		return new Vec2(this.x + o.x, this.y + o.y);
	};

	Vec2.prototype.minus = function minus(o) {
		return new Vec2(this.x - o.x, this.y - o.y);
	};

	Vec2.prototype.lenSq = function lenSq() {
		return this.x * this.x + this.y * this.y;
	};

	Vec2.prototype.len = function len() {
		return Math.sqrt(this.x * this.x + this.y * this.y);
	};

	Vec2.prototype.length = function length() {
		return this.len();
	};

	Vec2.prototype.lengthSquared = function lengthSquared() {
		return lenSq();
	};

	Vec2.prototype.scaled = function scaled(n) {
		return new Vec2(this.x * n, this.y * n);
	};

	Vec2.prototype.normalize = function normalize() {
		this.normalizeGetLen();return this;
	};

	Vec2.prototype.clone = function clone() {
		return new Vec2(this.x, this.y);
	};

	Vec2.prototype.copy = function copy(_ref) {
		var x = _ref.x;
		var y = _ref.y;
		this.x = x;;this.y = y;return this;
	};

	Vec2.prototype.scale = function scale(n) {
		this.x *= n;this.y *= n;return this;
	};

	Vec2.prototype.set = function set(x, y) {
		this.x = x;this.y = y;return this;
	};

	Vec2.prototype.clear = function clear() {
		return this.set(0.0, 0.0);
	};

	Vec2.prototype.add = function add(o) {
		this.x += o.x;this.y += o.y;return this;
	};

	Vec2.prototype.addScaled = function addScaled(o, n) {
		this.x += o.x * n;this.y += o.y * n;return this;
	};

	Vec2.prototype.translate = function translate(x, y) {
		this.x += x;this.y += y;return this;
	};

	Vec2.prototype.normalized = function normalized() {
		return this.clone().normalize();
	};

	Vec2.prototype.scaled = function scaled(n) {
		return this.clone().scale(n);
	};

	Vec2.prototype.toString = function toString() {
		return '(' + this.x + ', ' + this.y + ')';
	};

	Vec2.prototype.distance = function distance(o) {
		var dx = this.x - o.x,
		    dy = this.y - o.y;
		return Math.sqrt(dx * dx + dy * dy);
	};

	Vec2.prototype.distanceSq = function distanceSq(o) {
		this;
		var dx = this.x - o.x,
		    dy = this.y - o.y;
		return dx * dx + dy * dy;
	};

	Vec2.prototype.normalizeGetLen = function normalizeGetLen() {
		var l2 = this.x * this.x + this.y * this.y;
		if (l2 === 0.0) {
			this.x = 0.0;this.y = 1.0;return 0.00001;
		}
		var il = 1.0 / Math.sqrt(l2);
		this.x *= il;
		this.y *= il;
		this;
		return l2 * il;
	};

	Vec2.prototype.normalizeOrZero = function normalizeOrZero() {
		return this.scale(1.0 / (Math.sqrt(this.x * this.x + this.y * this.y) + 1e-37));
	};

	Vec2.prototype.xFlip = function xFlip() {
		var about = arguments.length <= 0 || arguments[0] === undefined ? 0.0 : arguments[0];
		this.x = 2.0 * about - this.x;return this;
	};

	Vec2.prototype.yFlip = function yFlip() {
		var about = arguments.length <= 0 || arguments[0] === undefined ? 0.0 : arguments[0];
		this.y = 2.0 * about - this.y;return this;
	};

	Vec2.prototype.rotate = function rotate(angle, about) {
		var aboutX = 0.0,
		    aboutY = 0.0;
		if (about) {
			aboutX = about.x;aboutY = about.y;
		}
		var x = this.x - aboutX;
		var y = this.y - aboutY;
		var c = Math.cos(angle);
		var s = Math.sin(angle);
		var nx = x * c - y * s;
		var ny = x * s + y * c;
		this.x = nx + aboutX;
		this.y = ny + aboutY;
		return this;
	};

	Vec2.prototype.rotate90 = function rotate90(about) {
		var aboutX = 0.0,
		    aboutY = 0.0;
		if (about) {
			aboutX = about.x;aboutY = about.y;
		}
		var x = this.x - aboutX;
		var y = this.y - aboutY;
		this.x = -y + aboutX;
		this.y = x + aboutY;
		return this;
	};

	Vec2.prototype.rotate180 = function rotate180(about) {
		var aboutX = 0.0,
		    aboutY = 0.0;
		if (about) {
			aboutX = about.x;aboutY = about.y;
		}
		var x = this.x - aboutX;
		var y = this.y - aboutY;
		this.x = -x + aboutX;
		this.y = -y + aboutY;
		return this;
	};

	Vec2.prototype.rotate270 = function rotate270(about) {
		var aboutX = 0.0,
		    aboutY = 0.0;
		if (about) {
			aboutX = about.x;aboutY = about.y;
		}
		var x = this.x - aboutX;
		var y = this.y - aboutY;
		this.x = y + aboutX;
		this.y = -x + aboutY;
		return this;
	};

	Vec2.prototype.rotate = function rotate(angle, about) {
		var aboutX = 0.0,
		    aboutY = 0.0;
		if (about) {
			aboutX = about.x;aboutY = about.y;
		}
		var sin = Math.sin(angle);
		var cos = Math.cos(angle);

		var x = this.x - aboutX;
		var y = this.y - aboutY;
		var nx = cos * x - sin * y;
		var ny = sin * x + cos * y;
		this.x = nx + aboutX;
		this.y = ny + aboutY;
		return this;
	};

	Vec2.prototype.rotated90 = function rotated90(about) {
		return this.clone().rotate90(about);
	};

	Vec2.prototype.rotated180 = function rotated180(about) {
		return this.clone().rotate180(about);
	};

	Vec2.prototype.rotated270 = function rotated270(about) {
		return this.clone().rotate270(about);
	};

	Vec2.prototype.xFlipped = function xFlipped(aboutX) {
		return this.clone().xFlip(aboutX);
	};

	Vec2.prototype.yFlipped = function yFlipped(aboutY) {
		return this.clone().yFlip(aboutY);
	};

	Vec2.prototype.nanCheck = function nanCheck() {
		ASSERT(+this.x === this.x);
		ASSERT(+this.y === this.y);
		return this;
	};

	return Vec2;
})();

Vec2.ZERO = Object.freeze(new Vec2(0.0, 0.0));

Vec2.zero = function () {
	return new Vec2(0.0, 0.0);
};
Vec2.fromDir = function (dir) {
	return new Vec2(Math.cos(dir), Math.sin(dir));
};
Vec2.towards = function (p0, p1) {
	return new Vec2(p1.x - p0.x, p1.y - p0.y);
};
Vec2.towardsXY = function (x0, y0, x1, y1) {
	return new Vec2(x1 - x0, y1 - y0);
};

Vec2.Pool = {
	items: [],
	count: 0,
	get: function get(x, y) {
		if (this.count === this.items.length) this.items.push(new Vec2(0.0, 0.0));
		return this.items[this.count++].set(+x || 0.0, +y || 0.0);
	},
	reset: function reset() {
		this.count = 0;
	},
	update: function update() {
		this.count = 0;
	}
};

Vec2.temp = function (x, y) {
	return Vec2.Pool.get(x, y);
};

module.exports = Vec2;

},{"./debug":161}],154:[function(require,module,exports){
'use strict';

var _require = require('./rand');

var RNG = _require.RNG;

function soundVariations(src) {
	var min = arguments.length <= 1 || arguments[1] === undefined ? 0.8 : arguments[1];
	var max = arguments.length <= 2 || arguments[2] === undefined ? 1.5 : arguments[2];
	var count = arguments.length <= 3 || arguments[3] === undefined ? 10 : arguments[3];

	var res = [new Howl({ src: src, volume: 0.2, rate: 1 })];
	for (var rate = min; rate <= max; rate += (max - min) / count) {
		res.push(new Howl({ rate: rate, src: src, volume: 0.2 }));
	}return res;
}
var Sounds = {
	currentSong: null,
	boom: soundVariations(['res/boom1.wav']),
	bang: soundVariations(['res/bang2.mp3'], 1, 1.1, 5),
	ouch: soundVariations(['res/big-ouch.mp3']),
	monstOuch: soundVariations(['res/monst-ouch.mp3']),
	growl: soundVariations(['res/growl.mp3'], 1.0, 2.0),
	unlock: soundVariations(['res/unlock.wav']),
	die: soundVariations(['res/die.mp3'], 0.9, 1.0),
	stop: [new Howl({ src: ['res/stop.mp3'], volume: 0.2 })],
	wait: [new Howl({ src: ['res/wait.mp3'], volume: 0.2 })],

	bangs: [new Howl({ src: ['res/bang1.wav'], rate: 1 }), new Howl({ src: ['res/bang1.wav'], rate: 0.9 }), new Howl({ src: ['res/bang1.wav'], rate: 1.1 }), new Howl({ src: ['res/bang1.wav'], rate: 1.5 }), new Howl({ src: ['res/bang1.wav'], rate: 0.8 })],
	song1: new Howl({ src: ['res/menubg.ogg', 'res/menubg.mp3'], loop: true, volume: 0.5 }),
	song2: new Howl({ src: ['res/song2.ogg', 'res/song2.mp3'], loop: true, volume: 0.5 }),
	song3: new Howl({ src: ['res/song3.ogg', 'res/song3.mp3'], loop: true, volume: 0.5 }),
	wobbles: new Howl({
		src: ['res/wobbles.ogg', 'res/wobbles.mp3'],
		sprite: {
			wobble0: [0, 8000],
			wobble1: [12500, 19000],
			wobble2: [24200, 31600],
			wobble3: [36300, 43600],
			wobble4: [47800, 56000],
			wobble5: [59400, 67800]
		}
	}),

	stopMusic: function stopMusic() {
		var _this = this;

		var fade = arguments.length <= 0 || arguments[0] === undefined ? false : arguments[0];

		if (this.currentSong == null) return;
		if (fade) {
			(function () {
				var cs = _this.currentSong;
				cs.fade(0.5, 0.0, 1.0);
				cs.once('faded', function () {
					return cs.stop();
				});
			})();
		} else {
			cs.stop();
		}
		this.currentSong = null;
	},
	playMusic: function playMusic(id) {
		var _this2 = this;

		var fade = arguments.length <= 1 || arguments[1] === undefined ? true : arguments[1];

		if (!(id in this)) id = 'song' + id;
		if (this.currentSong) {
			(function () {
				var cs = _this2.currentSong;
				var ns = _this2.currentSong = _this2[id];
				if (fade) {
					cs.fade(0.5, 0.0, 1.0);
					cs.once('faded', function () {
						cs.stop();
						if (ns === _this2.currentSong) {
							ns.play();
							ns.fade(0.0, 0.5, 1.0);
						}
					});
				} else {
					cs.stop();
					ns.play();
				}
			})();
		} else if (id in this) {
			this.currentSong = this[id];
			this.currentSong.play();
			if (fade) {
				this.currentSong.fade(0.0, 0.5, 1.0);
			}
		}
	},
	playEffect: function playEffect(name) {
		if (name === 'wobble') this.playWobble();else if (name in this) {
			RNG.choose(this[name]).play();
		} else {
			console.warn('cnat play ' + name);
		}
	},
	playWobble: function playWobble() {
		var which = arguments.length <= 0 || arguments[0] === undefined ? -1 : arguments[0];

		if (which < 0) {
			which = RNG.upTo(6);
		}
		this.wobbles.play('wobble' + which % 5);
	}
};

Sounds.play = Sounds.playEffect;

window.Sounds = Sounds;

module.exports = Sounds;

},{"./rand":179}],155:[function(require,module,exports){
'use strict';

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var Particle = require('./particle');
var Consts = require('./constants');
var Clock = require('./clock');

var _require = require('./rand');

var RNG = _require.RNG;

var math = require('./math');

var Blood = (function (_Particle) {
	_inherits(Blood, _Particle);

	function Blood(game, x, y, z) {
		_classCallCheck(this, Blood);

		var _this = _possibleConstructorReturn(this, _Particle.call(this, game, x, y, z));

		_this.collidesWithEntities = false;
		_this.collidesWithPlayer = false;
		_this.radius = 0.5;
		_this.zAcc = -80;

		_this.color = RNG.colorBetween(0xff000060, 0xff000080);
		_this.zBounce = 0.1;
		return _this;
	}

	Blood.prototype.update = function update(dt) {
		_Particle.prototype.update.call(this, dt);
		if (RNG.oneChanceIn(10)) {
			this.game.bloodBuffer.putPixel(Math.round(this.pos.x), Math.round(this.pos.y), this.color);
		}
	};

	Blood.prototype.onGroundCollision = function onGroundCollision() {
		this.game.bloodBuffer.putPixel(Math.round(this.pos.x), Math.round(this.pos.y), this.color);
	};

	return Blood;
})(Particle);

module.exports = Blood;

},{"./clock":158,"./constants":160,"./math":175,"./particle":176,"./rand":179}],156:[function(require,module,exports){
'use strict';

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var _require = require('./tweens');

var Tween = _require.Tween;
var TweenGroup = _require.TweenGroup;

var Entity = require('./entity');
var Input = require('./input');
var drawing = require('./drawing');
var Consts = require('./constants');
var Clock = require('./clock');

var _require2 = require('./rand');

var RNG = _require2.RNG;

var Gore = require('./gore');
var Sounds = require('./audio');

var Bullet = (function (_Entity) {
	_inherits(Bullet, _Entity);

	function Bullet(game, shooter, dx, dy) {
		var dmg = arguments.length <= 4 || arguments[4] === undefined ? RNG.upTo(4) : arguments[4];
		var speed = arguments.length <= 5 || arguments[5] === undefined ? 400 : arguments[5];

		_classCallCheck(this, Bullet);

		var _this = _possibleConstructorReturn(this, _Entity.call(this, game, shooter.pos.x + dx * shooter.radius, shooter.pos.y + dy * shooter.radius));

		Sounds.play('bang');
		_this.dmg = dmg;
		_this.speed = speed;
		_this.shooter = shooter;
		_this.drag.set(0, 0);
		_this.vel.x = dx * _this.speed;
		_this.vel.y = dy * _this.speed;
		_this.life = 3.0;
		_this.timed = true;
		return _this;
	}

	Bullet.prototype.render = function render(ctx, buffer, minX, minY) {
		var x0 = Math.round(this.pos.x - minX);
		var y0 = Math.round(this.pos.y - minY);
		var x1 = Math.round(this.lastPos.x - minX);
		var y1 = Math.round(this.lastPos.y - minY);

		var dx = x1 - x0,
		    dy = y1 - y0;
		var dist = Math.ceil(Math.sqrt(dx * dx + dy * dy));
		for (var i = 0; i < dist; ++i) {
			// if (RNG.xChanceInY(i, dist)) continue;
			var br = i * 128 / dist + 64 & 0xff;
			var xx = x0 - dx * i / dist | 0;
			var yy = y0 - dy * i / dist | 0;
			var pixel = 0xff000000 | br * 0x10101;
			buffer.putPixel(xx, yy, pixel);
		}
	};

	Bullet.prototype.onCollision = function onCollision(who) {
		if (!this.enabled) return;
		if (who != null && who != this.shooter) {
			who.damage(this.dmg, this.pos, this.vel);
			this.enabled = false;
		}
		if (who != this.shooter) this.enabled = false;
	};

	return Bullet;
})(Entity);

module.exports = Bullet;

},{"./audio":154,"./clock":158,"./constants":160,"./drawing":162,"./entity":164,"./gore":168,"./input":169,"./rand":179,"./tweens":180}],157:[function(require,module,exports){
'use strict';

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var math = require('./math');
var Vec2 = require('./vec2');
var Clock = require('./clock');

var _require = require('./rand');

var RNG = _require.RNG;

var _require2 = require('./debug');

var ASSERT = _require2.ASSERT;

var Input = require('./input');
var Consts = require('./constants');

var Camera = (function () {
	function Camera(game, focus, target, width, height) {
		_classCallCheck(this, Camera);

		this.game = game;
		this.focus = focus;
		this.target = target;
		// this.realTarget = new Vec2(0.0, 0.0);
		this.width = width;
		this.height = height;
		this.goal = new Vec2(0.0, 0.0);
		this.unclampedPos = new Vec2(0.0, 0.0);
		this.pos = new Vec2(0.0, 0.0);
		// this.vel = new Vec2(0.0, 0.0);
		// this.maxSpeed = Number.MAX_VALUE;
		// this.smoothing = 0.3;
		this.jitterLevel = 0;
		this.shake = new Vec2(0.0, 0.0);
		this.shakeDrag = 0.2;
		this.driftMul = new Vec2(0.1, 0.2);

		this.lookahead = 1.1;
		this.speed = 2.5;

		this.minX = 0;
		this.maxX = width;
		this.minY = 0;
		this.maxY = height;
	}

	Camera.prototype.xBound = function xBound() {
		return this.game.width;
	};

	Camera.prototype.yBound = function yBound() {
		return this.game.height;
	};

	Camera.prototype.setPosition = function setPosition(nx, ny, reset) {
		if (reset) {
			// this.vel.set(0, 0);
			this.goal.set(nx, ny);
			this.shake.set(0, 0);
		}
		this.unclampedPos.set(nx, ny);
		this.pos.x = math.clamp(nx, this.width * 0.5, this.xBound() - this.width * 0.5);
		this.pos.y = math.clamp(ny, this.height * 0.5, this.yBound() - this.height * 0.5);

		this.minX = this.pos.x - this.width * 0.5;
		this.minY = this.pos.y - this.height * 0.5;

		this.maxX = this.minX + this.width;
		this.maxY = this.minY + this.height;

		var _focus = this.focus;
		var _focus$pos = _focus.pos;
		var fx = _focus$pos.x;
		var fy = _focus$pos.y;
		var radius = _focus.radius;

		// @HACK: prevent camera from not containing player...

		if (fx - radius < this.minX) {
			this.minX = fx - radius;
			this.pos.x = this.minX + this.width * 0.5;
			this.maxX = this.minX + this.width;
		}

		if (fy - radius < this.minY) {
			this.minY = fy - radius;
			this.pos.y = this.minY + this.height * 0.5;
			this.maxY = this.minY + this.height;
		}

		if (fx + radius > this.maxX) {
			this.maxX = fx + radius;
			this.pos.x = this.maxX - this.width * 0.5;
			this.minX = this.maxX - this.width;
		}

		if (fy + radius > this.maxY) {
			this.maxY = fy + radius;
			this.pos.y = this.maxY - this.height * 0.5;
			this.minY = this.maxY - this.height;
		}
		ASSERT(+this.minX === this.minX);
		ASSERT(+this.minY === this.minY);
		ASSERT(+this.maxX === this.maxX);
		ASSERT(+this.maxY === this.maxY);
		this.pos.nanCheck();
		// this.vel.nanCheck();
		this.goal.nanCheck();
		this.target.nanCheck();
	};

	Camera.prototype.update = function update(dt) {
		var cx = this.pos.x;
		var cy = this.pos.y;
		var fx = this.focus.pos.x;
		var fy = this.focus.pos.y;

		if (Math.abs(fx - cx) < 100 / Consts.SCALE) {
			fx = cx;
		}
		if (Math.abs(fy - cy) < 100 / Consts.SCALE) {
			fy = cy;
		}

		var fvx = this.focus.vel.x * 0.1;
		var fvy = this.focus.vel.y * 0.1;

		var gx = fx + fvx * this.lookahead;
		var gy = fy + fvy * this.lookahead;
		var aiming = false;
		var aimDiv = 1;

		if (Input.mouse.isDown) {
			// aiming = true;
			aimDiv = 4;
		}

		if (Input.keyboard.isDown('space')) {
			// aiming = true;
			aimDiv = 2;
		}

		if (aiming) {
			var mwx = this.game.mouse.x;
			var mwy = this.game.mouse.y;

			var frx = mwx - this.focus.pos.x;
			var fry = mwy - this.focus.pos.y;
			gx += frx / aimDiv;
			gy += fry / aimDiv;
		}

		gx = math.clamp(gx, this.width / 2, this.xBound() - this.width / 2);
		gy = math.clamp(gy, this.height / 2, this.yBound() - this.height / 2);

		var nx = gx - cx;
		var ny = gy - cy;

		var relax = 1.0 - Math.exp(-this.speed * dt);

		nx = this.pos.x + nx * relax;
		ny = this.pos.y + ny * relax;

		this.setPosition(nx, ny);

		/*
  smoothDampV2(this.goal, this.goal, this.target, this.vel, this.smoothing, this.maxSpeed, dt);
  let driftX = Math.cos(Clock.accumTime*this.driftMul.x) * 5 * this.jitterLevel
  let driftY = Math.cos(Clock.accumTime*this.driftMul.y) * 5 * this.jitterLevel
  	this.unclampedPos.x = this.goal.x + driftX + this.shake.x;
  this.unclampedPos.y = this.goal.y + driftY + this.shake.y;
  	this.shake.x -= this.shakeDrag*this.shake.x*dt;
  this.shake.y -= this.shakeDrag*this.shake.y*dt;
  	this.setPosition(this.unclampedPos.x, this.unclampedPos.y);*/
	};

	return Camera;
})();

module.exports = Camera;

},{"./clock":158,"./constants":160,"./debug":161,"./input":169,"./math":175,"./rand":179,"./vec2":182}],158:[function(require,module,exports){
'use strict';

var Clock = {};

Clock.now = window.performance ? function () {
  return performance.now();
} : Date.now;

Clock.ticks = 0;
Clock.fps = 60.0;
Clock.time = 0.0;
Clock.realTime = 0.0;
Clock.accumTime = 0.0;
Clock.deltaTime = 1.0 / Clock.fps;
Clock.realDeltaTime = Clock.deltaTime;

Clock.timeScale = 1.0;

// debugging
window.CLOCK = Clock;

module.exports = Clock;

},{}],159:[function(require,module,exports){
'use strict';

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var _require = require('./debug');

var ASSERT = _require.ASSERT;

var scratchArray = [];

var CollisionGrid = (function () {
	function CollisionGrid(width, height, cellSize) {
		_classCallCheck(this, CollisionGrid);

		this.width = Math.ceil(width / cellSize);
		this.height = Math.ceil(height / cellSize);
		this.cellSize = cellSize;
		this.cells = new Array(this.width * this.height);
		for (var i = 0; i < this.width * this.height; ++i) {
			this.cells[i] = [];
		}
	}

	CollisionGrid.prototype.add = function add(e) {
		ASSERT(e.pos.x >= 0 && e.pos.x < this.width * this.cellSize);
		ASSERT(e.pos.y >= 0 && e.pos.y < this.height * this.cellSize);
		ASSERT(e._cell === -1);
		var cellX = Math.floor(e.pos.x / this.cellSize);
		var cellY = Math.floor(e.pos.y / this.cellSize);

		var cellIndex = cellX + cellY * this.width;
		var newCell = this.cells[cellIndex];
		e._cell = cellIndex;
		e._indexInCell = newCell.length;
		newCell.push(e);
	};

	CollisionGrid.prototype.remove = function remove(e) {
		ASSERT(e._cell !== -1);
		ASSERT(e._indexInCell !== -1);
		var cell = this.cells[e._cell];
		ASSERT(cell[e._indexInCell] === e);
		var indexInCell = e._indexInCell;

		cell[indexInCell] = cell[cell.length - 1];
		cell[indexInCell]._indexInCell = indexInCell;
		cell.pop();
		e._cell = -1;
		e._indexInCell = -1;
	};

	CollisionGrid.prototype.update = function update(e) {
		this.remove(e);
		this.add(e);
	};

	CollisionGrid.prototype.entitiesAround = function entitiesAround(e) {
		var result = scratchArray;

		var cells = this.cells;
		var width = this.width;
		var height = this.height;

		var cellY = Math.floor(e._cell / width);
		var cellX = e._cell % width;

		var minX = Math.max(0, cellX - 1);
		var maxX = Math.min(cellX + 1, width - 1);

		var minY = Math.max(0, cellY - 1);
		var maxY = Math.min(cellY + 1, height - 1);

		for (var y = minY; y <= maxY; ++y) {
			for (var x = minX; x <= maxX; ++x) {
				var cellIndex = x + y * width;
				var cell = cells[cellIndex];
				for (var i = 0, l = cell.length; i < l; ++i) {
					result.push(cell[i]);
				}
			}
		}
		return result;
	};

	// getCollidablePairs(outP0, outP1, entities) {
	// 	let lookup = {};
	// 	outP1.length = 0;
	// 	outP0.length = 0;
	// 	let {cells, width, height} = this;
	// 	for (let y = 0; y < height; ++y) {
	// 		for (let x = 0; x < width; ++x) {
	// 			const minX = Math.max(0, x-1);
	// 			const maxX = Math.min(x+1, width-1);
	// 			const minY = Math.max(0, y-1);
	// 			const maxY = Math.min(y+1, height-1);

	// 			for (let yy = minY; yy <= maxY; ++yy) {
	// 				for (let xx = minX; xx <= maxX; ++xx) {
	// 					const cellIndex = xx + yy * width;
	// 					const cell = cells[cellIndex];
	// 					for (let i = 0, l = cell.length; i < l; ++i) {
	// 					}
	// 				}
	// 			}

	// 		}
	// 	}
	// }

	return CollisionGrid;
})();

module.exports = CollisionGrid;

},{"./debug":161}],160:[function(require,module,exports){
'use strict';

var FPS = exports.FPS = 60.0;
var Scale = exports.Scale = 3;

var ClientScreenWidth = exports.ClientScreenWidth = 960;
var ClientScreenHeight = exports.ClientScreenHeight = 540;

var ScreenHeight = exports.ScreenHeight = ClientScreenHeight / Scale >>> 0;
var ScreenWidth = exports.ScreenWidth = ClientScreenWidth / Scale >>> 0;

var DevicePixels = exports.DevicePixels = window.devicePixelRatio || window.webkitDevicePixelRatio || 1.0;

var TileSize = exports.TileSize = 16;

},{}],161:[function(require,module,exports){
'use strict';

var DEBUG = false;

window.DEBUG = DEBUG;

function assert(cnd, msg) {
	if (cnd) return;
	console.error("Assertation failed: " + (msg || "no message"));
	throw new Error("Assertation failure");
}

if (window.DEBUG) {
	window.ASSERT = exports.ASSERT = assert;
} else {
	window.ASSERT = exports.ASSERT = function () {};
}

exports.debug = DEBUG;

},{}],162:[function(require,module,exports){
'use strict';

exports.blitFullCanvas = blitFullCanvas;
function blitFullCanvas(context, canvas) {
	context.drawImage(canvas, 0, 0, canvas.width, canvas.height, 0, 0, context.canvas.width, context.canvas.height);
}

// these are mostly for the debug canvas
exports.drawLine = drawLine;
function drawLine(ctx, x0, y0, x1, y1) {
	var _ref = arguments.length <= 5 || arguments[5] === undefined ? {} : arguments[5];

	var _ref$endpoints = _ref.endpoints;
	var endpoints = _ref$endpoints === undefined ? false : _ref$endpoints;
	var _ref$color = _ref.color;
	var color = _ref$color === undefined ? '' : _ref$color;

	var oldStrokeStyle = ctx.strokeStyle;
	if (color) ctx.strokeStyle = color;
	ctx.beginPath();
	ctx.moveTo(x0, y0);
	ctx.lineTo(x1, y1);
	ctx.stroke();
	if (endpoints) {
		drawBox(ctx, x0, y0);
		drawBox(ctx, x1, y1);
	}
	if (color) ctx.strokeStyle = oldStrokeStyle;
}

exports.drawBox = drawBox;
function drawBox(ctx, x, y) {
	var sz = arguments.length <= 3 || arguments[3] === undefined ? 2 : arguments[3];

	var hs = sz / 2;
	ctx.strokeRect(x - hs, y - hs, sz, sz);
}

exports.drawArrow = drawArrow;
function drawArrow(ctx, x0, y0, x1, y1, n) {
	drawLine(ctx, x0, y0, x1, y1);
	var dx = x0 - x1,
	    dy = y0 - y1;
	var l = Math.sqrt(dx * dx + dy * dy);
	if (l !== 0.0) {
		dx /= l;
		dy /= l;
		drawLine(ctx, x1, y1, x1 + n * dx + n * dy, y1 + n * dy - n * dx);
	}
}

exports.drawCircle = drawCircle;
function drawCircle(ctx, x0, y0, r) {
	ctx.beginPath();
	ctx.moveTo(x0, y0);
	ctx.arc(x0, y0, r, 0, Math.PI * 2);
	ctx.stroke();
}

},{}],163:[function(require,module,exports){
'use strict';

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var Entity = require('./entity');
var Input = require('./input');

var _require = require('./rand');

var RNG = _require.RNG;

var drawing = require('./drawing');
var Consts = require('./constants');
var Clock = require('./clock');
var Bullet = require('./bullet');
var Gore = require('./gore');
var Blood = require('./blood');
var Sounds = require('./audio');
var math = require('./math');
var Vec2 = require('./vec2');
var STATE = {
	Wander: 0,
	Attack: 1,
	Search: 2,
	Wait: 3
};

var Enemy = (function (_Entity) {
	_inherits(Enemy, _Entity);

	function Enemy(game, x, y) {
		_classCallCheck(this, Enemy);

		var _this = _possibleConstructorReturn(this, _Entity.call(this, game, x, y));

		_this.radius = 5.0;
		_this.normalizeAccel = true;
		_this.speed = 14 * 20;
		_this.drag.set(8, 8);
		_this.walking = false;
		_this.animProgress = 0.0;
		_this.maxHealth = 15;
		_this.health = _this.maxHealth;
		_this.castsShadow = true;
		_this.targetPos = new Vec2();
		_this.haveTarget = false;
		_this.lastSawPlayer = new Vec2();
		_this.state = STATE.Wander;
		_this.waitTimer = 0.0;
		_this.shootTimer = 0.0;
		_this.type = RNG.upTo(_this.game.assets.enemyRotations.length);
		return _this;
	}

	Enemy.prototype.pickRandomTarget = function pickRandomTarget() {
		var p = Vec2.temp(),
		    n = Vec2.temp();
		for (var i = 0; i < 3; ++i) {
			var v = Vec2.temp(RNG.betweenF(-1, 1), RNG.betweenF(-1, 1)).normalize();
			var r = this.game.raycast(this.targetPos, n, this.pos, v, 1000);
			if (r > 20 || RNG.oneChanceIn(10)) {
				this.moveTowards(this.targetPos);
				this.state = STATE.Wander;
				return;
			}
		}
		this.state = STATE.Wait;
	};

	Enemy.prototype.onCollision = function onCollision(who) {
		if (this.state === STATE.Wander && who == null) {
			this.pickRandomTarget();
		}
	};

	Enemy.prototype.damage = function damage(amt, pos, vel) {
		this.health -= amt;
		if (this.health <= 0) {
			Sounds.play('die');
			this.solid = false;
			this.castsShadow = false;
			this.game.grid.remove(this);
			this.collidesWithEntities = false;
			this.collidesWithPlayer = false;
		} else {
			Sounds.play('monstOuch');
		}
		this.drag.x += 2;
		this.drag.y += 2;

		var gib = new Gore(this.game, pos.x, pos.y);
		gib.vel.scale(0.1).addScaled(vel, 0.4);
		this.game.addEntity(gib);
	};

	Enemy.prototype.moveTowards = function moveTowards(pos) {
		var fy = pos.y - this.pos.y;
		var fx = pos.x - this.pos.x;
		var len = Math.sqrt(fx * fx + fy * fy);

		this.acc.set((pos.x - this.pos.x) / Consts.TileSize, (pos.y - this.pos.y) / Consts.TileSize);
		this.walking = true;
		this.heading = Math.atan2(fy, fx);
	};

	Enemy.prototype.think = function think(dt) {
		if (this.health <= 0) return;

		if (this.health != this.maxHealth) {
			if (RNG.xChanceInY(this.maxHealth - this.health, this.maxHealth)) {
				var blood = new Blood(this.game, this.pos.x, this.pos.y);
				blood.zPos = 5;
				blood.vel.x *= 0.05;blood.vel.x += this.vel.x;
				blood.vel.y *= 0.05;blood.vel.y += this.vel.y;
				this.game.addEntity(blood);
			}
		}

		if (this.walking) {
			this.animProgress += Math.min(this.lastPos.distance(this.pos) / 10, 1);
		}

		if (this.state === STATE.Wander) {
			this.drag.set(10, 10);
		} else {
			this.drag.set(8, 8);
		}

		var canSeePlayer = this.game.canSee(this.pos, this.game.player.pos);
		if (canSeePlayer && this.state !== STATE.Attack) {
			Sounds.play(RNG.choose(['wait', 'stop']));
			this.state = STATE.Attack;
			this.lastSawPlayer.copy(this.game.player.pos);
			this.shootAt(this.game.player.pos);
		} else if (this.state === STATE.Attack && !canSeePlayer) {
			this.state = STATE.Search;
		}

		switch (this.state) {
			case STATE.Wander:
				if (this.pos.distance(this.targetPos) < 8) {
					this.waitTimer = RNG.betweenF(1.0, 3.0);
					this.state = STATE.Wait;
				} else {
					this.moveTowards(this.targetPos);
				}
				break;
			case STATE.Wait:
				this.waitTimer -= dt;
				if (this.waitTimer < 0) {
					this.state = STATE.Wander;
					this.pickRandomTarget();
				} else {
					if (RNG.oneChanceIn(60)) {
						this.heading = RNG.betweenF(0, Math.PI * 2);
					}
					if (RNG.oneChanceIn(60)) {
						this.acc.set(RNG.betweenF(-10, 10), RNG.betweenF(-10, 10));
					}
				}

				break;
			case STATE.Search:
				if (this.pos.distance(this.lastSawPlayer) < 8) {
					this.state = STATE.Wait;
					this.waitTimer = RNG.betweenF(0.0, 1.0);
				} else {
					this.moveTowards(this.game.player.pos);
				}
				break;
			case STATE.Attack:
				this.shootTimer -= dt;
				var pdist = this.pos.distance(this.game.player.pos);
				if (pdist < 30) {
					this.shootTimer -= dt * 2;
				}
				if (pdist < 100) {
					this.moveTowards(this.game.player.pos);
				}
				if (this.shootTimer < 0) {
					this.shootAt(this.game.player.pos);
				}
				break;
		}
	};

	Enemy.prototype.postUpdate = function postUpdate() {
		this.acc.set(0, 0);
	};

	Enemy.prototype.shootAt = function shootAt(pos) {
		var fy = pos.y - this.pos.y;
		var fx = pos.x - this.pos.x;
		var len = Math.sqrt(fx * fx + fy * fy);
		if (len != 0) {
			var bullet = new Bullet(this.game, this, fx / len, fy / len);
			this.game.addEntity(bullet);
		}
		this.shootTimer = RNG.betweenF(1, 4);
	};

	Enemy.prototype.render = function render(layer) {
		if (!this.game.canSee(this.game.player.pos, Vec2.temp(this.pos.x + this.radius, this.pos.y + this.radius)) && !this.game.canSee(this.game.player.pos, Vec2.temp(this.pos.x + this.radius, this.pos.y - this.radius)) && !this.game.canSee(this.game.player.pos, Vec2.temp(this.pos.x - this.radius, this.pos.y + this.radius)) && !this.game.canSee(this.game.player.pos, Vec2.temp(this.pos.x - this.radius, this.pos.y - this.radius))) {
			return;
		}
		if (this.health <= 0) {
			layer.context.drawImage(this.game.assets.deadEnemies[this.type].canvas, 0, 0, 32, 16, Math.round(this.pos.x - 16), Math.round(this.pos.y - 8), 32, 16);
			layer.context.drawImage(this.game.assets.deadEnemies[this.type].canvas, 0, 16, 32, 16, Math.round(this.pos.x - 16), Math.round(this.pos.y - 8), 32, 16);
		} else {
			var rotation = Math.round(this.heading / (Math.PI * 2) * 16) & 15;

			var anim = (this.walking ? Math.floor(this.animProgress % 7) : 0) + 0;
			layer.context.drawImage(this.game.assets.enemyRotations[this.type].canvas, 16 * anim, 16 * rotation, 16, 16, Math.round(this.pos.x - 8), Math.round(this.pos.y - 8), 16, 16);
		}
		// drawing.drawCircle(this.game.debugContext, this.pos.x, this.pos.y, this.radius);
		//(layer.context, this.pos.x-mx, this.pos.y-my, this.radius);
	};

	return Enemy;
})(Entity);

module.exports = Enemy;

},{"./audio":154,"./blood":155,"./bullet":156,"./clock":158,"./constants":160,"./drawing":162,"./entity":164,"./gore":168,"./input":169,"./math":175,"./rand":179,"./vec2":182}],164:[function(require,module,exports){
'use strict';

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var _require = require('./tweens');

var Tween = _require.Tween;
var TweenGroup = _require.TweenGroup;

var _require2 = require('./math');

var distance2D = _require2.distance2D;

var Vec2 = require('./vec2');
var LineSegment = require('./line_segment');

var Entity = (function () {
	function Entity(game) {
		var x = arguments.length <= 1 || arguments[1] === undefined ? 0.0 : arguments[1];
		var y = arguments.length <= 2 || arguments[2] === undefined ? 0.0 : arguments[2];
		var z = arguments.length <= 3 || arguments[3] === undefined ? 0.0 : arguments[3];

		_classCallCheck(this, Entity);

		this.game = game;
		this.id = Entity.idCounter++;
		this.pos = new Vec2(x, y);
		this.vel = new Vec2(0, 0);
		this.radius = 1.0;
		this.enabled = true;
		this.elastic = false;

		this.collidesWithWorld = true;
		this.collidesWithEntities = true;
		this.collidesWithPlayer = true;
		this.life = 0;
		this.timed = false;

		this.tweenGroup = new TweenGroup();

		this.mobile = true;
		this.solid = true;
		this.castsShadow = false;

		this.alpha = 1.0;
		this.lastPos = new Vec2(0.0, 0.0);
		this.acc = new Vec2(0.0, 0.0);
		this.drag = new Vec2(0.0, 0.0);
		this.collisionIterations = 1;

		this.heading = 0;
		this.shadowSegments = null;

		this.normalizeAccel = false;
		this.speed = 1;

		this._cell = -1;
		this._indexInCell = -1;
		this.elasticity = 0.4;
		// @@@HACK
		this.hasZ = false;
		this.zPos = z;
		this.zVel = 0;
		this.zAcc = 0;
		this.zDrag = 0;
		this.zBounce = 0.8;
	}

	Entity.prototype.think = function think(dt) {};

	Entity.prototype.postUpdate = function postUpdate(dt) {};

	Entity.prototype.tryGridUpdate = function tryGridUpdate() {
		try {
			this.game.grid.update(this);
		} catch (e) {
			this.enabled = false;
		}
	}; // @@HACK}

	Entity.prototype.update = function update(dt) {
		if (!this.enabled) return;
		this.think(dt);
		this.tweenGroup.update(dt);
		if (this.mobile) {
			this.move(dt);
			if (this.collidesWithEntities || this.collidesWithPlayer) {
				this.tryGridUpdate();
			}
		}
		if (this.timed) {
			this.life -= dt;
			if (this.life <= 0) {
				this.enabled = false;
			}
		}
	};

	Entity.prototype.damage = function damage() {};

	Entity.prototype.updateShadowSegments = function updateShadowSegments() {
		var minX = this.pos.x - this.radius / 2;
		var maxX = this.pos.x + this.radius / 2;
		var minY = this.pos.y - this.radius / 2;
		var maxY = this.pos.y + this.radius / 2;

		var t0 = Vec2.temp(minX, minY).rotate(this.heading, this.pos);
		var t1 = Vec2.temp(minX, maxY).rotate(this.heading, this.pos);
		var t2 = Vec2.temp(maxX, maxY).rotate(this.heading, this.pos);
		var t3 = Vec2.temp(maxX, minY).rotate(this.heading, this.pos);

		this.shadowSegments[0].start.copy(t0);this.shadowSegments[0].end.copy(t1);
		this.shadowSegments[1].start.copy(t1);this.shadowSegments[1].end.copy(t2);
		this.shadowSegments[2].start.copy(t2);this.shadowSegments[2].end.copy(t3);
		this.shadowSegments[3].start.copy(t3);this.shadowSegments[3].end.copy(t0);
	};

	Entity.prototype.getSegments = function getSegments() {
		if (this.castsShadow) {
			if (this.shadowSegments == null) {
				this.shadowSegments = [new LineSegment(new Vec2(0.0, 0.0), new Vec2(0.0, 0.0)), new LineSegment(new Vec2(0.0, 0.0), new Vec2(0.0, 0.0)), new LineSegment(new Vec2(0.0, 0.0), new Vec2(0.0, 0.0)), new LineSegment(new Vec2(0.0, 0.0), new Vec2(0.0, 0.0))];
			}
			this.updateShadowSegments();
			return this.shadowSegments;
		}
		return null;
	};

	Entity.prototype.move = function move(dt) {
		this.lastPos.copy(this.pos);
		this.lastPos.nanCheck();
		if (this.normalizeAccel) {
			if (this.acc.length() > 1.0) {
				this.acc.normalizeOrZero();
			}
		}
		this.acc.scale(this.speed);
		this.acc.x += -this.drag.x * this.vel.x;
		this.acc.y += -this.drag.y * this.vel.y;
		this.acc.nanCheck();

		this.pos.x += this.vel.x * dt + this.acc.x * dt * dt * 0.5;
		this.pos.y += this.vel.y * dt + this.acc.y * dt * dt * 0.5;
		this.pos.nanCheck();

		this.vel.x += this.acc.x * dt;
		this.vel.y += this.acc.y * dt;
		this.vel.nanCheck();

		if (this.hasZ) {
			this.zAcc += -this.zDrag * this.zVel;
			this.zVel += this.zAcc * dt;
			var nzPos = this.zPos + this.zVel * dt + this.zAcc * dt * dt * 0.5;
			var deltaZ = nzPos - this.zPos;
			var steps = Math.ceil(Math.abs(deltaZ));
			for (var i = 0; i < steps; ++i) {
				var nz = this.zPos + deltaZ / steps;
				if (nz < 0) {
					this.zVel = -this.zVel * this.zBounce;
					this.onGroundCollision();
					break;
				}
				this.zPos = nz;
			}
		}

		if (this.collidesWithWorld) {
			for (var i = 0; i < this.collisionIterations; ++i) {
				this.collideWithWorld(dt);
			}
		}
		if (this.collidesWithEntities) {
			this.collideWithObjects(dt);
		} else if (this.collidesWithPlayer) {
			var e = this.game.player;
			if (this.pos.distance(e.pos) < this.radius + e.radius) {
				if (e.solid) {
					this.handleCollision(e, this.pos.to(e.pos), this.pos.distance(e.pos) - (this.radius + e.radius), false);
				}
			}
		}
	};

	Entity.prototype.collideWithObjects = function collideWithObjects() {
		var es = this.game.grid.entitiesAround(this);
		for (var i = 0; i < es.length; ++i) {
			var e = es[i];
			if (e === this || !e.enabled) continue;
			if (this.pos.distance(e.pos) < this.radius + e.radius) {
				if (e.solid && e.collidesWithEntities || this == this.game.player && e.collidesWithPlayer) this.handleCollision(e, this.pos.to(e.pos).normalize(), this.pos.distance(e.pos) - (this.radius + e.radius), false);
			}
		}
	};

	Entity.prototype.onGroundCollision = function onGroundCollision() {};

	Entity.prototype.collideWithWorld = function collideWithWorld(dt) {
		var collisionMaxTries = 4;
		var collisionPos = Vec2.Pool.get();
		for (var tries = 0;;) {
			var sign = this.game.closestPoint(collisionPos, this.pos, this.radius);
			if (sign === 0) {
				break;
			}
			collisionPos.nanCheck();
			var dx = this.pos.x - collisionPos.x;
			var dy = this.pos.y - collisionPos.y;

			var dist = Math.sqrt(dx * dx + dy * dy);

			var penetration = this.radius - sign * dist;
			if (penetration <= 0.001) {
				// @@ROBUSTNESS: this is a hack
				break;
			}
			if (dist === 0) {
				break;
			}
			dx /= dist;
			dy /= dist;
			// this should project us out of the collision
			this.handleCollision(null, collisionPos.set(dx, dy), sign * penetration, true);
			if (++tries >= collisionMaxTries) {
				// degenerate cases where projecting us out of something
				// projects us into something else
				console.warn("Collision detection hit max iteration.", penetration);
				return false;
			}
		}
		return true;
	};

	Entity.prototype.handleCollision = function handleCollision(who, normal, penetration, wasHard) {
		this.pos.nanCheck();
		this.vel.nanCheck();
		if (wasHard) {
			this.pos.x += normal.x * penetration;
			this.pos.y += normal.y * penetration;
			var dot = this.vel.dot(normal);
			if (this.elastic) {
				this.vel.x = -(2 * dot * normal.x - this.vel.x);
				this.vel.y = -(2 * dot * normal.y - this.vel.y);
				this.vel.x *= this.elasticity;
				this.vel.y *= this.elasticity;
			} else {
				if (dot < 0) {
					this.vel.x -= dot * normal.x;
					this.vel.y -= dot * normal.y;
				}
			}
		} else {
			if (who == null || !who.mobile) {
				this.vel.x += normal.x * penetration;
				this.vel.y += normal.y * penetration;
				this.pos.x += normal.x * penetration;
				this.pos.y += normal.y * penetration;
			} else {
				this.vel.x += normal.x * penetration * 0.5;
				this.vel.y += normal.y * penetration * 0.5;
				// who.vel.x -= normal.x * penetration * 0.5;
				// who.vel.y -= normal.y * penetration * 0.5;

				this.pos.x += normal.x * penetration * 0.5;
				this.pos.y += normal.y * penetration * 0.5;

				// who.pos.x -= normal.x * penetration * 0.5;
				// who.pos.y -= normal.y * penetration * 0.5;
				// who.onCollision(who, normal, penetration, wasHard)
			}
		}
		this.pos.nanCheck();
		this.vel.nanCheck();
		this.onCollision(who, normal, penetration, wasHard);
	};

	Entity.prototype.onCollision = function onCollision(who, normal, penetration, wasHard) {};

	Entity.prototype.tweenTo = function tweenTo(field, tweenOptions) {
		tweenOptions.enabledField = 'enabled';
		return this.tweenGroup.add(new Tween(this, field, tweenOptions)).promise;
	};

	return Entity;
})();

Entity.idCounter = 0;
module.exports = Entity;

},{"./line_segment":173,"./math":175,"./tweens":180,"./vec2":182}],165:[function(require,module,exports){
'use strict';

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var Consts = require('./constants');
var Camera = require('./camera');
var CollisionGrid = require('./collision_grid');

var _require = require('./tweens');

var Tween = _require.Tween;
var TweenGroup = _require.TweenGroup;

var PixelBuffer = require('./pixel_buffer');
var Player = require('./player');

var _require2 = require('./level_data');

var TestLevel = _require2.TestLevel;
var Tiles = _require2.Tiles;
var TileInfo = _require2.TileInfo;

var polybool = require('poly-bool');
var LineSegment = require('./line_segment');
var Layer = require('./gfx_layer');
var Vec2 = require('./vec2');
var math = require('./math');
var Input = require('./input');
var util = require('./util');
var drawing = require('./drawing');

var _require3 = require('./lighting');

var VisTracker = _require3.VisTracker;

var Sounds = require('./audio');
var Key = require('./key');
var Enemy = require('./enemy');

var _require4 = require('./rand');

var perlinNoise = _require4.perlinNoise;
var octaveNoise = _require4.octaveNoise;
var RNG = _require4.RNG;

var STATES = { Loading: 0, Menu: 1, Game: 2 };

var EnemyLocations = [[12, 1], [19, 10], [23, 7], [27, 10], [25, 14], [10, 19], [11, 19], [12, 19], [13, 19], [26, 20], [24, 21], [14, 27], [4, 9]];

function loadLevel(tmx) {
	var mapElem = tmx.querySelector('map');
	var result = {
		width: mapElem.getAttribute('width'),
		height: mapElem.getAttribute('height')
	};
	[].forEach.call(mapElem.querySelectorAll('properties property'), function (elem) {
		var val = elem.getAttribute('value');
		if (!isNaN(val)) {
			var fval = Number(val);
			if (+fval === fval) val = fval;
		}
		result[elem.getAttribute('name')] = val;
	});

	[].forEach.call(mapElem.querySelectorAll('layer'), function (layer) {
		if (result.data != null) return; // TODO
		var data = layer.querySelector('data');
		if (data == null) {
			console.warn("Layer without data...", layer, tmx);
			return;
		}
		if (data.getAttribute('encoding') && data.getAttribute('encoding').toLowerCase() !== 'csv') {
			console.error("Illegal tilemap type");
		}
		// try anyway
		var text = data.textContent.trim();
		var tileIds = text.split(/[\s,]+/g).filter(function (v) {
			return v.length !== 0;
		}).map(function (v) {
			return v | 0;
		});
		if (tileIds.length != result.width * result.height) {
			console.error("Not sure what to do about this, wrong size tile map...", tileIds, tmx);
			throw Error("Bad tile map");
		}
		result.tiles = tileIds;
	});

	return result;
}

var segmentTmp = [];

var LD34 = (function () {
	function LD34(drawCanv, dbgCanv) {
		_classCallCheck(this, LD34);

		this.debugCanvas = dbgCanv;
		this.debugContext = dbgCanv.getContext('2d');
		this.entities = [];

		this.paused = false;
		this.screen = drawCanv;
		this.ctx = drawCanv.getContext('2d');
		this.tweenGroup = new TweenGroup();
		this.loadingFailed = false;

		this.bgLayer = new Layer('bg', drawCanv.width, drawCanv.height);
		this.bgmodLayer = new Layer('bgmod', drawCanv.width, drawCanv.height);
		this.tileLayer = new Layer('tile', drawCanv.width, drawCanv.height);
		this.entsLayer = new Layer('ents', drawCanv.width, drawCanv.height);
		this.fxLayer = new Layer('fx', drawCanv.width, drawCanv.height);
		this.lightLayer = new Layer('light', drawCanv.width, drawCanv.height);
		this.hudLayer = new Layer('hud', drawCanv.width, drawCanv.height);
		this.overlayLayer = new Layer('overlay', drawCanv.width, drawCanv.height);

		this.startedGame = false;
		this.playerDead = false;
		this.deadPlayerTimer = 0.0;

		this.layers = [this.bgLayer,
		//this.bgmodLayer,
		this.bgmodLayer, this.fxLayer, this.entsLayer, this.lightLayer, this.tileLayer, this.hudLayer, this.overlayLayer];
		this.mouse = new Vec2(0.0, 0.0);

		this.width = 1000;
		this.height = 1000;

		this.grid = null;
		this.visTracker = new VisTracker();
		this.keys = [];
		this.locks = [];

		this.player = new Player(this);
		this.camTarget = new Vec2(0.0, 0.0);
		this.camera = new Camera(this, this.player, this.camTarget, drawCanv.width, drawCanv.height);
		this.tiles = [];
		this.edgeGeom = [];
		this.state = STATES.Loading;
		this.loadProgress = 0;
		this.assets = {};
		this.seenBuffer = null;
		this.bgbuffer = null;
		this.lightMaskCanvas = util.createCanvas(drawCanv.width, drawCanv.height);
		this.lightMaskCtx = this.lightMaskCanvas.getContext('2d');
		this.emptyTiles = null;
		this.bloodBuffer = null;
		this.gameWon = false;
		this.loadAssets();
	}

	LD34.prototype.loadAssets = function loadAssets() {
		var _this = this;

		var items = [{ path: 'res/player.png', name: 'player', type: 'image' }, { path: 'res/sprites.png', name: 'tiles', type: 'image' }, { path: 'res/lvl1.tmx', name: 'level0', type: 'level' }, { path: 'res/misc.png', name: 'misc', type: 'image' }, { path: 'res/dead.png', name: 'dead', type: 'image' }];
		var loaded = 0;
		return Promise.all(items.map(function (_ref) {
			var path = _ref.path;
			var name = _ref.name;
			var type = _ref.type;

			var p = null;
			switch (type) {
				case 'image':
					p = util.loadImage(path);
					break;
				case 'level':
					p = util.loadXML(path).then(function (doc) {
						return loadLevel(doc);
					});
					break;
				default:
					console.error("Not sure how to load ", type, name, path);
					debugger;
			}
			return p.then(function (stuff) {
				_this.assets[name] = stuff;
				_this.loadProgress = ++loaded / items.length * 0.8;
				return stuff;
			});
		})).then(function () {
			_this.assets.playerRotations = PixelBuffer.getRotatedTiles(_this.assets.player, 16);
			var hilight = _this.assets.playerRotations.getPixel(4, 7);
			var mid = _this.assets.playerRotations.getPixel(8, 5);
			var colors = [[[hilight, 0xff1717b4], [mid, 0xff0f0f6e]], [[hilight, 0xff00bacb], [mid, 0xff0099a7]], [[hilight, 0xff00bacb], [mid, 0xff0099a7]], [[hilight, 0xffcb0084], [mid, 0xffa7006c]]];
			_this.assets.enemyRotations = colors.map(function (replacements) {
				return _this.assets.playerRotations.withReplacedColors(replacements);
			});
			var deadPlayer = PixelBuffer.fromImage(_this.assets.dead);
			_this.assets.deadEnemies = colors.map(function (replacements) {
				return deadPlayer.withReplacedColors(replacements);
			});

			_this.setState(STATES.Game);
		}).catch(function (e) {
			console.error(e);
			_this.loadingFailed = true;
		});
	};

	LD34.prototype.startLevel = function startLevel(level) {
		var _this2 = this;

		this.player = new Player(this);
		this.camera = new Camera(this, this.player, this.camTarget, this.screen.width, this.screen.height);

		this.startedGame = true;
		this.entities.length = 0;
		this.playerDead = false;
		this.deadPlayerTimer = 0.0;

		this.width = level.width * Consts.TileSize;
		this.height = level.height * Consts.TileSize;
		this.grid = new CollisionGrid(this.width, this.height, Consts.TileSize * 4); // hm...

		// this.player.reset();
		this.addEntity(this.player, level.spawnX * Consts.TileSize + 8.1, level.spawnY * Consts.TileSize + 8.1);
		EnemyLocations.map(function (_ref2) {
			var x = _ref2[0];
			var y = _ref2[1];

			x *= Consts.TileSize;
			y *= Consts.TileSize;
			_this2.addEntity(new Enemy(_this2, x + 8, y + 8));
		});
		// this.addEn tity(new Enemy(this, 2*16+8, 5*16+8));
		this.camera.setPosition(this.player.pos.x, this.player.pos.y, true);
		this.tileWidth = level.width;
		this.tileHeight = level.height;
		this.tiles = new Array(this.tileWidth * this.tileHeight);
		this.emptyTiles = new Uint8Array(this.tileWidth * this.tileHeight);
		this.lockedTiles = new Array(this.tileWidth * this.tileHeight); // waste of memory...

		var knownKeysOrLocks = {};
		for (var y = 0; y < this.tileHeight; ++y) {
			for (var x = 0; x < this.tileWidth; ++x) {
				var i = x + y * this.tileWidth;
				var tileId = level.tiles[i];
				if (tileId >= Tiles.length) {
					if (!(tileId in knownKeysOrLocks)) {
						knownKeysOrLocks[tileId] = [];
					}
					knownKeysOrLocks[tileId].push({ x: x, y: y });
					tileId = 0;
				}
				var tileInfo = Tiles[tileId];
				this.tiles[i] = tileId ? tileInfo.offsetBy(x * Consts.TileSize, y * Consts.TileSize) : tileInfo;
				if (!tileId) {
					this.emptyTiles[i] = 1;
				}
				this.tiles[i].id = tileId;
			}
		}

		var geom = level.geom;
		if (this.edgeGeom.length === 0) {
			level.geom = geom = [];
			for (var y = 0; y < this.tileHeight; ++y) {
				for (var x = 0; x < this.tileWidth; ++x) {
					var i = x + y * this.tileWidth;
					var tileId = level.tiles[i];
					if (tileId >= Tiles.length) continue;
					var tileInfo = Tiles[tileId];
					if (tileId) {
						geom = polybool(geom, [this.tiles[i].edges.map(function (_ref3) {
							var start = _ref3.start;
							return [start.x, start.y];
						})]);
					}
				}
			}

			geom.forEach(function (poly) {
				for (var i = 1; i < poly.length; ++i) {
					var _poly = poly[i - 1];
					var px = _poly[0];
					var py = _poly[1];
					var _poly$i = poly[i];
					var cx = _poly$i[0];
					var cy = _poly$i[1];
					var _poly2 = poly[(i + 1) % poly.length];
					var nx = _poly2[0];
					var ny = _poly2[1];

					var dpx = cx - px,
					    dpy = cy - py;
					var dnx = nx - cx,
					    dny = ny - cy;
					var lp = Math.sqrt(dpx * dpx + dpy * dpy);
					if (lp !== 0) {
						dpx /= lp;dpy /= lp;
					}
					var ln = Math.sqrt(dnx * dnx + dny * dny);
					if (ln !== 0) {
						dnx /= ln;dny /= ln;
					}
					// same direction.
					if (Math.abs(dnx * dpx + dny * dpy - 1) < 0.0001) {
						poly.splice(i, 1);
						--i;
					}
				}
			});

			this.edgeGeom.length = 0;
			geom.forEach(function (poly, i) {
				for (var _i = 0; _i < poly.length; ++_i) {
					var _poly$_i = poly[_i];
					var px = _poly$_i[0];
					var py = _poly$_i[1];
					var _poly3 = poly[(_i + 1) % poly.length];
					var nx = _poly3[0];
					var ny = _poly3[1];

					_this2.edgeGeom.push(new LineSegment(new Vec2(px, py), new Vec2(nx, ny)));
				}
			});
		}

		this.keys.length = 0;
		this.locks.length = 0;
		Object.keys(knownKeysOrLocks).forEach(function (id, idx) {
			var lk = knownKeysOrLocks[id];
			var locks = [];
			var key = { id: idx, pos: null, locks: locks, locked: true };

			lk.forEach(function (_ref4) {
				var x = _ref4.x;
				var y = _ref4.y;

				var left = x !== 0 && _this2.tiles[x - 1 + y * _this2.tileWidth].id === 1;
				var right = x !== _this2.tileWidth - 1 && _this2.tiles[x + 1 + y * _this2.tileWidth].id === 1;
				var top = y !== 0 && _this2.tiles[(y - 1) * _this2.tileWidth + x].id === 1;
				var bottom = y !== _this2.tileHeight - 1 && _this2.tiles[x + (y + 1) * _this2.tileWidth].id === 1;
				if (left || right || top || bottom) {
					var lock = { key: key, id: idx, pos: new Vec2(x, y), tile: Tiles[1].offsetBy(x * Consts.TileSize, y * Consts.TileSize) };
					locks.push(lock);
					_this2.lockedTiles[x + y * _this2.tileWidth] = lock;
					_this2.locks.push(lock);
				} else {
					console.assert(key.pos == null);
					key.pos = new Vec2(x, y);
				}
			});
			console.assert(key.pos != null);
			_this2.keys.push(key);
		});

		this.keys.forEach(function (k) {
			return _this2.addEntity(new Key(_this2, k.pos.x * Consts.TileSize, k.pos.y * Consts.TileSize, k));
		});

		// let count = Math.ceil((this.geomPoints.length+4)*1.5);
		// let ptXYA = new Float32Array(count*3);
		// let tmpPoint = new Uint8Array(count)
		this.visTracker.setSegments(this.edgeGeom);
		this.bgbuffer = new PixelBuffer(this.width, this.height);
		// this.seenBuffer = new PixelBuffer(this.width, this.height);
		// this.seenBuffer.context.fillStyle = 'black'
		// this.seenBuffer.context.fillRect(0, 0, this.width, this.height);
		this.bloodBuffer = new PixelBuffer(this.width, this.height);

		Sounds.playMusic(1);
	};

	LD34.prototype.addEntity = function addEntity(ent) {
		var x = arguments.length <= 1 || arguments[1] === undefined ? ent.pos.x : arguments[1];
		var y = arguments.length <= 2 || arguments[2] === undefined ? ent.pos.y : arguments[2];

		ent.pos.x = x;
		ent.pos.y = y;
		this.entities.push(ent);
		if (ent.collidesWithEntities || ent.collidesWithPlayer) {
			this.grid.add(ent);
		}
		return ent;
	};

	LD34.prototype.segmentsAround = function segmentsAround(pos, radius) {
		var left = math.clamp(Math.floor((pos.x - radius) / Consts.TileSize) - 1, 0, this.tileWidth - 1);
		var right = math.clamp(Math.ceil((pos.x + radius) / Consts.TileSize) + 1, 0, this.tileWidth - 1);
		var top = math.clamp(Math.floor((pos.y - radius) / Consts.TileSize) - 1, 0, this.tileHeight - 1);
		var bottom = math.clamp(Math.ceil((pos.y + radius) / Consts.TileSize) + 1, 0, this.tileHeight - 1);
		var result = segmentTmp;
		result.length = 0;
		for (var y = top; y <= bottom; ++y) {
			for (var x = left; x <= right; ++x) {
				var tileIdx = y * this.tileWidth + x;
				result.push.apply(result, this.tiles[tileIdx].edges);
				if (this.lockedTiles[tileIdx] && this.lockedTiles[tileIdx].key.locked) {
					result.push.apply(result, this.lockedTiles[tileIdx].tile.edges);
				}
			}
		}
		return result;
	};

	LD34.prototype.update = function update(dt) {
		if (window.TIME_FUNCTIONS) console.time('update');
		switch (this.state) {
			case STATES.Game:
				if (!this.startedGame) {
					this.startLevel(this.assets.level0);
				} else if (this.playerDead) {
					this.deadPlayerTimer -= dt;
					if (this.deadPlayerTimer < 0) {
						this.startLevel(this.assets.level0);
					}
				}
				this.gameStateUpdate(dt);
				break;
			case STATES.Loading:
				// this is *stupid*
				if (this.loadProgress === 1.0) {
					this.state = STATES.Game;
				} else if (this.loadProgress >= 0.9) {
					this.loadProgress = 1.0;
				}
				break;
			case STATES.Menu:
				break; // NYI
		}
		if (window.TIME_FUNCTIONS) console.timeEnd('update');
	};

	LD34.prototype.gameStateUpdate = function gameStateUpdate(dt) {
		var _edgeGeom;

		this.debugContext.clearRect(0, 0, this.debugContext.canvas.width, this.debugContext.canvas.height);
		this.debugContext.save();
		this.debugContext.scale(Consts.Scale, Consts.Scale);

		// this.camTarget.copy(this.player.pos);

		this.mouse.x = this.camera.minX + Input.mouse.x;
		this.mouse.y = this.camera.minY + Input.mouse.y;
		if ( /*Input.mouse.isDown || */Input.keyboard.isDown('space')) {
			var mdx = this.mouse.x - this.player.pos.x;
			var mdy = this.mouse.y - this.player.pos.y;
			mdx /= 4;
			mdy /= 4;
			if (mdx < 20 && mdy < 20) {
				// this.camTarget.copy(this.player.pos)
			} else {
					// this.camTarget.set(this.player.pos.x+mdx, this.player.pos.y+mdy);
				}
		} else {
				this.camTarget.copy(this.player.pos);
			}
		var extraGeom = [];

		// if (window.TIME_FUNCTIONS) console.time('update:entities');
		{
			var entities = this.entities;
			for (var i = 0; i < entities.length; ++i) {
				entities[i].update(dt);
				entities[i].postUpdate(dt);
			}
			var j = 0;
			for (var i = 0, l = entities.length; i < l; ++i) {
				if (entities[i].enabled) {
					entities[j++] = entities[i];
					var segs = entities[i].getSegments();
					if (segs) extraGeom.push.apply(extraGeom, segs);
				}
			}
			entities.length = j;
		}
		// if (window.TIME_FUNCTIONS) console.timeEnd('update:entities');

		this.camera.update(dt);
		if (window.TIME_FUNCTIONS) console.time('lighting');
		//this.computeLighting();
		var _camera = this.camera;
		var minX = _camera.minX;
		var minY = _camera.minY;
		var maxX = _camera.maxX;
		var maxY = _camera.maxY;

		var p0 = Vec2.temp(minX - 1, minY - 1);
		var p1 = Vec2.temp(minX - 1, maxY + 1);
		var p2 = Vec2.temp(maxX + 1, maxY + 1);
		var p3 = Vec2.temp(maxX + 1, minY - 1);
		extraGeom.push(new LineSegment(p0, p1), new LineSegment(p1, p2), new LineSegment(p2, p3), new LineSegment(p3, p0));

		var ph = this.player.heading;
		var hx = Math.cos(ph);
		var hy = Math.sin(ph);
		var ihx = -hx;
		var ihy = -hy;
		var ih = Vec2.temp(ihx * 3 + this.player.pos.x, ihy * 3 + this.player.pos.y);
		var minAngle = ph - Math.PI / 5;
		var maxAngle = ph + Math.PI / 5;
		var minAx = Math.cos(minAngle) * 200 + ih.x;
		var minAy = Math.sin(minAngle) * 200 + ih.y;

		var maxAx = Math.cos(maxAngle) * 200 + ih.x;
		var maxAy = Math.sin(maxAngle) * 200 + ih.y;

		// @TODO: avoid copying this so frequently
		this.visTracker.setSegments((_edgeGeom = this.edgeGeom).concat.apply(_edgeGeom, [extraGeom].concat(this.locks.filter(function (l) {
			return l.key.locked;
		}).map(function (l) {
			return l.tile.edges;
		}))));

		this.visTracker.setCenter(this.player.pos);
		this.visTracker.sweep();
		if (window.TIME_FUNCTIONS) console.timeEnd('lighting');

		// if (window.TIME_FUNCTIONS) console.timeEnd('update:effects');
		this.debugContext.restore();
	};

	LD34.prototype.closestPoint = function closestPoint(out, pos, radius) {
		var min = Number.MAX_VALUE;
		var closestX = 0.0;
		var closestY = 0.0;
		var sign = 0;
		var segs = this.segmentsAround(pos, radius);
		var tmpClosest = Vec2.temp(0.0, 0.0);
		var px = pos.x;
		var py = pos.y;

		var paperWidth = 0.1;
		for (var si = 0, sl = segs.length; si < sl; ++si) {
			var seg = segs[si];
			var backface = seg.closestPoint(tmpClosest, pos);
			var dx = tmpClosest.x - px,
			    dy = tmpClosest.y - py;
			var dist = dx * dx + dy * dy;
			if (!backface) dist -= paperWidth;
			if (dist < min) {
				closestX = tmpClosest.x;
				closestY = tmpClosest.y;
				min = dist;
				sign = backface ? -1 : 1;
			}
		}
		out.x = closestX;
		out.y = closestY;
		return sign;
	};

	LD34.prototype.raycastCell = function raycastCell(outP, outN, x, y, rayPos, rayDir) {
		var tileIdx = x + y * this.tileWidth;
		var segs = this.tiles[tileIdx].edges;
		if (segs.length === 0) {
			if (this.lockedTiles[tileIdx] && this.lockedTiles[tileIdx].key.locked) {
				segs = this.lockedTiles[tileIdx].tile.edges;
			}
		}
		var curBest = 2.0;
		var tmpP = Vec2.temp(0.0, 0.0);
		var tmpN = Vec2.temp(0.0, 0.0);
		for (var i = 0, l = segs.length; i < l; ++i) {
			var seg = segs[i];
			var isect = seg.raycast(tmpP, tmpN, rayPos, rayDir, 0);
			if (isect === -1) return -1;
			if (isect < curBest) {
				curBest = isect;
				outP.copy(tmpP);
				outN.copy(tmpN);
			}
		}
		return curBest;
	};

	LD34.prototype.setState = function setState(state) {
		this.lastState = this.state;
		this.state = state;
	};

	LD34.prototype.canSee = function canSee(pt0, pt1) {
		var p = Vec2.temp();
		var n = Vec2.temp();
		var delta = pt0.to(pt1);
		var r = this.raycast(p, n, pt0, delta.normalized());
		if (r < 0 || r < delta.length()) {
			return false;
		}
		return true;
	};

	LD34.prototype.raycast = function raycast(outP, outN, rayPos, rayDir, rayLen, extraSegs) {
		var rayX = rayPos.x;
		var rayY = rayPos.y;
		var rayDirX = rayDir.x;
		var rayDirY = rayDir.y;

		var gx = Math.floor(rayX / Consts.TileSize);
		var gy = Math.floor(rayY / Consts.TileSize);
		var rayDxI = 0;
		var rayDyI = 0;
		var sx = 999999.0;
		var sy = 999999.0;
		var ex = 0.0;
		var ey = 0.0;

		if (rayDirX < 0) {
			rayDxI = -1;
			sx = (gx * Consts.TileSize - rayX) / rayDirX;
			ex = Consts.TileSize / -rayDirX;
		} else if (rayDirX > 0) {
			rayDxI = 1;
			sx = ((gx + 1) * Consts.TileSize - rayX) / rayDirX;
			ex = Consts.TileSize / rayDirX;
		}

		if (rayDirY < 0) {
			rayDyI = -1;
			sy = (gy * Consts.TileSize - rayY) / rayDirY;
			ey = Consts.TileSize / -rayDirY;
		} else if (rayDirY > 0) {
			rayDyI = 1;
			sy = ((gy + 1) * Consts.TileSize - rayY) / rayDirY;
			ey = Consts.TileSize / rayDirY;
		}

		if (rayDxI === 0 && rayDyI === 0) {
			console.error("Empty ray vector in raycast(): ", rayDirX, rayDirY);
			return -1;
		}

		var rayMaxDist = rayLen || 10000.0;
		var tmpRayP = Vec2.temp(rayX, rayY);
		var tmpRayV = Vec2.temp(rayDirX * rayMaxDist, rayDirY * rayMaxDist);

		var esBestT = 2;
		var esBestN = Vec2.temp();
		var esBestP = Vec2.temp();
		if (extraSegs != null) {
			var segTmpP = Vec2.temp();
			var segTmpN = Vec2.temp();
			for (var si = 0; si < extraSegs.length; ++si) {
				var t = extraSegs[si].raycast(segTmpP, segTmpN, tmpRayP, tmpRayV, 0);
				if (math.betweenI(t, 0.0, 1.0) && t < esBestT) {
					esBestT = t;
					esBestN.copy(segTmpN);
					esBestP.copy(segTmpP);
				}
			}
		}

		var travel = -1;
		while ((travel = this.raycastCell(outP, outN, gx, gy, tmpRayP, tmpRayV)) !== -1) {

			if (travel !== 2) {
				if (esBestT >= 0 && esBestT !== 2) {
					travel = Math.min(esBestT, travel);
					outP.copy(esBestP);
					outN.copy(esBestN);
				}
				return travel * rayMaxDist;
			}

			if (sx < sy) {
				sx += ex;
				gx += rayDxI;
				if (gx < 0 || gx >= this.tileWidth) {
					console.warn("raycast missed everything!", new Vec2(rayX, rayY), new Vec2(rayDirX, rayDirY));
					return -1;
				}
			} else {
				sy += ey;
				gy += rayDyI;
				if (gy < 0 || gy >= this.tileHeight) {
					console.warn("raycast missed everything!", new Vec2(rayX, rayY), new Vec2(rayDirX, rayDirY));
					return -1;
				}
			}
		}
		console.warn("raycast got bad ray (start pos inside geom)", new Vec2(rayX, rayY), new Vec2(rayDirX, rayDirY));
		return -1;
	};

	LD34.prototype.render = function render() {
		if (window.TIME_FUNCTIONS) console.time('render');
		switch (this.lastState) {
			case STATES.Game:
				this.gameStateRender();break;
			case STATES.Loading:
				this.renderLoading();break;
			case STATES.Menu:
				break; // NYI
		}
		if (window.TIME_FUNCTIONS) console.timeEnd('render');
		this.lastState = this.state; // @@HACK: we don't want to render until we've updated with our new state at least once.
	};

	LD34.prototype.renderLoading = function renderLoading() {
		this.overlayLayer.clear();
		this.hudLayer.fill('black');
		var progressBarWidth = this.hudLayer.width >> 1;
		var progressBarHeight = 8;

		this.hudLayer.context.strokeStyle = 'white';
		this.hudLayer.context.strokeRect((this.hudLayer.width - progressBarWidth) / 2, (this.hudLayer.height - progressBarHeight) / 2, progressBarWidth, progressBarHeight);

		this.hudLayer.context.fillStyle = 'black';
		this.hudLayer.context.fillRect((this.hudLayer.width - progressBarWidth) / 2, (this.hudLayer.height - progressBarHeight) / 2, progressBarWidth, progressBarHeight);

		this.hudLayer.context.fillStyle = this.loadingFailed ? 'red' : 'white';

		this.hudLayer.context.fillRect((this.hudLayer.width - progressBarWidth) / 2, (this.hudLayer.height - progressBarHeight) / 2, progressBarWidth * this.loadProgress, progressBarHeight);
	};

	LD34.prototype.unlock = function unlock(key) {
		key.locked = false;
		key.locks.forEach(function (l) {
			l.locked = false;
		});

		if (!this.keys.some(function (k) {
			return k.locked;
		})) {
			this.gameWon = true;
			alert("You win (this message is all I had time for, sorry)");
		}
	};

	LD34.prototype.killPlayer = function killPlayer() {
		this.deadPlayerTimer = 1.0;
		this.playerDead = true;
	};

	LD34.prototype.gameStateRender = function gameStateRender() {
		var _this3 = this;

		var _camera2 = this.camera;
		var minX = _camera2.minX;
		var minY = _camera2.minY;
		var maxX = _camera2.maxX;
		var maxY = _camera2.maxY;
		// minX = Math.floor(minX);
		// minY = Math.floor(minY);

		var iMinX = Math.round(minX);
		var iMinY = Math.round(minY);

		for (var i = 0; i < this.layers.length; ++i) {
			var pb = this.layers[i].buffer;
			if (pb.pixelsDirty) pb.reset();
			this.layers[i].clear();
			this.layers[i].context.save();
			this.layers[i].context.translate(-iMinX, -iMinY);
		}

		this.debugContext.save();
		this.debugContext.scale(Consts.Scale, Consts.Scale);
		this.debugContext.lineWidth = 1 / Consts.Scale;
		this.debugContext.strokeStyle = 'red';
		this.debugContext.translate(-minX, -minY);

		var minTileX = math.clamp(Math.floor(minX / Consts.TileSize), 0, this.tileWidth - 1);
		var minTileY = math.clamp(Math.floor(minY / Consts.TileSize), 0, this.tileHeight - 1);

		var maxTileX = math.clamp(Math.ceil(maxX / Consts.TileSize), 0, this.tileWidth - 1);
		var maxTileY = math.clamp(Math.ceil(maxY / Consts.TileSize), 0, this.tileHeight - 1);

		// this.bgmodLayer.context.drawImage(this.bgbuffer.canvas, -minX, -minY);
		// this.bgmodLayer.blendMode = 'overlay';
		// this.bgmodLayer.alpha = 0.2;
		{
			if (window.TIME_FUNCTIONS) console.time('render tiles');
			var tileCtx = this.tileLayer.context;
			tileCtx.fillStyle = 'red';
			for (var ty = minTileY; ty <= maxTileY; ++ty) {
				var row = ty * this.tileWidth;
				for (var tx = minTileX; tx <= maxTileX; ++tx) {
					var tile = this.tiles[tx + row];
					if (tile.id === 0) {
						var lock = this.lockedTiles[tx + row];
						if (lock && lock.key.locked) {
							this.entsLayer.context.drawImage(this.assets.misc, 0, lock.id * 16, 16, 16, tx * Consts.TileSize, ty * Consts.TileSize, Consts.TileSize, Consts.TileSize);
						}
						continue;
					}
					var tileId = tile.id - 1;
					var tileX = tileId % 16;
					var tileY = tileId / 16 | 0;
					tileX *= 16;
					tileY *= 16;

					tileCtx.drawImage(this.assets.tiles, tileX, tileY, 16, 16, tx * Consts.TileSize, ty * Consts.TileSize, Consts.TileSize, Consts.TileSize);
				}
			}
			if (window.TIME_FUNCTIONS) console.timeEnd('render tiles');
		}

		// if (window.TIME_FUNCTIONS) console.time('render entities');
		for (var ei = 1; ei < this.entities.length; ++ei) {
			var ent = this.entities[ei];
			if (ent.enabled) {
				ent.render(this.entsLayer, this.fxLayer.buffer, minX, minY);
			}
		}
		this.entities[0].render(this.entsLayer, this.fxLayer.buffer, minX, minY); // player
		// if (window.TIME_FUNCTIONS) console.timeEnd('render entities');

		if (this.visTracker.outXs.length) {
			if (window.TIME_FUNCTIONS) console.time('render lighting');
			this.lightLayer.clear();

			this.lightLayer.alpha = 0.5;
			this.lightLayer.blendMode = 'multiply';
			var lctx = this.lightLayer.context;
			// let sctx = this.seenBuffer.context;
			lctx.save();
			lctx.beginPath();
			lctx.moveTo(this.player.pos.x, this.player.pos.y);

			var _visTracker = this.visTracker;
			var outXs = _visTracker.outXs;
			var outYs = _visTracker.outYs;

			lctx.moveTo(outXs[0], outYs[0]);
			for (var i = 0, l = outXs.length; i < l; ++i) {
				var px = outXs[i];
				var py = outYs[i];
				if (i === 0) {
					lctx.moveTo(px, py); /*sctx.moveTo(px, py);*/
				} else {
						lctx.lineTo(px, py); /*sctx.lineTo(px, py);*/
					}
				if (DEBUG) drawing.drawArrow(this.debugContext, this.player.pos.x, this.player.pos.y, px, py);
			}
			var ShadowBlur = 10;
			lctx.shadowColor = 'white';
			lctx.shadowBlur = ShadowBlur / 2;
			lctx.shadowOffsetX = 0;
			lctx.shadowOffsetY = 0;

			lctx.closePath();
			// sctx.closePath();
			lctx.fillStyle = 'white';
			// sctx.fillStyle = 'white';
			lctx.fill();
			// sctx.fill();

			var maskCtx = this.lightMaskCtx;
			maskCtx.save();
			maskCtx.clearRect(0, 0, maskCtx.canvas.width, maskCtx.canvas.height);
			maskCtx.globalCompositeOperation = 'source-over';

			maskCtx.shadowColor = 'black';
			maskCtx.shadowBlur = ShadowBlur;
			maskCtx.shadowOffsetX = 0;
			maskCtx.shadowOffsetY = 0;
			maskCtx.beginPath();
			maskCtx.moveTo(this.player.pos.x - minX, this.player.pos.y - minY);
			maskCtx.arc(this.player.pos.x - minX, this.player.pos.y - minY, 200, this.player.heading - Math.PI / 5, this.player.heading + Math.PI / 5);
			maskCtx.closePath();
			maskCtx.fill();
			maskCtx.restore();

			maskCtx.globalCompositeOperation = 'source-in';
			maskCtx.drawImage(lctx.canvas, 0, 0);
			lctx.restore();
			lctx.translate(iMinX, iMinY);

			lctx.clearRect(0, 0, lctx.canvas.width, lctx.canvas.height);
			lctx.fillStyle = 'black';
			lctx.fillRect(0, 0, lctx.canvas.width, lctx.canvas.height);
			lctx.drawImage(maskCtx.canvas, 0, 0);
			// this.seenBuffer.context.drawImage(maskCtx.canvas, iMinX, iMinY);
			if (window.TIME_FUNCTIONS) console.timeEnd('render lighting');
		}

		// this.bgLayer.fill('rgb(55, 55, 55)');
		// this.bgmodLayer.clear();
		// this.bgmodLayer.context.drawImage(this.seenBuffer.canvas, 0, 0);
		//,
		//	0, 0, this.bgmodLayer.width, this.bgmodLayer.height,
		//	-iMinX, -iMinY, this.bgmodLayer.width, this.bgmodLayer.height);
		// this.bgmodLayer.blendMode = 'multiply';
		// this.bgmodLayer.alpha = 0.3

		var DRAW_DEBUG_GEOM = false;

		if (DRAW_DEBUG_GEOM) {
			this.debugContext.strokeStyle = 'yellow';
			this.edgeGeom.forEach(function (seg) {
				return seg.debugRender(_this3.debugContext);
			});
			this.debugContext.strokeStyle = 'yellow';
		}

		for (var i = 0; i < this.layers.length; ++i) {
			this.layers[i].context.restore();
			if (this.layers[i].buffer.pixelsDirty) this.layers[i].buffer.update(false);
		}

		this.bloodBuffer.update(true);
		this.bgmodLayer.context.drawImage(this.bloodBuffer.canvas, iMinX, iMinY, this.bgmodLayer.width, this.bgmodLayer.height, 0, 0, this.bgmodLayer.width, this.bgmodLayer.height);

		this.debugContext.restore();
	};

	return LD34;
})();

module.exports = LD34;

},{"./audio":154,"./camera":157,"./collision_grid":159,"./constants":160,"./drawing":162,"./enemy":163,"./gfx_layer":167,"./input":169,"./key":170,"./level_data":171,"./lighting":172,"./line_segment":173,"./math":175,"./pixel_buffer":177,"./player":178,"./rand":179,"./tweens":180,"./util":181,"./vec2":182,"poly-bool":8}],166:[function(require,module,exports){
'use strict';

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var Game = require('./game');

var _require = require('./input');

var updateInput = _require.update;

var Clock = require('./clock');
var Consts = require('./constants');
var Input = require('./input');

var _require2 = require('./util');

var createCanvas = _require2.createCanvas;
var createContext2D = _require2.createContext2D;

var Vec2 = require('./vec2');

var GameRunner = (function () {
	function GameRunner() {
		var _this = this;

		_classCallCheck(this, GameRunner);

		var screen = this.screen = document.getElementById('screen');
		this.screen.width = Consts.ClientScreenWidth * Consts.DevicePixels;
		this.screen.height = Consts.ClientScreenHeight * Consts.DevicePixels;
		this.screen.style.width = Consts.ClientScreenWidth + "px";
		this.screen.style.height = Consts.ClientScreenHeight + "px";
		this.screenCtx = screen.getContext('2d');

		this.debugElem = document.getElementById('debug');

		this.debugCanvas = createCanvas(Consts.ClientScreenWidth, Consts.ClientScreenHeight);
		this.debugCtx = this.debugCanvas.getContext('2d');

		this.drawCanvas = createCanvas(Consts.ScreenWidth, Consts.ScreenHeight);
		this.drawContext = this.drawCanvas.getContext('2d');

		Input.initialize(screen);
		window.addEventListener('keydown', function (e) {
			if (e.which === 27) {
				_this.paused = !_this.paused;
				if (!_this.paused) _this.start();
			}
		});
		this.paused = false;
		this.game = null;
		this.startTime = 0;
		this.accum = 0;
		this.lastUpdate = 0;
		this.frames = 0;
		this.ticks = 0;
		this.lastSecond = 0;
		this.fpsElem = document.getElementById('fps');
		this.tpsElem = document.getElementById('tps');
		this.mspfElem = document.getElementById('mspf');
		this.doUpdate = function (timestamp) {
			return _this.update(timestamp);
		};
	}

	GameRunner.prototype.start = function start() {
		if (!this.game) this.game = new Game(this.drawCanvas, this.debugCanvas);
		this.startTime = 0;
		this.accum = 0;
		this.lastUpdate = 0;
		this.frames = 0;
		this.ticks = 0;
		this.lastSecond = 0;
		requestAnimationFrame(this.doUpdate);
	};

	GameRunner.prototype.update = function update(timestamp) {
		if (this.paused) {
			return;
		}
		if (!this.lastUpdate) {
			this.lastUpdate = timestamp;
			this.lastSecond = timestamp;
			return requestAnimationFrame(this.doUpdate);
		}
		requestAnimationFrame(this.doUpdate);
		Clock.realTime = timestamp / 1000.0;
		var unscaledDeltaTime = 1.0 / Clock.fps;

		var dt = unscaledDeltaTime * Clock.timeScale;
		Clock.realDeltaTime = (timestamp - this.lastUpdate) / 1000.0;
		Clock.deltaTime = dt;
		this.lastUpdate = timestamp;

		this.accum += Clock.realDeltaTime;
		if (this.accum >= 5 * unscaledDeltaTime) {
			this.accum = unscaledDeltaTime;
		}
		var frameStart = Clock.now();
		while (this.accum >= dt) {
			++this.ticks;
			Vec2.Pool.reset();
			this.game.update(dt);
			Clock.accumTime += dt;
			Input.update();
			this.accum -= dt;
			++Clock.ticks;
		}
		++this.frames;
		this.game.render();
		this.render();

		var frameEnd = Clock.now();
		if (this.mspfElem != null) {
			this.mspfElem.textContent = 'mspf: ' + (frameEnd - frameStart).toFixed(2);
		}

		if (timestamp - this.lastSecond >= 1000.0) {
			this.lastSecond = timestamp;
			console.log("fps: " + this.frames + ", tps: " + this.ticks + ', mspf: ' + (frameEnd - frameStart).toFixed(2));
			if (this.tpsElem != null) {
				this.tpsElem.textContent = "tps: " + this.ticks;
			}
			if (this.fpsElem != null) {
				this.fpsElem.textContent = "fps: " + this.frames;
			}
			this.frames = this.ticks = 0;
		}
	};

	GameRunner.prototype.render = function render() {
		var screenCtx = this.screenCtx;
		var screen = this.screen;

		screenCtx.imageSmoothingEnabled = false;
		screenCtx.mozImageSmoothingEnabled = false;
		screenCtx.webkitImageSmoothingEnabled = false;
		screenCtx.clearRect(0, 0, screenCtx.canvas.width, screenCtx.canvas.height);
		screenCtx.globalCompositeOperation = 'source-over';
		screenCtx.globalAlpha = 1.0;
		if (this.game.layers) {
			// let camMinX = 0, camMinY = 0;
			// if (this.game.needCameraAdjust) {
			// 	camMinX = this.game.camera.minX;
			// 	camMinY = this.game.camera.minY;
			// }
			var gco = 'source-over';
			var globalAlpha = 1.0;
			for (var i = 0; i < this.game.layers.length; ++i) {
				var _game$layers$i = this.game.layers[i];
				var blendMode = _game$layers$i.blendMode;
				var alpha = _game$layers$i.alpha;
				var canvas = _game$layers$i.canvas;

				if (blendMode && blendMode !== gco) {
					gco = screenCtx.globalCompositeOperation = blendMode;
				}
				if (globalAlpha && globalAlpha !== alpha) {
					globalAlpha = screenCtx.globalAlpha = alpha;
				}
				screenCtx.drawImage(canvas, 0, 0, canvas.width, canvas.height, 0, 0, screen.width, screen.height);
			}
		} else {
			screenCtx.drawImage(this.drawCanvas, 0, 0, this.drawCanvas.width, this.drawCanvas.height, 0, 0, screen.width, screen.height);
		}
		screenCtx.drawImage(this.debugCanvas, 0, 0, this.debugCanvas.width, this.debugCanvas.height, 0, 0, screen.width, screen.height);
	};

	return GameRunner;
})();

module.exports = GameRunner;

},{"./clock":158,"./constants":160,"./game":165,"./input":169,"./util":181,"./vec2":182}],167:[function(require,module,exports){
'use strict';

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var PixelBuffer = require('./pixel_buffer');

var Layer = (function () {
	function Layer(name, width, height) {
		_classCallCheck(this, Layer);

		this.name = name;
		this.buffer = new PixelBuffer(width, height);
		this.width = this.buffer.width;
		this.height = this.buffer.height;
		this.canvas = this.buffer.canvas;
		this.context = this.buffer.context;
		this.viewport = { x: 0, y: 0, width: this.width, height: this.height };

		this.alpha = 1.0;
		this.blendMode = 'source-over';
	}

	Layer.prototype.clear = function clear() {
		this.context.clearRect(0, 0, this.width, this.height);
	};

	Layer.prototype.fill = function fill(color) {
		this.context.fillStyle = color;
		this.context.fillRect(0, 0, this.width, this.height);
	};

	return Layer;
})();

module.exports = Layer;

},{"./pixel_buffer":177}],168:[function(require,module,exports){
'use strict';

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var Particle = require('./particle');
var Consts = require('./constants');
var Clock = require('./clock');

var _require = require('./rand');

var RNG = _require.RNG;

var math = require('./math');
var Blood = require('./blood');

var Gore = (function (_Particle) {
	_inherits(Gore, _Particle);

	function Gore(game, x, y) {
		var z = arguments.length <= 3 || arguments[3] === undefined ? 5 : arguments[3];

		_classCallCheck(this, Gore);

		var _this = _possibleConstructorReturn(this, _Particle.call(this, game, x, y, z));

		_this.radius = 1;
		_this.life *= 2;
		_this.timed = true;
		_this.collidesWithEntities = false;
		_this.drag.set(2, 2);
		_this.elastic = true;
		_this.color = RNG.colorBetween(0xff1a395f, 0xff304880); // 0xff7898f0, 0xff88a8ff)
		return _this;
	}

	Gore.prototype.update = function update(dt) {
		_Particle.prototype.update.call(this, dt);
		if (this.vel.length() > 5) {
			var blood = new Blood(this.game, this.pos.x, this.pos.y, Math.max(0.1, this.pos.z - 1));
			blood.zPos = this.zPos;
			blood.vel.x *= 0.05;blood.vel.x += this.vel.x;
			blood.vel.y *= 0.05;blood.vel.y += this.vel.y;
			blood.zVel *= 0.05;blood.zVel += this.zVel;
			this.game.addEntity(blood);
		}
	};

	Gore.prototype.doCollision = function doCollision(o) {
		if (!this.enabled) return;
		if (o && o instanceof Gore) return;
		for (var i = 0; i < 20; i++) {
			var blood = new Blood(this.game, this.pos.x, this.pos.y);
			blood.zPos = this.zPos;
			blood.vel.x *= 0.05;blood.vel.x += this.vel.x * 0.5;
			blood.vel.y *= 0.05;blood.vel.y += this.vel.y * 0.5;
			blood.zVel *= 0.05;blood.zVel += this.zVel * 0.5;
			this.game.addEntity(blood);
		}
	};

	Gore.prototype.onGroundCollision = function onGroundCollision() {
		if (Math.abs(this.zVel) > 5) this.doCollision();
	};

	Gore.prototype.onCollision = function onCollision(o) {
		this.doCollision(o);
	};

	return Gore;
})(Particle);

module.exports = Gore;

},{"./blood":155,"./clock":158,"./constants":160,"./math":175,"./particle":176,"./rand":179}],169:[function(require,module,exports){
'use strict';

var _require = require('./debug');

var ASSERT = _require.ASSERT;

var Consts = require('./constants');
// mostly borrowed from my library, demon.js, with some modifications
var Mouse = {
	x: 0,
	y: 0,
	dx: 0,
	dy: 0,
	lastX: 0,
	lastY: 0,
	isDown: false,
	transitions: 0,
	wasPressed: function wasPressed() {
		return this.isDown && this.transitions > 0;
	},
	wasReleased: function wasReleased() {
		return !this.isDown && this.transitions > 0;
	}
};

var MouseScreen = null;
function updateMousePos(cx, cy) {
	var rect = MouseScreen.getBoundingClientRect();
	cx -= rect.left;
	cy -= rect.top;
	Mouse.x = cx / Consts.Scale;
	Mouse.y = cy / Consts.Scale;
	Mouse.dx = Mouse.x - Mouse.lastX;
	Mouse.dy = Mouse.y - Mouse.lastY;
}

function initMouse(screen) {
	MouseScreen = screen;
	window.addEventListener('blur', function () {
		Mouse.isDown = false;
		Mouse.lastX = Mouse.dx = Mouse.x = Mouse.lastY = Mouse.dy = Mouse.y = 0;
		Mouse.transitions = 0;
	});

	window.addEventListener('mousedown', function (e) {
		if (e.button === 0) {
			Mouse.isDown = true;++Mouse.transitions;
		}
		updateMousePos(e.clientX, e.clientY);
		e.preventDefault();
	});

	window.addEventListener('mouseup', function (e) {
		if (e.button === 0) {
			Mouse.isDown = false;++Mouse.transitions;
		}
		updateMousePos(e.clientX, e.clientY);
		e.preventDefault();
	});

	window.addEventListener('mousemove', function (e) {
		updateMousePos(e.clientX, e.clientY);
		e.preventDefault();
	});
}

function updateMouse() {
	Mouse.transitions = 0;
	Mouse.lastX = Mouse.x;
	Mouse.lastY = Mouse.y;
}

var KEYMAX = 256;

var Keyboard = {
	KeyCodes: null,
	KeyCodeInverse: null,
	KC: {},
	KCI: {},
	keyTransitions: new Uint8Array(KEYMAX),
	keysDown: new Uint8Array(KEYMAX),
	defaultPrevented: new Array(KEYMAX),

	isDownC: function isDownC(kc) {
		return !!this.keysDown[kc >>> 0];
	},
	transitionsC: function transitionsC(kc) {
		return this.keyTransitions[kc >>> 0];
	},
	wasPressedC: function wasPressedC(kc) {
		var code = kc >>> 0;return !!(this.keysDown[code] && this.keyTransitions[code]);
	},
	wasReleasedC: function wasReleasedC(kc) {
		var code = kc >>> 0;return !!(!this.keysDown[code] && this.keyTransitions[code]);
	},
	isDown: function isDown(key) {
		return this.isDownC(keyToCode(key));
	},
	transitions: function transitions(key) {
		return this.transitionsC(keyToCode(key));
	},
	wasPressed: function wasPressed(key) {
		return this.wasPressedC(keyToCode(key));
	},
	wasReleased: function wasReleased(key) {
		return this.wasReleasedC(keyToCode(key));
	}
};

Keyboard.KeyCodes = Keyboard.KC;
Keyboard.KeyCodeInverse = Keyboard.KCI;
var KnownKeys = new Uint8Array(KEYMAX);

function keyToCode(key) {
	var code = 0;
	if (typeof key === 'number') {
		code = key >>> 0;
		if (KnownKeys[code] === 0) {
			console.error("Keycode " + key + " is not mapped to any known key");return 0;
		}
	} else {
		var maybeCode = Keyboard.KC[key];
		if (maybeCode === 0) {
			console.error("Unknown key: " + key);return 0;
		}
		code = maybeCode >>> 0;
	}
	if (code >= KEYMAX || code === 0) {
		console.error("Keycode " + key + " is outside valid range: " + code);return 0;
	}
	return code;
}

(function () {
	var keysToCodes = {
		A: 65, B: 66, C: 67, D: 68, E: 69, F: 70, G: 71, H: 72, I: 73, J: 74, K: 75, L: 76, M: 77, N: 78, O: 79, P: 80, Q: 81, R: 82, S: 83, T: 84, U: 85, V: 86, W: 87, X: 88, Y: 89, Z: 90,
		Left: 37, Up: 38, Right: 39, Down: 40,
		Escape: 27, Return: 13,
		Backspace: 8, Space: 32, Tab: 9,
		Num0: 48, Num1: 49, Num2: 50, Num3: 51, Num4: 52, Num5: 53, Num6: 54, Num7: 55, Num8: 56, Num9: 57,
		Numpad0: 96, Numpad1: 97, Numpad2: 98, Numpad3: 99, Numpad4: 100, Numpad5: 101, Numpad6: 102, Numpad7: 103, Numpad8: 104, Numpad9: 105,
		NumpadMinus: 109, NumpadPlus: 107, NumpadEqual: 12, NumpadSlash: 111,
		F1: 112, F2: 113, F3: 114, F4: 115, F5: 116, F6: 117, F7: 118, F8: 119, F9: 120, F10: 121, F11: 122, F12: 123,
		Tilde: 192, Shift: 16, Ctrl: 17, Alt: 18,
		Colon: 186, Equals: 187, Comma: 188, Minus: 189, Period: 190, Slash: 191, OpenBracket: 219, CloseBracket: 221, Backslash: 220, Quote: 222
	};

	var kcAliases = {
		Tilde: ['Backtick'], Return: ['Enter'], Escape: ['Esc'], Ctrl: ['Control'], Alt: ['Meta'],
		Num0: ['Zero'], Num1: ['One'], Num2: ['Two'], Num3: ['Three'], Num4: ['Four'], Num5: ['Five'], Num6: ['Six'], Num7: ['Seven'], Num8: ['Eight'], Num9: ['Nine']
	};

	Object.keys(keysToCodes).forEach(function (key) {
		var code = keysToCodes[key];
		ASSERT(code < KEYMAX, "[BUG] keycode for " + key + " is greater than KEYMAX");
		Keyboard.KCI[code] = key;
		KnownKeys[code] = 1;
		var keys = [key].concat(kcAliases[key] || []);
		keys.forEach(function (keyName) {
			Keyboard.KC[keyName] = code;
			Keyboard.KC[keyName.toLowerCase()] = code;
			var camelCase = keyName[0].toLowerCase() + keyName.slice(1);
			Keyboard.KC[camelCase] = code;
			var capCase = keyName.replace(/([a-z])([A-Z])/g, '$1_$2').toUpperCase();
			Keyboard.KC[capCase] = code;
		});
	});

	for (var _i = 0; _i < KEYMAX; ++_i) {
		Keyboard.defaultPrevented[_i] = true;
	}

	for (var i = 1; i <= 12; ++i) {
		Keyboard.defaultPrevented[Keyboard.KC["F" + i]] = false;
	}
})();

var keyTransitions32 = new Uint32Array(Keyboard.keyTransitions.buffer);
var keysDown32 = new Uint32Array(Keyboard.keysDown.buffer);

function initKeyboard() {
	window.addEventListener('keydown', function (e) {
		var kc = e.keyCode >>> 0;
		if (kc > KEYMAX || kc === 0) {
			console.warn("Unknown keycode value from DOM event.", e);return;
		}
		if (!Keyboard.keysDown[kc]) {
			Keyboard.keysDown[kc] = 1;++Keyboard.keyTransitions[kc];
		}
		if (Keyboard.defaultPrevented[kc]) {
			e.preventDefault();
		}
	});

	window.addEventListener('keyup', function (e) {
		var kc = e.keyCode >>> 0;
		if (kc > KEYMAX || kc === 0) {
			console.warn("Unknown keycode value from DOM event.", e);return;
		}
		if (Keyboard.keysDown[kc]) {
			Keyboard.keysDown[kc] = false;++Keyboard.keyTransitions[kc];
		}
		if (Keyboard.defaultPrevented[kc]) {
			e.preventDefault();
		}
	});

	window.addEventListener('blur', function () {
		for (var i = 0; i < keyTransitions32.length; ++i) {
			keyTransitions32[i] = 0;
		}for (var i = 0; i < keysDown32.length; ++i) {
			keysDown32[i] = 0;
		}
	});
}

function updateKeyboard() {
	for (var i = 0; i < keyTransitions32.length; ++i) {
		keyTransitions32[i] = 0;
	}
}

exports.mouse = exports.Mouse = Mouse;
exports.keyboard = exports.keys = exports.Keyboard = Keyboard;
exports.KeyCode = Keyboard.KeyCodes;

exports.initialize = function (screen) {
	initMouse(screen);
	initKeyboard(screen);
};

exports.update = function () {
	updateMouse();
	updateKeyboard();
};

},{"./constants":160,"./debug":161}],170:[function(require,module,exports){
'use strict';

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var Particle = require('./particle');
var Consts = require('./constants');
var Clock = require('./clock');

var _require = require('./rand');

var RNG = _require.RNG;

var math = require('./math');
var Sounds = require('./audio');
var Entity = require('./entity');
var Vec2 = require('./vec2');

var Key = (function (_Entity) {
	_inherits(Key, _Entity);

	function Key(game, x, y, keyInfo) {
		_classCallCheck(this, Key);

		var _this = _possibleConstructorReturn(this, _Entity.call(this, game, x, y));

		_this.keyInfo = keyInfo;
		_this.radius = 8;
		_this.mobile = false;
		_this.noiseTimer = 0;
		return _this;
	}

	Key.prototype.onCollision = function onCollision(who) {
		if (who === this.game.player) {
			this.unlock();
		}
	};

	Key.prototype.unlock = function unlock() {
		Sounds.play('unlock');
		this.game.unlock(this.keyInfo);
		this.enabled = false;
	};

	Key.prototype.update = function update(dt) {
		_Entity.prototype.update.call(this, dt);
		this.noiseTimer += dt;
		var pdist = this.game.player.pos.distance(this.pos);
		if (pdist < this.radius + this.game.player.radius) {
			this.unlock();
		} else if (this.noiseTimer > 3000) {
			if (this.game.player.pos.distance(this.pos) < 10 * Consts.TileSize) {
				Sounds.playWobble(this.keyInfo.id);
			}
		}
	};

	Key.prototype.render = function render(layer) {
		if (!this.game.canSee(this.game.player.pos, Vec2.temp(this.pos.x + this.radius, this.pos.y + this.radius)) && !this.game.canSee(this.game.player.pos, Vec2.temp(this.pos.x + this.radius, this.pos.y - this.radius)) && !this.game.canSee(this.game.player.pos, Vec2.temp(this.pos.x - this.radius, this.pos.y + this.radius)) && !this.game.canSee(this.game.player.pos, Vec2.temp(this.pos.x - this.radius, this.pos.y - this.radius))) {
			return;
		}
		layer.context.drawImage(this.game.assets.misc, 16, 16 * this.keyInfo.id, 16, 16, this.pos.x - 8, this.pos.y - 8, 16, 16);
	};

	return Key;
})(Entity);

module.exports = Key;

},{"./audio":154,"./clock":158,"./constants":160,"./entity":164,"./math":175,"./particle":176,"./rand":179,"./vec2":182}],171:[function(require,module,exports){
'use strict';

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var LineSegment = require('./line_segment');
var Vec2 = require('./vec2');
var Consts = require('./constants');

var TileInfo = (function () {
	function TileInfo(edges) {
		var tx = arguments.length <= 1 || arguments[1] === undefined ? 0 : arguments[1];
		var ty = arguments.length <= 2 || arguments[2] === undefined ? 0 : arguments[2];

		_classCallCheck(this, TileInfo);

		this.id = -1;
		this.edges = edges.map(function (_ref) {
			var _ref$start = _ref.start;
			var sx = _ref$start.x;
			var sy = _ref$start.y;
			var _ref$end = _ref.end;
			var ex = _ref$end.x;
			var ey = _ref$end.y;
			return new LineSegment(new Vec2(sx + tx, sy + ty), new Vec2(ex + tx, ey + ty));
		});
	}

	TileInfo.prototype.offsetBy = function offsetBy(x, y) {
		return new TileInfo(this.edges, x, y);
	};

	return TileInfo;
})();

// function triangle(p0, p1, p2) {
// 	return new TileInfo([{start: p0, end: p1}, {start: p1, end: p2}, {start: p2, end: p0}])
// }

function polygon() {
	for (var _len = arguments.length, pts = Array(_len), _key = 0; _key < _len; _key++) {
		pts[_key] = arguments[_key];
	}

	return new TileInfo(pts.map(function (pt, i) {
		return { start: pt.scaled(Consts.TileSize), end: pts[(i + 1) % pts.length].scaled(Consts.TileSize) };
	}));
}

function v(x, y) {
	return new Vec2(x, y);
}

var TILE_MID = new Vec2(0.5, 0.5);

// function triTile(p0, p1, p2) {
// 	return [
// 		triangle(p0, p1, p2),
// 		triangle(p0.rotated90(TILE_MID), p1.rotated90(TILE_MID), p2.rotated90(TILE_MID)),
// 		triangle(p0.rotated180(TILE_MID), p1.rotated180(TILE_MID), p2.rotated180(TILE_MID)),
// 		triangle(p0.rotated270(TILE_MID), p1.rotated270(TILE_MID), p2.rotated270(TILE_MID))
// 	];
// }

function polyTile() {
	for (var _len2 = arguments.length, pts = Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
		pts[_key2] = arguments[_key2];
	}

	return [polygon.apply(undefined, pts), polygon.apply(undefined, pts.map(function (pt) {
		return pt.rotated90(TILE_MID);
	})), polygon.apply(undefined, pts.map(function (pt) {
		return pt.rotated180(TILE_MID);
	})), polygon.apply(undefined, pts.map(function (pt) {
		return pt.rotated270(TILE_MID);
	}))];
}

function polyTile2S() {
	for (var _len3 = arguments.length, pts = Array(_len3), _key3 = 0; _key3 < _len3; _key3++) {
		pts[_key3] = arguments[_key3];
	}

	return [polygon.apply(undefined, pts), polygon.apply(undefined, pts.map(function (pt) {
		return pt.rotated90(TILE_MID);
	})), polygon.apply(undefined, pts.map(function (pt) {
		return pt.xFlipped(0.5);
	}).reverse()), polygon.apply(undefined, pts.map(function (pt) {
		return pt.xFlipped(0.5).rotated90(TILE_MID);
	}).reverse())];
}
function polyTile2() {
	for (var _len4 = arguments.length, pts = Array(_len4), _key4 = 0; _key4 < _len4; _key4++) {
		pts[_key4] = arguments[_key4];
	}

	return [polygon.apply(undefined, pts), polygon.apply(undefined, pts.map(function (pt) {
		return pt.rotated90(TILE_MID);
	}))];
}

function polyTile2F() {
	for (var _len5 = arguments.length, pts = Array(_len5), _key5 = 0; _key5 < _len5; _key5++) {
		pts[_key5] = arguments[_key5];
	}

	return polyTile.apply(undefined, pts).concat(polyTile.apply(undefined, pts.map(function (pt) {
		return pt.xFlipped();
	})));
}

var H = 0.5;
var Q = 0.25;
var S = 0.75;
var T = 1.0 / 3.0;
var X = 2.0 / 3.0;

var Tiles = [].concat([new TileInfo([])], // empty
[polygon(v(0, 0), v(0, 1), v(1, 1), v(1, 0))], // quad, 100% symmetry
polyTile(v(0, 0), v(0, H), v(1, H), v(1, 0)), polyTile(v(0, 0), v(0, 1), v(1, 0)), polyTile(v(0, 0), v(0, H), v(1, 0)), polyTile(v(0, 0), v(1, H), v(1, 0)), polyTile(v(0, 0), v(0, 1), v(1, H), v(1, 0)), polyTile(v(0, 0), v(0, H), v(1, 1), v(1, 0)), polyTile(v(0, H), v(1, H), v(1, 0)), polyTile(v(0, 0), v(0, H), v(1, H)), polyTile(v(0, 0), v(0, H), v(H, 0)), polyTile(v(0, 0), v(0, H), v(H, H), v(H, 0)), polyTile2S(v(0, 0), v(H, 1), v(1, 1), v(H, 0)), polyTile2(v(0, 0), v(0, H), v(H, 1), v(1, 1), v(1, H), v(H, 0)), polyTile(v(0, 0), v(0, 1), v(H, 1), v(H, H), v(1, H), v(1, 0)), polyTile(v(0, 0), v(0, 1), v(H, 1), v(1, H), v(1, 0))
// polyTile2F(v(0, 0), v(0, 1), v(1, 1), v(H, H), v(H, 0))

);

var TestLevel = {
	width: 30,
	height: 30,
	spawnX: 3,
	spawnY: 2,
	tiles: [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 6, 0, 0, 19, 1, 1, 1, 1, 18, 2, 2, 2, 2, 2, 2, 2, 10, 0, 0, 0, 14, 1, 1, 18, 10, 0, 0, 7, 1, 1, 0, 0, 0, 11, 1, 1, 1, 1, 0, 12, 4, 0, 4, 4, 0, 2, 34, 0, 12, 4, 20, 1, 6, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 19, 1, 1, 1, 0, 7, 1, 0, 1, 1, 0, 2, 34, 15, 25, 0, 19, 25, 0, 0, 0, 12, 4, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 7, 13, 0, 1, 0, 1, 1, 0, 2, 34, 3, 5, 0, 3, 17, 0, 0, 15, 17, 0, 0, 1, 1, 56, 57, 58, 59, 0, 1, 9, 0, 0, 15, 1, 0, 1, 1, 0, 2, 34, 3, 5, 0, 3, 0, 0, 0, 3, 0, 0, 0, 1, 1, 9, 0, 0, 0, 8, 1, 1, 1, 1, 1, 1, 0, 1, 1, 0, 2, 34, 3, 5, 0, 11, 0, 13, 0, 3, 10, 12, 4, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 18, 0, 1, 1, 0, 2, 34, 11, 21, 0, 0, 12, 17, 0, 3, 0, 0, 0, 1, 1, 1, 25, 0, 0, 0, 0, 0, 0, 0, 0, 0, 12, 1, 1, 0, 2, 34, 0, 14, 2, 2, 10, 0, 0, 3, 0, 12, 4, 1, 1, 1, 5, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 2, 34, 0, 0, 0, 0, 0, 0, 0, 23, 0, 0, 0, 1, 1, 1, 21, 0, 0, 15, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 1, 1, 17, 0, 0, 0, 0, 0, 15, 25, 0, 0, 0, 1, 1, 1, 1, 21, 0, 23, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 23, 17, 0, 0, 0, 1, 1, 1, 1, 1, 0, 22, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 19, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 10, 0, 19, 0, 0, 0, 0, 0, 0, 14, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 11, 1, 1, 0, 0, 3, 0, 8, 1, 1, 1, 24, 0, 1, 1, 1, 1, 9, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 23, 0, 1, 1, 1, 1, 1, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 9, 0, 0, 0, 0, 0, 1, 1, 0, 20, 18, 0, 1, 1, 1, 1, 1, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 21, 0, 23, 1, 1, 1, 1, 9, 0, 0, 0, 7, 1, 1, 1, 1, 0, 1, 1, 1, 1, 1, 17, 0, 0, 0, 0, 0, 11, 1, 25, 0, 19, 1, 1, 1, 1, 1, 1, 1, 13, 0, 1, 1, 1, 10, 0, 14, 1, 1, 1, 1, 0, 8, 1, 1, 1, 21, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 21, 0, 1, 1, 1, 0, 0, 0, 1, 1, 1, 1, 0, 1, 1, 1, 1, 6, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 25, 0, 1, 1, 1, 16, 0, 12, 1, 1, 1, 1, 0, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 17, 15, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 7, 1, 1, 24, 16, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 0, 23, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 21, 0, 1, 1, 1, 1, 24, 16, 0, 0, 8, 1, 1, 1, 1, 1, 1, 0, 22, 1, 1, 1, 6, 0, 0, 0, 0, 0, 0, 0, 0, 8, 1, 1, 1, 1, 1, 1, 0, 0, 1, 1, 1, 1, 1, 1, 1, 9, 0, 0, 0, 0, 8, 1, 1, 1, 1, 1, 1, 1, 18, 22, 1, 1, 1, 1, 1, 1, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 14, 22, 22, 22, 22, 22, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 8, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 13, 0, 12, 20, 20, 20, 20, 20, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1

	/*
 1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,
 1,6,0,0,19,1,1,1,1,18,2,2,2,2,2,2,2,10,0,0,0,14,1,1,18,10,0,0,7,1,
 1,0,0,0,11,1,1,1,1,0,12,4,0,4,4,0,2,10,0,12,4,20,1,6,0,0,0,0,0,1,
 1,0,0,0,0,19,1,1,1,0,7,1,0,1,1,0,2,10,15,25,0,19,25,0,0,0,12,4,0,1,
 1,0,0,0,0,0,0,0,7,13,0,1,0,1,1,0,2,10,3,5,0,3,17,0,0,15,17,0,0,1,
 1,0,0,0,0,0,1,9,0,0,15,1,0,1,1,0,2,10,3,5,0,3,0,0,0,3,0,0,0,1,
 1,9,0,0,0,8,1,1,1,1,1,1,0,1,1,0,2,10,3,5,0,11,0,13,0,3,10,12,4,1,
 1,1,1,1,1,1,1,1,1,1,1,18,0,1,1,0,2,10,11,21,0,0,12,17,0,3,0,0,0,1,
 1,1,25,0,0,0,0,0,0,0,0,0,12,1,1,0,2,10,0,14,2,2,10,0,0,3,0,12,4,1,
 1,1,5,0,0,0,1,1,1,1,1,1,1,1,1,0,2,10,0,0,0,0,0,0,0,23,0,0,0,1,
 1,1,21,0,0,15,1,1,1,1,1,1,1,1,1,0,1,1,17,0,0,0,0,0,15,25,0,0,0,1,
 1,1,1,21,0,23,1,1,1,1,1,1,1,1,1,0,0,0,0,0,0,0,0,0,23,17,0,0,0,1,
 1,1,1,1,0,22,1,1,1,1,1,1,1,1,1,0,19,1,1,1,1,1,1,1,1,1,1,1,1,1,
 1,10,0,19,0,0,0,0,0,0,14,1,1,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,11,1,
 1,0,0,3,0,8,1,1,1,24,0,1,1,1,1,9,0,0,0,0,0,0,0,0,0,0,0,0,0,1,
 1,0,0,23,0,1,1,1,1,1,0,1,1,1,1,1,1,1,1,1,1,1,1,9,0,0,0,0,0,1,
 1,0,20,18,0,1,1,1,1,1,0,1,1,1,1,1,1,1,1,1,1,1,1,1,21,0,23,1,1,1,
 1,9,0,0,0,7,1,1,1,1,0,1,1,1,1,1,17,0,0,0,0,0,11,1,25,0,19,1,1,1,
 1,1,1,1,13,0,1,1,1,10,0,14,1,1,1,1,0,8,1,1,1,21,0,0,0,0,0,0,1,1,
 1,1,1,1,21,0,1,1,1,0,0,0,1,1,1,1,0,1,1,1,1,6,0,0,0,0,0,0,1,1,
 1,1,1,1,25,0,1,1,1,16,0,12,1,1,1,1,0,1,1,1,1,0,0,0,0,0,0,0,1,1,
 1,1,1,1,17,15,1,1,1,1,1,1,1,1,1,1,0,0,7,1,1,24,16,0,0,0,0,0,1,1,
 1,1,1,1,0,23,1,1,1,1,1,1,1,1,1,1,1,21,0,1,1,1,1,24,16,0,0,8,1,1,
 1,1,1,1,0,22,1,1,1,6,0,0,0,0,0,0,0,0,8,1,1,1,1,1,1,0,0,1,1,1,
 1,1,1,1,9,0,0,0,0,8,1,1,1,1,1,1,1,18,22,1,1,1,1,1,1,0,0,1,1,1,
 1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,0,14,22,22,22,22,22,0,0,1,1,1,
 1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,0,0,0,0,0,0,0,0,8,1,1,1,
 1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,13,0,12,20,20,20,20,20,1,1,1,1,1,
 1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,
 1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1*/
	]
};

exports.TestLevel = TestLevel;

exports.Tiles = Tiles;
exports.TileInfo = TileInfo;

},{"./constants":160,"./line_segment":173,"./vec2":182}],172:[function(require,module,exports){
'use strict';

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var Vec2 = require('./Vec2');
// const LineSegment = require('./line_segment');
var math = require('./math');

var _require = require('./debug');

var ASSERT = _require.ASSERT;
// based on code originally by amit patel: www.redblobgames.com/articles/visibility/
// needs some work since it seems to be O(n^2) in the number of points in the level... @NOTE: may have fixed this now
// if this weren't in a jam i'd make an effort to fix that problem, and to reuse the
// line segment / raycasting code I already wrote...

function leftOf(_ref, x, y) {
	var start = _ref.start;
	var end = _ref.end;

	return (end.x - start.x) * (y - start.y) - (end.y - start.y) * (x - start.x) < 0.0;
}

function inFrontOf(a, b, center) {
	// @NOTE: check if we can just compare a.d to b.d...
	var a1 = leftOf(a, math.lerp(b.start.x, b.end.x, 0.01), math.lerp(b.start.y, b.end.y, 0.01));
	var a2 = leftOf(a, math.lerp(b.end.x, b.start.x, 0.01), math.lerp(b.end.y, b.start.y, 0.01));
	var a3 = leftOf(a, center.x, center.y);

	var b1 = leftOf(b, math.lerp(a.start.x, a.end.x, 0.01), math.lerp(a.start.y, a.end.y, 0.01));
	var b2 = leftOf(b, math.lerp(a.end.x, a.start.x, 0.01), math.lerp(a.end.y, a.start.y, 0.01));
	var b3 = leftOf(b, center.x, center.y);

	if (b1 === b2 && b2 !== b3) return true;
	if (a1 === a2 && a2 === a3) return true;
	if (a1 === a2 && a2 !== a3) return false;
	if (b1 === b2 && b2 === b3) return false;
	return false;
}
var idctr = 0;

var VisSegment = (function () {
	function VisSegment(start, end) {
		_classCallCheck(this, VisSegment);

		this.start = start;
		this.end = end;
		this.start.segment = this;
		this.end.segment = this;
		this.d = 0.0;
		this.next = null;
		this.prev = null;
		this.listGen_ = -1;
		this.id_ = ++idctr;
	}

	VisSegment.prototype.clone = function clone() {
		var vs = new VisSegment(this.start, this.end);
		vs.start = this.start;
		vs.end = this.end;
		vs.start = this.start;
		vs.end = this.end;
		vs.d = this.d;
		vs.next = this.next;
		vs.prev = this.prev;
		// vs.listGen_ = this.listGen_;
		// vs.id_ = this.id_;
		return vs;
	};

	return VisSegment;
})();

var currentListGen = 0;

function lineIntersection(p1x, p1y, p2x, p2y, p3x, p3y, p4x, p4y) {
	var s = ((p4x - p3x) * (p1y - p3y) - (p4y - p3y) * (p1x - p3x)) / ((p4y - p3y) * (p2x - p1x) - (p4x - p3x) * (p2y - p1y));
	return Vec2.temp(p1x + s * (p2x - p1x), p1y + s * (p2y - p1y));
}

function pointSorter(a, b) {
	var aAngle = +a.angle,
	    bAngle = +b.angle;
	if (aAngle !== bAngle) return aAngle - bAngle;else return !a.begin && b.begin ? -1 : a.begin && !b.begin ? 1 : 0;
}

var SegList = (function () {
	function SegList() {
		_classCallCheck(this, SegList);

		this.head = null;
		this.tail = null;
	}

	SegList.prototype.append = function append(seg) {
		// console.log('APPEND: '+seg.id_);
		if (seg.listGen_ === currentListGen) {
			seg = seg.clone();
			// console.log(' NEW ID => '+seg.id_)
		}
		seg.listGen_ = currentListGen;
		seg.next = seg.prev = null;
		if (this.head == null && this.tail == null) {
			this.head = this.tail = seg;
			// console.log('  ONLY NODE: '+seg.id_);
		} else {
				ASSERT(seg != this.head && seg != this.tail);
				// console.log('  TAIL '+this.tail.id_+' => '+seg.id_);
				this.tail.next = seg;
				seg.prev = this.tail;
				this.tail = seg;
			}
		// this.check();
	};

	SegList.prototype.remove = function remove(seg) {
		if (seg === this.tail) this.tail = seg.prev;
		if (seg === this.head) this.head = seg.next;
		if (seg.next) seg.next.prev = seg.prev;
		if (seg.prev) seg.prev.next = seg.next;
		seg.next = seg.prev = null;
	};

	SegList.prototype.empty = function empty() {
		return !this.head;
	};

	SegList.prototype.insertBefore = function insertBefore(seg, other) {
		// console.log('INSERT_BEFORE: '+seg.id_+', '+other.id_);
		if (other.listGen_ === currentListGen) {
			other = other.clone();
			// console.log('  NEW ID => '+other.id_);
		}
		other.listGen_ = currentListGen;
		other.next = other.prev = null;
		ASSERT(seg != null);
		if (this.empty() || seg == null) {
			return this.append(other);
		}
		// console.log('  BETWEEN: '+(!seg.prev ? 'nothing' : seg.prev.id_)+' AND: '+seg.id_);

		other.prev = seg.prev;
		other.next = seg;
		seg.prev = other;
		if (other.prev) {
			other.prev.next = other;
		}
		other.next.prev = other;
		if (seg === this.head) {
			this.head = other;
		}
		// this.check();
	};

	SegList.prototype.clear = function clear(unlink) {
		while (this.head != null) {
			var next = this.head.next;

			this.head.prev = this.head.next = null;
			this.head = next;
		}
		this.head = this.tail = null;
	};

	SegList.prototype.toString = function toString() {
		var r = [];
		for (var n = this.head; n != null; n = n.next) {
			r.push('[' + n.id_ + ']');
			if (n.next === this.head) {
				debugger;
				document.body.innerHTML += 'BAD';
			}
		}
		return '[' + r.join(' ') + ']';
	};

	SegList.prototype.check = function check() {
		// console.log(this.toString());
		var seen = {};
		ASSERT(this.head == null === (this.tail == null));
		ASSERT(this.head.prev == null);
		ASSERT(this.tail.next == null);

		for (var n = this.head; n != null; n = n.next) {

			if (n.prev) ASSERT(n.prev.next === n);else ASSERT(n === this.head);

			if (n.next) ASSERT(n.next.prev === n);else ASSERT(n === this.tail);
			ASSERT(!(n.id_ in seen));
			seen[n.id_] = true;
		}
	};

	return SegList;
})();

var SegPoint = function SegPoint(pos) {
	_classCallCheck(this, SegPoint);

	this.x = pos.x;
	this.y = pos.y;
	this.pos = pos;
	this.begin = false;
	this.segment = null;
	this.angle = 0.0;
};

// @TODO: support camera explicitly.

var VisTracker = (function () {
	function VisTracker() {
		_classCallCheck(this, VisTracker);

		this.segments = [];
		this.points = [];
		this.open = new SegList();
		this.center = new Vec2(0.0, 0.0);
		this.outXs = [];
		this.outYs = [];
	}

	VisTracker.prototype.setSegments = function setSegments(segs) {
		this.segments.length = 0;
		this.points.length = 0;
		// this.open.clear();
		// this.outXs.length = 0;
		// this.outYs.length = 0;
		for (var i = 0; i < segs.length; ++i) {
			this.addSegment(segs[i].start, segs[i].end);
		}
	};

	VisTracker.prototype.addSegment = function addSegment(start, end) {
		var sp = new SegPoint(start);
		var ep = new SegPoint(end);
		this.segments.push(new VisSegment(sp, ep));
		this.points.push(sp, ep);
	};

	VisTracker.prototype.setCenter = function setCenter(_ref2) {
		var x = _ref2.x;
		var y = _ref2.y;

		this.center.set(x, y);
		for (var i = 0; i < this.segments.length; ++i) {
			var seg = this.segments[i];
			var dx = 0.5 * (seg.start.x + seg.end.x) - x;
			var dy = 0.5 * (seg.start.y + seg.end.y) - y;
			seg.d = dx * dx + dy * dy;
			seg.start.angle = Math.atan2(seg.start.y - y, seg.start.x - x);
			seg.end.angle = Math.atan2(seg.end.y - y, seg.end.x - x);
			var delta = seg.end.angle - seg.start.angle;
			if (delta <= -Math.PI) {
				delta += 2 * Math.PI;
			}
			if (delta > Math.PI) {
				delta -= 2 * Math.PI;
			}
			seg.start.begin = delta > 0.0;
			seg.end.begin = !seg.start.begin;
		}
	};

	VisTracker.prototype.sweep = function sweep() {
		var maxAngle = arguments.length <= 0 || arguments[0] === undefined ? 999 : arguments[0];

		++currentListGen;
		this.outXs.length = 0;
		this.outYs.length = 0;
		this.points.sort(pointSorter);
		this.open.clear();
		var beginAngle = 0;
		for (var pass = 0; pass < 2; ++pass) {
			for (var ep = 0, epl = this.points.length; ep < epl; ++ep) {
				var p = this.points[ep];
				if (pass === 1 && p.angle > maxAngle) {
					break;
				}
				var currentOld = this.open.head;
				if (p.begin) {
					var node = this.open.head;
					while (node != null && inFrontOf(p.segment, node, this.center)) {
						node = node.next;
					}
					if (node == null) {
						this.open.append(p.segment);
					} else {
						this.open.insertBefore(node, p.segment);
					}
					this.open.check();
				} else {
					this.open.remove(p.segment);
				}

				var currentNew = this.open.head;
				if (currentOld != currentNew) {
					if (pass === 1) {
						this.addTri_(beginAngle, p.angle, currentOld);
					}
					beginAngle = p.angle;
				}
			}
		}
	};

	VisTracker.prototype.addTri_ = function addTri_(a1, a2, segment) {
		var centerX = +this.center.x,
		    centerY = +this.center.y;
		var p1x = centerX,
		    p1y = +centerY;
		var p2x = p1x + Math.cos(a1),
		    p2y = p1y + Math.sin(a1);
		var p3x = 0.0,
		    p3y = 0.0;
		var p4x = 0.0,
		    p4y = 0.0;

		if (segment) {
			p3x = +segment.start.x;
			p3y = +segment.start.y;
			p4x = +segment.end.x;
			p4y = +segment.end.y;
		} else {
			p3x = centerX + Math.cos(a1) * 10000;
			p3y = centerY + Math.sin(a1) * 10000;
			p4x = centerX + Math.cos(a2) * 10000;
			p4y = centerY + Math.sin(a2) * 10000;
		}

		var _lineIntersection = lineIntersection(p3x, p3y, p4x, p4y, p1x, p1y, p2x, p2y);

		var xBegin = _lineIntersection.x;
		var yBegin = _lineIntersection.y;

		p2x = centerX + Math.cos(a2);
		p2y = centerY + Math.sin(a2);

		var _lineIntersection2 = lineIntersection(p3x, p3y, p4x, p4y, p1x, p1y, p2x, p2y);

		var xEnd = _lineIntersection2.x;
		var yEnd = _lineIntersection2.y;

		/*
  		let d21x = p2x-p1x, d21y = p2y-p1y;
  		let d31x = p3x-p1x, d31y = p3y-p1y;
  		let d43x = p4x-p3x, d43y = p4y-p3y;
  
  		let s = (d21x*d31y - d21y*d31x) / (d21y*d43x - d21x*d43y);
  		let xBegin = p3x + s * d43x;
  		let yBegin = p3y + s * d43y;
  
  		p2x = centerX + Math.cos(a2);
  		p2y = centerY + Math.sin(a2);
  
  		d21x = p2x-p1x;
  		d21y = p2y-p1y;
  		s = (d21x*d31y - d21y*d31x) / (d21y*d43x - d21x*d43y);
  
  		let xEnd = p3x + s * d43x;
  		let yEnd = p3y + s * d43y;
  
  		this.outXs.push(xEnd);
  		this.outYs.push(yEnd);*/

		this.outXs.push(xBegin, xEnd);
		this.outYs.push(yBegin, yEnd);
	};

	return VisTracker;
})();

exports.VisTracker = VisTracker;

},{"./Vec2":153,"./debug":161,"./math":175}],173:[function(require,module,exports){
'use strict';

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var Vec2 = require('./vec2');
var math = require('./math');

var _require = require('./debug');

var ASSERT = _require.ASSERT;

var drawing = require('./drawing');

var LineSegment = (function () {
	function LineSegment(start, end) {
		var flags = arguments.length <= 2 || arguments[2] === undefined ? 0 : arguments[2];

		_classCallCheck(this, LineSegment);

		this.start = start;
		this.end = end;
		this.flags = flags | 0;
	}

	LineSegment.prototype.normal = function normal() {
		// @HACK: seg is broken.
		var idx = this.start.x - this.end.x;
		var idy = this.start.y - this.end.y;
		var px = -idy,
		    py = idx;
		var il = 1.0 / (Math.sqrt(px * px + py * py) + 1e-37);
		return Vec2.temp(px * il, py * il);
	};

	LineSegment.prototype.closestPoint = function closestPoint(out, _ref) {
		var x = _ref.x;
		var y = _ref.y;

		var segX = this.end.x - this.start.x;
		var segY = this.end.y - this.start.y;

		var fx = x - this.start.x;
		var fy = y - this.start.y;

		var proj = segX * fx + segY * fy;
		var sdot = segX * segX + segY * segY;
		if (out) {
			if (proj <= 0) {
				out.x = this.start.x;
				out.y = this.start.y;
			} else if (proj >= sdot) {
				out.x = this.end.x;
				out.y = this.end.y;
			} else {
				var amount = proj / sdot;
				out.x = this.start.x + amount * segX;
				out.y = this.start.y + amount * segY;
			}
		}
		if (this.flags & LineSegment.DoubleSided) return false;
		return fx * -segY + fy * segX < 0;
	};

	LineSegment.prototype.getClosestPoint = function getClosestPoint(out, point) {
		if (!out) out = Vec2.temp(0.0, 0.0);
		this.closestPoint(out, point);
		return out;
	};

	LineSegment.prototype.debugRender = function debugRender(dbgCtx) {
		drawing.drawLine(dbgCtx, this.start.x, this.start.y, this.end.x, this.end.y, { endpoints: true });
		// drawing.drawBox(dbgCtx, this.start.x, this.start.y);
		// drawing.drawBox(dbgCtx, this.end.x, this.end.y);
		var delta = this.start.to(this.end);
		var norm = delta.perp().normalize();
		var mx = (this.start.x + this.end.x) * 0.5;
		var my = (this.start.y + this.end.y) * 0.5;
		drawing.drawLine(dbgCtx, mx, my, mx + 4 * norm.x, my + 4 * norm.y);
	};

	LineSegment.prototype.raycast = function raycast(outPos, outDir, rayPos, rayDir, size) {
		var bgnHit = math.raycastTimePoint(rayPos, rayDir, this.start, Vec2.ZERO, size);
		var endHit = math.raycastTimePoint(rayPos, rayDir, this.end, Vec2.ZERO, size);
		var midHit = math.raycastTimeLine(rayPos, rayDir, this.start, this.end, size);

		var hit = Math.min(Math.min(bgnHit, midHit), endHit);
		if (0 <= hit && hit <= 1) {
			var rayPoint = Vec2.temp(rayPos.x + hit * rayDir.x, rayPos.y + hit * rayDir.y);
			if (size > 0) {
				var closest = this.getClosestPoint(Vec2.temp(0.0, 0.0), rayPoint);
				var dx = rayPoint.x - closest.x;
				var dy = rayPoint.y - closest.y;
				var il = 1.0 / (Math.sqrt(dx * dx + dy * dy) + 1e-37);
				dx *= il;
				dy *= il;
				outPos.copy(closest);
				outDir.set(dx, dy);
			} else {
				var nx = -(this.end.y - this.start.y);
				var ny = this.end.x - this.start.x;
				var il = 1.0 / (Math.sqrt(nx * nx + ny * ny) + 1e-37);
				nx *= il;
				ny *= il;
				if (nx * rayDir.x + ny * rayDir.y > 0) {
					nx = -nx;
					ny = -ny;
				}
				outPos.copy(rayPos);
				outDir.set(nx, ny);
			}
		}
		return hit;
	};

	return LineSegment;
})();

LineSegment.Flags = {
	None: 0,
	DoubleSided: 1 << 0
};

// Transparent: (1 << 1),
// Nonspatial: (1 << 2),
module.exports = LineSegment;

},{"./debug":161,"./drawing":162,"./math":175,"./vec2":182}],174:[function(require,module,exports){
'use strict';

window.TIME_FUNCTIONS = false;

window.onload = function () {
	var GameRunner = require('./game_runner');
	window.gameRunner = new GameRunner(document.getElementById('screen'));
	window.gameRunner.start();
};

},{"./game_runner":166}],175:[function(require,module,exports){
'use strict';

var _require = require('./debug');

var ASSERT = _require.ASSERT;

var EPSILON = 0.0001;
var DEG2RAD = Math.PI / 180.0;
var RAD2DEG = 180.0 / Math.PI;

exports.EPSILON = EPSILON;
exports.DEG2RAD = DEG2RAD;
exports.RAD2DEG = RAD2DEG;

exports.toRadians = toRadians;
function toRadians(v) {
	return v * DEG2RAD;
}

exports.toDegrees = toDegrees;
function toDegrees(v) {
	return v * RAD2DEG;
}

exports.clamp = clamp;
function clamp(n, lo, hi) {
	return Math.min(hi, Math.max(lo, n));
}

exports.saturate = saturate;
function saturate(v) {
	return clamp(v, 0.0, 1.0);
}

exports.lerp = lerp;
function lerp(a, b, t) {
	var s = saturate(t);return a * (1.0 - s) + b * s;
}

exports.uLerp = uLerp;
function uLerp(a, b, t) {
	return a + (b - a) * t;
}

exports.square = square;
function square(v) {
	return v * v;
}

exports.cube = cube;
function cube(v) {
	return v * v * v;
}

exports.approxZero = approxZero;
function approxZero(v) {
	var eps = arguments.length <= 1 || arguments[1] === undefined ? EPSILON : arguments[1];
	return v <= eps || v >= -eps;
}

exports.approxEqual = approxEqual;
function approxEqual(a, b) {
	var eps = arguments.length <= 2 || arguments[2] === undefined ? EPSILON : arguments[2];
	return Math.abs(a - b) <= eps * Math.max(1.0, Math.abs(a), Math.abs(b));
}

exports.safeDiv = safeDiv;
function safeDiv(a, b, r) {
	return b === 0.0 ? r : a / b;
}

exports.safeDiv0 = safeDiv0;
function safeDiv0(a, b) {
	return safeDiv(a, b, 0.0);
}

exports.safeDiv1 = safeDiv1;
function safeDiv1(a, b) {
	return safeDiv(a, b, 1.0);
}

exports.signOf = signOf;
function signOf(v) {
	return v < 0 ? -1 : v > 0 ? 1 : 0;
}

exports.smoothStep01 = smoothStep01;
function smoothStep01(t) {
	return t * t * t * (t * (t * 6.0 - 15.0) + 10.0);
}

exports.linearStep = linearStep;
function linearStep(a, b, t) {
	return saturate(safeDiv0(t - a, b - a));
}

exports.smoothStep = smoothStep;
function smoothStep(a, b, t) {
	return smoothStep01(linearStep(a, b, t));
}

exports.repeat = repeat;
function repeat(t, len) {
	return t - Math.floor(t / len) * len;
}

exports.pingpong = pingpong;
function pingpong(t, len) {
	return len - Math.abs(repeat(t, len * 2) - len);
}

exports.length2D = length2D;
function length2D(x, y) {
	return Math.sqrt(x * x + y * y);
}

exports.length3D = length3D;
function length3D(x, y, z) {
	return Math.sqrt(x * x + y * y + z * z);
}

exports.distance2D = distance2D;
function distance2D(x0, y0, x1, y1) {
	var dx = x0 - x1,
	    dy = y0 - y1;
	return Math.sqrt(dx * dx + dy * dy);
};

exports.distance3D = distance3D;
function distance3D(x0, y0, z0, x1, y1, z1) {
	var dx = x0 - x1,
	    dy = y0 - y1,
	    dz = z0 - z1;
	return Math.sqrt(dx * dx + dy * dy + dz * dz);
};

exports.normLen2D = normLen2D;
function normLen2D(x, y) {
	var l = x * x + y * y;
	return l < EPSILON ? 1.0 : Math.sqrt(l);
};

exports.safeInvLen = exports.safeInverseLength = safeInvLen;
function safeInvLen(x, y) {
	return 1.0 / (Math.sqrt(x * x + y * y) + 1e-37);
};

exports.normLen3D = normLen3D;
function normLen3D(x, y, z) {
	var l = x * x + y * y + z * z;
	return l < EPSILON ? 1.0 : Math.sqrt(l);
};

exports.lerpColors = lerpColors;
function lerpColors(c0, c1, t) {
	var supportAlpha = arguments.length <= 3 || arguments[3] === undefined ? false : arguments[3];

	var b0 = (c0 >>> 16 & 0xff) / 255.0;
	var g0 = (c0 >>> 8 & 0xff) / 255.0;
	var r0 = (c0 >>> 0 & 0xff) / 255.0;
	var a0 = (c0 >>> 24 & 0xff) / 255.0;

	var b1 = (c1 >>> 16 & 0xff) / 255.0;
	var g1 = (c1 >>> 8 & 0xff) / 255.0;
	var r1 = (c1 >>> 0 & 0xff) / 255.0;
	var a1 = (c1 >>> 24 & 0xff) / 255.0;

	var rr = lerp(r0, r1, t) * 255 | 0;
	var rg = lerp(g0, g1, t) * 255 | 0;
	var rb = lerp(b0, b1, t) * 255 | 0;
	var ra = supportAlpha ? lerp(a0, a1, t) * 255 | 0 : 0xff;

	return ra << 24 | rb << 16 | rg << 8 | rr;
};

exports.buildPixelRGBA = buildPixelRGBA;
function buildPixelRGBA(r, g, b, a) {
	r = r & 0xff;g = g & 0xff;b = b & 0xff;a = a & 0xff;
	return a << 24 | b << 16 | g << 8 | r;
}

exports.buildPixelRGB = buildPixelRGB;
function buildPixelRGB(r, g, b) {
	r = r & 0xff;g = g & 0xff;b = b & 0xff;
	return b << 16 | g << 8 | r;
}

exports.gammaToLinear32 = gammaToLinear32;
function gammaToLinear32(pixel) {
	var b = (pixel >>> 16 & 0xff) / 255.0;
	var g = (pixel >>> 8 & 0xff) / 255.0;
	var r = (pixel >>> 0 & 0xff) / 255.0;

	var rr = r * r * 255 | 0;
	var rg = g * g * 255 | 0;
	var rb = b * b * 255 | 0;

	return pixel & 0xff000000 | rb << 16 | rg << 8 | rr;
}

exports.changeSaturation = changeSaturation;
function changeSaturation(pixel, level, gamma) {
	var r = (pixel >>> 16 & 0xff) / 255.0;
	var g = (pixel >>> 8 & 0xff) / 255.0;
	var b = (pixel >>> 0 & 0xff) / 255.0;
	var a = pixel & 0xff000000;

	if (gamma) {
		r *= r;
		g *= g;
		b *= b;
	}

	var avg = 1.0 / 3.0 * (r + g + b);

	var dr = r - avg;
	var dg = g - avg;
	var db = b - avg;

	var rr = avg + level * dr;
	var rg = avg + level * dg;
	var rb = avg + level * db;

	if (gamma) {
		rr = Math.sqrt(rr);
		rg = Math.sqrt(rg);
		rb = Math.sqrt(rb);
	}

	var pr = rr * 255.0 | 0;
	var pg = rg * 255.0 | 0;
	var pb = rb * 255.0 | 0;

	return pixel & 0xff000000 | pr << 16 | pg << 8 | pb;
}

exports.raycastTimePoint = raycastTimePoint;
function raycastTimePoint(pos0, dir0, pos1, dir1, Size) {
	var dirDX = dir0.x - dir1.x,
	    dirDY = dir0.y - dir1.y;
	var posDX = pos0.x - pos1.x,
	    posDY = pos0.y - pos1.y;

	var dirMag = dirDX * dirDX + dirDY * dirDY;
	var ref = 2.0 * (posDX * dirDX + posDY * dirDY);
	var d2d = posDX * posDX + posDY * posDY - Size * Size;

	var eps = 0.0001;

	if (d2d <= 0) return -1;
	if (Math.abs(dirMag) < eps) return 2;

	if (ref >= 0) return 2;

	var t = ref * ref - 4 * dirMag * d2d;
	if (t < 0) return 2;

	var s = -0.5 * (ref - Math.sqrt(t));
	return Math.min(s / dirMag, d2d / s);
};

exports.raycastTimeLine = raycastTimeLine;
function raycastTimeLine(rayPos, rayDir, p0, p1, size) {
	var segDirX = p1.x - p0.x,
	    segDirY = p1.y - p0.y;
	var segLen = Math.sqrt(segDirX * segDirX + segDirY * segDirY);

	ASSERT(segLen !== 0);

	segDirX /= segLen;
	segDirY /= segLen;

	var segNormX = -segDirY;
	var segNormY = segDirX;

	var fx = rayPos.x - p0.x;
	var fy = rayPos.y - p0.y;

	var pnf = segNormX * fx + segNormY * fy;
	var pnr = segNormX * rayDir.x + segNormY * rayDir.y;

	var fsp = segDirX * fx + segDirY * fy;

	var dist = Math.abs(pnf) - size;

	if (dist < 0) {
		return fsp < 0 || fsp > segLen ? 2 : -1;
	}

	if (pnf * pnr >= 0) {
		return 2;
	}

	var time = dist / Math.abs(pnr);
	var segray = segDirX * rayDir.x + segDirY * rayDir.y;
	var t = fsp + time * segray;

	return t < 0 || t > segLen ? 2 : time;
}

// hm...
exports.Vec2 = require('./vec2');

exports.betweenI = betweenI;
function betweenI(n, lo, hi) {
	return n >= lo && n <= hi;
}

exports.betweenX = exports.between = betweenX;
function betweenX(n, lo, hi) {
	return n > lo && n < hi;
}

exports.betweenXI = betweenXI;
function betweenXI(n, lo, hi) {
	return n > lo && n <= hi;
}

exports.betweenIX = betweenIX;
function betweenIX(n, lo, hi) {
	return n >= lo && n < hi;
}

},{"./debug":161,"./vec2":182}],176:[function(require,module,exports){
'use strict';

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var Entity = require('./entity');
var Input = require('./input');
var drawing = require('./drawing');
var Consts = require('./constants');
var Clock = require('./clock');

var _require = require('./rand');

var RNG = _require.RNG;

var math = require('./math');

var Particle = (function (_Entity) {
	_inherits(Particle, _Entity);

	function Particle(game) {
		var x = arguments.length <= 1 || arguments[1] === undefined ? 0.0 : arguments[1];
		var y = arguments.length <= 2 || arguments[2] === undefined ? 0.0 : arguments[2];
		var z = arguments.length <= 3 || arguments[3] === undefined ? 0.0 : arguments[3];

		_classCallCheck(this, Particle);

		var _this = _possibleConstructorReturn(this, _Entity.call(this, game, x, y, z));

		_this.collidesWithEntities = false;
		_this.collidesWithPlayer = false;
		_this.radius = 1;
		_this.drag.set(1, 1);

		_this.hasZ = true;
		_this.zDrag = 0.5;
		_this.color = 0xff000000;
		_this.life = RNG.betweenF(0.4, 0.8);
		do {
			_this.vel.x = RNG.betweenF(-1.0, 1.0);
			_this.vel.y = RNG.betweenF(-1.0, 1.0);
		} while (_this.vel.lenSq() > 1.0);
		_this.vel.x *= 60;
		_this.vel.y *= 60;
		_this.zAcc = -60;
		return _this;
	}

	Particle.prototype.update = function update(dt) {
		_Entity.prototype.update.call(this, dt);
		this.life -= dt;
		if (this.life <= 0) {
			this.enabled = false;
		}
	};

	Particle.prototype.postUpdate = function postUpdate(dt) {
		this.acc.set(0, 0);
		this.zAcc = -60;
	};

	Particle.prototype.render = function render(ctx, buffer, minX, minY) {
		var width = buffer.width;
		var height = buffer.height;

		var x = Math.round(this.pos.x - minX);
		var y = Math.round(this.pos.y - minY); //-this.zPos); // no visual representation for z
		if (x >>> 0 >= width) return;
		if (y >>> 0 >= height) return;

		var _buffer$getPixbuf = buffer.getPixbuf();

		var pixels = _buffer$getPixbuf.pixels;

		var c = this.color >>> 0;
		if (this.radius < 1.0) {
			pixels[x + y * width] = c;
			return;
		}
		var x0 = math.clamp(Math.round(x - this.radius), 0, width - 1) >>> 0;
		var x1 = math.clamp(Math.round(x + this.radius), 0, width - 1) >>> 0;
		var y0 = math.clamp(Math.round(y - this.radius), 0, height - 1) >>> 0;
		var y1 = math.clamp(Math.round(y + this.radius), 0, height - 1) >>> 0;
		for (var yy = y0; yy < y1; ++yy) {
			var row = yy * width >>> 0;
			for (var xx = x0; xx < x1; ++xx) {
				pixels[xx + row] = c;
			}
		}
	};

	return Particle;
})(Entity);

module.exports = Particle;

},{"./clock":158,"./constants":160,"./drawing":162,"./entity":164,"./input":169,"./math":175,"./rand":179}],177:[function(require,module,exports){
'use strict';

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var _require = require('./util');

var createCanvas = _require.createCanvas;

var math = require('./math');

var PixelBuffer = (function () {
	function PixelBuffer(width, height) {
		var trackBounds = arguments.length <= 2 || arguments[2] === undefined ? false : arguments[2];

		_classCallCheck(this, PixelBuffer);

		this.width = width;
		this.height = height;
		this.canvas = createCanvas(this.width, this.height);
		this.context = this.canvas.getContext('2d');
		this.imageData = this.context.createImageData(this.width, this.height);
		this.pixels = new Uint32Array(this.imageData.data.buffer);
		this.bounds = { minX: width, minY: height, maxX: 0, maxY: 0 }; // dirty rect
		this.trackBounds = trackBounds;
		this.pixelsDirty = false;
	}

	PixelBuffer.prototype.reset = function reset() {
		this.resetBounds();
		for (var i = 0, pix = this.pixels, len = pix.length; i < len; ++i) {
			pix[i] = 0;
		}
	};

	PixelBuffer.prototype.refreshImageData = function refreshImageData() {
		this.imageData = this.context.getImageData(0, 0, this.width, this.height);
		this.pixels = new Uint32Array(this.imageData.data.buffer);
	};

	PixelBuffer.prototype.resetBounds = function resetBounds() {
		this.bounds.minX = this.width;
		this.bounds.minY = this.height;
		this.bounds.maxX = 0;
		this.bounds.maxY = 0;
	};

	PixelBuffer.prototype.update = function update() {
		var clear = arguments.length <= 0 || arguments[0] === undefined ? true : arguments[0];

		if (clear) this.context.clearRect(0, 0, this.width, this.height);
		this.context.putImageData(this.imageData, 0, 0);
	};

	PixelBuffer.prototype.putPixel = function putPixel(x, y, v) {
		if (x >>> 0 < this.width && y >>> 0 < this.height) {
			this.pixelsDirty = true;
			this.pixels[x + y * this.width] = v;
			if (this.trackBounds) {
				this.bounds.minX = Math.min(this.bounds.minX, x);
				this.bounds.maxX = Math.max(this.bounds.maxX, x);
				this.bounds.minY = Math.min(this.bounds.minY, y);
				this.bounds.maxY = Math.max(this.bounds.maxY, y);
			}
		}
	};

	PixelBuffer.prototype.getPixbuf = function getPixbuf() {
		this.pixelsDirty = true;
		return this;
	};

	PixelBuffer.prototype.inBounds = function inBounds(x, y) {
		return x >>> 0 < this.width && y >>> 0 < this.height;
	};

	PixelBuffer.prototype.getPixel = function getPixel(x, y) {
		if (x >>> 0 < this.width && y >>> 0 < this.height) {
			return this.pixels[x + y * this.width];
		}
		return 0;
	};

	PixelBuffer.prototype.bresenham = function bresenham(x0, y0, x1, y1, color) {
		this.pixelsDirty = true;
		x0 = x0 | 0;
		y0 = y0 | 0;
		x1 = x1 | 0;
		y1 = y1 | 0;
		color = color | 0;
		var dx = Math.abs(x1 - x0) | 0;
		var dy = Math.abs(y1 - y0) | 0;
		var sx = x0 < x1 ? 1 : -1;
		var sy = y0 < y1 ? 1 : -1;
		var err = dx - dy;
		var pixels = this.pixels;
		var width = this.width >>> 0;
		var height = this.height >>> 0;
		if (x0 >= 0 && x0 < width && y0 >= 0 && y0 < height) {
			pixels[x0 + y0 * width] = color;
		} else if (x1 < 0 || x1 >= width || y1 < 0 && y1 >= height) {
			return;
		}

		this.bounds.minX = Math.min(this.bounds.minX, x0, x1);
		this.bounds.maxX = Math.max(this.bounds.maxX, x0, x1);
		this.bounds.minY = Math.min(this.bounds.minY, y0, y1);
		this.bounds.maxY = Math.max(this.bounds.maxY, y0, y1);

		pixels[x0 + y0 * width] = color;
		while (x0 !== x1 && y0 !== y1) {
			var e2 = err << 1;
			if (e2 > -dy) {
				err -= dy;
				x0 += sx;
				if (x0 < 0 || x0 > width) {
					break;
				}
			}
			if (e2 < dx) {
				err += dx;
				y0 += sy;
				if (y0 < 0 || y0 > height) {
					break;
				}
			}
			pixels[x0 + y0 * width] = color;
		}
	};

	PixelBuffer.prototype.withReplacedColors = function withReplacedColors(replacements) {
		var pb = new PixelBuffer(this.width, this.height);
		var pbpix = pb.pixels;
		var ownPix = this.pixels;
		for (var i = 0; i < ownPix.length; ++i) {
			var pixel = ownPix[i] >>> 0;
			pbpix[i] = pixel;
			for (var r = 0; r < replacements.length; ++r) {
				var search = replacements[r][0] >>> 0;
				if (pixel === search) {
					pbpix[i] = replacements[r][1] >>> 0;
					break;
				}
			}
		}
		pb.update();
		return pb;
	};

	return PixelBuffer;
})();

PixelBuffer.fromImage = function (image) {
	var pb = new PixelBuffer(image.width, image.height);
	pb.context.drawImage(image, 0, 0);
	pb.refreshImageData();
	return pb;
};

PixelBuffer.getRotatedTiles = function (image, tileSize) {
	var rotations = arguments.length <= 2 || arguments[2] === undefined ? 16 : arguments[2];

	var pb = PixelBuffer.fromImage(image);
	var result = new PixelBuffer(pb.width, pb.height * rotations);
	var numTiles = Math.floor(image.width / tileSize);
	for (var rot = 0; rot < rotations; ++rot) {
		var angle = rot / rotations * 2 * Math.PI;
		var sa = Math.sin(angle);
		var ca = Math.cos(angle);
		var yOffset = rot * tileSize;
		for (var tile = 0; tile < numTiles; ++tile) {
			var xOffset = tile * tileSize;
			for (var j = 0; j < tileSize; ++j) {
				for (var i = 0; i < tileSize; ++i) {
					var px = Math.floor(ca * (i - tileSize / 2) + sa * (j - tileSize / 2) + tileSize / 2);
					var py = Math.floor(ca * (j - tileSize / 2) - sa * (i - tileSize / 2) + tileSize / 2);
					px = math.clamp(px, 0, tileSize - 1);
					py = math.clamp(py, 0, tileSize - 1);
					result.putPixel(xOffset + i, yOffset + j, pb.getPixel(xOffset + px, py));
				}
			}
		}
	}
	result.update();
	return result;
};

module.exports = PixelBuffer;

},{"./math":175,"./util":181}],178:[function(require,module,exports){
'use strict';

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var _require = require('./tweens');

var Tween = _require.Tween;
var TweenGroup = _require.TweenGroup;

var Entity = require('./entity');
var Input = require('./input');

var _require2 = require('./rand');

var RNG = _require2.RNG;

var drawing = require('./drawing');
var Consts = require('./constants');
var Clock = require('./clock');
var Bullet = require('./bullet');
var Gore = require('./gore');
var Blood = require('./blood');
var Sounds = require('./audio');

var Player = (function (_Entity) {
	_inherits(Player, _Entity);

	function Player(game) {
		_classCallCheck(this, Player);

		var _this = _possibleConstructorReturn(this, _Entity.call(this, game));

		_this.radius = 5.0;
		_this.normalizeAccel = true;
		_this.speed = 20 * 20;
		_this.drag.set(5, 5);
		_this.walking = false;
		_this.animProgress = 0.0;
		_this.health = 50;
		_this.maxHealth = 50;
		return _this;
	}

	Player.prototype.damage = function damage(amt, pos, vel) {
		var gib = new Gore(this.game, pos.x, pos.y);
		gib.vel.scale(0.1).addScaled(vel, 0.4);
		this.vel.addScaled(vel, 0.3);
		this.game.addEntity(gib);
		this.health -= amt;
		if (this.health <= 0) {
			Sounds.play('die');
			this.game.killPlayer();
		} else {
			Sounds.play('ouch');
		}
	};

	Player.prototype.think = function think(dt) {
		if (this.walking) {
			this.animProgress += Math.min(this.lastPos.distance(this.pos) / 10, 1);
		}
		var _game$mouse = this.game.mouse;
		var mwx = _game$mouse.x;
		var mwy = _game$mouse.y;

		var fy = mwy - this.pos.y;
		var fx = mwx - this.pos.x;
		var len = Math.sqrt(fx * fx + fy * fy);

		if (this.health > 0) {
			if (Input.mouse.isDown && len > 1 && !Input.keyboard.isDown('space')) {
				this.acc.set((mwx - this.pos.x) / Consts.TileSize, (mwy - this.pos.y) / Consts.TileSize);
				this.walking = true;
			} else {
				this.walking = false;
				this.animProgress = 0.0;
				this.acc.set(0.0, 0.0);
			}

			this.heading = Math.atan2(fy, fx);
			if (Input.mouse.wasPressed() && Input.keyboard.isDown('space')) {
				var bullet = new Bullet(this.game, this, fx / len, fy / len, 10);
				this.game.addEntity(bullet);
			}
		}
		if (this.health != this.maxHealth) {
			if (RNG.xChanceInY(this.maxHealth - this.health, this.maxHealth)) {
				var blood = new Blood(this.game, this.pos.x, this.pos.y);
				blood.zPos = 5;
				blood.vel.x *= 0.05;blood.vel.x += this.vel.x;
				blood.vel.y *= 0.05;blood.vel.y += this.vel.y;
				this.game.addEntity(blood);
			}
			if (RNG.oneChanceIn(60)) {
				this.health = Math.min(this.health + 1, this.maxHealth);
			}
		}
	};

	Player.prototype.render = function render(layer, pix, minX, minY) {
		if (this.health <= 0) {
			layer.context.drawImage(this.game.assets.dead, 0, 0, 32, 16, Math.round(this.pos.x - 16), Math.round(this.pos.y - 8), 32, 16);
			layer.context.drawImage(this.game.assets.dead, 0, 16, 32, 16, Math.round(this.pos.x - 16), Math.round(this.pos.y - 8), 32, 16);
			return;
		}
		var rotation = Math.round(this.heading / (Math.PI * 2) * 16) & 15;
		var anim = (this.walking ? Math.floor(this.animProgress % 7) : 0) + 0;
		layer.context.strokeStyle = 'green';
		layer.context.drawImage(this.game.assets.playerRotations.canvas, 16 * anim, 16 * rotation, 16, 16, Math.round(this.pos.x - 8), Math.round(this.pos.y - 8), 16, 16);

		// drawing.drawCircle(this.game.debugContext, this.pos.x, this.pos.y, this.radius);
		//(layer.context, this.pos.x-mx, this.pos.y-my, this.radius);
	};

	return Player;
})(Entity);

module.exports = Player;

},{"./audio":154,"./blood":155,"./bullet":156,"./clock":158,"./constants":160,"./drawing":162,"./entity":164,"./gore":168,"./input":169,"./rand":179,"./tweens":180}],179:[function(require,module,exports){
'use strict';

var PCGRandom = require('pcg-random');
var quickNoise = require('quick-noise-js');

var RandUtils = {
	nextInt: function nextInt(a) {
		return this.integer(a);
	},
	random: function random() {
		return this.number();
	},
	upTo: function upTo(a) {
		return this.integer(a);
	},
	upToI: function upToI(a) {
		return this.upTo(a + 1);
	},
	// inclusive
	upToF: function upToF(a) {
		return this.number() * a;
	},
	betweenF: function betweenF(min, max) {
		return min + this.number() * (max - min);
	},
	betweenI: function betweenI(min, max) {
		return min + this.upTo(max - min + 1);
	},
	betweenX: function betweenX(min, max) {
		return min + this.upTo(max - min);
	},
	oneChanceIn: function oneChanceIn(n) {
		return this.upTo(n) === 0;
	},
	coinflip: function coinflip() {
		return this.oneChanceIn(2);
	},
	probability: function probability(n) {
		return this.number() < n;
	},
	xChanceInY: function xChanceInY(x, y) {
		return this.upTo(y) < x;
	},
	choose: function choose(arr) {
		if (arr.length === 0) {
			console.error("empty array in choose");
			return null;
		}
		return arr[this.upTo(arr.length)];
	},
	round: function round(v) {
		var vi = Math.floor(v);
		return vi + this.probability(v - vi) ? 1 : 0;
	},
	diceRoll: function diceRoll(count, size) {
		if (count <= 0 || size <= 0) return 0;
		var result = count;
		for (var i = 0; i < count; ++i) {
			result += this.upTo(size);
		}
		return result;
	},
	bestRoll: function bestRoll(max, rolls) {
		var best = 0;
		for (var i = 0; i < rolls; ++i) {
			best = Math.max(this.upTo(max), best);
		}
		return best;
	},
	gaussian01: function gaussian01() {
		var u = 0.0,
		    v = 0.0,
		    r = 0.0;
		do {
			u = this.number() * 2.0 - 1.0;
			v = this.number() * 2.0 - 1.0;
			r = u * u + v * v;
		} while (r === 0.0 || r > 1.0);
		var mul = Math.sqrt(-2.0 * Math.log(r) / r);
		return u * mul;
	},
	gaussian: function gaussian(mean, stddev) {
		return this.gaussian01() * stddev + mean;
	},
	uniform: function uniform() {
		var mean = arguments.length <= 0 || arguments[0] === undefined ? 0.0 : arguments[0];
		var halfRange = arguments.length <= 1 || arguments[1] === undefined ? 1.0 : arguments[1];

		return this.number() * (halfRange * 2.0) + (mean - 1.0);
	},
	chooseIndexWeighted: function chooseIndexWeighted(weights) {
		var l = weights.length;
		if (l === 0) {
			console.error("empty array passed to chooseIndexWeighted");
			return -1;
		}
		var sum = 0;
		for (var i = 0; i < l; ++i) {
			sum += weights[i];
		}sum *= this.number();
		for (var i = 0; i < l; ++i) {
			sum -= weights[i];
			if (sum <= 0.0) return i;
		}
		console.error("fell through choice loop", weights);
		return this.upTo(weights.length);
	},
	chooseWeightedFn: function chooseWeightedFn(arr, getWeight) {
		var l = arr.length;
		if (l === 0) {
			console.error("empty array passed to chooseWeightedFn");
			return -1;
		}
		var sum = 0;
		for (var i = 0; i < l; ++i) {
			sum += getWeight(arr[i]);
		}sum *= this.number();
		for (var i = 0; i < l; ++i) {
			sum -= getWeight(arr[i]);
			if (sum <= 0.0) return i;
		}
		console.error("fell through choice loop", arr);
		return this.upTo(arr.length);
	},
	shuffle: function shuffle(arr) {
		for (var i = arr.length - 1; i > 0; --i) {
			var r = this.upToI(i);
			var tmp = arr[r];arr[r] = arr[i];arr[i] = tmp;
		}
		return arr;
	},
	colorBetween: function colorBetween(c0, c1) {
		var a0 = c0 >>> 24;
		var b0 = c0 >>> 16 & 0xff;
		var g0 = c0 >>> 8 & 0xff;
		var r0 = c0 & 0xff;

		var a1 = c1 >>> 24;
		var b1 = c1 >>> 16 & 0xff;
		var g1 = c1 >>> 8 & 0xff;
		var r1 = c1 & 0xff;

		return RNG.betweenI(a0, a1) << 24 | RNG.betweenI(b0, b1) << 16 | RNG.betweenI(g0, g1) << 8 | RNG.betweenI(r0, r1);
	}
};

Object.assign(PCGRandom.prototype, RandUtils);

var RNG = new PCGRandom();
exports.RNG = RNG;
exports.RNGType = PCGRandom;

var perlinNoise = quickNoise.noise;

exports.perlinNoise = perlinNoise;
exports.octaveNoise = octaveNoise;

function octaveNoise(x, y, z) {
	var octaves = arguments.length <= 3 || arguments[3] === undefined ? 3 : arguments[3];
	var persistence = arguments.length <= 4 || arguments[4] === undefined ? 0.5 : arguments[4];

	var total = 0.0;
	var frequency = 1.0;
	var amplitude = 1.0;
	var maxValue = 0.0;
	for (var i = 0; i < octaves; ++i) {
		total += perlinNoise(x * frequency, y * frequency, z * frequency) * amplitude;
		maxValue += amplitude;
		amplitude *= persistence;
		frequency *= 2.0;
	}
	return total / maxValue;
}

},{"pcg-random":7,"quick-noise-js":152}],180:[function(require,module,exports){
'use strict';

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var _Math = Math;
var cos = _Math.cos;
var sin = _Math.sin;
var PI = _Math.PI;
var pow = _Math.pow;
var sqrt = _Math.sqrt;

var _require = require('./rand');

var RNG = _require.RNG;

var Promise = require('bluebird');

var HALF_PI = PI * 0.5;
var TWO_PI = PI * 2.0;

var EaseTypeIn = 0;
var EaseTypeOut = 1;
var EaseTypeInOut = 2;
var EaseTypeShake = 3;

exports.EaseType = { In: EaseTypeIn, Out: EaseTypeOut, InOut: EaseTypeInOut, Shake: EaseTypeShake };

function bounceReverse(t) {
	if (t < 1.0 / 2.75) return 7.5625 * t * t;else if (t < 2.0 / 2.75) {
		t -= 1.50 / 2.75;return 7.5625 * t * t + 0.75;
	} else if (t < 2.5 / 2.75) {
		t -= 2.25 / 2.75;return 7.5625 * t * t + 0.9375;
	} else {
		t -= 2.625 / 2.75;return 7.5625 * t * t + 0.984375;
	}
}

function bezier(t, p0, p1, p2, p3) {
	var s = 1.0 - t;
	return s * s * s * p0 + 3.0 * t * s * s * p1 + 3.0 * t * t * s * p2 + t * t * t * p3;
}

function easeLinear(t) {
	return t;
}
function easeQuad(t) {
	return t * t;
}
function easeCubic(t) {
	return t * t * t;
}
function easeQuart(t) {
	return t * t * t * t;
}
function easeQuint(t) {
	return t * t * t * t * t;
}
function easeExpo(t) {
	return pow(2.0, 10.0 * (t - 1.0));
}
function easeSine(t) {
	return -cos(p * HALF_PI) + 1.0;
}
function easeCirc(t) {
	return -(sqrt(1.0 - p * p) - 1.0);
}
function easeBack(t) {
	return p * p * (2.7 * p - 1.7);
}
function easeElastic(t) {
	return -(pow(2.0, 10.0 * (p - 1.0)) * sin((p - 1.075) * TWO_PI / 0.3));
}
function easeBounce(t) {
	return 1.0 - bounceReverse(1.0 - t);
}
function easeZigzag(t) {
	return bezier(t, 0.0, 2.5, -1.5, 1.0);
}
function easeShake(t) {
	return bezier(t, 0.5, 1.22, 1.25, 0.0);
}
function easeRubberband(t) {
	return bezier(t, 0.0, 0.7, 1.5, 1.0);
}

var Easings = exports.Easings = {
	linear: easeLinear,
	quad: easeQuad,
	cubic: easeCubic,
	quart: easeQuart,
	quint: easeQuint,
	expo: easeExpo,
	sine: easeSine,
	circ: easeCirc,
	back: easeBack,
	elastic: easeElastic,
	bounce: easeBounce,
	zigzag: easeZigzag,
	shake: easeShake,
	rubberband: easeRubberband
};

var objects = [];

var Tween = (function () {
	function Tween(object, field, _ref) {
		var end = _ref.end;
		var _ref$start = _ref.start;
		var start = _ref$start === undefined ? object[field] : _ref$start;
		var _ref$duration = _ref.duration;
		var duration = _ref$duration === undefined ? 1.0 : _ref$duration;
		var _ref$easing = _ref.easing;
		var easing = _ref$easing === undefined ? Easings.linear : _ref$easing;
		var _ref$type = _ref.type;
		var type = _ref$type === undefined ? EaseTypeIn : _ref$type;
		var _ref$loop = _ref.loop;
		var loop = _ref$loop === undefined ? false : _ref$loop;
		var _ref$snap = _ref.snap;
		var snap = _ref$snap === undefined ? false : _ref$snap;
		var _ref$enabledField = _ref.enabledField;
		var enabledField = _ref$enabledField === undefined ? '' : _ref$enabledField;
		var _ref$resolveOnFinish = _ref.resolveOnFinish;
		var resolveOnFinish = _ref$resolveOnFinish === undefined ? true : _ref$resolveOnFinish;

		_classCallCheck(this, Tween);

		this.object = object;
		this.field = field;
		this.end = end;
		this.start = start;
		this.duration = duration;
		this.easing = typeof easing === 'string' ? Easings[easing] : easing;
		this.type = type;
		this.looped = loop;
		this.snap = snap;
		this.time = 0.0;
		this.deferred = Promise.pending();
		this.promise = deferred.promise;
		this.object[this.field] = this.start;
		this.finished = true;
	}

	Tween.prototype.update = function update(deltaTime) {
		this.time += deltaTime;
		var time = this.time;
		var duration = this.duration;
		var object = this.object;
		var field = this.field;
		var easing = this.easing;
		var start = this.start;
		var end = this.end;

		if (time > duration && !this.looped) {
			object[field] = this.end;
			if (this.resolveOnFinish) this.deferred.resolve(this.object);
			return true;
		}
		var t = 0.0;
		var progress = time / duration;
		if (this.looped) {
			progress = this.looped === 'pingpong' ? pingpong(progress, 1.0) : progress % 1.0;
		}
		switch (type) {
			case EaseTypeIn:
				t = easing(progress);break;
			case EaseTypeOut:
				t = 1.0 - easing(1.0 - progress);break;
			case EaseTypeInOut:
				t = progress < 0.5 ? easing(progress) : 1.0 - easing(1.0 - progress);break;
			case EaseTypeShake:
				t = easing(progress) * RNG.number();break;
			default:
				console.error("illegal value for type: " + type);t = easing(progress);break;
		}
		var value = start * (1.0 - t) + end * t;
		if (this.snap) {
			value = Math.round(value);
		}
		object[field] = value;
		return false;
	};

	Tween.prototype.complete = function complete() {
		return this.finished || this.enabledField && !this.object[this.enabledField];
	};

	return Tween;
})();

var TweenGroup = (function () {
	function TweenGroup() {
		_classCallCheck(this, TweenGroup);

		this.tweens = [];
		this.resolveQueue_ = [];
	}

	TweenGroup.prototype.add = function add(obj) {
		obj.resolveOnFinish = false;
		this.tweens.push(obj);
		return obj;
	};

	TweenGroup.prototype.update = function update(deltaTime) {
		var tweens = this.tweens;
		var l = tweens.length;
		for (var i = 0; i < l; ++i) {
			tweens[i].update();
		}
		var newLen = tweens.length,
		    j = 0;
		this.resolveQueue_.length = 0;
		for (var i = 0; i < l; ++i) {
			if (tweens[i].complete()) {
				this.resolveQueue_.push(tweens[i]);
			} else {
				this.tweens[j++] = this.tweens[i];
			}
		}
		this.tweens.length = j + Math.max(0, newLen - l);
		for (var i = 0; i < this.resolveQueue_.length; ++i) {
			this.resolveQueue_[i].deferred.resolve(this.resolveQueue_[i].object);
		}
		this.resolveQueue_.length = 0;
	};

	return TweenGroup;
})();

var TweenManager = new TweenGroup();

exports.Tween = Tween;
exports.TweenGroup = TweenGroup;
exports.TweenManager = TweenManager;

},{"./rand":179,"bluebird":1}],181:[function(require,module,exports){
'use strict';

var Promise = require('bluebird');

exports.createCanvas = createCanvas;
function createCanvas(width, height) {
	var result = document.createElement('canvas');
	result.width = width;
	result.height = height;
	return result;
}

exports.createContext2D = createContext2D;
function createContext2D(width, height) {
	var c = createCanvas(width, height);
	return c.getContext('2d');
}

exports.loadImage = loadImage;
function loadImage(src) {
	return new Promise(function (resolve, reject) {
		var image = new Image();
		image.onload = function () {
			resolve(image);
		};
		image.onerror = function (e) {
			console.log(e);
			console.error("Failed to load: " + src);
			reject(e);
		};
		image.src = src;
	});
}

exports.getRequest = getRequest;
function getRequest(src) {
	var preRequest = arguments.length <= 1 || arguments[1] === undefined ? null : arguments[1];

	return new Promise(function (resolve, reject) {
		var xhr = new XMLHttpRequest();
		xhr.open('GET', src, true);
		if (preRequest) preRequest(xhr);
		xhr.onload = function () {
			if (xhr.status >= 200 && xhr.status < 400) {
				resolve(xhr);
			} else {
				console.error("request failed");
				reject(xhr);
			}
		};
		xhr.onerror = function (e) {
			console.error(e, xhr);
			reject(xhr);
		};
		xhr.send();
	});
}

exports.loadXML = loadXML;
function loadXML(src) {
	return getRequest(src).then(function (response) {
		return new DOMParser().parseFromString(response.responseText, "application/xml");
	});
}

exports.loadText = loadText;
function loadText(src) {
	return getRequest(src).then(function (response) {
		return response.responseText;
	});
}

exports.loadJSON = loadJSON;
function loadJSON(src) {
	return getRequest(src).then(function (response) {
		return JSON.parse(response.responseText);
	});
}

},{"bluebird":1}],182:[function(require,module,exports){
'use strict';

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var _require = require('./debug');

var ASSERT = _require.ASSERT;

var Vec2 = (function () {
	function Vec2(x, y) {
		_classCallCheck(this, Vec2);

		this.x = +x || 0.0;this.y = +y || 0.0;
	}

	Vec2.prototype.perp = function perp() {
		return new Vec2(-this.y, this.x);
	};

	Vec2.prototype.to = function to(o) {
		return new Vec2(o.x - this.x, o.y - this.y);
	};

	Vec2.prototype.dot = function dot(o) {
		return this.x * o.x + this.y * o.y;
	};

	Vec2.prototype.perpDot = function perpDot(o) {
		return -this.y * o.x + this.x * o.y;
	};

	Vec2.prototype.plus = function plus(o) {
		return new Vec2(this.x + o.x, this.y + o.y);
	};

	Vec2.prototype.minus = function minus(o) {
		return new Vec2(this.x - o.x, this.y - o.y);
	};

	Vec2.prototype.lenSq = function lenSq() {
		return this.x * this.x + this.y * this.y;
	};

	Vec2.prototype.len = function len() {
		return Math.sqrt(this.x * this.x + this.y * this.y);
	};

	Vec2.prototype.length = function length() {
		return this.len();
	};

	Vec2.prototype.lengthSquared = function lengthSquared() {
		return lenSq();
	};

	Vec2.prototype.scaled = function scaled(n) {
		return new Vec2(this.x * n, this.y * n);
	};

	Vec2.prototype.normalize = function normalize() {
		this.normalizeGetLen();return this;
	};

	Vec2.prototype.clone = function clone() {
		return new Vec2(this.x, this.y);
	};

	Vec2.prototype.copy = function copy(_ref) {
		var x = _ref.x;
		var y = _ref.y;
		this.x = x;;this.y = y;return this;
	};

	Vec2.prototype.scale = function scale(n) {
		this.x *= n;this.y *= n;return this;
	};

	Vec2.prototype.set = function set(x, y) {
		this.x = x;this.y = y;return this;
	};

	Vec2.prototype.clear = function clear() {
		return this.set(0.0, 0.0);
	};

	Vec2.prototype.add = function add(o) {
		this.x += o.x;this.y += o.y;return this;
	};

	Vec2.prototype.addScaled = function addScaled(o, n) {
		this.x += o.x * n;this.y += o.y * n;return this;
	};

	Vec2.prototype.translate = function translate(x, y) {
		this.x += x;this.y += y;return this;
	};

	Vec2.prototype.normalized = function normalized() {
		return this.clone().normalize();
	};

	Vec2.prototype.scaled = function scaled(n) {
		return this.clone().scale(n);
	};

	Vec2.prototype.toString = function toString() {
		return '(' + this.x + ', ' + this.y + ')';
	};

	Vec2.prototype.distance = function distance(o) {
		var dx = this.x - o.x,
		    dy = this.y - o.y;
		return Math.sqrt(dx * dx + dy * dy);
	};

	Vec2.prototype.distanceSq = function distanceSq(o) {
		this;
		var dx = this.x - o.x,
		    dy = this.y - o.y;
		return dx * dx + dy * dy;
	};

	Vec2.prototype.normalizeGetLen = function normalizeGetLen() {
		var l2 = this.x * this.x + this.y * this.y;
		if (l2 === 0.0) {
			this.x = 0.0;this.y = 1.0;return 0.00001;
		}
		var il = 1.0 / Math.sqrt(l2);
		this.x *= il;
		this.y *= il;
		this;
		return l2 * il;
	};

	Vec2.prototype.normalizeOrZero = function normalizeOrZero() {
		return this.scale(1.0 / (Math.sqrt(this.x * this.x + this.y * this.y) + 1e-37));
	};

	Vec2.prototype.xFlip = function xFlip() {
		var about = arguments.length <= 0 || arguments[0] === undefined ? 0.0 : arguments[0];
		this.x = 2.0 * about - this.x;return this;
	};

	Vec2.prototype.yFlip = function yFlip() {
		var about = arguments.length <= 0 || arguments[0] === undefined ? 0.0 : arguments[0];
		this.y = 2.0 * about - this.y;return this;
	};

	Vec2.prototype.rotate = function rotate(angle, about) {
		var aboutX = 0.0,
		    aboutY = 0.0;
		if (about) {
			aboutX = about.x;aboutY = about.y;
		}
		var x = this.x - aboutX;
		var y = this.y - aboutY;
		var c = Math.cos(angle);
		var s = Math.sin(angle);
		var nx = x * c - y * s;
		var ny = x * s + y * c;
		this.x = nx + aboutX;
		this.y = ny + aboutY;
		return this;
	};

	Vec2.prototype.rotate90 = function rotate90(about) {
		var aboutX = 0.0,
		    aboutY = 0.0;
		if (about) {
			aboutX = about.x;aboutY = about.y;
		}
		var x = this.x - aboutX;
		var y = this.y - aboutY;
		this.x = -y + aboutX;
		this.y = x + aboutY;
		return this;
	};

	Vec2.prototype.rotate180 = function rotate180(about) {
		var aboutX = 0.0,
		    aboutY = 0.0;
		if (about) {
			aboutX = about.x;aboutY = about.y;
		}
		var x = this.x - aboutX;
		var y = this.y - aboutY;
		this.x = -x + aboutX;
		this.y = -y + aboutY;
		return this;
	};

	Vec2.prototype.rotate270 = function rotate270(about) {
		var aboutX = 0.0,
		    aboutY = 0.0;
		if (about) {
			aboutX = about.x;aboutY = about.y;
		}
		var x = this.x - aboutX;
		var y = this.y - aboutY;
		this.x = y + aboutX;
		this.y = -x + aboutY;
		return this;
	};

	Vec2.prototype.rotate = function rotate(angle, about) {
		var aboutX = 0.0,
		    aboutY = 0.0;
		if (about) {
			aboutX = about.x;aboutY = about.y;
		}
		var sin = Math.sin(angle);
		var cos = Math.cos(angle);

		var x = this.x - aboutX;
		var y = this.y - aboutY;
		var nx = cos * x - sin * y;
		var ny = sin * x + cos * y;
		this.x = nx + aboutX;
		this.y = ny + aboutY;
		return this;
	};

	Vec2.prototype.rotated90 = function rotated90(about) {
		return this.clone().rotate90(about);
	};

	Vec2.prototype.rotated180 = function rotated180(about) {
		return this.clone().rotate180(about);
	};

	Vec2.prototype.rotated270 = function rotated270(about) {
		return this.clone().rotate270(about);
	};

	Vec2.prototype.xFlipped = function xFlipped(aboutX) {
		return this.clone().xFlip(aboutX);
	};

	Vec2.prototype.yFlipped = function yFlipped(aboutY) {
		return this.clone().yFlip(aboutY);
	};

	Vec2.prototype.nanCheck = function nanCheck() {
		ASSERT(+this.x === this.x);
		ASSERT(+this.y === this.y);
		return this;
	};

	return Vec2;
})();

Vec2.ZERO = Object.freeze(new Vec2(0.0, 0.0));

Vec2.zero = function () {
	return new Vec2(0.0, 0.0);
};
Vec2.fromDir = function (dir) {
	return new Vec2(Math.cos(dir), Math.sin(dir));
};
Vec2.towards = function (p0, p1) {
	return new Vec2(p1.x - p0.x, p1.y - p0.y);
};
Vec2.towardsXY = function (x0, y0, x1, y1) {
	return new Vec2(x1 - x0, y1 - y0);
};

Vec2.Pool = {
	items: [],
	count: 0,
	get: function get(x, y) {
		if (this.count === this.items.length) this.items.push(new Vec2(0.0, 0.0));
		return this.items[this.count++].set(+x || 0.0, +y || 0.0);
	},
	reset: function reset() {
		this.count = 0;
	},
	update: function update() {
		this.count = 0;
	}
};

Vec2.temp = function (x, y) {
	return Vec2.Pool.get(x, y);
};

module.exports = Vec2;

},{"./debug":161}]},{},[174])
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIm5vZGVfbW9kdWxlcy9icm93c2VyaWZ5L25vZGVfbW9kdWxlcy9icm93c2VyLXBhY2svX3ByZWx1ZGUuanMiLCJub2RlX21vZHVsZXMvYmx1ZWJpcmQvanMvYnJvd3Nlci9ibHVlYmlyZC5qcyIsIm5vZGVfbW9kdWxlcy9icm93c2VyaWZ5L25vZGVfbW9kdWxlcy9idWZmZXIvaW5kZXguanMiLCJub2RlX21vZHVsZXMvYnJvd3NlcmlmeS9ub2RlX21vZHVsZXMvYnVmZmVyL25vZGVfbW9kdWxlcy9iYXNlNjQtanMvbGliL2I2NC5qcyIsIm5vZGVfbW9kdWxlcy9icm93c2VyaWZ5L25vZGVfbW9kdWxlcy9idWZmZXIvbm9kZV9tb2R1bGVzL2llZWU3NTQvaW5kZXguanMiLCJub2RlX21vZHVsZXMvYnJvd3NlcmlmeS9ub2RlX21vZHVsZXMvaXNhcnJheS9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9icm93c2VyaWZ5L25vZGVfbW9kdWxlcy9wcm9jZXNzL2Jyb3dzZXIuanMiLCJub2RlX21vZHVsZXMvcGNnLXJhbmRvbS9wY2ctcmFuZG9tLmpzIiwibm9kZV9tb2R1bGVzL3BvbHktYm9vbC9ib29sLmpzIiwibm9kZV9tb2R1bGVzL3BvbHktYm9vbC9ub2RlX21vZHVsZXMvb3ZlcmxheS1wc2xnL25vZGVfbW9kdWxlcy9iaW5hcnktc2VhcmNoLWJvdW5kcy9zZWFyY2gtYm91bmRzLmpzIiwibm9kZV9tb2R1bGVzL3BvbHktYm9vbC9ub2RlX21vZHVsZXMvb3ZlcmxheS1wc2xnL25vZGVfbW9kdWxlcy9jZHQyZC9jZHQyZC5qcyIsIm5vZGVfbW9kdWxlcy9wb2x5LWJvb2wvbm9kZV9tb2R1bGVzL292ZXJsYXktcHNsZy9ub2RlX21vZHVsZXMvY2R0MmQvbGliL2RlbGF1bmF5LmpzIiwibm9kZV9tb2R1bGVzL3BvbHktYm9vbC9ub2RlX21vZHVsZXMvb3ZlcmxheS1wc2xnL25vZGVfbW9kdWxlcy9jZHQyZC9saWIvZmlsdGVyLmpzIiwibm9kZV9tb2R1bGVzL3BvbHktYm9vbC9ub2RlX21vZHVsZXMvb3ZlcmxheS1wc2xnL25vZGVfbW9kdWxlcy9jZHQyZC9saWIvbW9ub3RvbmUuanMiLCJub2RlX21vZHVsZXMvcG9seS1ib29sL25vZGVfbW9kdWxlcy9vdmVybGF5LXBzbGcvbm9kZV9tb2R1bGVzL2NkdDJkL2xpYi90cmlhbmd1bGF0aW9uLmpzIiwibm9kZV9tb2R1bGVzL3BvbHktYm9vbC9ub2RlX21vZHVsZXMvb3ZlcmxheS1wc2xnL25vZGVfbW9kdWxlcy9jZHQyZC9ub2RlX21vZHVsZXMvcm9idXN0LWluLXNwaGVyZS9pbi1zcGhlcmUuanMiLCJub2RlX21vZHVsZXMvcG9seS1ib29sL25vZGVfbW9kdWxlcy9vdmVybGF5LXBzbGcvbm9kZV9tb2R1bGVzL2NkdDJkL25vZGVfbW9kdWxlcy9yb2J1c3QtaW4tc3BoZXJlL25vZGVfbW9kdWxlcy9yb2J1c3Qtc2NhbGUvbm9kZV9tb2R1bGVzL3R3by1zdW0vdHdvLXN1bS5qcyIsIm5vZGVfbW9kdWxlcy9wb2x5LWJvb2wvbm9kZV9tb2R1bGVzL292ZXJsYXktcHNsZy9ub2RlX21vZHVsZXMvY2R0MmQvbm9kZV9tb2R1bGVzL3JvYnVzdC1pbi1zcGhlcmUvbm9kZV9tb2R1bGVzL3JvYnVzdC1zY2FsZS9yb2J1c3Qtc2NhbGUuanMiLCJub2RlX21vZHVsZXMvcG9seS1ib29sL25vZGVfbW9kdWxlcy9vdmVybGF5LXBzbGcvbm9kZV9tb2R1bGVzL2NkdDJkL25vZGVfbW9kdWxlcy9yb2J1c3QtaW4tc3BoZXJlL25vZGVfbW9kdWxlcy9yb2J1c3Qtc3VidHJhY3Qvcm9idXN0LWRpZmYuanMiLCJub2RlX21vZHVsZXMvcG9seS1ib29sL25vZGVfbW9kdWxlcy9vdmVybGF5LXBzbGcvbm9kZV9tb2R1bGVzL2NkdDJkL25vZGVfbW9kdWxlcy9yb2J1c3QtaW4tc3BoZXJlL25vZGVfbW9kdWxlcy9yb2J1c3Qtc3VtL3JvYnVzdC1zdW0uanMiLCJub2RlX21vZHVsZXMvcG9seS1ib29sL25vZGVfbW9kdWxlcy9vdmVybGF5LXBzbGcvbm9kZV9tb2R1bGVzL2NkdDJkL25vZGVfbW9kdWxlcy9yb2J1c3QtaW4tc3BoZXJlL25vZGVfbW9kdWxlcy90d28tcHJvZHVjdC90d28tcHJvZHVjdC5qcyIsIm5vZGVfbW9kdWxlcy9wb2x5LWJvb2wvbm9kZV9tb2R1bGVzL292ZXJsYXktcHNsZy9ub2RlX21vZHVsZXMvY2R0MmQvbm9kZV9tb2R1bGVzL3JvYnVzdC1vcmllbnRhdGlvbi9vcmllbnRhdGlvbi5qcyIsIm5vZGVfbW9kdWxlcy9wb2x5LWJvb2wvbm9kZV9tb2R1bGVzL292ZXJsYXktcHNsZy9ub2RlX21vZHVsZXMvY2xlYW4tcHNsZy9jbGVhbi1wc2xnLmpzIiwibm9kZV9tb2R1bGVzL3BvbHktYm9vbC9ub2RlX21vZHVsZXMvb3ZlcmxheS1wc2xnL25vZGVfbW9kdWxlcy9jbGVhbi1wc2xnL2xpYi9yYXQtc2VnLWludGVyc2VjdC5qcyIsIm5vZGVfbW9kdWxlcy9wb2x5LWJvb2wvbm9kZV9tb2R1bGVzL292ZXJsYXktcHNsZy9ub2RlX21vZHVsZXMvY2xlYW4tcHNsZy9ub2RlX21vZHVsZXMvYmlnLXJhdC9hZGQuanMiLCJub2RlX21vZHVsZXMvcG9seS1ib29sL25vZGVfbW9kdWxlcy9vdmVybGF5LXBzbGcvbm9kZV9tb2R1bGVzL2NsZWFuLXBzbGcvbm9kZV9tb2R1bGVzL2JpZy1yYXQvY21wLmpzIiwibm9kZV9tb2R1bGVzL3BvbHktYm9vbC9ub2RlX21vZHVsZXMvb3ZlcmxheS1wc2xnL25vZGVfbW9kdWxlcy9jbGVhbi1wc2xnL25vZGVfbW9kdWxlcy9iaWctcmF0L2Rpdi5qcyIsIm5vZGVfbW9kdWxlcy9wb2x5LWJvb2wvbm9kZV9tb2R1bGVzL292ZXJsYXktcHNsZy9ub2RlX21vZHVsZXMvY2xlYW4tcHNsZy9ub2RlX21vZHVsZXMvYmlnLXJhdC9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9wb2x5LWJvb2wvbm9kZV9tb2R1bGVzL292ZXJsYXktcHNsZy9ub2RlX21vZHVsZXMvY2xlYW4tcHNsZy9ub2RlX21vZHVsZXMvYmlnLXJhdC9pcy1yYXQuanMiLCJub2RlX21vZHVsZXMvcG9seS1ib29sL25vZGVfbW9kdWxlcy9vdmVybGF5LXBzbGcvbm9kZV9tb2R1bGVzL2NsZWFuLXBzbGcvbm9kZV9tb2R1bGVzL2JpZy1yYXQvbGliL2JuLXNpZ24uanMiLCJub2RlX21vZHVsZXMvcG9seS1ib29sL25vZGVfbW9kdWxlcy9vdmVybGF5LXBzbGcvbm9kZV9tb2R1bGVzL2NsZWFuLXBzbGcvbm9kZV9tb2R1bGVzL2JpZy1yYXQvbGliL2JuLXRvLW51bS5qcyIsIm5vZGVfbW9kdWxlcy9wb2x5LWJvb2wvbm9kZV9tb2R1bGVzL292ZXJsYXktcHNsZy9ub2RlX21vZHVsZXMvY2xlYW4tcHNsZy9ub2RlX21vZHVsZXMvYmlnLXJhdC9saWIvY3R6LmpzIiwibm9kZV9tb2R1bGVzL3BvbHktYm9vbC9ub2RlX21vZHVsZXMvb3ZlcmxheS1wc2xnL25vZGVfbW9kdWxlcy9jbGVhbi1wc2xnL25vZGVfbW9kdWxlcy9iaWctcmF0L2xpYi9pcy1ibi5qcyIsIm5vZGVfbW9kdWxlcy9wb2x5LWJvb2wvbm9kZV9tb2R1bGVzL292ZXJsYXktcHNsZy9ub2RlX21vZHVsZXMvY2xlYW4tcHNsZy9ub2RlX21vZHVsZXMvYmlnLXJhdC9saWIvbnVtLXRvLWJuLmpzIiwibm9kZV9tb2R1bGVzL3BvbHktYm9vbC9ub2RlX21vZHVsZXMvb3ZlcmxheS1wc2xnL25vZGVfbW9kdWxlcy9jbGVhbi1wc2xnL25vZGVfbW9kdWxlcy9iaWctcmF0L2xpYi9yYXRpb25hbGl6ZS5qcyIsIm5vZGVfbW9kdWxlcy9wb2x5LWJvb2wvbm9kZV9tb2R1bGVzL292ZXJsYXktcHNsZy9ub2RlX21vZHVsZXMvY2xlYW4tcHNsZy9ub2RlX21vZHVsZXMvYmlnLXJhdC9saWIvc3RyLXRvLWJuLmpzIiwibm9kZV9tb2R1bGVzL3BvbHktYm9vbC9ub2RlX21vZHVsZXMvb3ZlcmxheS1wc2xnL25vZGVfbW9kdWxlcy9jbGVhbi1wc2xnL25vZGVfbW9kdWxlcy9iaWctcmF0L211bC5qcyIsIm5vZGVfbW9kdWxlcy9wb2x5LWJvb2wvbm9kZV9tb2R1bGVzL292ZXJsYXktcHNsZy9ub2RlX21vZHVsZXMvY2xlYW4tcHNsZy9ub2RlX21vZHVsZXMvYmlnLXJhdC9ub2RlX21vZHVsZXMvYml0LXR3aWRkbGUvdHdpZGRsZS5qcyIsIm5vZGVfbW9kdWxlcy9wb2x5LWJvb2wvbm9kZV9tb2R1bGVzL292ZXJsYXktcHNsZy9ub2RlX21vZHVsZXMvY2xlYW4tcHNsZy9ub2RlX21vZHVsZXMvYmlnLXJhdC9ub2RlX21vZHVsZXMvYm4uanMvbGliL2JuLmpzIiwibm9kZV9tb2R1bGVzL3BvbHktYm9vbC9ub2RlX21vZHVsZXMvb3ZlcmxheS1wc2xnL25vZGVfbW9kdWxlcy9jbGVhbi1wc2xnL25vZGVfbW9kdWxlcy9iaWctcmF0L25vZGVfbW9kdWxlcy9kb3VibGUtYml0cy9kb3VibGUuanMiLCJub2RlX21vZHVsZXMvcG9seS1ib29sL25vZGVfbW9kdWxlcy9vdmVybGF5LXBzbGcvbm9kZV9tb2R1bGVzL2NsZWFuLXBzbGcvbm9kZV9tb2R1bGVzL2JpZy1yYXQvc2lnbi5qcyIsIm5vZGVfbW9kdWxlcy9wb2x5LWJvb2wvbm9kZV9tb2R1bGVzL292ZXJsYXktcHNsZy9ub2RlX21vZHVsZXMvY2xlYW4tcHNsZy9ub2RlX21vZHVsZXMvYmlnLXJhdC9zdWIuanMiLCJub2RlX21vZHVsZXMvcG9seS1ib29sL25vZGVfbW9kdWxlcy9vdmVybGF5LXBzbGcvbm9kZV9tb2R1bGVzL2NsZWFuLXBzbGcvbm9kZV9tb2R1bGVzL2JpZy1yYXQvdG8tZmxvYXQuanMiLCJub2RlX21vZHVsZXMvcG9seS1ib29sL25vZGVfbW9kdWxlcy9vdmVybGF5LXBzbGcvbm9kZV9tb2R1bGVzL2NsZWFuLXBzbGcvbm9kZV9tb2R1bGVzL2JveC1pbnRlcnNlY3QvaW5kZXguanMiLCJub2RlX21vZHVsZXMvcG9seS1ib29sL25vZGVfbW9kdWxlcy9vdmVybGF5LXBzbGcvbm9kZV9tb2R1bGVzL2NsZWFuLXBzbGcvbm9kZV9tb2R1bGVzL2JveC1pbnRlcnNlY3QvbGliL2JydXRlLmpzIiwibm9kZV9tb2R1bGVzL3BvbHktYm9vbC9ub2RlX21vZHVsZXMvb3ZlcmxheS1wc2xnL25vZGVfbW9kdWxlcy9jbGVhbi1wc2xnL25vZGVfbW9kdWxlcy9ib3gtaW50ZXJzZWN0L2xpYi9pbnRlcnNlY3QuanMiLCJub2RlX21vZHVsZXMvcG9seS1ib29sL25vZGVfbW9kdWxlcy9vdmVybGF5LXBzbGcvbm9kZV9tb2R1bGVzL2NsZWFuLXBzbGcvbm9kZV9tb2R1bGVzL2JveC1pbnRlcnNlY3QvbGliL21lZGlhbi5qcyIsIm5vZGVfbW9kdWxlcy9wb2x5LWJvb2wvbm9kZV9tb2R1bGVzL292ZXJsYXktcHNsZy9ub2RlX21vZHVsZXMvY2xlYW4tcHNsZy9ub2RlX21vZHVsZXMvYm94LWludGVyc2VjdC9saWIvcGFydGl0aW9uLmpzIiwibm9kZV9tb2R1bGVzL3BvbHktYm9vbC9ub2RlX21vZHVsZXMvb3ZlcmxheS1wc2xnL25vZGVfbW9kdWxlcy9jbGVhbi1wc2xnL25vZGVfbW9kdWxlcy9ib3gtaW50ZXJzZWN0L2xpYi9zb3J0LmpzIiwibm9kZV9tb2R1bGVzL3BvbHktYm9vbC9ub2RlX21vZHVsZXMvb3ZlcmxheS1wc2xnL25vZGVfbW9kdWxlcy9jbGVhbi1wc2xnL25vZGVfbW9kdWxlcy9ib3gtaW50ZXJzZWN0L2xpYi9zd2VlcC5qcyIsIm5vZGVfbW9kdWxlcy9wb2x5LWJvb2wvbm9kZV9tb2R1bGVzL292ZXJsYXktcHNsZy9ub2RlX21vZHVsZXMvY2xlYW4tcHNsZy9ub2RlX21vZHVsZXMvYm94LWludGVyc2VjdC9ub2RlX21vZHVsZXMvdHlwZWRhcnJheS1wb29sL25vZGVfbW9kdWxlcy9kdXAvZHVwLmpzIiwibm9kZV9tb2R1bGVzL3BvbHktYm9vbC9ub2RlX21vZHVsZXMvb3ZlcmxheS1wc2xnL25vZGVfbW9kdWxlcy9jbGVhbi1wc2xnL25vZGVfbW9kdWxlcy9ib3gtaW50ZXJzZWN0L25vZGVfbW9kdWxlcy90eXBlZGFycmF5LXBvb2wvcG9vbC5qcyIsIm5vZGVfbW9kdWxlcy9wb2x5LWJvb2wvbm9kZV9tb2R1bGVzL292ZXJsYXktcHNsZy9ub2RlX21vZHVsZXMvY2xlYW4tcHNsZy9ub2RlX21vZHVsZXMvY29tcGFyZS1jZWxsL2NvbXBhcmUuanMiLCJub2RlX21vZHVsZXMvcG9seS1ib29sL25vZGVfbW9kdWxlcy9vdmVybGF5LXBzbGcvbm9kZV9tb2R1bGVzL2NsZWFuLXBzbGcvbm9kZV9tb2R1bGVzL25leHRhZnRlci9uZXh0YWZ0ZXIuanMiLCJub2RlX21vZHVsZXMvcG9seS1ib29sL25vZGVfbW9kdWxlcy9vdmVybGF5LXBzbGcvbm9kZV9tb2R1bGVzL2NsZWFuLXBzbGcvbm9kZV9tb2R1bGVzL25leHRhZnRlci9ub2RlX21vZHVsZXMvZG91YmxlLWJpdHMvZG91YmxlLmpzIiwibm9kZV9tb2R1bGVzL3BvbHktYm9vbC9ub2RlX21vZHVsZXMvb3ZlcmxheS1wc2xnL25vZGVfbW9kdWxlcy9jbGVhbi1wc2xnL25vZGVfbW9kdWxlcy9yYXQtdmVjL2FkZC5qcyIsIm5vZGVfbW9kdWxlcy9wb2x5LWJvb2wvbm9kZV9tb2R1bGVzL292ZXJsYXktcHNsZy9ub2RlX21vZHVsZXMvY2xlYW4tcHNsZy9ub2RlX21vZHVsZXMvcmF0LXZlYy9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9wb2x5LWJvb2wvbm9kZV9tb2R1bGVzL292ZXJsYXktcHNsZy9ub2RlX21vZHVsZXMvY2xlYW4tcHNsZy9ub2RlX21vZHVsZXMvcmF0LXZlYy9tdWxzLmpzIiwibm9kZV9tb2R1bGVzL3BvbHktYm9vbC9ub2RlX21vZHVsZXMvb3ZlcmxheS1wc2xnL25vZGVfbW9kdWxlcy9jbGVhbi1wc2xnL25vZGVfbW9kdWxlcy9yYXQtdmVjL3N1Yi5qcyIsIm5vZGVfbW9kdWxlcy9wb2x5LWJvb2wvbm9kZV9tb2R1bGVzL292ZXJsYXktcHNsZy9ub2RlX21vZHVsZXMvY2xlYW4tcHNsZy9ub2RlX21vZHVsZXMvcm9idXN0LXNlZ21lbnQtaW50ZXJzZWN0L3NlZ3NlZy5qcyIsIm5vZGVfbW9kdWxlcy9wb2x5LWJvb2wvbm9kZV9tb2R1bGVzL292ZXJsYXktcHNsZy9ub2RlX21vZHVsZXMvY2xlYW4tcHNsZy9ub2RlX21vZHVsZXMvdW5pb24tZmluZC9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9wb2x5LWJvb2wvbm9kZV9tb2R1bGVzL292ZXJsYXktcHNsZy9ub2RlX21vZHVsZXMvc2ltcGxpY2lhbC1jb21wbGV4LWJvdW5kYXJ5L2JvdW5kYXJ5LmpzIiwibm9kZV9tb2R1bGVzL3BvbHktYm9vbC9ub2RlX21vZHVsZXMvb3ZlcmxheS1wc2xnL25vZGVfbW9kdWxlcy9zaW1wbGljaWFsLWNvbXBsZXgtYm91bmRhcnkvbm9kZV9tb2R1bGVzL2JvdW5kYXJ5LWNlbGxzL2JvdW5kYXJ5LmpzIiwibm9kZV9tb2R1bGVzL3BvbHktYm9vbC9ub2RlX21vZHVsZXMvb3ZlcmxheS1wc2xnL25vZGVfbW9kdWxlcy9zaW1wbGljaWFsLWNvbXBsZXgtYm91bmRhcnkvbm9kZV9tb2R1bGVzL3JlZHVjZS1zaW1wbGljaWFsLWNvbXBsZXgvbm9kZV9tb2R1bGVzL2NlbGwtb3JpZW50YXRpb24vb3JpZW50YXRpb24uanMiLCJub2RlX21vZHVsZXMvcG9seS1ib29sL25vZGVfbW9kdWxlcy9vdmVybGF5LXBzbGcvbm9kZV9tb2R1bGVzL3NpbXBsaWNpYWwtY29tcGxleC1ib3VuZGFyeS9ub2RlX21vZHVsZXMvcmVkdWNlLXNpbXBsaWNpYWwtY29tcGxleC9ub2RlX21vZHVsZXMvY29tcGFyZS1vcmllbnRlZC1jZWxsL2NvbXBhcmUuanMiLCJub2RlX21vZHVsZXMvcG9seS1ib29sL25vZGVfbW9kdWxlcy9vdmVybGF5LXBzbGcvbm9kZV9tb2R1bGVzL3NpbXBsaWNpYWwtY29tcGxleC1ib3VuZGFyeS9ub2RlX21vZHVsZXMvcmVkdWNlLXNpbXBsaWNpYWwtY29tcGxleC9yZWR1Y2UuanMiLCJub2RlX21vZHVsZXMvcG9seS1ib29sL25vZGVfbW9kdWxlcy9vdmVybGF5LXBzbGcvb3ZlcmxheS1wc2xnLmpzIiwibm9kZV9tb2R1bGVzL3BvbHktYm9vbC9ub2RlX21vZHVsZXMvcG9seS10by1wc2xnL25vZGVfbW9kdWxlcy9jbGVhbi1wc2xnL25vZGVfbW9kdWxlcy9iaWctcmF0L25vZGVfbW9kdWxlcy9kb3VibGUtYml0cy9kb3VibGUuanMiLCJub2RlX21vZHVsZXMvcG9seS1ib29sL25vZGVfbW9kdWxlcy9wb2x5LXRvLXBzbGcvbm9kZV9tb2R1bGVzL2NsZWFuLXBzbGcvbm9kZV9tb2R1bGVzL2JveC1pbnRlcnNlY3Qvbm9kZV9tb2R1bGVzL3R5cGVkYXJyYXktcG9vbC9wb29sLmpzIiwibm9kZV9tb2R1bGVzL3BvbHktYm9vbC9ub2RlX21vZHVsZXMvcG9seS10by1wc2xnL25vZGVfbW9kdWxlcy9jbGVhbi1wc2xnL25vZGVfbW9kdWxlcy9uZXh0YWZ0ZXIvbm9kZV9tb2R1bGVzL2RvdWJsZS1iaXRzL2RvdWJsZS5qcyIsIm5vZGVfbW9kdWxlcy9wb2x5LWJvb2wvbm9kZV9tb2R1bGVzL3BvbHktdG8tcHNsZy9wb2x5LXRvLXBzbGcuanMiLCJub2RlX21vZHVsZXMvcG9seS1ib29sL25vZGVfbW9kdWxlcy9wc2xnLXRvLXBvbHkvcHNsZy10by1wb2x5LmpzIiwibm9kZV9tb2R1bGVzL3F1aWNrLW5vaXNlLWpzL3F1aWNrLW5vaXNlLmpzIiwic3JjL1ZlYzIuanMiLCJzcmMvYXVkaW8uanMiLCJzcmMvYmxvb2QuanMiLCJzcmMvYnVsbGV0LmpzIiwic3JjL2NhbWVyYS5qcyIsInNyYy9jbG9jay5qcyIsInNyYy9jb2xsaXNpb25fZ3JpZC5qcyIsInNyYy9jb25zdGFudHMuanMiLCJzcmMvZGVidWcuanMiLCJzcmMvZHJhd2luZy5qcyIsInNyYy9lbmVteS5qcyIsInNyYy9lbnRpdHkuanMiLCJzcmMvZ2FtZS5qcyIsInNyYy9nYW1lX3J1bm5lci5qcyIsInNyYy9nZnhfbGF5ZXIuanMiLCJzcmMvZ29yZS5qcyIsInNyYy9pbnB1dC5qcyIsInNyYy9rZXkuanMiLCJzcmMvbGV2ZWxfZGF0YS5qcyIsInNyYy9saWdodGluZy5qcyIsInNyYy9saW5lX3NlZ21lbnQuanMiLCJzcmMvbWFpbi5qcyIsInNyYy9tYXRoLmpzIiwic3JjL3BhcnRpY2xlLmpzIiwic3JjL3BpeGVsX2J1ZmZlci5qcyIsInNyYy9wbGF5ZXIuanMiLCJzcmMvcmFuZC5qcyIsInNyYy90d2VlbnMuanMiLCJzcmMvdXRpbC5qcyIsInNyYy92ZWMyLmpzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBOztBQ0FBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7QUNycUtBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7OztBQ3hnREE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM1SEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDcEZBO0FBQ0E7QUFDQTtBQUNBOztBQ0hBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDM0ZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdEtBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNqQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNwREE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNsRkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNuSEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDcExBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDM0xBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN4R0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN0S0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNoQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNqREE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzNKQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDM0pBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7O0FDaENBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzdMQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN4V0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzVDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDWEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNQQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNUQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM1REE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDVEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDVEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN0QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNuQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ1hBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2ZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMxQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDVEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDVEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDNU1BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FDOXdFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7O0FDcEdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ1RBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ1RBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN6Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3pJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDL0lBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDN2VBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzdJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ25CQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzNPQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7O0FDamJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUNoREE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7QUNyTkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdERBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FDekNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7QUNwR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2RBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDYkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNoQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7OztBQ2RBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDOUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDN0RBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDVkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDeEJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7OztBQ2pCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ1ZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDL0JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FDNVNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FDcEdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7QUNyTkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQ3BHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQ3ZEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzNDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN6TUEsWUFBWSxDQUFBOzs7O2VBQ0ssT0FBTyxDQUFDLFNBQVMsQ0FBQzs7SUFBNUIsTUFBTSxZQUFOLE1BQU07O0lBQ1AsSUFBSTtBQUNULFVBREssSUFBSSxDQUNHLENBQUMsRUFBRSxDQUFDLEVBQUU7d0JBRGIsSUFBSTs7QUFDVyxNQUFJLENBQUMsQ0FBQyxHQUFHLENBQUMsQ0FBQyxJQUFFLEdBQUcsQ0FBQyxBQUFDLElBQUksQ0FBQyxDQUFDLEdBQUcsQ0FBQyxDQUFDLElBQUUsR0FBRyxDQUFDO0VBQUU7O0FBRHBELEtBQUksV0FFVCxJQUFJLG1CQUFHO0FBQUUsU0FBTyxJQUFJLElBQUksQ0FBQyxDQUFDLElBQUksQ0FBQyxDQUFDLEVBQUUsSUFBSSxDQUFDLENBQUMsQ0FBQyxDQUFDO0VBQUU7O0FBRnZDLEtBQUksV0FHVCxFQUFFLGVBQUMsQ0FBQyxFQUFFO0FBQUUsU0FBTyxJQUFJLElBQUksQ0FBQyxDQUFDLENBQUMsQ0FBQyxHQUFDLElBQUksQ0FBQyxDQUFDLEVBQUUsQ0FBQyxDQUFDLENBQUMsR0FBQyxJQUFJLENBQUMsQ0FBQyxDQUFDLENBQUM7RUFBRTs7QUFIN0MsS0FBSSxXQUlULEdBQUcsZ0JBQUMsQ0FBQyxFQUFFO0FBQUUsU0FBTyxJQUFJLENBQUMsQ0FBQyxHQUFDLENBQUMsQ0FBQyxDQUFDLEdBQUMsSUFBSSxDQUFDLENBQUMsR0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDO0VBQUU7O0FBSm5DLEtBQUksV0FNVCxPQUFPLG9CQUFDLENBQUMsRUFBRTtBQUFFLFNBQU8sQ0FBQyxJQUFJLENBQUMsQ0FBQyxHQUFDLENBQUMsQ0FBQyxDQUFDLEdBQUMsSUFBSSxDQUFDLENBQUMsR0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDO0VBQUU7O0FBTnhDLEtBQUksV0FPVCxJQUFJLGlCQUFDLENBQUMsRUFBRTtBQUFFLFNBQU8sSUFBSSxJQUFJLENBQUMsSUFBSSxDQUFDLENBQUMsR0FBQyxDQUFDLENBQUMsQ0FBQyxFQUFFLElBQUksQ0FBQyxDQUFDLEdBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDO0VBQUU7O0FBUC9DLEtBQUksV0FTVCxLQUFLLGtCQUFDLENBQUMsRUFBRTtBQUFFLFNBQU8sSUFBSSxJQUFJLENBQUMsSUFBSSxDQUFDLENBQUMsR0FBQyxDQUFDLENBQUMsQ0FBQyxFQUFFLElBQUksQ0FBQyxDQUFDLEdBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDO0VBQUU7O0FBVGhELEtBQUksV0FVVCxLQUFLLG9CQUFHO0FBQUUsU0FBTyxJQUFJLENBQUMsQ0FBQyxHQUFDLElBQUksQ0FBQyxDQUFDLEdBQUMsSUFBSSxDQUFDLENBQUMsR0FBQyxJQUFJLENBQUMsQ0FBQyxDQUFDO0VBQUU7O0FBVjFDLEtBQUksV0FXVCxHQUFHLGtCQUFHO0FBQUUsU0FBTyxJQUFJLENBQUMsSUFBSSxDQUFDLElBQUksQ0FBQyxDQUFDLEdBQUMsSUFBSSxDQUFDLENBQUMsR0FBRyxJQUFJLENBQUMsQ0FBQyxHQUFDLElBQUksQ0FBQyxDQUFDLENBQUMsQ0FBQztFQUFFOztBQVhyRCxLQUFJLFdBWVQsTUFBTSxxQkFBRztBQUFFLFNBQU8sSUFBSSxDQUFDLEdBQUcsRUFBRSxDQUFDO0VBQUU7O0FBWjFCLEtBQUksV0FhVCxhQUFhLDRCQUFHO0FBQUUsU0FBTyxLQUFLLEVBQUUsQ0FBQztFQUFFOztBQWI5QixLQUFJLFdBY1QsTUFBTSxtQkFBQyxDQUFDLEVBQUU7QUFBRSxTQUFPLElBQUksSUFBSSxDQUFDLElBQUksQ0FBQyxDQUFDLEdBQUMsQ0FBQyxFQUFFLElBQUksQ0FBQyxDQUFDLEdBQUMsQ0FBQyxDQUFDLENBQUM7RUFBRTs7QUFkN0MsS0FBSSxXQWVULFNBQVMsd0JBQUc7QUFBRSxNQUFJLENBQUMsZUFBZSxFQUFFLENBQUMsQUFBQyxPQUFPLElBQUksQ0FBQztFQUFFOztBQWYvQyxLQUFJLFdBZ0JULEtBQUssb0JBQUc7QUFBRSxTQUFPLElBQUksSUFBSSxDQUFDLElBQUksQ0FBQyxDQUFDLEVBQUUsSUFBSSxDQUFDLENBQUMsQ0FBQyxDQUFDO0VBQUU7O0FBaEJ2QyxLQUFJLFdBaUJULElBQUksdUJBQVM7TUFBUCxDQUFDLFFBQUQsQ0FBQztNQUFFLENBQUMsUUFBRCxDQUFDO0FBQUssTUFBSSxDQUFDLENBQUMsR0FBRyxDQUFDLENBQUMsQUFBQyxDQUFDLEFBQUMsSUFBSSxDQUFDLENBQUMsR0FBRyxDQUFDLENBQUMsQUFBQyxPQUFPLElBQUksQ0FBQztFQUFFOztBQWpCbEQsS0FBSSxXQW1CVCxLQUFLLGtCQUFDLENBQUMsRUFBRTtBQUFFLE1BQUksQ0FBQyxDQUFDLElBQUksQ0FBQyxDQUFDLEFBQUMsSUFBSSxDQUFDLENBQUMsSUFBSSxDQUFDLENBQUMsQUFBQyxPQUFPLElBQUksQ0FBQztFQUFFOztBQW5COUMsS0FBSSxXQW9CVCxHQUFHLGdCQUFDLENBQUMsRUFBRSxDQUFDLEVBQUU7QUFBRSxNQUFJLENBQUMsQ0FBQyxHQUFHLENBQUMsQ0FBQyxBQUFDLElBQUksQ0FBQyxDQUFDLEdBQUcsQ0FBQyxDQUFDLEFBQUMsT0FBTyxJQUFJLENBQUM7RUFBRTs7QUFwQjdDLEtBQUksV0FxQlQsS0FBSyxvQkFBRztBQUFFLFNBQU8sSUFBSSxDQUFDLEdBQUcsQ0FBQyxHQUFHLEVBQUUsR0FBRyxDQUFDLENBQUM7RUFBRTs7QUFyQmpDLEtBQUksV0FzQlQsR0FBRyxnQkFBQyxDQUFDLEVBQUU7QUFBRSxNQUFJLENBQUMsQ0FBQyxJQUFJLENBQUMsQ0FBQyxDQUFDLENBQUMsQUFBQyxJQUFJLENBQUMsQ0FBQyxJQUFJLENBQUMsQ0FBQyxDQUFDLENBQUMsQUFBQyxPQUFPLElBQUksQ0FBQztFQUFFOztBQXRCaEQsS0FBSSxXQXdCVCxTQUFTLHNCQUFDLENBQUMsRUFBRSxDQUFDLEVBQUU7QUFBRSxNQUFJLENBQUMsQ0FBQyxJQUFJLENBQUMsQ0FBQyxDQUFDLEdBQUMsQ0FBQyxDQUFDLEFBQUMsSUFBSSxDQUFDLENBQUMsSUFBSSxDQUFDLENBQUMsQ0FBQyxHQUFDLENBQUMsQ0FBQyxBQUFDLE9BQU8sSUFBSSxDQUFDO0VBQUU7O0FBeEI3RCxLQUFJLFdBMEJULFNBQVMsc0JBQUMsQ0FBQyxFQUFFLENBQUMsRUFBRTtBQUFFLE1BQUksQ0FBQyxDQUFDLElBQUksQ0FBQyxDQUFDLEFBQUMsSUFBSSxDQUFDLENBQUMsSUFBSSxDQUFDLENBQUMsQUFBQyxPQUFPLElBQUksQ0FBQztFQUFFOztBQTFCckQsS0FBSSxXQTJCVCxVQUFVLHlCQUFHO0FBQUUsU0FBTyxJQUFJLENBQUMsS0FBSyxFQUFFLENBQUMsU0FBUyxFQUFFLENBQUM7RUFBRTs7QUEzQjVDLEtBQUksV0E0QlQsTUFBTSxtQkFBQyxDQUFDLEVBQUU7QUFBRSxTQUFPLElBQUksQ0FBQyxLQUFLLEVBQUUsQ0FBQyxLQUFLLENBQUMsQ0FBQyxDQUFDLENBQUM7RUFBRTs7QUE1QnRDLEtBQUksV0E2QlQsUUFBUSx1QkFBRztBQUFFLGVBQVcsSUFBSSxDQUFDLENBQUMsVUFBSyxJQUFJLENBQUMsQ0FBQyxPQUFJO0VBQUU7O0FBN0IxQyxLQUFJLFdBK0JULFFBQVEscUJBQUMsQ0FBQyxFQUFFO0FBQ1gsTUFBSSxFQUFFLEdBQUcsSUFBSSxDQUFDLENBQUMsR0FBRyxDQUFDLENBQUMsQ0FBQztNQUFFLEVBQUUsR0FBRyxJQUFJLENBQUMsQ0FBQyxHQUFHLENBQUMsQ0FBQyxDQUFDLENBQUM7QUFDekMsU0FBTyxJQUFJLENBQUMsSUFBSSxDQUFDLEVBQUUsR0FBQyxFQUFFLEdBQUcsRUFBRSxHQUFDLEVBQUUsQ0FBQyxDQUFDO0VBQ2hDOztBQWxDSSxLQUFJLFdBb0NULFVBQVUsdUJBQUMsQ0FBQyxFQUFFO0FBQ2IsTUFBSSxDQUFBO0FBQ0osTUFBSSxFQUFFLEdBQUcsSUFBSSxDQUFDLENBQUMsR0FBRyxDQUFDLENBQUMsQ0FBQztNQUFFLEVBQUUsR0FBRyxJQUFJLENBQUMsQ0FBQyxHQUFHLENBQUMsQ0FBQyxDQUFDLENBQUM7QUFDekMsU0FBTyxFQUFFLEdBQUMsRUFBRSxHQUFHLEVBQUUsR0FBQyxFQUFFLENBQUM7RUFDckI7O0FBeENJLEtBQUksV0EwQ1QsZUFBZSw4QkFBRztBQUNqQixNQUFJLEVBQUUsR0FBRyxJQUFJLENBQUMsQ0FBQyxHQUFDLElBQUksQ0FBQyxDQUFDLEdBQUMsSUFBSSxDQUFDLENBQUMsR0FBQyxJQUFJLENBQUMsQ0FBQyxDQUFDO0FBQ3JDLE1BQUksRUFBRSxLQUFLLEdBQUcsRUFBRTtBQUFFLE9BQUksQ0FBQyxDQUFDLEdBQUcsR0FBRyxDQUFDLEFBQUMsSUFBSSxDQUFDLENBQUMsR0FBRyxHQUFHLENBQUMsQUFBQyxPQUFPLE9BQU8sQ0FBQztHQUFFO0FBQy9ELE1BQUksRUFBRSxHQUFHLEdBQUcsR0FBQyxJQUFJLENBQUMsSUFBSSxDQUFDLEVBQUUsQ0FBQyxDQUFDO0FBQzNCLE1BQUksQ0FBQyxDQUFDLElBQUksRUFBRSxDQUFDO0FBQ2IsTUFBSSxDQUFDLENBQUMsSUFBSSxFQUFFLENBQUM7QUFDYixNQUFJLENBQUE7QUFDSixTQUFPLEVBQUUsR0FBQyxFQUFFLENBQUM7RUFDYjs7QUFsREksS0FBSSxXQW9EVCxlQUFlLDhCQUFHO0FBQ2pCLFNBQU8sSUFBSSxDQUFDLEtBQUssQ0FBQyxHQUFHLElBQUUsSUFBSSxDQUFDLElBQUksQ0FBQyxJQUFJLENBQUMsQ0FBQyxHQUFDLElBQUksQ0FBQyxDQUFDLEdBQUMsSUFBSSxDQUFDLENBQUMsR0FBQyxJQUFJLENBQUMsQ0FBQyxDQUFDLEdBQUMsS0FBSyxDQUFBLEFBQUMsQ0FBQyxDQUFDO0VBQ3RFOztBQXRESSxLQUFJLFdBd0RULEtBQUssb0JBQVk7TUFBWCxLQUFLLHlEQUFDLEdBQUc7QUFBSSxNQUFJLENBQUMsQ0FBQyxHQUFHLEdBQUcsR0FBRyxLQUFLLEdBQUcsSUFBSSxDQUFDLENBQUMsQ0FBQyxBQUFDLE9BQU8sSUFBSSxDQUFDO0VBQUU7O0FBeEQzRCxLQUFJLFdBeURULEtBQUssb0JBQVk7TUFBWCxLQUFLLHlEQUFDLEdBQUc7QUFBSSxNQUFJLENBQUMsQ0FBQyxHQUFHLEdBQUcsR0FBRyxLQUFLLEdBQUcsSUFBSSxDQUFDLENBQUMsQ0FBQyxBQUFDLE9BQU8sSUFBSSxDQUFDO0VBQUU7O0FBekQzRCxLQUFJLFdBMkRULE1BQU0sbUJBQUMsS0FBSyxFQUFFLEtBQUssRUFBRTtBQUNwQixNQUFJLE1BQU0sR0FBRyxHQUFHO01BQUUsTUFBTSxHQUFHLEdBQUcsQ0FBQztBQUMvQixNQUFJLEtBQUssRUFBRTtBQUFFLFNBQU0sR0FBRyxLQUFLLENBQUMsQ0FBQyxDQUFDLEFBQUMsTUFBTSxHQUFHLEtBQUssQ0FBQyxDQUFDLENBQUM7R0FBRTtBQUNsRCxNQUFJLENBQUMsR0FBRyxJQUFJLENBQUMsQ0FBQyxHQUFHLE1BQU0sQ0FBQztBQUN4QixNQUFJLENBQUMsR0FBRyxJQUFJLENBQUMsQ0FBQyxHQUFHLE1BQU0sQ0FBQztBQUN4QixNQUFJLENBQUMsR0FBRyxJQUFJLENBQUMsR0FBRyxDQUFDLEtBQUssQ0FBQyxDQUFDO0FBQ3hCLE1BQUksQ0FBQyxHQUFHLElBQUksQ0FBQyxHQUFHLENBQUMsS0FBSyxDQUFDLENBQUM7QUFDeEIsTUFBSSxFQUFFLEdBQUcsQ0FBQyxHQUFHLENBQUMsR0FBRyxDQUFDLEdBQUcsQ0FBQyxDQUFDO0FBQ3ZCLE1BQUksRUFBRSxHQUFHLENBQUMsR0FBRyxDQUFDLEdBQUcsQ0FBQyxHQUFHLENBQUMsQ0FBQztBQUN2QixNQUFJLENBQUMsQ0FBQyxHQUFHLEVBQUUsR0FBRyxNQUFNLENBQUM7QUFDckIsTUFBSSxDQUFDLENBQUMsR0FBRyxFQUFFLEdBQUcsTUFBTSxDQUFDO0FBQ3JCLFNBQU8sSUFBSSxDQUFDO0VBQ1o7O0FBdkVJLEtBQUksV0F5RVQsUUFBUSxxQkFBQyxLQUFLLEVBQUU7QUFDZixNQUFJLE1BQU0sR0FBRyxHQUFHO01BQUUsTUFBTSxHQUFHLEdBQUcsQ0FBQztBQUMvQixNQUFJLEtBQUssRUFBRTtBQUFFLFNBQU0sR0FBRyxLQUFLLENBQUMsQ0FBQyxDQUFDLEFBQUMsTUFBTSxHQUFHLEtBQUssQ0FBQyxDQUFDLENBQUM7R0FBRTtBQUNsRCxNQUFJLENBQUMsR0FBRyxJQUFJLENBQUMsQ0FBQyxHQUFHLE1BQU0sQ0FBQztBQUN4QixNQUFJLENBQUMsR0FBRyxJQUFJLENBQUMsQ0FBQyxHQUFHLE1BQU0sQ0FBQztBQUN4QixNQUFJLENBQUMsQ0FBQyxHQUFHLENBQUMsQ0FBQyxHQUFDLE1BQU0sQ0FBQztBQUNuQixNQUFJLENBQUMsQ0FBQyxHQUFJLENBQUMsR0FBQyxNQUFNLENBQUM7QUFDbkIsU0FBTyxJQUFJLENBQUM7RUFDWjs7QUFqRkksS0FBSSxXQW1GVCxTQUFTLHNCQUFDLEtBQUssRUFBRTtBQUNoQixNQUFJLE1BQU0sR0FBRyxHQUFHO01BQUUsTUFBTSxHQUFHLEdBQUcsQ0FBQztBQUMvQixNQUFJLEtBQUssRUFBRTtBQUFFLFNBQU0sR0FBRyxLQUFLLENBQUMsQ0FBQyxDQUFDLEFBQUMsTUFBTSxHQUFHLEtBQUssQ0FBQyxDQUFDLENBQUM7R0FBRTtBQUNsRCxNQUFJLENBQUMsR0FBRyxJQUFJLENBQUMsQ0FBQyxHQUFHLE1BQU0sQ0FBQztBQUN4QixNQUFJLENBQUMsR0FBRyxJQUFJLENBQUMsQ0FBQyxHQUFHLE1BQU0sQ0FBQztBQUN4QixNQUFJLENBQUMsQ0FBQyxHQUFHLENBQUMsQ0FBQyxHQUFDLE1BQU0sQ0FBQztBQUNuQixNQUFJLENBQUMsQ0FBQyxHQUFHLENBQUMsQ0FBQyxHQUFDLE1BQU0sQ0FBQztBQUNuQixTQUFPLElBQUksQ0FBQztFQUNaOztBQTNGSSxLQUFJLFdBNkZULFNBQVMsc0JBQUMsS0FBSyxFQUFFO0FBQ2hCLE1BQUksTUFBTSxHQUFHLEdBQUc7TUFBRSxNQUFNLEdBQUcsR0FBRyxDQUFDO0FBQy9CLE1BQUksS0FBSyxFQUFFO0FBQUUsU0FBTSxHQUFHLEtBQUssQ0FBQyxDQUFDLENBQUMsQUFBQyxNQUFNLEdBQUcsS0FBSyxDQUFDLENBQUMsQ0FBQztHQUFFO0FBQ2xELE1BQUksQ0FBQyxHQUFHLElBQUksQ0FBQyxDQUFDLEdBQUcsTUFBTSxDQUFDO0FBQ3hCLE1BQUksQ0FBQyxHQUFHLElBQUksQ0FBQyxDQUFDLEdBQUcsTUFBTSxDQUFDO0FBQ3hCLE1BQUksQ0FBQyxDQUFDLEdBQUksQ0FBQyxHQUFDLE1BQU0sQ0FBQztBQUNuQixNQUFJLENBQUMsQ0FBQyxHQUFHLENBQUMsQ0FBQyxHQUFDLE1BQU0sQ0FBQztBQUNuQixTQUFPLElBQUksQ0FBQztFQUNaOztBQXJHSSxLQUFJLFdBdUdULE1BQU0sbUJBQUMsS0FBSyxFQUFFLEtBQUssRUFBRTtBQUNwQixNQUFJLE1BQU0sR0FBRyxHQUFHO01BQUUsTUFBTSxHQUFHLEdBQUcsQ0FBQztBQUMvQixNQUFJLEtBQUssRUFBRTtBQUFFLFNBQU0sR0FBRyxLQUFLLENBQUMsQ0FBQyxDQUFDLEFBQUMsTUFBTSxHQUFHLEtBQUssQ0FBQyxDQUFDLENBQUM7R0FBRTtBQUNsRCxNQUFJLEdBQUcsR0FBRyxJQUFJLENBQUMsR0FBRyxDQUFDLEtBQUssQ0FBQyxDQUFDO0FBQzFCLE1BQUksR0FBRyxHQUFHLElBQUksQ0FBQyxHQUFHLENBQUMsS0FBSyxDQUFDLENBQUM7O0FBRTFCLE1BQUksQ0FBQyxHQUFHLElBQUksQ0FBQyxDQUFDLEdBQUcsTUFBTSxDQUFDO0FBQ3hCLE1BQUksQ0FBQyxHQUFHLElBQUksQ0FBQyxDQUFDLEdBQUcsTUFBTSxDQUFDO0FBQ3hCLE1BQUksRUFBRSxHQUFHLEFBQUMsR0FBRyxHQUFHLENBQUMsR0FBSyxHQUFHLEdBQUcsQ0FBQyxBQUFDLENBQUM7QUFDL0IsTUFBSSxFQUFFLEdBQUcsQUFBQyxHQUFHLEdBQUcsQ0FBQyxHQUFLLEdBQUcsR0FBRyxDQUFDLEFBQUMsQ0FBQztBQUMvQixNQUFJLENBQUMsQ0FBQyxHQUFHLEVBQUUsR0FBRyxNQUFNLENBQUM7QUFDckIsTUFBSSxDQUFDLENBQUMsR0FBRyxFQUFFLEdBQUcsTUFBTSxDQUFDO0FBQ3JCLFNBQU8sSUFBSSxDQUFDO0VBQ1o7O0FBcEhJLEtBQUksV0FzSFQsU0FBUyxzQkFBQyxLQUFLLEVBQUU7QUFBRSxTQUFPLElBQUksQ0FBQyxLQUFLLEVBQUUsQ0FBQyxRQUFRLENBQUMsS0FBSyxDQUFDLENBQUM7RUFBRTs7QUF0SHBELEtBQUksV0F1SFQsVUFBVSx1QkFBQyxLQUFLLEVBQUU7QUFBRSxTQUFPLElBQUksQ0FBQyxLQUFLLEVBQUUsQ0FBQyxTQUFTLENBQUMsS0FBSyxDQUFDLENBQUM7RUFBRTs7QUF2SHRELEtBQUksV0F3SFQsVUFBVSx1QkFBQyxLQUFLLEVBQUU7QUFBRSxTQUFPLElBQUksQ0FBQyxLQUFLLEVBQUUsQ0FBQyxTQUFTLENBQUMsS0FBSyxDQUFDLENBQUM7RUFBRTs7QUF4SHRELEtBQUksV0EwSFQsUUFBUSxxQkFBQyxNQUFNLEVBQUU7QUFBRSxTQUFPLElBQUksQ0FBQyxLQUFLLEVBQUUsQ0FBQyxLQUFLLENBQUMsTUFBTSxDQUFDLENBQUM7RUFBRTs7QUExSGxELEtBQUksV0EySFQsUUFBUSxxQkFBQyxNQUFNLEVBQUU7QUFBRSxTQUFPLElBQUksQ0FBQyxLQUFLLEVBQUUsQ0FBQyxLQUFLLENBQUMsTUFBTSxDQUFDLENBQUM7RUFBRTs7QUEzSGxELEtBQUksV0E4SFQsUUFBUSx1QkFBRztBQUNWLFFBQU0sQ0FBQyxDQUFDLElBQUksQ0FBQyxDQUFDLEtBQUssSUFBSSxDQUFDLENBQUMsQ0FBQyxDQUFDO0FBQzNCLFFBQU0sQ0FBQyxDQUFDLElBQUksQ0FBQyxDQUFDLEtBQUssSUFBSSxDQUFDLENBQUMsQ0FBQyxDQUFDO0FBQzNCLFNBQU8sSUFBSSxDQUFDO0VBQ1o7O1FBbElJLElBQUk7OztBQXFJVixJQUFJLENBQUMsSUFBSSxHQUFHLE1BQU0sQ0FBQyxNQUFNLENBQUMsSUFBSSxJQUFJLENBQUMsR0FBRyxFQUFFLEdBQUcsQ0FBQyxDQUFDLENBQUM7O0FBRTlDLElBQUksQ0FBQyxJQUFJLEdBQUcsWUFBVztBQUFFLFFBQU8sSUFBSSxJQUFJLENBQUMsR0FBRyxFQUFFLEdBQUcsQ0FBQyxDQUFDO0NBQUUsQ0FBQztBQUN0RCxJQUFJLENBQUMsT0FBTyxHQUFHLFVBQVMsR0FBRyxFQUFFO0FBQUUsUUFBTyxJQUFJLElBQUksQ0FBQyxJQUFJLENBQUMsR0FBRyxDQUFDLEdBQUcsQ0FBQyxFQUFFLElBQUksQ0FBQyxHQUFHLENBQUMsR0FBRyxDQUFDLENBQUMsQ0FBQztDQUFFLENBQUM7QUFDaEYsSUFBSSxDQUFDLE9BQU8sR0FBRyxVQUFTLEVBQUUsRUFBRSxFQUFFLEVBQUU7QUFBRSxRQUFPLElBQUksSUFBSSxDQUFDLEVBQUUsQ0FBQyxDQUFDLEdBQUcsRUFBRSxDQUFDLENBQUMsRUFBRSxFQUFFLENBQUMsQ0FBQyxHQUFHLEVBQUUsQ0FBQyxDQUFDLENBQUMsQ0FBQztDQUFFLENBQUM7QUFDL0UsSUFBSSxDQUFDLFNBQVMsR0FBRyxVQUFTLEVBQUUsRUFBRSxFQUFFLEVBQUUsRUFBRSxFQUFFLEVBQUUsRUFBRTtBQUFFLFFBQU8sSUFBSSxJQUFJLENBQUMsRUFBRSxHQUFHLEVBQUUsRUFBRSxFQUFFLEdBQUcsRUFBRSxDQUFDLENBQUM7Q0FBRSxDQUFDOztBQUVqRixJQUFJLENBQUMsSUFBSSxHQUFHO0FBQ1gsTUFBSyxFQUFFLEVBQUU7QUFDVCxNQUFLLEVBQUUsQ0FBQztBQUNSLElBQUcsZUFBQyxDQUFDLEVBQUUsQ0FBQyxFQUFFO0FBQ1QsTUFBSSxJQUFJLENBQUMsS0FBSyxLQUFLLElBQUksQ0FBQyxLQUFLLENBQUMsTUFBTSxFQUNuQyxJQUFJLENBQUMsS0FBSyxDQUFDLElBQUksQ0FBQyxJQUFJLElBQUksQ0FBQyxHQUFHLEVBQUUsR0FBRyxDQUFDLENBQUMsQ0FBQztBQUNyQyxTQUFPLElBQUksQ0FBQyxLQUFLLENBQUMsSUFBSSxDQUFDLEtBQUssRUFBRSxDQUFDLENBQUMsR0FBRyxDQUFDLENBQUMsQ0FBQyxJQUFFLEdBQUcsRUFBRSxDQUFDLENBQUMsSUFBRSxHQUFHLENBQUMsQ0FBQztFQUN0RDtBQUNELE1BQUssbUJBQUc7QUFBRSxNQUFJLENBQUMsS0FBSyxHQUFHLENBQUMsQ0FBQztFQUFFO0FBQzNCLE9BQU0sb0JBQUc7QUFBRSxNQUFJLENBQUMsS0FBSyxHQUFHLENBQUMsQ0FBQztFQUFFO0NBQzVCLENBQUE7O0FBRUQsSUFBSSxDQUFDLElBQUksR0FBRyxVQUFTLENBQUMsRUFBRSxDQUFDLEVBQUU7QUFBRSxRQUFPLElBQUksQ0FBQyxJQUFJLENBQUMsR0FBRyxDQUFDLENBQUMsRUFBRSxDQUFDLENBQUMsQ0FBQztDQUFFLENBQUM7O0FBRzNELE1BQU0sQ0FBQyxPQUFPLEdBQUcsSUFBSSxDQUFDOzs7QUM3SnRCLFlBQVksQ0FBQzs7ZUFDRCxPQUFPLENBQUMsUUFBUSxDQUFDOztJQUF4QixHQUFHLFlBQUgsR0FBRzs7QUFFUixTQUFTLGVBQWUsQ0FBQyxHQUFHLEVBQThCO0tBQTVCLEdBQUcseURBQUMsR0FBRztLQUFFLEdBQUcseURBQUMsR0FBRztLQUFFLEtBQUsseURBQUMsRUFBRTs7QUFDdkQsS0FBSSxHQUFHLEdBQUcsQ0FDVCxJQUFJLElBQUksQ0FBQyxFQUFFLEdBQUcsRUFBRSxHQUFHLEVBQUUsTUFBTSxFQUFFLEdBQUcsRUFBRSxJQUFJLEVBQUUsQ0FBQyxFQUFFLENBQUMsQ0FDNUMsQ0FBQztBQUNGLE1BQUssSUFBSSxJQUFJLEdBQUcsR0FBRyxFQUFFLElBQUksSUFBSSxHQUFHLEVBQUUsSUFBSSxJQUFJLENBQUMsR0FBRyxHQUFDLEdBQUcsQ0FBQSxHQUFFLEtBQUs7QUFDeEQsS0FBRyxDQUFDLElBQUksQ0FBQyxJQUFJLElBQUksQ0FBQyxFQUFFLElBQUksRUFBSixJQUFJLEVBQUUsR0FBRyxFQUFFLEdBQUcsRUFBRSxNQUFNLEVBQUUsR0FBRyxFQUFFLENBQUMsQ0FBQyxDQUFDO0VBQUEsQUFDckQsT0FBTyxHQUFHLENBQUM7Q0FDWDtBQUNELElBQUksTUFBTSxHQUFHO0FBQ1osWUFBVyxFQUFFLElBQUk7QUFDakIsS0FBSSxFQUFFLGVBQWUsQ0FBQyxDQUFDLGVBQWUsQ0FBQyxDQUFDO0FBQ3hDLEtBQUksRUFBRSxlQUFlLENBQUMsQ0FBQyxlQUFlLENBQUMsRUFBRSxDQUFDLEVBQUUsR0FBRyxFQUFFLENBQUMsQ0FBQztBQUNuRCxLQUFJLEVBQUUsZUFBZSxDQUFDLENBQUMsa0JBQWtCLENBQUMsQ0FBQztBQUMzQyxVQUFTLEVBQUUsZUFBZSxDQUFDLENBQUMsb0JBQW9CLENBQUMsQ0FBQztBQUNsRCxNQUFLLEVBQUUsZUFBZSxDQUFDLENBQUMsZUFBZSxDQUFDLEVBQUUsR0FBRyxFQUFFLEdBQUcsQ0FBQztBQUNuRCxPQUFNLEVBQUUsZUFBZSxDQUFDLENBQUMsZ0JBQWdCLENBQUMsQ0FBQztBQUMzQyxJQUFHLEVBQUUsZUFBZSxDQUFDLENBQUMsYUFBYSxDQUFDLEVBQUUsR0FBRyxFQUFFLEdBQUcsQ0FBQztBQUMvQyxLQUFJLEVBQUUsQ0FBQyxJQUFJLElBQUksQ0FBQyxFQUFFLEdBQUcsRUFBRSxDQUFDLGNBQWMsQ0FBQyxFQUFFLE1BQU0sRUFBRSxHQUFHLEVBQUUsQ0FBQyxDQUFDO0FBQ3hELEtBQUksRUFBRSxDQUFDLElBQUksSUFBSSxDQUFDLEVBQUUsR0FBRyxFQUFFLENBQUMsY0FBYyxDQUFDLEVBQUUsTUFBTSxFQUFFLEdBQUcsRUFBRSxDQUFDLENBQUM7O0FBRXhELE1BQUssRUFBRSxDQUNOLElBQUksSUFBSSxDQUFDLEVBQUUsR0FBRyxFQUFFLENBQUMsZUFBZSxDQUFDLEVBQUUsSUFBSSxFQUFFLENBQUMsRUFBRSxDQUFDLEVBQzdDLElBQUksSUFBSSxDQUFDLEVBQUUsR0FBRyxFQUFFLENBQUMsZUFBZSxDQUFDLEVBQUUsSUFBSSxFQUFFLEdBQUcsRUFBRSxDQUFDLEVBQy9DLElBQUksSUFBSSxDQUFDLEVBQUUsR0FBRyxFQUFFLENBQUMsZUFBZSxDQUFDLEVBQUUsSUFBSSxFQUFFLEdBQUcsRUFBRSxDQUFDLEVBQy9DLElBQUksSUFBSSxDQUFDLEVBQUUsR0FBRyxFQUFFLENBQUMsZUFBZSxDQUFDLEVBQUUsSUFBSSxFQUFFLEdBQUcsRUFBRSxDQUFDLEVBQy9DLElBQUksSUFBSSxDQUFDLEVBQUUsR0FBRyxFQUFFLENBQUMsZUFBZSxDQUFDLEVBQUUsSUFBSSxFQUFFLEdBQUcsRUFBRSxDQUFDLENBQy9DO0FBQ0QsTUFBSyxFQUFFLElBQUksSUFBSSxDQUFDLEVBQUUsR0FBRyxFQUFFLENBQUMsZ0JBQWdCLEVBQUUsZ0JBQWdCLENBQUMsRUFBRSxJQUFJLEVBQUUsSUFBSSxFQUFFLE1BQU0sRUFBRSxHQUFHLEVBQUUsQ0FBQztBQUN2RixNQUFLLEVBQUUsSUFBSSxJQUFJLENBQUMsRUFBRSxHQUFHLEVBQUUsQ0FBQyxlQUFlLEVBQUUsZUFBZSxDQUFDLEVBQUUsSUFBSSxFQUFFLElBQUksRUFBRSxNQUFNLEVBQUUsR0FBRyxFQUFFLENBQUM7QUFDckYsTUFBSyxFQUFFLElBQUksSUFBSSxDQUFDLEVBQUUsR0FBRyxFQUFFLENBQUMsZUFBZSxFQUFFLGVBQWUsQ0FBQyxFQUFFLElBQUksRUFBRSxJQUFJLEVBQUUsTUFBTSxFQUFFLEdBQUcsRUFBRSxDQUFDO0FBQ3JGLFFBQU8sRUFBRSxJQUFJLElBQUksQ0FBQztBQUNqQixLQUFHLEVBQUUsQ0FBQyxpQkFBaUIsRUFBRSxpQkFBaUIsQ0FBQztBQUMzQyxRQUFNLEVBQUU7QUFDUCxVQUFPLEVBQUUsQ0FBQyxDQUFDLEVBQUUsSUFBSSxDQUFDO0FBQ2xCLFVBQU8sRUFBRSxDQUFDLEtBQUssRUFBRSxLQUFLLENBQUM7QUFDdkIsVUFBTyxFQUFFLENBQUMsS0FBSyxFQUFFLEtBQUssQ0FBQztBQUN2QixVQUFPLEVBQUUsQ0FBQyxLQUFLLEVBQUUsS0FBSyxDQUFDO0FBQ3ZCLFVBQU8sRUFBRSxDQUFDLEtBQUssRUFBRSxLQUFLLENBQUM7QUFDdkIsVUFBTyxFQUFFLENBQUMsS0FBSyxFQUFFLEtBQUssQ0FBQztHQUN2QjtFQUNELENBQUM7O0FBRUYsVUFBUyx1QkFBYTs7O01BQVosSUFBSSx5REFBQyxLQUFLOztBQUNuQixNQUFJLElBQUksQ0FBQyxXQUFXLElBQUksSUFBSSxFQUFFLE9BQU87QUFDckMsTUFBSSxJQUFJLEVBQUU7O0FBQ1QsUUFBSSxFQUFFLEdBQUcsTUFBSyxXQUFXLENBQUM7QUFDMUIsTUFBRSxDQUFDLElBQUksQ0FBQyxHQUFHLEVBQUUsR0FBRyxFQUFFLEdBQUcsQ0FBQyxDQUFDO0FBQ3ZCLE1BQUUsQ0FBQyxJQUFJLENBQUMsT0FBTyxFQUFFO1lBQU0sRUFBRSxDQUFDLElBQUksRUFBRTtLQUFBLENBQUMsQ0FBQzs7R0FDbEMsTUFDSTtBQUNKLEtBQUUsQ0FBQyxJQUFJLEVBQUUsQ0FBQztHQUNWO0FBQ0QsTUFBSSxDQUFDLFdBQVcsR0FBRyxJQUFJLENBQUM7RUFDeEI7QUFFRCxVQUFTLHFCQUFDLEVBQUUsRUFBYTs7O01BQVgsSUFBSSx5REFBQyxJQUFJOztBQUN0QixNQUFJLEVBQUUsRUFBRSxJQUFJLElBQUksQ0FBQSxBQUFDLEVBQUUsRUFBRSxHQUFHLE1BQU0sR0FBQyxFQUFFLENBQUM7QUFDbEMsTUFBSSxJQUFJLENBQUMsV0FBVyxFQUFFOztBQUNyQixRQUFJLEVBQUUsR0FBRyxPQUFLLFdBQVcsQ0FBQztBQUMxQixRQUFJLEVBQUUsR0FBRyxPQUFLLFdBQVcsR0FBRyxPQUFLLEVBQUUsQ0FBQyxDQUFDO0FBQ3JDLFFBQUksSUFBSSxFQUFFO0FBQ1QsT0FBRSxDQUFDLElBQUksQ0FBQyxHQUFHLEVBQUUsR0FBRyxFQUFFLEdBQUcsQ0FBQyxDQUFDO0FBQ3ZCLE9BQUUsQ0FBQyxJQUFJLENBQUMsT0FBTyxFQUFFLFlBQU07QUFDdEIsUUFBRSxDQUFDLElBQUksRUFBRSxDQUFDO0FBQ1YsVUFBSSxFQUFFLEtBQUssT0FBSyxXQUFXLEVBQUU7QUFDNUIsU0FBRSxDQUFDLElBQUksRUFBRSxDQUFDO0FBQ1YsU0FBRSxDQUFDLElBQUksQ0FBQyxHQUFHLEVBQUUsR0FBRyxFQUFFLEdBQUcsQ0FBQyxDQUFDO09BQ3ZCO01BQ0QsQ0FBQyxDQUFDO0tBQ0gsTUFDSTtBQUNKLE9BQUUsQ0FBQyxJQUFJLEVBQUUsQ0FBQztBQUNWLE9BQUUsQ0FBQyxJQUFJLEVBQUUsQ0FBQztLQUNWOztHQUNELE1BQ0ksSUFBSSxFQUFFLElBQUksSUFBSSxFQUFFO0FBQ3BCLE9BQUksQ0FBQyxXQUFXLEdBQUcsSUFBSSxDQUFDLEVBQUUsQ0FBQyxDQUFDO0FBQzVCLE9BQUksQ0FBQyxXQUFXLENBQUMsSUFBSSxFQUFFLENBQUM7QUFDeEIsT0FBSSxJQUFJLEVBQUU7QUFDVCxRQUFJLENBQUMsV0FBVyxDQUFDLElBQUksQ0FBQyxHQUFHLEVBQUUsR0FBRyxFQUFFLEdBQUcsQ0FBQyxDQUFDO0lBQ3JDO0dBQ0Q7RUFDRDtBQUVELFdBQVUsc0JBQUMsSUFBSSxFQUFFO0FBQ2hCLE1BQUksSUFBSSxLQUFLLFFBQVEsRUFBRSxJQUFJLENBQUMsVUFBVSxFQUFFLENBQUMsS0FDcEMsSUFBSSxJQUFJLElBQUksSUFBSSxFQUFFO0FBQ3RCLE1BQUcsQ0FBQyxNQUFNLENBQUMsSUFBSSxDQUFDLElBQUksQ0FBQyxDQUFDLENBQUMsSUFBSSxFQUFFLENBQUM7R0FDOUIsTUFDSTtBQUNKLFVBQU8sQ0FBQyxJQUFJLENBQUMsWUFBWSxHQUFDLElBQUksQ0FBQyxDQUFDO0dBQ2hDO0VBQ0Q7QUFFRCxXQUFVLHdCQUFXO01BQVYsS0FBSyx5REFBQyxDQUFDLENBQUM7O0FBQ2xCLE1BQUksS0FBSyxHQUFHLENBQUMsRUFBRTtBQUNkLFFBQUssR0FBRyxHQUFHLENBQUMsSUFBSSxDQUFDLENBQUMsQ0FBQyxDQUFDO0dBQ3BCO0FBQ0QsTUFBSSxDQUFDLE9BQU8sQ0FBQyxJQUFJLENBQUMsUUFBUSxHQUFFLEtBQUssR0FBQyxDQUFDLEFBQUMsQ0FBQyxDQUFDO0VBQ3RDO0NBRUQsQ0FBQTs7QUFFRCxNQUFNLENBQUMsSUFBSSxHQUFHLE1BQU0sQ0FBQyxVQUFVLENBQUM7O0FBRWhDLE1BQU0sQ0FBQyxNQUFNLEdBQUcsTUFBTSxDQUFDOztBQUd2QixNQUFNLENBQUMsT0FBTyxHQUFHLE1BQU0sQ0FBQzs7O0FDL0d4QixZQUFZLENBQUM7Ozs7Ozs7O0FBQ2IsSUFBTSxRQUFRLEdBQUcsT0FBTyxDQUFDLFlBQVksQ0FBQyxDQUFDO0FBQ3ZDLElBQU0sTUFBTSxHQUFHLE9BQU8sQ0FBQyxhQUFhLENBQUMsQ0FBQztBQUN0QyxJQUFNLEtBQUssR0FBRyxPQUFPLENBQUMsU0FBUyxDQUFDLENBQUM7O2VBQ25CLE9BQU8sQ0FBQyxRQUFRLENBQUM7O0lBQXhCLEdBQUcsWUFBSCxHQUFHOztBQUNWLElBQU0sSUFBSSxHQUFHLE9BQU8sQ0FBQyxRQUFRLENBQUMsQ0FBQzs7SUFFekIsS0FBSztXQUFMLEtBQUs7O0FBQ1YsVUFESyxLQUFLLENBQ0UsSUFBSSxFQUFFLENBQUMsRUFBRSxDQUFDLEVBQUUsQ0FBQyxFQUFFO3dCQUR0QixLQUFLOzsrQ0FFVCxxQkFBTSxJQUFJLEVBQUUsQ0FBQyxFQUFFLENBQUMsRUFBRSxDQUFDLENBQUM7O0FBQ3BCLFFBQUssb0JBQW9CLEdBQUcsS0FBSyxDQUFDO0FBQ2xDLFFBQUssa0JBQWtCLEdBQUcsS0FBSyxDQUFDO0FBQ2hDLFFBQUssTUFBTSxHQUFHLEdBQUcsQ0FBQztBQUNsQixRQUFLLElBQUksR0FBRyxDQUFDLEVBQUUsQ0FBQTs7QUFFZixRQUFLLEtBQUssR0FBRyxHQUFHLENBQUMsWUFBWSxDQUFDLFVBQVUsRUFBRSxVQUFVLENBQUMsQ0FBQztBQUN0RCxRQUFLLE9BQU8sR0FBRyxHQUFHLENBQUM7O0VBQ25COztBQVZJLE1BQUssV0FZVixNQUFNLG1CQUFDLEVBQUUsRUFBRTtBQUNWLHNCQUFNLE1BQU0sS0FBQSxPQUFDLEVBQUUsQ0FBQyxDQUFDO0FBQ2pCLE1BQUksR0FBRyxDQUFDLFdBQVcsQ0FBQyxFQUFFLENBQUMsRUFBRTtBQUN4QixPQUFJLENBQUMsSUFBSSxDQUFDLFdBQVcsQ0FBQyxRQUFRLENBQUMsSUFBSSxDQUFDLEtBQUssQ0FBQyxJQUFJLENBQUMsR0FBRyxDQUFDLENBQUMsQ0FBQyxFQUFFLElBQUksQ0FBQyxLQUFLLENBQUMsSUFBSSxDQUFDLEdBQUcsQ0FBQyxDQUFDLENBQUMsRUFBRSxJQUFJLENBQUMsS0FBSyxDQUFDLENBQUM7R0FDM0Y7RUFDRDs7QUFqQkksTUFBSyxXQW1CVixpQkFBaUIsZ0NBQUc7QUFDbkIsTUFBSSxDQUFDLElBQUksQ0FBQyxXQUFXLENBQUMsUUFBUSxDQUFDLElBQUksQ0FBQyxLQUFLLENBQUMsSUFBSSxDQUFDLEdBQUcsQ0FBQyxDQUFDLENBQUMsRUFBRSxJQUFJLENBQUMsS0FBSyxDQUFDLElBQUksQ0FBQyxHQUFHLENBQUMsQ0FBQyxDQUFDLEVBQUUsSUFBSSxDQUFDLEtBQUssQ0FBQyxDQUFDO0VBQzNGOztRQXJCSSxLQUFLO0dBQVMsUUFBUTs7QUF1QjVCLE1BQU0sQ0FBQyxPQUFPLEdBQUcsS0FBSyxDQUFDOzs7QUM5QnZCLFlBQVksQ0FBQzs7Ozs7Ozs7ZUFFZSxPQUFPLENBQUMsVUFBVSxDQUFDOztJQUF4QyxLQUFLLFlBQUwsS0FBSztJQUFFLFVBQVUsWUFBVixVQUFVOztBQUN4QixJQUFNLE1BQU0sR0FBRyxPQUFPLENBQUMsVUFBVSxDQUFDLENBQUM7QUFDbkMsSUFBTSxLQUFLLEdBQUcsT0FBTyxDQUFDLFNBQVMsQ0FBQyxDQUFDO0FBQ2pDLElBQU0sT0FBTyxHQUFHLE9BQU8sQ0FBQyxXQUFXLENBQUMsQ0FBQztBQUNyQyxJQUFNLE1BQU0sR0FBRyxPQUFPLENBQUMsYUFBYSxDQUFDLENBQUM7QUFDdEMsSUFBTSxLQUFLLEdBQUcsT0FBTyxDQUFDLFNBQVMsQ0FBQyxDQUFDOztnQkFDbkIsT0FBTyxDQUFDLFFBQVEsQ0FBQzs7SUFBeEIsR0FBRyxhQUFILEdBQUc7O0FBQ1YsSUFBTSxJQUFJLEdBQUcsT0FBTyxDQUFDLFFBQVEsQ0FBQyxDQUFDO0FBQy9CLElBQU0sTUFBTSxHQUFHLE9BQU8sQ0FBQyxTQUFTLENBQUMsQ0FBQzs7SUFDNUIsTUFBTTtXQUFOLE1BQU07O0FBQ1gsVUFESyxNQUFNLENBQ0MsSUFBSSxFQUFFLE9BQU8sRUFBRSxFQUFFLEVBQUUsRUFBRSxFQUE4QjtNQUE1QixHQUFHLHlEQUFDLEdBQUcsQ0FBQyxJQUFJLENBQUMsQ0FBQyxDQUFDO01BQUUsS0FBSyx5REFBQyxHQUFHOzt3QkFEeEQsTUFBTTs7K0NBRVYsbUJBQU0sSUFBSSxFQUFFLE9BQU8sQ0FBQyxHQUFHLENBQUMsQ0FBQyxHQUFDLEVBQUUsR0FBQyxPQUFPLENBQUMsTUFBTSxFQUFFLE9BQU8sQ0FBQyxHQUFHLENBQUMsQ0FBQyxHQUFDLEVBQUUsR0FBQyxPQUFPLENBQUMsTUFBTSxDQUFDOztBQUM3RSxRQUFNLENBQUMsSUFBSSxDQUFDLE1BQU0sQ0FBQyxDQUFDO0FBQ3BCLFFBQUssR0FBRyxHQUFHLEdBQUcsQ0FBQztBQUNmLFFBQUssS0FBSyxHQUFHLEtBQUssQ0FBQztBQUNuQixRQUFLLE9BQU8sR0FBRyxPQUFPLENBQUM7QUFDdkIsUUFBSyxJQUFJLENBQUMsR0FBRyxDQUFDLENBQUMsRUFBRSxDQUFDLENBQUMsQ0FBQztBQUNwQixRQUFLLEdBQUcsQ0FBQyxDQUFDLEdBQUcsRUFBRSxHQUFDLE1BQUssS0FBSyxDQUFDO0FBQzNCLFFBQUssR0FBRyxDQUFDLENBQUMsR0FBRyxFQUFFLEdBQUMsTUFBSyxLQUFLLENBQUM7QUFDM0IsUUFBSyxJQUFJLEdBQUcsR0FBRyxDQUFDO0FBQ2hCLFFBQUssS0FBSyxHQUFHLElBQUksQ0FBQzs7RUFDbEI7O0FBWkksT0FBTSxXQWNYLE1BQU0sbUJBQUMsR0FBRyxFQUFFLE1BQU0sRUFBRSxJQUFJLEVBQUUsSUFBSSxFQUFFO0FBQy9CLE1BQUksRUFBRSxHQUFHLElBQUksQ0FBQyxLQUFLLENBQUMsSUFBSSxDQUFDLEdBQUcsQ0FBQyxDQUFDLEdBQUMsSUFBSSxDQUFDLENBQUM7QUFDckMsTUFBSSxFQUFFLEdBQUcsSUFBSSxDQUFDLEtBQUssQ0FBQyxJQUFJLENBQUMsR0FBRyxDQUFDLENBQUMsR0FBQyxJQUFJLENBQUMsQ0FBQztBQUNyQyxNQUFJLEVBQUUsR0FBRyxJQUFJLENBQUMsS0FBSyxDQUFDLElBQUksQ0FBQyxPQUFPLENBQUMsQ0FBQyxHQUFDLElBQUksQ0FBQyxDQUFDO0FBQ3pDLE1BQUksRUFBRSxHQUFHLElBQUksQ0FBQyxLQUFLLENBQUMsSUFBSSxDQUFDLE9BQU8sQ0FBQyxDQUFDLEdBQUMsSUFBSSxDQUFDLENBQUM7O0FBRXpDLE1BQUksRUFBRSxHQUFHLEVBQUUsR0FBQyxFQUFFO01BQUUsRUFBRSxHQUFHLEVBQUUsR0FBQyxFQUFFLENBQUM7QUFDM0IsTUFBSSxJQUFJLEdBQUcsSUFBSSxDQUFDLElBQUksQ0FBQyxJQUFJLENBQUMsSUFBSSxDQUFDLEVBQUUsR0FBQyxFQUFFLEdBQUMsRUFBRSxHQUFDLEVBQUUsQ0FBQyxDQUFDLENBQUM7QUFDN0MsT0FBSyxJQUFJLENBQUMsR0FBRyxDQUFDLEVBQUUsQ0FBQyxHQUFHLElBQUksRUFBRSxFQUFFLENBQUMsRUFBRTs7QUFFOUIsT0FBSSxFQUFFLEdBQUcsQUFBQyxDQUFDLEdBQUcsR0FBRyxHQUFHLElBQUksR0FBQyxFQUFFLEdBQUUsSUFBSSxDQUFDO0FBQ2xDLE9BQUksRUFBRSxHQUFHLEFBQUMsRUFBRSxHQUFHLEVBQUUsR0FBRyxDQUFDLEdBQUcsSUFBSSxHQUFFLENBQUMsQ0FBQztBQUNoQyxPQUFJLEVBQUUsR0FBRyxBQUFDLEVBQUUsR0FBRyxFQUFFLEdBQUcsQ0FBQyxHQUFHLElBQUksR0FBRSxDQUFDLENBQUM7QUFDaEMsT0FBSSxLQUFLLEdBQUcsVUFBVSxHQUFJLEVBQUUsR0FBRyxPQUFPLEFBQUMsQ0FBQztBQUN4QyxTQUFNLENBQUMsUUFBUSxDQUFDLEVBQUUsRUFBRSxFQUFFLEVBQUUsS0FBSyxDQUFDLENBQUM7R0FDL0I7RUFDRDs7QUE5QkksT0FBTSxXQWdDWCxXQUFXLHdCQUFDLEdBQUcsRUFBRTtBQUNoQixNQUFJLENBQUMsSUFBSSxDQUFDLE9BQU8sRUFBRSxPQUFPO0FBQzFCLE1BQUksR0FBRyxJQUFJLElBQUksSUFBSSxHQUFHLElBQUksSUFBSSxDQUFDLE9BQU8sRUFBRTtBQUN2QyxNQUFHLENBQUMsTUFBTSxDQUFDLElBQUksQ0FBQyxHQUFHLEVBQUUsSUFBSSxDQUFDLEdBQUcsRUFBRSxJQUFJLENBQUMsR0FBRyxDQUFDLENBQUM7QUFDekMsT0FBSSxDQUFDLE9BQU8sR0FBRyxLQUFLLENBQUM7R0FDckI7QUFDRCxNQUFJLEdBQUcsSUFBSSxJQUFJLENBQUMsT0FBTyxFQUFFLElBQUksQ0FBQyxPQUFPLEdBQUcsS0FBSyxDQUFDO0VBQzlDOztRQXZDSSxNQUFNO0dBQVMsTUFBTTs7QUEwQzNCLE1BQU0sQ0FBQyxPQUFPLEdBQUcsTUFBTSxDQUFDOzs7QUNyRHhCLFlBQVksQ0FBQzs7OztBQUNiLElBQU0sSUFBSSxHQUFHLE9BQU8sQ0FBQyxRQUFRLENBQUMsQ0FBQztBQUMvQixJQUFNLElBQUksR0FBRyxPQUFPLENBQUMsUUFBUSxDQUFDLENBQUM7QUFDL0IsSUFBTSxLQUFLLEdBQUcsT0FBTyxDQUFDLFNBQVMsQ0FBQyxDQUFDOztlQUNuQixPQUFPLENBQUMsUUFBUSxDQUFDOztJQUF4QixHQUFHLFlBQUgsR0FBRzs7Z0JBQ08sT0FBTyxDQUFDLFNBQVMsQ0FBQzs7SUFBNUIsTUFBTSxhQUFOLE1BQU07O0FBQ2IsSUFBTSxLQUFLLEdBQUcsT0FBTyxDQUFDLFNBQVMsQ0FBQyxDQUFDO0FBQ2pDLElBQU0sTUFBTSxHQUFHLE9BQU8sQ0FBQyxhQUFhLENBQUMsQ0FBQzs7SUFFaEMsTUFBTTtBQUNYLFVBREssTUFBTSxDQUNDLElBQUksRUFBRSxLQUFLLEVBQUUsTUFBTSxFQUFFLEtBQUssRUFBRSxNQUFNLEVBQUU7d0JBRDNDLE1BQU07O0FBRVYsTUFBSSxDQUFDLElBQUksR0FBRyxJQUFJLENBQUM7QUFDakIsTUFBSSxDQUFDLEtBQUssR0FBRyxLQUFLLENBQUM7QUFDbkIsTUFBSSxDQUFDLE1BQU0sR0FBRyxNQUFNOztBQUFDLEFBRXJCLE1BQUksQ0FBQyxLQUFLLEdBQUcsS0FBSyxDQUFDO0FBQ25CLE1BQUksQ0FBQyxNQUFNLEdBQUcsTUFBTSxDQUFDO0FBQ3JCLE1BQUksQ0FBQyxJQUFJLEdBQUcsSUFBSSxJQUFJLENBQUMsR0FBRyxFQUFFLEdBQUcsQ0FBQyxDQUFDO0FBQy9CLE1BQUksQ0FBQyxZQUFZLEdBQUcsSUFBSSxJQUFJLENBQUMsR0FBRyxFQUFFLEdBQUcsQ0FBQyxDQUFDO0FBQ3ZDLE1BQUksQ0FBQyxHQUFHLEdBQUcsSUFBSSxJQUFJLENBQUMsR0FBRyxFQUFFLEdBQUcsQ0FBQzs7OztBQUFDLEFBSTlCLE1BQUksQ0FBQyxXQUFXLEdBQUcsQ0FBQyxDQUFDO0FBQ3JCLE1BQUksQ0FBQyxLQUFLLEdBQUcsSUFBSSxJQUFJLENBQUMsR0FBRyxFQUFFLEdBQUcsQ0FBQyxDQUFDO0FBQ2hDLE1BQUksQ0FBQyxTQUFTLEdBQUcsR0FBRyxDQUFDO0FBQ3JCLE1BQUksQ0FBQyxRQUFRLEdBQUcsSUFBSSxJQUFJLENBQUMsR0FBRyxFQUFFLEdBQUcsQ0FBQyxDQUFDOztBQUVuQyxNQUFJLENBQUMsU0FBUyxHQUFHLEdBQUcsQ0FBQztBQUNyQixNQUFJLENBQUMsS0FBSyxHQUFHLEdBQUcsQ0FBQzs7QUFFakIsTUFBSSxDQUFDLElBQUksR0FBRyxDQUFDLENBQUM7QUFDZCxNQUFJLENBQUMsSUFBSSxHQUFHLEtBQUssQ0FBQztBQUNsQixNQUFJLENBQUMsSUFBSSxHQUFHLENBQUMsQ0FBQztBQUNkLE1BQUksQ0FBQyxJQUFJLEdBQUcsTUFBTSxDQUFDO0VBQ25COztBQTFCSSxPQUFNLFdBNEJYLE1BQU0scUJBQUc7QUFBRSxTQUFPLElBQUksQ0FBQyxJQUFJLENBQUMsS0FBSyxDQUFDO0VBQUU7O0FBNUIvQixPQUFNLFdBNkJYLE1BQU0scUJBQUc7QUFBRSxTQUFPLElBQUksQ0FBQyxJQUFJLENBQUMsTUFBTSxDQUFDO0VBQUU7O0FBN0JoQyxPQUFNLFdBK0JYLFdBQVcsd0JBQUMsRUFBRSxFQUFFLEVBQUUsRUFBRSxLQUFLLEVBQUU7QUFDMUIsTUFBSSxLQUFLLEVBQUU7O0FBRVYsT0FBSSxDQUFDLElBQUksQ0FBQyxHQUFHLENBQUMsRUFBRSxFQUFFLEVBQUUsQ0FBQyxDQUFDO0FBQ3RCLE9BQUksQ0FBQyxLQUFLLENBQUMsR0FBRyxDQUFDLENBQUMsRUFBRSxDQUFDLENBQUMsQ0FBQztHQUNyQjtBQUNELE1BQUksQ0FBQyxZQUFZLENBQUMsR0FBRyxDQUFDLEVBQUUsRUFBRSxFQUFFLENBQUMsQ0FBQTtBQUM3QixNQUFJLENBQUMsR0FBRyxDQUFDLENBQUMsR0FBRyxJQUFJLENBQUMsS0FBSyxDQUFDLEVBQUUsRUFBRSxJQUFJLENBQUMsS0FBSyxHQUFDLEdBQUcsRUFBRSxJQUFJLENBQUMsTUFBTSxFQUFFLEdBQUMsSUFBSSxDQUFDLEtBQUssR0FBQyxHQUFHLENBQUMsQ0FBQztBQUMxRSxNQUFJLENBQUMsR0FBRyxDQUFDLENBQUMsR0FBRyxJQUFJLENBQUMsS0FBSyxDQUFDLEVBQUUsRUFBRSxJQUFJLENBQUMsTUFBTSxHQUFDLEdBQUcsRUFBRSxJQUFJLENBQUMsTUFBTSxFQUFFLEdBQUMsSUFBSSxDQUFDLE1BQU0sR0FBQyxHQUFHLENBQUMsQ0FBQzs7QUFHNUUsTUFBSSxDQUFDLElBQUksR0FBRyxJQUFJLENBQUMsR0FBRyxDQUFDLENBQUMsR0FBQyxJQUFJLENBQUMsS0FBSyxHQUFDLEdBQUcsQ0FBQztBQUN0QyxNQUFJLENBQUMsSUFBSSxHQUFHLElBQUksQ0FBQyxHQUFHLENBQUMsQ0FBQyxHQUFDLElBQUksQ0FBQyxNQUFNLEdBQUMsR0FBRyxDQUFDOztBQUV2QyxNQUFJLENBQUMsSUFBSSxHQUFHLElBQUksQ0FBQyxJQUFJLEdBQUMsSUFBSSxDQUFDLEtBQUssQ0FBQztBQUNqQyxNQUFJLENBQUMsSUFBSSxHQUFHLElBQUksQ0FBQyxJQUFJLEdBQUMsSUFBSSxDQUFDLE1BQU0sQ0FBQzs7ZUFFRCxJQUFJLENBQUMsS0FBSzswQkFBdEMsR0FBRztNQUFJLEVBQUUsY0FBSixDQUFDO01BQU8sRUFBRSxjQUFKLENBQUM7TUFBTSxNQUFNLFVBQU4sTUFBTTs7OztBQUc3QixNQUFJLEVBQUUsR0FBRyxNQUFNLEdBQUcsSUFBSSxDQUFDLElBQUksRUFBRTtBQUM1QixPQUFJLENBQUMsSUFBSSxHQUFHLEVBQUUsR0FBQyxNQUFNLENBQUM7QUFDdEIsT0FBSSxDQUFDLEdBQUcsQ0FBQyxDQUFDLEdBQUcsSUFBSSxDQUFDLElBQUksR0FBRyxJQUFJLENBQUMsS0FBSyxHQUFDLEdBQUcsQ0FBQztBQUN4QyxPQUFJLENBQUMsSUFBSSxHQUFHLElBQUksQ0FBQyxJQUFJLEdBQUcsSUFBSSxDQUFDLEtBQUssQ0FBQztHQUNuQzs7QUFFRCxNQUFJLEVBQUUsR0FBRyxNQUFNLEdBQUcsSUFBSSxDQUFDLElBQUksRUFBRTtBQUM1QixPQUFJLENBQUMsSUFBSSxHQUFHLEVBQUUsR0FBQyxNQUFNLENBQUM7QUFDdEIsT0FBSSxDQUFDLEdBQUcsQ0FBQyxDQUFDLEdBQUcsSUFBSSxDQUFDLElBQUksR0FBRyxJQUFJLENBQUMsTUFBTSxHQUFDLEdBQUcsQ0FBQztBQUN6QyxPQUFJLENBQUMsSUFBSSxHQUFHLElBQUksQ0FBQyxJQUFJLEdBQUcsSUFBSSxDQUFDLE1BQU0sQ0FBQztHQUNwQzs7QUFFRCxNQUFJLEVBQUUsR0FBRyxNQUFNLEdBQUcsSUFBSSxDQUFDLElBQUksRUFBRTtBQUM1QixPQUFJLENBQUMsSUFBSSxHQUFHLEVBQUUsR0FBRyxNQUFNLENBQUM7QUFDeEIsT0FBSSxDQUFDLEdBQUcsQ0FBQyxDQUFDLEdBQUcsSUFBSSxDQUFDLElBQUksR0FBRyxJQUFJLENBQUMsS0FBSyxHQUFDLEdBQUcsQ0FBQztBQUN4QyxPQUFJLENBQUMsSUFBSSxHQUFHLElBQUksQ0FBQyxJQUFJLEdBQUcsSUFBSSxDQUFDLEtBQUssQ0FBQztHQUNuQzs7QUFFRCxNQUFJLEVBQUUsR0FBRyxNQUFNLEdBQUcsSUFBSSxDQUFDLElBQUksRUFBRTtBQUM1QixPQUFJLENBQUMsSUFBSSxHQUFHLEVBQUUsR0FBRyxNQUFNLENBQUM7QUFDeEIsT0FBSSxDQUFDLEdBQUcsQ0FBQyxDQUFDLEdBQUcsSUFBSSxDQUFDLElBQUksR0FBRyxJQUFJLENBQUMsTUFBTSxHQUFDLEdBQUcsQ0FBQztBQUN6QyxPQUFJLENBQUMsSUFBSSxHQUFHLElBQUksQ0FBQyxJQUFJLEdBQUcsSUFBSSxDQUFDLE1BQU0sQ0FBQztHQUNwQztBQUNELFFBQU0sQ0FBQyxDQUFDLElBQUksQ0FBQyxJQUFJLEtBQUssSUFBSSxDQUFDLElBQUksQ0FBQyxDQUFDO0FBQ2pDLFFBQU0sQ0FBQyxDQUFDLElBQUksQ0FBQyxJQUFJLEtBQUssSUFBSSxDQUFDLElBQUksQ0FBQyxDQUFDO0FBQ2pDLFFBQU0sQ0FBQyxDQUFDLElBQUksQ0FBQyxJQUFJLEtBQUssSUFBSSxDQUFDLElBQUksQ0FBQyxDQUFDO0FBQ2pDLFFBQU0sQ0FBQyxDQUFDLElBQUksQ0FBQyxJQUFJLEtBQUssSUFBSSxDQUFDLElBQUksQ0FBQyxDQUFDO0FBQ2pDLE1BQUksQ0FBQyxHQUFHLENBQUMsUUFBUSxFQUFFOztBQUFDLEFBRXBCLE1BQUksQ0FBQyxJQUFJLENBQUMsUUFBUSxFQUFFLENBQUM7QUFDckIsTUFBSSxDQUFDLE1BQU0sQ0FBQyxRQUFRLEVBQUUsQ0FBQztFQUN2Qjs7QUFsRkksT0FBTSxXQXFGWCxNQUFNLG1CQUFDLEVBQUUsRUFBRTtBQUNWLE1BQUksRUFBRSxHQUFHLElBQUksQ0FBQyxHQUFHLENBQUMsQ0FBQyxDQUFDO0FBQ3BCLE1BQUksRUFBRSxHQUFHLElBQUksQ0FBQyxHQUFHLENBQUMsQ0FBQyxDQUFDO0FBQ3BCLE1BQUksRUFBRSxHQUFHLElBQUksQ0FBQyxLQUFLLENBQUMsR0FBRyxDQUFDLENBQUMsQ0FBQztBQUMxQixNQUFJLEVBQUUsR0FBRyxJQUFJLENBQUMsS0FBSyxDQUFDLEdBQUcsQ0FBQyxDQUFDLENBQUM7O0FBRTFCLE1BQUksSUFBSSxDQUFDLEdBQUcsQ0FBQyxFQUFFLEdBQUcsRUFBRSxDQUFDLEdBQUcsR0FBRyxHQUFDLE1BQU0sQ0FBQyxLQUFLLEVBQUU7QUFDekMsS0FBRSxHQUFHLEVBQUUsQ0FBQztHQUNSO0FBQ0QsTUFBSSxJQUFJLENBQUMsR0FBRyxDQUFDLEVBQUUsR0FBRyxFQUFFLENBQUMsR0FBRyxHQUFHLEdBQUMsTUFBTSxDQUFDLEtBQUssRUFBRTtBQUN6QyxLQUFFLEdBQUcsRUFBRSxDQUFDO0dBQ1I7O0FBRUQsTUFBSSxHQUFHLEdBQUcsSUFBSSxDQUFDLEtBQUssQ0FBQyxHQUFHLENBQUMsQ0FBQyxHQUFDLEdBQUcsQ0FBQztBQUMvQixNQUFJLEdBQUcsR0FBRyxJQUFJLENBQUMsS0FBSyxDQUFDLEdBQUcsQ0FBQyxDQUFDLEdBQUMsR0FBRyxDQUFDOztBQUUvQixNQUFJLEVBQUUsR0FBRyxFQUFFLEdBQUcsR0FBRyxHQUFHLElBQUksQ0FBQyxTQUFTLENBQUM7QUFDbkMsTUFBSSxFQUFFLEdBQUcsRUFBRSxHQUFHLEdBQUcsR0FBRyxJQUFJLENBQUMsU0FBUyxDQUFDO0FBQ25DLE1BQUksTUFBTSxHQUFHLEtBQUssQ0FBQztBQUNuQixNQUFJLE1BQU0sR0FBRyxDQUFDLENBQUM7O0FBRWYsTUFBSSxLQUFLLENBQUMsS0FBSyxDQUFDLE1BQU0sRUFBRTs7QUFFdkIsU0FBTSxHQUFHLENBQUMsQ0FBQztHQUNYOztBQUVELE1BQUksS0FBSyxDQUFDLFFBQVEsQ0FBQyxNQUFNLENBQUMsT0FBTyxDQUFDLEVBQUU7O0FBRW5DLFNBQU0sR0FBRyxDQUFDLENBQUM7R0FDWDs7QUFFRCxNQUFJLE1BQU0sRUFBRTtBQUNYLE9BQUksR0FBRyxHQUFHLElBQUksQ0FBQyxJQUFJLENBQUMsS0FBSyxDQUFDLENBQUMsQ0FBQztBQUM1QixPQUFJLEdBQUcsR0FBRyxJQUFJLENBQUMsSUFBSSxDQUFDLEtBQUssQ0FBQyxDQUFDLENBQUM7O0FBRTVCLE9BQUksR0FBRyxHQUFHLEdBQUcsR0FBRyxJQUFJLENBQUMsS0FBSyxDQUFDLEdBQUcsQ0FBQyxDQUFDLENBQUM7QUFDakMsT0FBSSxHQUFHLEdBQUcsR0FBRyxHQUFHLElBQUksQ0FBQyxLQUFLLENBQUMsR0FBRyxDQUFDLENBQUMsQ0FBQztBQUNqQyxLQUFFLElBQUksR0FBRyxHQUFHLE1BQU0sQ0FBQztBQUNuQixLQUFFLElBQUksR0FBRyxHQUFHLE1BQU0sQ0FBQztHQUNuQjs7QUFFRCxJQUFFLEdBQUcsSUFBSSxDQUFDLEtBQUssQ0FBQyxFQUFFLEVBQUUsSUFBSSxDQUFDLEtBQUssR0FBQyxDQUFDLEVBQUUsSUFBSSxDQUFDLE1BQU0sRUFBRSxHQUFDLElBQUksQ0FBQyxLQUFLLEdBQUMsQ0FBQyxDQUFDLENBQUM7QUFDOUQsSUFBRSxHQUFHLElBQUksQ0FBQyxLQUFLLENBQUMsRUFBRSxFQUFFLElBQUksQ0FBQyxNQUFNLEdBQUMsQ0FBQyxFQUFFLElBQUksQ0FBQyxNQUFNLEVBQUUsR0FBQyxJQUFJLENBQUMsTUFBTSxHQUFDLENBQUMsQ0FBQyxDQUFDOztBQUVoRSxNQUFJLEVBQUUsR0FBRyxFQUFFLEdBQUcsRUFBRSxDQUFDO0FBQ2pCLE1BQUksRUFBRSxHQUFHLEVBQUUsR0FBRyxFQUFFLENBQUM7O0FBRWpCLE1BQUksS0FBSyxHQUFHLEdBQUcsR0FBRyxJQUFJLENBQUMsR0FBRyxDQUFDLENBQUMsSUFBSSxDQUFDLEtBQUssR0FBQyxFQUFFLENBQUMsQ0FBQzs7QUFFM0MsSUFBRSxHQUFHLElBQUksQ0FBQyxHQUFHLENBQUMsQ0FBQyxHQUFHLEVBQUUsR0FBQyxLQUFLLENBQUM7QUFDM0IsSUFBRSxHQUFHLElBQUksQ0FBQyxHQUFHLENBQUMsQ0FBQyxHQUFHLEVBQUUsR0FBQyxLQUFLLENBQUM7O0FBRTNCLE1BQUksQ0FBQyxXQUFXLENBQUMsRUFBRSxFQUFFLEVBQUUsQ0FBQzs7Ozs7Ozs7Ozs7QUFBQyxFQWN6Qjs7UUF2SkksTUFBTTs7O0FBNEpaLE1BQU0sQ0FBQyxPQUFPLEdBQUcsTUFBTSxDQUFDOzs7QUNyS3hCLFlBQVksQ0FBQzs7QUFDYixJQUFNLEtBQUssR0FBRyxFQUFFLENBQUM7O0FBRWpCLEtBQUssQ0FBQyxHQUFHLEdBQUcsTUFBTSxDQUFDLFdBQVcsR0FBRyxZQUFXO0FBQUUsU0FBTyxXQUFXLENBQUMsR0FBRyxFQUFFLENBQUM7Q0FBRSxHQUFHLElBQUksQ0FBQyxHQUFHLENBQUM7O0FBRXJGLEtBQUssQ0FBQyxLQUFLLEdBQUcsQ0FBQyxDQUFDO0FBQ2hCLEtBQUssQ0FBQyxHQUFHLEdBQUcsSUFBSSxDQUFDO0FBQ2pCLEtBQUssQ0FBQyxJQUFJLEdBQUcsR0FBRyxDQUFDO0FBQ2pCLEtBQUssQ0FBQyxRQUFRLEdBQUcsR0FBRyxDQUFDO0FBQ3JCLEtBQUssQ0FBQyxTQUFTLEdBQUcsR0FBRyxDQUFDO0FBQ3RCLEtBQUssQ0FBQyxTQUFTLEdBQUcsR0FBRyxHQUFHLEtBQUssQ0FBQyxHQUFHLENBQUM7QUFDbEMsS0FBSyxDQUFDLGFBQWEsR0FBRyxLQUFLLENBQUMsU0FBUyxDQUFDOztBQUV0QyxLQUFLLENBQUMsU0FBUyxHQUFHLEdBQUc7OztBQUFDLEFBR3RCLE1BQU0sQ0FBQyxLQUFLLEdBQUcsS0FBSyxDQUFDOztBQUVyQixNQUFNLENBQUMsT0FBTyxHQUFHLEtBQUssQ0FBQzs7O0FDbEJ2QixZQUFZLENBQUM7Ozs7ZUFDSSxPQUFPLENBQUMsU0FBUyxDQUFDOztJQUE1QixNQUFNLFlBQU4sTUFBTTs7QUFFYixJQUFJLFlBQVksR0FBRyxFQUFFLENBQUM7O0lBQ2hCLGFBQWE7QUFDbEIsVUFESyxhQUFhLENBQ04sS0FBSyxFQUFFLE1BQU0sRUFBRSxRQUFRLEVBQUU7d0JBRGhDLGFBQWE7O0FBRWpCLE1BQUksQ0FBQyxLQUFLLEdBQUcsSUFBSSxDQUFDLElBQUksQ0FBQyxLQUFLLEdBQUMsUUFBUSxDQUFDLENBQUM7QUFDdkMsTUFBSSxDQUFDLE1BQU0sR0FBRyxJQUFJLENBQUMsSUFBSSxDQUFDLE1BQU0sR0FBQyxRQUFRLENBQUMsQ0FBQztBQUN6QyxNQUFJLENBQUMsUUFBUSxHQUFHLFFBQVEsQ0FBQztBQUN6QixNQUFJLENBQUMsS0FBSyxHQUFHLElBQUksS0FBSyxDQUFDLElBQUksQ0FBQyxLQUFLLEdBQUMsSUFBSSxDQUFDLE1BQU0sQ0FBQyxDQUFDO0FBQy9DLE9BQUssSUFBSSxDQUFDLEdBQUcsQ0FBQyxFQUFFLENBQUMsR0FBRyxJQUFJLENBQUMsS0FBSyxHQUFDLElBQUksQ0FBQyxNQUFNLEVBQUUsRUFBRSxDQUFDLEVBQUU7QUFDaEQsT0FBSSxDQUFDLEtBQUssQ0FBQyxDQUFDLENBQUMsR0FBRyxFQUFFLENBQUM7R0FDbkI7RUFDRDs7QUFUSSxjQUFhLFdBV2xCLEdBQUcsZ0JBQUMsQ0FBQyxFQUFFO0FBQ04sUUFBTSxDQUFDLENBQUMsQ0FBQyxHQUFHLENBQUMsQ0FBQyxJQUFJLENBQUMsSUFBSSxDQUFDLENBQUMsR0FBRyxDQUFDLENBQUMsR0FBRyxJQUFJLENBQUMsS0FBSyxHQUFDLElBQUksQ0FBQyxRQUFRLENBQUMsQ0FBQztBQUMzRCxRQUFNLENBQUMsQ0FBQyxDQUFDLEdBQUcsQ0FBQyxDQUFDLElBQUksQ0FBQyxJQUFJLENBQUMsQ0FBQyxHQUFHLENBQUMsQ0FBQyxHQUFHLElBQUksQ0FBQyxNQUFNLEdBQUMsSUFBSSxDQUFDLFFBQVEsQ0FBQyxDQUFDO0FBQzVELFFBQU0sQ0FBQyxDQUFDLENBQUMsS0FBSyxLQUFLLENBQUMsQ0FBQyxDQUFDLENBQUM7QUFDdkIsTUFBTSxLQUFLLEdBQUcsSUFBSSxDQUFDLEtBQUssQ0FBQyxDQUFDLENBQUMsR0FBRyxDQUFDLENBQUMsR0FBRyxJQUFJLENBQUMsUUFBUSxDQUFDLENBQUM7QUFDbEQsTUFBTSxLQUFLLEdBQUcsSUFBSSxDQUFDLEtBQUssQ0FBQyxDQUFDLENBQUMsR0FBRyxDQUFDLENBQUMsR0FBRyxJQUFJLENBQUMsUUFBUSxDQUFDLENBQUM7O0FBRWxELE1BQU0sU0FBUyxHQUFHLEtBQUssR0FBRyxLQUFLLEdBQUMsSUFBSSxDQUFDLEtBQUssQ0FBQztBQUMzQyxNQUFNLE9BQU8sR0FBRyxJQUFJLENBQUMsS0FBSyxDQUFDLFNBQVMsQ0FBQyxDQUFDO0FBQ3RDLEdBQUMsQ0FBQyxLQUFLLEdBQUcsU0FBUyxDQUFDO0FBQ3BCLEdBQUMsQ0FBQyxZQUFZLEdBQUcsT0FBTyxDQUFDLE1BQU0sQ0FBQztBQUNoQyxTQUFPLENBQUMsSUFBSSxDQUFDLENBQUMsQ0FBQyxDQUFDO0VBQ2hCOztBQXZCSSxjQUFhLFdBeUJsQixNQUFNLG1CQUFDLENBQUMsRUFBRTtBQUNULFFBQU0sQ0FBQyxDQUFDLENBQUMsS0FBSyxLQUFLLENBQUMsQ0FBQyxDQUFDLENBQUM7QUFDdkIsUUFBTSxDQUFDLENBQUMsQ0FBQyxZQUFZLEtBQUssQ0FBQyxDQUFDLENBQUMsQ0FBQztBQUM5QixNQUFNLElBQUksR0FBRyxJQUFJLENBQUMsS0FBSyxDQUFDLENBQUMsQ0FBQyxLQUFLLENBQUMsQ0FBQztBQUNqQyxRQUFNLENBQUMsSUFBSSxDQUFDLENBQUMsQ0FBQyxZQUFZLENBQUMsS0FBSyxDQUFDLENBQUMsQ0FBQztBQUNuQyxNQUFNLFdBQVcsR0FBRyxDQUFDLENBQUMsWUFBWSxDQUFDOztBQUVuQyxNQUFJLENBQUMsV0FBVyxDQUFDLEdBQUcsSUFBSSxDQUFDLElBQUksQ0FBQyxNQUFNLEdBQUMsQ0FBQyxDQUFDLENBQUM7QUFDeEMsTUFBSSxDQUFDLFdBQVcsQ0FBQyxDQUFDLFlBQVksR0FBRyxXQUFXLENBQUM7QUFDN0MsTUFBSSxDQUFDLEdBQUcsRUFBRSxDQUFDO0FBQ1gsR0FBQyxDQUFDLEtBQUssR0FBRyxDQUFDLENBQUMsQ0FBQztBQUNiLEdBQUMsQ0FBQyxZQUFZLEdBQUcsQ0FBQyxDQUFDLENBQUM7RUFDcEI7O0FBckNJLGNBQWEsV0F1Q2xCLE1BQU0sbUJBQUMsQ0FBQyxFQUFFO0FBQ1QsTUFBSSxDQUFDLE1BQU0sQ0FBQyxDQUFDLENBQUMsQ0FBQztBQUNmLE1BQUksQ0FBQyxHQUFHLENBQUMsQ0FBQyxDQUFDLENBQUM7RUFDWjs7QUExQ0ksY0FBYSxXQTRDbEIsY0FBYywyQkFBQyxDQUFDLEVBQUU7QUFDakIsTUFBSSxNQUFNLEdBQUcsWUFBWSxDQUFDOztNQUVuQixLQUFLLEdBQW1CLElBQUksQ0FBNUIsS0FBSztNQUFFLEtBQUssR0FBWSxJQUFJLENBQXJCLEtBQUs7TUFBRSxNQUFNLEdBQUksSUFBSSxDQUFkLE1BQU07O0FBRTNCLE1BQU0sS0FBSyxHQUFHLElBQUksQ0FBQyxLQUFLLENBQUMsQ0FBQyxDQUFDLEtBQUssR0FBRyxLQUFLLENBQUMsQ0FBQztBQUMxQyxNQUFNLEtBQUssR0FBRyxDQUFDLENBQUMsS0FBSyxHQUFHLEtBQUssQ0FBQzs7QUFFOUIsTUFBTSxJQUFJLEdBQUcsSUFBSSxDQUFDLEdBQUcsQ0FBQyxDQUFDLEVBQUUsS0FBSyxHQUFDLENBQUMsQ0FBQyxDQUFDO0FBQ2xDLE1BQU0sSUFBSSxHQUFHLElBQUksQ0FBQyxHQUFHLENBQUMsS0FBSyxHQUFDLENBQUMsRUFBRSxLQUFLLEdBQUMsQ0FBQyxDQUFDLENBQUM7O0FBRXhDLE1BQU0sSUFBSSxHQUFHLElBQUksQ0FBQyxHQUFHLENBQUMsQ0FBQyxFQUFFLEtBQUssR0FBQyxDQUFDLENBQUMsQ0FBQztBQUNsQyxNQUFNLElBQUksR0FBRyxJQUFJLENBQUMsR0FBRyxDQUFDLEtBQUssR0FBQyxDQUFDLEVBQUUsTUFBTSxHQUFDLENBQUMsQ0FBQyxDQUFDOztBQUV6QyxPQUFLLElBQUksQ0FBQyxHQUFHLElBQUksRUFBRSxDQUFDLElBQUksSUFBSSxFQUFFLEVBQUUsQ0FBQyxFQUFFO0FBQ2xDLFFBQUssSUFBSSxDQUFDLEdBQUcsSUFBSSxFQUFFLENBQUMsSUFBSSxJQUFJLEVBQUUsRUFBRSxDQUFDLEVBQUU7QUFDbEMsUUFBTSxTQUFTLEdBQUcsQ0FBQyxHQUFHLENBQUMsR0FBRyxLQUFLLENBQUM7QUFDaEMsUUFBTSxJQUFJLEdBQUcsS0FBSyxDQUFDLFNBQVMsQ0FBQyxDQUFDO0FBQzlCLFNBQUssSUFBSSxDQUFDLEdBQUcsQ0FBQyxFQUFFLENBQUMsR0FBRyxJQUFJLENBQUMsTUFBTSxFQUFFLENBQUMsR0FBRyxDQUFDLEVBQUUsRUFBRSxDQUFDLEVBQUU7QUFDNUMsV0FBTSxDQUFDLElBQUksQ0FBQyxJQUFJLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQztLQUNyQjtJQUNEO0dBQ0Q7QUFDRCxTQUFPLE1BQU0sQ0FBQztFQUNkOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7UUFwRUksYUFBYTs7O0FBZ0duQixNQUFNLENBQUMsT0FBTyxHQUFHLGFBQWEsQ0FBQzs7O0FDcEcvQixZQUFZLENBQUM7O0FBRWIsSUFBTSxHQUFHLEdBQUcsT0FBTyxDQUFDLEdBQUcsR0FBRyxJQUFJLENBQUM7QUFDL0IsSUFBTSxLQUFLLEdBQUcsT0FBTyxDQUFDLEtBQUssR0FBRyxDQUFDLENBQUM7O0FBRWhDLElBQU0saUJBQWlCLEdBQUcsT0FBTyxDQUFDLGlCQUFpQixHQUFHLEdBQUcsQ0FBQztBQUMxRCxJQUFNLGtCQUFrQixHQUFHLE9BQU8sQ0FBQyxrQkFBa0IsR0FBRyxHQUFHLENBQUM7O0FBRTVELElBQU0sWUFBWSxHQUFHLE9BQU8sQ0FBQyxZQUFZLEdBQUcsQUFBQyxrQkFBa0IsR0FBQyxLQUFLLEtBQUksQ0FBQyxDQUFDO0FBQzNFLElBQU0sV0FBVyxHQUFHLE9BQU8sQ0FBQyxXQUFXLEdBQUcsQUFBQyxpQkFBaUIsR0FBQyxLQUFLLEtBQUksQ0FBQyxDQUFDOztBQUV4RSxJQUFNLFlBQVksR0FBRyxPQUFPLENBQUMsWUFBWSxHQUFJLE1BQU0sQ0FBQyxnQkFBZ0IsSUFBSSxNQUFNLENBQUMsc0JBQXNCLElBQUksR0FBRyxBQUFDLENBQUM7O0FBRTlHLElBQU0sUUFBUSxHQUFHLE9BQU8sQ0FBQyxRQUFRLEdBQUcsRUFBRSxDQUFDOzs7QUNidkMsWUFBWSxDQUFDOztBQUViLElBQU0sS0FBSyxHQUFHLEtBQUssQ0FBQzs7QUFHcEIsTUFBTSxDQUFDLEtBQUssR0FBRyxLQUFLLENBQUM7O0FBR3JCLFNBQVMsTUFBTSxDQUFDLEdBQUcsRUFBRSxHQUFHLEVBQUU7QUFDekIsS0FBSSxHQUFHLEVBQUUsT0FBTztBQUNoQixRQUFPLENBQUMsS0FBSyxDQUFDLHNCQUFzQixJQUFFLEdBQUcsSUFBRSxZQUFZLENBQUEsQUFBQyxDQUFDLENBQUM7QUFDMUQsT0FBTSxJQUFJLEtBQUssQ0FBQyxxQkFBcUIsQ0FBQyxDQUFDO0NBQ3ZDOztBQUVELElBQUksTUFBTSxDQUFDLEtBQUssRUFBRTtBQUNqQixPQUFNLENBQUMsTUFBTSxHQUFHLE9BQU8sQ0FBQyxNQUFNLEdBQUcsTUFBTSxDQUFDO0NBQ3hDLE1BQ0k7QUFDSixPQUFNLENBQUMsTUFBTSxHQUFHLE9BQU8sQ0FBQyxNQUFNLEdBQUcsWUFBVyxFQUFFLENBQUM7Q0FDL0M7O0FBR0QsT0FBTyxDQUFDLEtBQUssR0FBRyxLQUFLLENBQUM7OztBQ3RCdEIsWUFBWSxDQUFDOztBQUdiLE9BQU8sQ0FBQyxjQUFjLEdBQUcsY0FBYyxDQUFDO0FBQ3hDLFNBQVMsY0FBYyxDQUFDLE9BQU8sRUFBRSxNQUFNLEVBQUU7QUFDeEMsUUFBTyxDQUFDLFNBQVMsQ0FBQyxNQUFNLEVBQ3ZCLENBQUMsRUFBRSxDQUFDLEVBQUUsTUFBTSxDQUFDLEtBQUssRUFBRSxNQUFNLENBQUMsTUFBTSxFQUNqQyxDQUFDLEVBQUUsQ0FBQyxFQUFFLE9BQU8sQ0FBQyxNQUFNLENBQUMsS0FBSyxFQUFFLE9BQU8sQ0FBQyxNQUFNLENBQUMsTUFBTSxDQUFDLENBQUM7Q0FDcEQ7OztBQUFBLEFBR0QsT0FBTyxDQUFDLFFBQVEsR0FBRyxRQUFRLENBQUM7QUFDNUIsU0FBUyxRQUFRLENBQUMsR0FBRyxFQUFFLEVBQUUsRUFBRSxFQUFFLEVBQUUsRUFBRSxFQUFFLEVBQUUsRUFBa0M7a0VBQUosRUFBRTs7MkJBQTdCLFNBQVM7S0FBVCxTQUFTLGtDQUFDLEtBQUs7dUJBQUUsS0FBSztLQUFMLEtBQUssOEJBQUMsRUFBRTs7QUFDaEUsS0FBSSxjQUFjLEdBQUcsR0FBRyxDQUFDLFdBQVcsQ0FBQztBQUNyQyxLQUFJLEtBQUssRUFBRSxHQUFHLENBQUMsV0FBVyxHQUFHLEtBQUssQ0FBQztBQUNuQyxJQUFHLENBQUMsU0FBUyxFQUFFLENBQUM7QUFDaEIsSUFBRyxDQUFDLE1BQU0sQ0FBQyxFQUFFLEVBQUUsRUFBRSxDQUFDLENBQUM7QUFDbkIsSUFBRyxDQUFDLE1BQU0sQ0FBQyxFQUFFLEVBQUUsRUFBRSxDQUFDLENBQUM7QUFDbkIsSUFBRyxDQUFDLE1BQU0sRUFBRSxDQUFDO0FBQ2IsS0FBSSxTQUFTLEVBQUU7QUFDZCxTQUFPLENBQUMsR0FBRyxFQUFFLEVBQUUsRUFBRSxFQUFFLENBQUMsQ0FBQztBQUNyQixTQUFPLENBQUMsR0FBRyxFQUFFLEVBQUUsRUFBRSxFQUFFLENBQUMsQ0FBQztFQUNyQjtBQUNELEtBQUksS0FBSyxFQUFFLEdBQUcsQ0FBQyxXQUFXLEdBQUcsY0FBYyxDQUFDO0NBQzVDOztBQUVELE9BQU8sQ0FBQyxPQUFPLEdBQUcsT0FBTyxDQUFDO0FBQzFCLFNBQVMsT0FBTyxDQUFDLEdBQUcsRUFBRSxDQUFDLEVBQUUsQ0FBQyxFQUFRO0tBQU4sRUFBRSx5REFBQyxDQUFDOztBQUMvQixLQUFJLEVBQUUsR0FBRyxFQUFFLEdBQUMsQ0FBQyxDQUFBO0FBQ2IsSUFBRyxDQUFDLFVBQVUsQ0FBQyxDQUFDLEdBQUMsRUFBRSxFQUFFLENBQUMsR0FBQyxFQUFFLEVBQUUsRUFBRSxFQUFFLEVBQUUsQ0FBQyxDQUFDO0NBQ25DOztBQUVELE9BQU8sQ0FBQyxTQUFTLEdBQUcsU0FBUyxDQUFDO0FBQzlCLFNBQVMsU0FBUyxDQUFDLEdBQUcsRUFBRSxFQUFFLEVBQUUsRUFBRSxFQUFFLEVBQUUsRUFBRSxFQUFFLEVBQUUsQ0FBQyxFQUFFO0FBQzFDLFNBQVEsQ0FBQyxHQUFHLEVBQUUsRUFBRSxFQUFFLEVBQUUsRUFBRSxFQUFFLEVBQUUsRUFBRSxDQUFDLENBQUM7QUFDOUIsS0FBSSxFQUFFLEdBQUcsRUFBRSxHQUFDLEVBQUU7S0FBRSxFQUFFLEdBQUcsRUFBRSxHQUFDLEVBQUUsQ0FBQztBQUMzQixLQUFJLENBQUMsR0FBRyxJQUFJLENBQUMsSUFBSSxDQUFDLEVBQUUsR0FBQyxFQUFFLEdBQUMsRUFBRSxHQUFDLEVBQUUsQ0FBQyxDQUFDO0FBQy9CLEtBQUksQ0FBQyxLQUFLLEdBQUcsRUFBRTtBQUNkLElBQUUsSUFBSSxDQUFDLENBQUM7QUFDUixJQUFFLElBQUksQ0FBQyxDQUFDO0FBQ1IsVUFBUSxDQUFDLEdBQUcsRUFBRSxFQUFFLEVBQUUsRUFBRSxFQUFFLEVBQUUsR0FBQyxDQUFDLEdBQUMsRUFBRSxHQUFDLENBQUMsR0FBQyxFQUFFLEVBQUUsRUFBRSxHQUFDLENBQUMsR0FBQyxFQUFFLEdBQUMsQ0FBQyxHQUFDLEVBQUUsQ0FBQyxDQUFDO0VBQ2xEO0NBQ0Q7O0FBRUQsT0FBTyxDQUFDLFVBQVUsR0FBRyxVQUFVLENBQUM7QUFDaEMsU0FBUyxVQUFVLENBQUMsR0FBRyxFQUFFLEVBQUUsRUFBRSxFQUFFLEVBQUUsQ0FBQyxFQUFFO0FBQ25DLElBQUcsQ0FBQyxTQUFTLEVBQUUsQ0FBQztBQUNoQixJQUFHLENBQUMsTUFBTSxDQUFDLEVBQUUsRUFBRSxFQUFFLENBQUMsQ0FBQztBQUNuQixJQUFHLENBQUMsR0FBRyxDQUFDLEVBQUUsRUFBRSxFQUFFLEVBQUUsQ0FBQyxFQUFFLENBQUMsRUFBRSxJQUFJLENBQUMsRUFBRSxHQUFDLENBQUMsQ0FBQyxDQUFDO0FBQ2pDLElBQUcsQ0FBQyxNQUFNLEVBQUUsQ0FBQztDQUNiOzs7QUNsREQsWUFBWSxDQUFDOzs7Ozs7OztBQUNiLElBQU0sTUFBTSxHQUFHLE9BQU8sQ0FBQyxVQUFVLENBQUMsQ0FBQztBQUNuQyxJQUFNLEtBQUssR0FBRyxPQUFPLENBQUMsU0FBUyxDQUFDLENBQUM7O2VBQ25CLE9BQU8sQ0FBQyxRQUFRLENBQUM7O0lBQXhCLEdBQUcsWUFBSCxHQUFHOztBQUNWLElBQU0sT0FBTyxHQUFHLE9BQU8sQ0FBQyxXQUFXLENBQUMsQ0FBQztBQUNyQyxJQUFNLE1BQU0sR0FBRyxPQUFPLENBQUMsYUFBYSxDQUFDLENBQUM7QUFDdEMsSUFBTSxLQUFLLEdBQUcsT0FBTyxDQUFDLFNBQVMsQ0FBQyxDQUFDO0FBQ2pDLElBQU0sTUFBTSxHQUFHLE9BQU8sQ0FBQyxVQUFVLENBQUMsQ0FBQztBQUNuQyxJQUFNLElBQUksR0FBRyxPQUFPLENBQUMsUUFBUSxDQUFDLENBQUM7QUFDL0IsSUFBTSxLQUFLLEdBQUcsT0FBTyxDQUFDLFNBQVMsQ0FBQyxDQUFDO0FBQ2pDLElBQU0sTUFBTSxHQUFHLE9BQU8sQ0FBQyxTQUFTLENBQUMsQ0FBQztBQUNsQyxJQUFNLElBQUksR0FBRyxPQUFPLENBQUMsUUFBUSxDQUFDLENBQUM7QUFDL0IsSUFBTSxJQUFJLEdBQUcsT0FBTyxDQUFDLFFBQVEsQ0FBQyxDQUFDO0FBQy9CLElBQU0sS0FBSyxHQUFHO0FBQ2IsT0FBTSxFQUFFLENBQUM7QUFDVCxPQUFNLEVBQUUsQ0FBQztBQUNULE9BQU0sRUFBRSxDQUFDO0FBQ1QsS0FBSSxFQUFFLENBQUM7Q0FDUCxDQUFBOztJQUVLLEtBQUs7V0FBTCxLQUFLOztBQUNWLFVBREssS0FBSyxDQUNFLElBQUksRUFBRSxDQUFDLEVBQUUsQ0FBQyxFQUFFO3dCQURuQixLQUFLOzsrQ0FFVCxtQkFBTSxJQUFJLEVBQUUsQ0FBQyxFQUFFLENBQUMsQ0FBQzs7QUFDakIsUUFBSyxNQUFNLEdBQUcsR0FBRyxDQUFDO0FBQ2xCLFFBQUssY0FBYyxHQUFHLElBQUksQ0FBQztBQUMzQixRQUFLLEtBQUssR0FBRyxFQUFFLEdBQUMsRUFBRSxDQUFDO0FBQ25CLFFBQUssSUFBSSxDQUFDLEdBQUcsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxDQUFDLENBQUM7QUFDcEIsUUFBSyxPQUFPLEdBQUcsS0FBSyxDQUFDO0FBQ3JCLFFBQUssWUFBWSxHQUFHLEdBQUcsQ0FBQztBQUN4QixRQUFLLFNBQVMsR0FBRyxFQUFFLENBQUM7QUFDcEIsUUFBSyxNQUFNLEdBQUcsTUFBSyxTQUFTLENBQUM7QUFDN0IsUUFBSyxXQUFXLEdBQUcsSUFBSSxDQUFDO0FBQ3hCLFFBQUssU0FBUyxHQUFHLElBQUksSUFBSSxFQUFFLENBQUM7QUFDNUIsUUFBSyxVQUFVLEdBQUcsS0FBSyxDQUFDO0FBQ3hCLFFBQUssYUFBYSxHQUFHLElBQUksSUFBSSxFQUFFLENBQUM7QUFDaEMsUUFBSyxLQUFLLEdBQUcsS0FBSyxDQUFDLE1BQU0sQ0FBQztBQUMxQixRQUFLLFNBQVMsR0FBRyxHQUFHLENBQUM7QUFDckIsUUFBSyxVQUFVLEdBQUcsR0FBRyxDQUFDO0FBQ3RCLFFBQUssSUFBSSxHQUFHLEdBQUcsQ0FBQyxJQUFJLENBQUMsTUFBSyxJQUFJLENBQUMsTUFBTSxDQUFDLGNBQWMsQ0FBQyxNQUFNLENBQUMsQ0FBQzs7RUFDN0Q7O0FBbkJJLE1BQUssV0FxQlYsZ0JBQWdCLCtCQUFHO0FBQ2xCLE1BQUksQ0FBQyxHQUFHLElBQUksQ0FBQyxJQUFJLEVBQUU7TUFBRSxDQUFDLEdBQUcsSUFBSSxDQUFDLElBQUksRUFBRSxDQUFDO0FBQ3JDLE9BQUssSUFBSSxDQUFDLEdBQUcsQ0FBQyxFQUFFLENBQUMsR0FBRyxDQUFDLEVBQUUsRUFBRSxDQUFDLEVBQUU7QUFDM0IsT0FBSSxDQUFDLEdBQUcsSUFBSSxDQUFDLElBQUksQ0FBQyxHQUFHLENBQUMsUUFBUSxDQUFDLENBQUMsQ0FBQyxFQUFFLENBQUMsQ0FBQyxFQUFFLEdBQUcsQ0FBQyxRQUFRLENBQUMsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxDQUFDLENBQUMsQ0FBQyxTQUFTLEVBQUUsQ0FBQztBQUN4RSxPQUFJLENBQUMsR0FBRyxJQUFJLENBQUMsSUFBSSxDQUFDLE9BQU8sQ0FBQyxJQUFJLENBQUMsU0FBUyxFQUFFLENBQUMsRUFBRSxJQUFJLENBQUMsR0FBRyxFQUFFLENBQUMsRUFBRSxJQUFJLENBQUMsQ0FBQztBQUNoRSxPQUFJLENBQUMsR0FBRyxFQUFFLElBQUksR0FBRyxDQUFDLFdBQVcsQ0FBQyxFQUFFLENBQUMsRUFBRTtBQUNsQyxRQUFJLENBQUMsV0FBVyxDQUFDLElBQUksQ0FBQyxTQUFTLENBQUMsQ0FBQztBQUNqQyxRQUFJLENBQUMsS0FBSyxHQUFHLEtBQUssQ0FBQyxNQUFNLENBQUM7QUFDMUIsV0FBTztJQUNQO0dBQ0Q7QUFDRCxNQUFJLENBQUMsS0FBSyxHQUFHLEtBQUssQ0FBQyxJQUFJLENBQUM7RUFDeEI7O0FBakNJLE1BQUssV0FtQ1YsV0FBVyx3QkFBQyxHQUFHLEVBQUU7QUFDaEIsTUFBSSxJQUFJLENBQUMsS0FBSyxLQUFLLEtBQUssQ0FBQyxNQUFNLElBQUksR0FBRyxJQUFJLElBQUksRUFBRTtBQUMvQyxPQUFJLENBQUMsZ0JBQWdCLEVBQUUsQ0FBQztHQUN4QjtFQUNEOztBQXZDSSxNQUFLLFdBeUNWLE1BQU0sbUJBQUMsR0FBRyxFQUFFLEdBQUcsRUFBRSxHQUFHLEVBQUU7QUFDckIsTUFBSSxDQUFDLE1BQU0sSUFBSSxHQUFHLENBQUM7QUFDbkIsTUFBSSxJQUFJLENBQUMsTUFBTSxJQUFJLENBQUMsRUFBRTtBQUNyQixTQUFNLENBQUMsSUFBSSxDQUFDLEtBQUssQ0FBQyxDQUFDO0FBQ25CLE9BQUksQ0FBQyxLQUFLLEdBQUcsS0FBSyxDQUFDO0FBQ25CLE9BQUksQ0FBQyxXQUFXLEdBQUcsS0FBSyxDQUFDO0FBQ3pCLE9BQUksQ0FBQyxJQUFJLENBQUMsSUFBSSxDQUFDLE1BQU0sQ0FBQyxJQUFJLENBQUMsQ0FBQTtBQUMzQixPQUFJLENBQUMsb0JBQW9CLEdBQUcsS0FBSyxDQUFDO0FBQ2xDLE9BQUksQ0FBQyxrQkFBa0IsR0FBRyxLQUFLLENBQUM7R0FDaEMsTUFBTTtBQUNOLFNBQU0sQ0FBQyxJQUFJLENBQUMsV0FBVyxDQUFDLENBQUM7R0FDekI7QUFDRCxNQUFJLENBQUMsSUFBSSxDQUFDLENBQUMsSUFBSSxDQUFDLENBQUM7QUFDakIsTUFBSSxDQUFDLElBQUksQ0FBQyxDQUFDLElBQUksQ0FBQyxDQUFDOztBQUVqQixNQUFJLEdBQUcsR0FBRyxJQUFJLElBQUksQ0FBQyxJQUFJLENBQUMsSUFBSSxFQUFFLEdBQUcsQ0FBQyxDQUFDLEVBQUUsR0FBRyxDQUFDLENBQUMsQ0FBQyxDQUFDO0FBQzVDLEtBQUcsQ0FBQyxHQUFHLENBQUMsS0FBSyxDQUFDLEdBQUcsQ0FBQyxDQUFDLFNBQVMsQ0FBQyxHQUFHLEVBQUUsR0FBRyxDQUFDLENBQUM7QUFDdkMsTUFBSSxDQUFDLElBQUksQ0FBQyxTQUFTLENBQUMsR0FBRyxDQUFDLENBQUM7RUFDekI7O0FBM0RJLE1BQUssV0E2RFYsV0FBVyx3QkFBQyxHQUFHLEVBQUU7QUFDaEIsTUFBSSxFQUFFLEdBQUcsR0FBRyxDQUFDLENBQUMsR0FBQyxJQUFJLENBQUMsR0FBRyxDQUFDLENBQUMsQ0FBQztBQUMxQixNQUFJLEVBQUUsR0FBRyxHQUFHLENBQUMsQ0FBQyxHQUFDLElBQUksQ0FBQyxHQUFHLENBQUMsQ0FBQyxDQUFDO0FBQzFCLE1BQUksR0FBRyxHQUFHLElBQUksQ0FBQyxJQUFJLENBQUMsRUFBRSxHQUFDLEVBQUUsR0FBQyxFQUFFLEdBQUMsRUFBRSxDQUFDLENBQUM7O0FBRWpDLE1BQUksQ0FBQyxHQUFHLENBQUMsR0FBRyxDQUFDLENBQUMsR0FBRyxDQUFDLENBQUMsR0FBQyxJQUFJLENBQUMsR0FBRyxDQUFDLENBQUMsQ0FBQSxHQUFFLE1BQU0sQ0FBQyxRQUFRLEVBQUUsQ0FBQyxHQUFHLENBQUMsQ0FBQyxHQUFDLElBQUksQ0FBQyxHQUFHLENBQUMsQ0FBQyxDQUFBLEdBQUUsTUFBTSxDQUFDLFFBQVEsQ0FBQyxDQUFDO0FBQ3JGLE1BQUksQ0FBQyxPQUFPLEdBQUcsSUFBSSxDQUFDO0FBQ3BCLE1BQUksQ0FBQyxPQUFPLEdBQUcsSUFBSSxDQUFDLEtBQUssQ0FBQyxFQUFFLEVBQUUsRUFBRSxDQUFDLENBQUM7RUFDbEM7O0FBckVJLE1BQUssV0F1RVYsS0FBSyxrQkFBQyxFQUFFLEVBQUU7QUFDVCxNQUFJLElBQUksQ0FBQyxNQUFNLElBQUksQ0FBQyxFQUFFLE9BQU87O0FBRTdCLE1BQUksSUFBSSxDQUFDLE1BQU0sSUFBSSxJQUFJLENBQUMsU0FBUyxFQUFFO0FBQ2xDLE9BQUksR0FBRyxDQUFDLFVBQVUsQ0FBQyxJQUFJLENBQUMsU0FBUyxHQUFDLElBQUksQ0FBQyxNQUFNLEVBQUUsSUFBSSxDQUFDLFNBQVMsQ0FBQyxFQUFFO0FBQy9ELFFBQUksS0FBSyxHQUFHLElBQUksS0FBSyxDQUFDLElBQUksQ0FBQyxJQUFJLEVBQUUsSUFBSSxDQUFDLEdBQUcsQ0FBQyxDQUFDLEVBQUUsSUFBSSxDQUFDLEdBQUcsQ0FBQyxDQUFDLENBQUMsQ0FBQztBQUN6RCxTQUFLLENBQUMsSUFBSSxHQUFHLENBQUMsQ0FBQztBQUNmLFNBQUssQ0FBQyxHQUFHLENBQUMsQ0FBQyxJQUFJLElBQUksQ0FBQyxBQUFDLEtBQUssQ0FBQyxHQUFHLENBQUMsQ0FBQyxJQUFJLElBQUksQ0FBQyxHQUFHLENBQUMsQ0FBQyxDQUFDO0FBQy9DLFNBQUssQ0FBQyxHQUFHLENBQUMsQ0FBQyxJQUFJLElBQUksQ0FBQyxBQUFDLEtBQUssQ0FBQyxHQUFHLENBQUMsQ0FBQyxJQUFJLElBQUksQ0FBQyxHQUFHLENBQUMsQ0FBQyxDQUFDO0FBQy9DLFFBQUksQ0FBQyxJQUFJLENBQUMsU0FBUyxDQUFDLEtBQUssQ0FBQyxDQUFDO0lBQzNCO0dBQ0Q7O0FBRUQsTUFBSSxJQUFJLENBQUMsT0FBTyxFQUFFO0FBQ2pCLE9BQUksQ0FBQyxZQUFZLElBQUksSUFBSSxDQUFDLEdBQUcsQ0FBQyxJQUFJLENBQUMsT0FBTyxDQUFDLFFBQVEsQ0FBQyxJQUFJLENBQUMsR0FBRyxDQUFDLEdBQUMsRUFBRSxFQUFFLENBQUMsQ0FBQyxDQUFDO0dBQ3JFOztBQUVELE1BQUksSUFBSSxDQUFDLEtBQUssS0FBSyxLQUFLLENBQUMsTUFBTSxFQUFFO0FBQ2hDLE9BQUksQ0FBQyxJQUFJLENBQUMsR0FBRyxDQUFDLEVBQUUsRUFBRSxFQUFFLENBQUMsQ0FBQztHQUN0QixNQUNJO0FBQ0osT0FBSSxDQUFDLElBQUksQ0FBQyxHQUFHLENBQUMsQ0FBQyxFQUFFLENBQUMsQ0FBQyxDQUFDO0dBQ3BCOztBQUVELE1BQUksWUFBWSxHQUFHLElBQUksQ0FBQyxJQUFJLENBQUMsTUFBTSxDQUFDLElBQUksQ0FBQyxHQUFHLEVBQUUsSUFBSSxDQUFDLElBQUksQ0FBQyxNQUFNLENBQUMsR0FBRyxDQUFDLENBQUM7QUFDcEUsTUFBSSxZQUFZLElBQUksSUFBSSxDQUFDLEtBQUssS0FBSyxLQUFLLENBQUMsTUFBTSxFQUFFO0FBQ2hELFNBQU0sQ0FBQyxJQUFJLENBQUMsR0FBRyxDQUFDLE1BQU0sQ0FBQyxDQUFDLE1BQU0sRUFBRSxNQUFNLENBQUMsQ0FBQyxDQUFDLENBQUM7QUFDMUMsT0FBSSxDQUFDLEtBQUssR0FBRyxLQUFLLENBQUMsTUFBTSxDQUFDO0FBQzFCLE9BQUksQ0FBQyxhQUFhLENBQUMsSUFBSSxDQUFDLElBQUksQ0FBQyxJQUFJLENBQUMsTUFBTSxDQUFDLEdBQUcsQ0FBQyxDQUFDO0FBQzlDLE9BQUksQ0FBQyxPQUFPLENBQUMsSUFBSSxDQUFDLElBQUksQ0FBQyxNQUFNLENBQUMsR0FBRyxDQUFDLENBQUE7R0FDbEMsTUFDSSxJQUFJLElBQUksQ0FBQyxLQUFLLEtBQUssS0FBSyxDQUFDLE1BQU0sSUFBSSxDQUFDLFlBQVksRUFBRTtBQUN0RCxPQUFJLENBQUMsS0FBSyxHQUFHLEtBQUssQ0FBQyxNQUFNLENBQUM7R0FDMUI7O0FBRUQsVUFBUSxJQUFJLENBQUMsS0FBSztBQUNsQixRQUFLLEtBQUssQ0FBQyxNQUFNO0FBQ2hCLFFBQUksSUFBSSxDQUFDLEdBQUcsQ0FBQyxRQUFRLENBQUMsSUFBSSxDQUFDLFNBQVMsQ0FBQyxHQUFHLENBQUMsRUFBRTtBQUMxQyxTQUFJLENBQUMsU0FBUyxHQUFHLEdBQUcsQ0FBQyxRQUFRLENBQUMsR0FBRyxFQUFFLEdBQUcsQ0FBQyxDQUFDO0FBQ3hDLFNBQUksQ0FBQyxLQUFLLEdBQUcsS0FBSyxDQUFDLElBQUksQ0FBQztLQUN4QixNQUNJO0FBQ0osU0FBSSxDQUFDLFdBQVcsQ0FBQyxJQUFJLENBQUMsU0FBUyxDQUFDLENBQUM7S0FDakM7QUFDRCxVQUFNO0FBQUEsQUFDUCxRQUFLLEtBQUssQ0FBQyxJQUFJO0FBQ2QsUUFBSSxDQUFDLFNBQVMsSUFBSSxFQUFFLENBQUM7QUFDckIsUUFBSSxJQUFJLENBQUMsU0FBUyxHQUFHLENBQUMsRUFBRTtBQUN2QixTQUFJLENBQUMsS0FBSyxHQUFHLEtBQUssQ0FBQyxNQUFNLENBQUM7QUFDMUIsU0FBSSxDQUFDLGdCQUFnQixFQUFFLENBQUM7S0FDeEIsTUFDSTtBQUNKLFNBQUksR0FBRyxDQUFDLFdBQVcsQ0FBQyxFQUFFLENBQUMsRUFBRTtBQUN4QixVQUFJLENBQUMsT0FBTyxHQUFHLEdBQUcsQ0FBQyxRQUFRLENBQUMsQ0FBQyxFQUFFLElBQUksQ0FBQyxFQUFFLEdBQUMsQ0FBQyxDQUFDLENBQUM7TUFDMUM7QUFDRCxTQUFJLEdBQUcsQ0FBQyxXQUFXLENBQUMsRUFBRSxDQUFDLEVBQUU7QUFDeEIsVUFBSSxDQUFDLEdBQUcsQ0FBQyxHQUFHLENBQUMsR0FBRyxDQUFDLFFBQVEsQ0FBQyxDQUFDLEVBQUUsRUFBRSxFQUFFLENBQUMsRUFBRSxHQUFHLENBQUMsUUFBUSxDQUFDLENBQUMsRUFBRSxFQUFFLEVBQUUsQ0FBQyxDQUFDLENBQUM7TUFDM0Q7S0FDRDs7QUFFRCxVQUFNO0FBQUEsQUFDUCxRQUFLLEtBQUssQ0FBQyxNQUFNO0FBQ2hCLFFBQUksSUFBSSxDQUFDLEdBQUcsQ0FBQyxRQUFRLENBQUMsSUFBSSxDQUFDLGFBQWEsQ0FBQyxHQUFHLENBQUMsRUFBRTtBQUM5QyxTQUFJLENBQUMsS0FBSyxHQUFHLEtBQUssQ0FBQyxJQUFJLENBQUM7QUFDeEIsU0FBSSxDQUFDLFNBQVMsR0FBRyxHQUFHLENBQUMsUUFBUSxDQUFDLEdBQUcsRUFBRSxHQUFHLENBQUMsQ0FBQztLQUN4QyxNQUNJO0FBQ0osU0FBSSxDQUFDLFdBQVcsQ0FBQyxJQUFJLENBQUMsSUFBSSxDQUFDLE1BQU0sQ0FBQyxHQUFHLENBQUMsQ0FBQztLQUN2QztBQUNELFVBQU07QUFBQSxBQUNQLFFBQUssS0FBSyxDQUFDLE1BQU07QUFDaEIsUUFBSSxDQUFDLFVBQVUsSUFBSSxFQUFFLENBQUM7QUFDdEIsUUFBSSxLQUFLLEdBQUcsSUFBSSxDQUFDLEdBQUcsQ0FBQyxRQUFRLENBQUMsSUFBSSxDQUFDLElBQUksQ0FBQyxNQUFNLENBQUMsR0FBRyxDQUFDLENBQUM7QUFDcEQsUUFBSSxLQUFLLEdBQUcsRUFBRSxFQUFFO0FBQ2YsU0FBSSxDQUFDLFVBQVUsSUFBSSxFQUFFLEdBQUMsQ0FBQyxDQUFDO0tBQ3hCO0FBQ0QsUUFBSSxLQUFLLEdBQUcsR0FBRyxFQUFFO0FBQ2hCLFNBQUksQ0FBQyxXQUFXLENBQUMsSUFBSSxDQUFDLElBQUksQ0FBQyxNQUFNLENBQUMsR0FBRyxDQUFDLENBQUM7S0FDdkM7QUFDRCxRQUFJLElBQUksQ0FBQyxVQUFVLEdBQUcsQ0FBQyxFQUFFO0FBQ3hCLFNBQUksQ0FBQyxPQUFPLENBQUMsSUFBSSxDQUFDLElBQUksQ0FBQyxNQUFNLENBQUMsR0FBRyxDQUFDLENBQUM7S0FDbkM7QUFDRCxVQUFNO0FBQUEsR0FDTjtFQUNEOztBQTNKSSxNQUFLLFdBNkpWLFVBQVUseUJBQUc7QUFDWixNQUFJLENBQUMsR0FBRyxDQUFDLEdBQUcsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxDQUFDLENBQUM7RUFDbkI7O0FBL0pJLE1BQUssV0FpS1YsT0FBTyxvQkFBQyxHQUFHLEVBQUU7QUFDWixNQUFJLEVBQUUsR0FBRyxHQUFHLENBQUMsQ0FBQyxHQUFDLElBQUksQ0FBQyxHQUFHLENBQUMsQ0FBQyxDQUFDO0FBQzFCLE1BQUksRUFBRSxHQUFHLEdBQUcsQ0FBQyxDQUFDLEdBQUMsSUFBSSxDQUFDLEdBQUcsQ0FBQyxDQUFDLENBQUM7QUFDMUIsTUFBSSxHQUFHLEdBQUcsSUFBSSxDQUFDLElBQUksQ0FBQyxFQUFFLEdBQUMsRUFBRSxHQUFDLEVBQUUsR0FBQyxFQUFFLENBQUMsQ0FBQztBQUNqQyxNQUFJLEdBQUcsSUFBSSxDQUFDLEVBQUU7QUFDYixPQUFJLE1BQU0sR0FBRyxJQUFJLE1BQU0sQ0FBQyxJQUFJLENBQUMsSUFBSSxFQUFFLElBQUksRUFBRSxFQUFFLEdBQUMsR0FBRyxFQUFFLEVBQUUsR0FBQyxHQUFHLENBQUMsQ0FBQztBQUN6RCxPQUFJLENBQUMsSUFBSSxDQUFDLFNBQVMsQ0FBQyxNQUFNLENBQUMsQ0FBQztHQUM1QjtBQUNELE1BQUksQ0FBQyxVQUFVLEdBQUcsR0FBRyxDQUFDLFFBQVEsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxDQUFDLENBQUM7RUFDckM7O0FBMUtJLE1BQUssV0E0S1YsTUFBTSxtQkFBQyxLQUFLLEVBQUU7QUFDYixNQUFJLENBQUMsSUFBSSxDQUFDLElBQUksQ0FBQyxNQUFNLENBQUMsSUFBSSxDQUFDLElBQUksQ0FBQyxNQUFNLENBQUMsR0FBRyxFQUFFLElBQUksQ0FBQyxJQUFJLENBQUMsSUFBSSxDQUFDLEdBQUcsQ0FBQyxDQUFDLEdBQUMsSUFBSSxDQUFDLE1BQU0sRUFBRSxJQUFJLENBQUMsR0FBRyxDQUFDLENBQUMsR0FBQyxJQUFJLENBQUMsTUFBTSxDQUFDLENBQUMsSUFDbEcsQ0FBQyxJQUFJLENBQUMsSUFBSSxDQUFDLE1BQU0sQ0FBQyxJQUFJLENBQUMsSUFBSSxDQUFDLE1BQU0sQ0FBQyxHQUFHLEVBQUUsSUFBSSxDQUFDLElBQUksQ0FBQyxJQUFJLENBQUMsR0FBRyxDQUFDLENBQUMsR0FBQyxJQUFJLENBQUMsTUFBTSxFQUFFLElBQUksQ0FBQyxHQUFHLENBQUMsQ0FBQyxHQUFDLElBQUksQ0FBQyxNQUFNLENBQUMsQ0FBQyxJQUNsRyxDQUFDLElBQUksQ0FBQyxJQUFJLENBQUMsTUFBTSxDQUFDLElBQUksQ0FBQyxJQUFJLENBQUMsTUFBTSxDQUFDLEdBQUcsRUFBRSxJQUFJLENBQUMsSUFBSSxDQUFDLElBQUksQ0FBQyxHQUFHLENBQUMsQ0FBQyxHQUFDLElBQUksQ0FBQyxNQUFNLEVBQUUsSUFBSSxDQUFDLEdBQUcsQ0FBQyxDQUFDLEdBQUMsSUFBSSxDQUFDLE1BQU0sQ0FBQyxDQUFDLElBQ2xHLENBQUMsSUFBSSxDQUFDLElBQUksQ0FBQyxNQUFNLENBQUMsSUFBSSxDQUFDLElBQUksQ0FBQyxNQUFNLENBQUMsR0FBRyxFQUFFLElBQUksQ0FBQyxJQUFJLENBQUMsSUFBSSxDQUFDLEdBQUcsQ0FBQyxDQUFDLEdBQUMsSUFBSSxDQUFDLE1BQU0sRUFBRSxJQUFJLENBQUMsR0FBRyxDQUFDLENBQUMsR0FBQyxJQUFJLENBQUMsTUFBTSxDQUFDLENBQUMsRUFBRTtBQUN2RyxVQUFPO0dBQ1A7QUFDRCxNQUFJLElBQUksQ0FBQyxNQUFNLElBQUksQ0FBQyxFQUFFO0FBQ3JCLFFBQUssQ0FBQyxPQUFPLENBQUMsU0FBUyxDQUFDLElBQUksQ0FBQyxJQUFJLENBQUMsTUFBTSxDQUFDLFdBQVcsQ0FBQyxJQUFJLENBQUMsSUFBSSxDQUFDLENBQUMsTUFBTSxFQUNyRSxDQUFDLEVBQUUsQ0FBQyxFQUFFLEVBQUUsRUFBRSxFQUFFLEVBQUUsSUFBSSxDQUFDLEtBQUssQ0FBQyxJQUFJLENBQUMsR0FBRyxDQUFDLENBQUMsR0FBQyxFQUFFLENBQUMsRUFBRSxJQUFJLENBQUMsS0FBSyxDQUFDLElBQUksQ0FBQyxHQUFHLENBQUMsQ0FBQyxHQUFDLENBQUMsQ0FBQyxFQUFFLEVBQUUsRUFBRSxFQUFFLENBQUMsQ0FBQztBQUM1RSxRQUFLLENBQUMsT0FBTyxDQUFDLFNBQVMsQ0FBQyxJQUFJLENBQUMsSUFBSSxDQUFDLE1BQU0sQ0FBQyxXQUFXLENBQUMsSUFBSSxDQUFDLElBQUksQ0FBQyxDQUFDLE1BQU0sRUFDckUsQ0FBQyxFQUFFLEVBQUUsRUFBRSxFQUFFLEVBQUUsRUFBRSxFQUFFLElBQUksQ0FBQyxLQUFLLENBQUMsSUFBSSxDQUFDLEdBQUcsQ0FBQyxDQUFDLEdBQUMsRUFBRSxDQUFDLEVBQUUsSUFBSSxDQUFDLEtBQUssQ0FBQyxJQUFJLENBQUMsR0FBRyxDQUFDLENBQUMsR0FBQyxDQUFDLENBQUMsRUFBRSxFQUFFLEVBQUUsRUFBRSxDQUFDLENBQUM7R0FDN0UsTUFDSTtBQUNKLE9BQUksUUFBUSxHQUFHLElBQUksQ0FBQyxLQUFLLENBQUMsSUFBSSxDQUFDLE9BQU8sSUFBSSxJQUFJLENBQUMsRUFBRSxHQUFDLENBQUMsQ0FBQSxBQUFDLEdBQUMsRUFB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QUM5RCxNQUFJLEVBQUUsR0FBRyxJQUFJLENBQUMsSUFBSSxDQUFDLElBQUksRUFBRSxJQUFJLENBQUMsQ0FBQyxNQUFNLENBQUMsSUFBSSxDQUFDLE9BQU8sRUFBRSxJQUFJLENBQUMsR0FBRyxDQUFDLENBQUM7QUFDOUQsTUFBSSxFQUFFLEdBQUcsSUFBSSxDQUFDLElBQUksQ0FBQyxJQUFJLEVBQUUsSUFBSSxDQUFDLENBQUMsTUFBTSxDQUFDLElBQUksQ0FBQyxPQUFPLEVBQUUsSUFBSSxDQUFDLEdBQUcsQ0FBQyxDQUFDO0FBQzlELE1BQUksRUFBRSxHQUFHLElBQUksQ0FBQyxJQUFJLENBQUMsSUFBSSxFQUFFLElBQUksQ0FBQyxDQUFDLE1BQU0sQ0FBQyxJQUFJLENBQUMsT0FBTyxFQUFFLElBQUksQ0FBQyxHQUFHLENBQUMsQ0FBQzs7QUFFOUQsTUFBSSxDQUFDLGNBQWMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxLQUFLLENBQUMsSUFBSSxDQUFDLEVBQUUsQ0FBQyxDQUFDLEFBQUMsSUFBSSxDQUFDLGNBQWMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxHQUFHLENBQUMsSUFBSSxDQUFDLEVBQUUsQ0FBQyxDQUFDO0FBQzNFLE1BQUksQ0FBQyxjQUFjLENBQUMsQ0FBQyxDQUFDLENBQUMsS0FBSyxDQUFDLElBQUksQ0FBQyxFQUFFLENBQUMsQ0FBQyxBQUFDLElBQUksQ0FBQyxjQUFjLENBQUMsQ0FBQyxDQUFDLENBQUMsR0FBRyxDQUFDLElBQUksQ0FBQyxFQUFFLENBQUMsQ0FBQztBQUMzRSxNQUFJLENBQUMsY0FBYyxDQUFDLENBQUMsQ0FBQyxDQUFDLEtBQUssQ0FBQyxJQUFJLENBQUMsRUFBRSxDQUFDLENBQUMsQUFBQyxJQUFJLENBQUMsY0FBYyxDQUFDLENBQUMsQ0FBQyxDQUFDLEdBQUcsQ0FBQyxJQUFJLENBQUMsRUFBRSxDQUFDLENBQUM7QUFDM0UsTUFBSSxDQUFDLGNBQWMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxLQUFLLENBQUMsSUFBSSxDQUFDLEVBQUUsQ0FBQyxDQUFDLEFBQUMsSUFBSSxDQUFDLGNBQWMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxHQUFHLENBQUMsSUFBSSxDQUFDLEVBQUUsQ0FBQyxDQUFDO0VBQzNFOztBQXJGSSxPQUFNLFdBdUZYLFdBQVcsMEJBQUc7QUFDYixNQUFJLElBQUksQ0FBQyxXQUFXLEVBQUU7QUFDckIsT0FBSSxJQUFJLENBQUMsY0FBYyxJQUFJLElBQUksRUFBRTtBQUNoQyxRQUFJLENBQUMsY0FBYyxHQUFHLENBQ3JCLElBQUksV0FBVyxDQUFDLElBQUksSUFBSSxDQUFDLEdBQUcsRUFBRSxHQUFHLENBQUMsRUFBRSxJQUFJLElBQUksQ0FBQyxHQUFHLEVBQUUsR0FBRyxDQUFDLENBQUMsRUFDdkQsSUFBSSxXQUFXLENBQUMsSUFBSSxJQUFJLENBQUMsR0FBRyxFQUFFLEdBQUcsQ0FBQyxFQUFFLElBQUksSUFBSSxDQUFDLEdBQUcsRUFBRSxHQUFHLENBQUMsQ0FBQyxFQUN2RCxJQUFJLFdBQVcsQ0FBQyxJQUFJLElBQUksQ0FBQyxHQUFHLEVBQUUsR0FBRyxDQUFDLEVBQUUsSUFBSSxJQUFJLENBQUMsR0FBRyxFQUFFLEdBQUcsQ0FBQyxDQUFDLEVBQ3ZELElBQUksV0FBVyxDQUFDLElBQUksSUFBSSxDQUFDLEdBQUcsRUFBRSxHQUFHLENBQUMsRUFBRSxJQUFJLElBQUksQ0FBQyxHQUFHLEVBQUUsR0FBRyxDQUFDLENBQUMsQ0FDdkQsQ0FBQztJQUNGO0FBQ0QsT0FBSSxDQUFDLG9CQUFvQixFQUFFLENBQUE7QUFDM0IsVUFBTyxJQUFJLENBQUMsY0FBYyxDQUFDO0dBQzNCO0FBQ0QsU0FBTyxJQUFJLENBQUM7RUFDWjs7QUFyR0ksT0FBTSxXQXVHWCxJQUFJLGlCQUFDLEVBQUUsRUFBRTtBQUNSLE1BQUksQ0FBQyxPQUFPLENBQUMsSUFBSSxDQUFDLElBQUksQ0FBQyxHQUFHLENBQUMsQ0FBQztBQUM1QixNQUFJLENBQUMsT0FBTyxDQUFDLFFBQVEsRUFBRSxDQUFDO0FBQ3hCLE1BQUksSUFBSSxDQUFDLGNBQWMsRUFBRTtBQUN4QixPQUFJLElBQUksQ0FBQyxHQUFHLENBQUMsTUFBTSxFQUFFLEdBQUcsR0FBRyxFQUFFO0FBQzVCLFFBQUksQ0FBQyxHQUFHLENBQUMsZUFBZSxFQUFFLENBQUM7SUFDM0I7R0FDRDtBQUNELE1BQUksQ0FBQyxHQUFHLENBQUMsS0FBSyxDQUFDLElBQUksQ0FBQyxLQUFLLENBQUMsQ0FBQztBQUMzQixNQUFJLENBQUMsR0FBRyxDQUFDLENBQUMsSUFBSSxDQUFDLElBQUksQ0FBQyxJQUFJLENBQUMsQ0FBQyxHQUFHLElBQUksQ0FBQyxHQUFHLENBQUMsQ0FBQyxDQUFDO0FBQ3hDLE1BQUksQ0FBQyxHQUFHLENBQUMsQ0FBQyxJQUFJLENBQUMsSUFBSSxDQUFDLElBQUksQ0FBQyxDQUFDLEdBQUcsSUFBSSxDQUFDLEdBQUcsQ0FBQyxDQUFDLENBQUM7QUFDeEMsTUFBSSxDQUFDLEdBQUcsQ0FBQyxRQUFRLEVBQUUsQ0FBQzs7QUFFcEIsTUFBSSxDQUFDLEdBQUcsQ0FBQyxDQUFDLElBQUksSUFBSSxDQUFDLEdBQUcsQ0FBQyxDQUFDLEdBQUMsRUFBRSxHQUFHLElBQUksQ0FBQyxHQUFHLENBQUMsQ0FBQyxHQUFDLEVBQUUsR0FBQyxFQUFFLEdBQUMsR0FBRyxDQUFDO0FBQ25ELE1BQUksQ0FBQyxHQUFHLENBQUMsQ0FBQyxJQUFJLElBQUksQ0FBQyxHQUFHLENBQUMsQ0FBQyxHQUFDLEVBQUUsR0FBRyxJQUFJLENBQUMsR0FBRyxDQUFDLENBQUMsR0FBQyxFQUFFLEdBQUMsRUFBRSxHQUFDLEdBQUcsQ0FBQztBQUNuRCxNQUFJLENBQUMsR0FBRyxDQUFDLFFBQVEsRUFBRSxDQUFDOztBQUVwQixNQUFJLENBQUMsR0FBRyxDQUFDLENBQUMsSUFBSSxJQUFJLENBQUMsR0FBRyxDQUFDLENBQUMsR0FBQyxFQUFFLENBQUM7QUFDNUIsTUFBSSxDQUFDLEdBQUcsQ0FBQyxDQUFDLElBQUksSUFBSSxDQUFDLEdBQUcsQ0FBQyxDQUFDLEdBQUMsRUFBRSxDQUFDO0FBQzVCLE1BQUksQ0FBQyxHQUFHLENBQUMsUUFBUSxFQUFFLENB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QUcsR0FBRyxJQUFJLENBQUMsR0FBRyxDQUFDLEdBQUcsQ0FBQyxNQUFNLENBQUMsQ0FBQztBQUMvQixPQUFJLElBQUksQ0FBQyxPQUFPLEVBQUU7QUFDakIsUUFBSSxDQUFDLEdBQUcsQ0FBQyxDQUFDLEdBQUcsRUFBRSxDQUFDLEdBQUMsR0FBRyxHQUFDLE1BQU0sQ0FBQyxDQUFDLEdBQUcsSUFBSSxDQUFDLEdBQUcsQ0FBQyxDQUFDLENBQUEsQUFBQyxDQUFDO0FBQzVDLFFBQUksQ0FBQyxHQUFHLENBQUMsQ0FBQyxHQUFHLEVBQUUsQ0FBQyxHQUFDLEdBQUcsR0FBQyxNQUFNLENBQUMsQ0FBQyxHQUFHLElBQUksQ0FBQyxHQUFHLENBQUMsQ0FBQyxDQUFBLEFBQUMsQ0FBQztBQUM1QyxRQUFJLENBQUMsR0FBRyxDQUFDLENBQUMsSUFBSSxJQUFJLENBQUMsVUFBVSxDQUFDO0FBQzlCLFFBQUksQ0FBQyxHQUFHLENBQUMsQ0FBQyxJQUFJLElBQUksQ0FBQyxVQUFVLENBQUM7SUFDOUIsTUFDSTtBQUNKLFFBQUksR0FBRyxHQUFHLENBQUMsRUFBRTtBQUNaLFNBQUksQ0FBQyxHQUFHLENBQUMsQ0FBQyxJQUFJLEdBQUcsR0FBQyxNQUFNLENBQUMsQ0FBQyxDQUFDO0FBQzNCLFNBQUksQ0FBQyxHQUFHLENBQUMsQ0FBQyxJQUFJLEdBQUcsR0FBQyxNQUFNLENBQUMsQ0FBQyxDQUFDO0tBQzNCO0lBQ0Q7R0FDRCxNQUNJO0FBQ0osT0FBSSxHQUFHLElBQUksSUFBSSxJQUFJLENBQUMsR0FBRyxDQUFDLE1BQU0sRUFBRTtBQUMvQixRQUFJLENBQUMsR0FBRyxDQUFDLENBQUMsSUFBSSxNQUFNLENBQUMsQ0FBQyxHQUFHLFdBQVcsQ0FBQztBQUNyQyxRQUFJLENBQUMsR0FBRyxDQUFDLENBQUMsSUFBSSxNQUFNLENBQUMsQ0FBQyxHQUFHLFdBQVcsQ0FBQztBQUNyQyxRQUFJLENBQUMsR0FBRyxDQUFDLENBQUMsSUFBSSxNQUFNLENBQUMsQ0FBQyxHQUFHLFdBQVcsQ0FBQztBQUNyQyxRQUFJLENBQUMs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SSxFQUFFLFFBQVEsQ0FBQyxLQUFLLEVBQUUsUUFBUSxDQUFDLE1BQU0sQ0FBQyxDQUFDO0FBQ2hFLE1BQUksQ0FBQyxVQUFVLEdBQUcsSUFBSSxLQUFLLENBQUMsT0FBTyxFQUFFLFFBQVEsQ0FBQyxLQUFLLEVBQUUsUUFBUSxDQUFDLE1BQU0sQ0FBQyxDQUFDO0FBQ3RFLE1BQUksQ0FBQyxTQUFTLEdBQUcsSUFBSSxLQUFLLENBQUMsTUFBTSxFQUFHLFFBQVEsQ0FBQyxLQUFLLEVBQUUsUUFBUSxDQUFDLE1BQU0sQ0FBQyxDQUFDO0FBQ3JFLE1BQUksQ0FBQyxTQUFTLEdBQUcsSUFBSSxLQUFLLENBQUMsTUFBTSxFQUFFLFFBQVEsQ0FBQyxLQUFLLEVBQUUsUUFBUSxDQUFDLE1BQU0sQ0FBQyxDQUFDO0FBQ3BFLE1BQUksQ0FBQyxPQUFPLEdBQUcsSUFBSSxLQUFLLENBQUMsSUFBSSxFQUFFLFFBQVEsQ0FBQyxLQUFLLEVBQUUsUUFBUSxDQUFDLE1BQU0sQ0FBQyxDQUFDO0FBQ2hFLE1BQUksQ0FBQyxVQUFVLEdBQUcsSUFBSSxLQUFLLENBQUMsT0FBTyxFQUFFLFFBQVEsQ0FBQyxLQUFLLEVBQUUsUUFBUSxDQUFDLE1BQU0sQ0FBQyxDQUFDO0FBQ3RFLE1BQUksQ0FBQyxRQUFRLEdBQUcsSUFBSSxLQUFLLENBQUMsS0FBSyxFQUFFLFFBQVEsQ0FBQyxLQUFLLEVBQUUsUUFBUSxDQUFDLE1BQU0sQ0FBQyxDQUFDO0FBQ2xFLE1BQUksQ0FBQyxZQUFZLEdBQUcsSUFBSSxLQUFLLENBQUMsU0FBUyxFQUFFLFFBQVEsQ0FBQyxLQUFLLEVBQUUsUUFBUSxDQUFDLE1BQU0sQ0FBQyxDQUFDOztBQUUxRSxNQUFJLENBQUMsV0FBVyxHQUFHLEtBQUssQ0FBQztBQUN6QixNQUFJLENBQUMsVUFBVSxHQUFHLEtBQUssQ0FBQztBQUN4QixNQUFJLENBQUMsZUFBZSxHQUFHLEdBQUcsQ0FBQzs7QUFFM0IsTUFBSSxDQUFDLE1BQU0sR0FBRyxDQUNiLElBQUksQ0FBQyxPQUFPOztBQUVaLE1BQUksQ0FBQyxVQUFV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LENBQUM7R0FDMUMsQ0FBQzs7QUFBQyxBQUVILE1BQUksQ0FBQyxNQUFNLENBQUMsV0FBVyxDQUFDLElBQUksQ0FBQyxNQUFNLENBQUMsR0FBRyxDQUFDLENBQUMsRUFBRSxJQUFJLENBQUMsTUFBTSxDQUFDLEdBQUcsQ0FBQyxDQUFDLEVBQUUsSUFBSSxDQUFDLENBQUM7QUFDcEUsTUFBSSxDQUFDLFNBQVMsR0FBRyxLQUFLLENBQUMsS0FBSyxDQUFDO0FBQzdCLE1BQUksQ0FBQyxVQUFVLEdBQUcsS0FBSyxDQUFDLE1BQU0sQ0FBQztBQUMvQixNQUFJLENBQUMsS0FBSyxHQUFHLElBQUksS0FBSyxDQUFDLElBQUksQ0FBQyxTQUFTLEdBQUMsSUFBSSxDQUFDLFVBQVUsQ0FBQyxDQUFDO0FBQ3ZELE1BQUksQ0FBQyxVQUFVLEdBQUcsSUFBSSxVQUFVLENBQUMsSUFBSSxDQUFDLFNBQVMsR0FBQyxJQUFJLENBQUMsVUFBVSxDQUFDLENBQUM7QUFDakUsTUFBSSxDQUFDLFdBQVcsR0FBRyxJQUFJLEtBQUssQ0FBQyxJQUFJLENBQUMsU0FBUyxHQUFDLElBQUksQ0FBQyxVQUFVLENBQUM7O0FBQUMsQUFFN0QsTUFBSSxnQkFBZ0IsR0FBRyxFQUFFLENBQUM7QUFDMUIsT0FBSyxJQUFJLENBQUMsR0FBRyxDQUFDLEVBQUUsQ0FBQyxHQUFHLElBQUksQ0FBQyxVQUFVLEVBQUUsRUFBRSxDQUFDLEVBQUU7QUFDekMsUUFBSyxJQUFJLENBQUMsR0FBRyxDQUFDLEVBQUUsQ0FBQyxHQUFHLElBQUksQ0FBQyxTQUFTLEVBQUUsRUFBRSxDQUFDLEVBQUU7QUFDeEMsUUFBSSxDQUFDLEdBQUcsQ0FBQyxHQUFDLENBQUMsR0FBQyxJQUFJLENBQUMsU0FBUyxDQUFDO0FBQzNCLFFBQUksTUFBTSxHQUFHLEtBQUssQ0FBQyxLQUFLLENBQUMsQ0FBQyxDQUFDLENBQUM7QUFDNUIsUUFBSSxNQUFNLElBQUksS0FBSyxDQUFDLE1BQU0sRUFBRTtBQUMzQixTQUFJLEVBQUUsTUFBTSxJQUFJLGdCQUFnQixDQUFBLEFBQUMsRUFBRTtBQUNsQyxzQkFBZ0IsQ0FBQyxNQUFNLENBQUMsR0FBRyxFQUFFLENBQUM7TUFDOUI7QUFDRCxxQkFBZ0IsQ0FBQyxNQUFNLENBQUMsQ0FBQyxJQUFJLENBQUMsRUFBQyxDQUFDLEVBQUQsQ0FBQyxFQUFFLENBQUMsRUFBRCxDQUFDLEVBQUMsQ0FBQyxDQUFDO0FBQ3RDLFdBQU0sR0FBRyxDQUFDLENBQUM7S0FDWDtBQUNELFFBQUksUUFBUSxHQUFHLEtBQUssQ0FBQyxNQUFNLENBQUMsQ0FBQztBQUM3QixRQUFJLENBQUMsS0FBSyxDQUFDLENBQUMsQ0FBQyxHQUFHLE1BQU0sR0FBRyxRQUFRLENBQUMsUUFBUSxDQUFDLENBQUMsR0FBQyxNQUFNLENBQUMsUUFBUSxFQUFFLENBQUMsR0FBQyxNQUFNLENBQUMsUUFBUSxDQUFDLEdBQUcsUUFBUSxDQUFDO0FBQzVGLFFBQUksQ0FBQyxNQUFNLEVBQUU7QUFDWixTQUFJLENBQUMsVUFBVSxDQUFDLENBQUMsQ0FBQyxHQUFHLENBQUMsQ0FBQztLQUN2QjtBQUNELFFBQUksQ0FBQyxLQUFLLENBQUMsQ0FBQyxDQUFDLENBQUMsRUFBRSxHQUFHLE1BQU0sQ0FBQztJQUMxQjtHQUNEOztBQUVELE1BQUksSUFBSSxHQUFHLEtBQUssQ0FBQyxJQUFJLENBQUM7QUFDdEIsTUFBSSxJQUFJLENBQUMsUUFBUSxDQUFDLE1BQU0sS0FBSyxDQUFDLEVBQUU7QUFDL0IsUUFBSyxDQUFDLElBQUksR0FBRyxJQUFJLEdBQUcsRUFBRSxDQUFDO0FBQ3ZCLFFBQUssSUFBSSxDQUFDLEdBQUcsQ0FBQyxFQUFFLENBQUMsR0FBRyxJQUFJLENBQUMsVUFBVSxFQUFFLEVBQUUsQ0FBQyxFQUFFO0FBQ3pDLFNBQUssSUFBSSxDQUFDLEdBQUcsQ0FBQyxFQUFFLENBQUMsR0FBRyxJQUFJLENBQUMsU0FBUyxFQUFFLEVBQUUsQ0FBQyxFQUFFO0FBQ3hDLFNBQUksQ0FBQyxHQUFHLENBQUMsR0FBQyxDQUFDLEdBQUMsSUFBSSxDQUFDLFNBQVMsQ0FBQztBQUMzQixTQUFJLE1B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QUFHLEVBQUUsTUFBTSxFQUFFO0FBQzNCLE1BQUksSUFBSSxHQUFHLElBQUksQ0FBQyxLQUFLLENBQUMsSUFBSSxDQUFDLEtBQUssQ0FBQyxDQUFDLEdBQUcsQ0FBQyxDQUFDLEdBQUcsTUFBTSxDQUFBLEdBQUksTUFBTSxDQUFDLFFBQVEsQ0FBQyxHQUFDLENBQUMsRUFBRSxDQUFDLEVBQUUsSUFBSSxDQUFDLFNBQVMsR0FBQyxDQUFDLENBQUMsQ0FBQztBQUM3RixNQUFJLEtBQUssR0FBRyxJQUFJLENBQUMsS0FBSyxDQUFDLElBQUksQ0FBQyxJQUFJLENBQUMsQ0FBQyxHQUFHLENBQUMsQ0FBQyxHQUFHLE1BQU0sQ0FBQSxHQUFJLE1BQU0sQ0FBQyxRQUFRLENBQUMsR0FBQyxDQUFDLEVBQUUsQ0FBQyxFQUFFLElBQUksQ0FBQyxTQUFTLEdBQUMsQ0FBQyxDQUFDLENBQUM7QUFDN0YsTUFBSSxHQUFHLEdBQUcsSUFBSSxDQUFDLEtBQUssQ0FBQyxJQUFJLENBQUMsS0FBSyxDQUFDLENBQUMsR0FBRyxDQUFDLENBQUMsR0FBRyxNQUFNLENBQUEsR0FBSSxNQUFNLENBQUMsUUFBUSxDQUFDLEdBQUMsQ0FBQyxFQUFFLENBQUMsRUFBRSxJQUFJLENBQUMsVUFBVSxHQUFDLENBQUMsQ0FBQyxDQUFDO0FBQzdGLE1BQUksTUFBTSxHQUFHLElBQUksQ0FBQyxLQUFLLENBQUMsSUFBSSxDQUFDLElBQUksQ0FBQyxDQUFDLEdBQUcsQ0FBQyxDQUFDLEdBQUcsTUFBTSxDQUFBLEdBQUksTUFBTSxDQUFDLFFBQVEsQ0FBQyxHQUFDLENBQUMsRUFBRSxDQUFDLEVBQUUsSUFBSSxDQUFDLFVBQVUsR0FBQyxDQUFDLENBQUMsQ0FBQztBQUMvRixNQUFJLE1BQU0sR0FBRyxVQUFVLENBQUM7QUFDeEIsUUFBTSxDQUFDLE1BQU0sR0FBRyxDQUFDLENBQUM7QUFDbEIsT0FBSyxJQUFJLENBQUMsR0FBRyxHQUFHLEVBQUUsQ0FBQyxJQUFJLE1BQU0sRUFBRSxFQUFFLENBQUMsRUFBRTtBQUNuQyxRQUFLLElBQUksQ0FB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QUMsRUFDaEQsSUFBSSxXQUFXLENBQUMsRUFBRSxFQUFFLEVBQUUsQ0FBQyxFQUFFLElBQUksV0FBVyxDQUFDLEVBQUUsRUFBRSxFQUFFLENBQUMsQ0FBQyxDQUFBOztBQUVoRSxNQUFJLEVBQUUsR0FBRyxJQUFJLENBQUMsTUFBTSxDQUFDLE9BQU8sQ0FBQztBQUM3QixNQUFJLEVBQUUsR0FBRyxJQUFJLENBQUMsR0FBRyxDQUFDLEVBQUUsQ0FBQyxDQUFDO0FBQ3RCLE1BQUksRUFBRSxHQUFHLElBQUksQ0FBQyxHQUFHLENBQUMsRUFBRSxDQUFDLENBQUM7QUFDdEIsTUFBSSxHQUFHLEdBQUcsQ0FBQyxFQUFFLENBQUE7QUFDYixNQUFJLEdBQUcsR0FBRyxDQUFDLEVBQUUsQ0FBQztBQUNkLE1BQUksRUFBRSxHQUFHLElBQUksQ0FBQyxJQUFJLENBQUMsR0FBRyxHQUFDLENBQUMsR0FBQyxJQUFJLENBQUMsTUFBTSxDQUFDLEdBQUcsQ0FBQyxDQUFDLEVBQUUsR0FBRyxHQUFDLENBQUMsR0FBQyxJQUFJLENBQUMsTUFBTSxDQUFDLEdBQUcsQ0FBQyxDQUFDLENBQUMsQ0FBQztBQUNyRSxNQUFJLFFBQVEsR0FBRyxFQUFFLEdBQUMsSUFBSSxDQUFDLEVBQUUsR0FBQyxDQUFDLENBQUM7QUFDNUIsTUFBSSxRQUFRLEdBQUcsRUFBRSxHQUFDLElBQUksQ0FBQyxFQUFFLEdBQUMsQ0FBQyxDQUFDO0FBQzVCLE1BQUksS0FBSyxHQUFHLElBQUksQ0FBQyxHQUFHLENBQUMsUUFBUSxDQUFDLEdBQUMsR0FBRyxHQUFHLEVBQUUsQ0FBQyxDQUFDLENBQUM7QUFDMUMsTUFBSSxLQUFLLEdBQUcsSUFBSSxDQUFDLEdBQUcsQ0FBQyxRQUFRLENBQUMsR0FBQyxHQUFHLEdBQUcsRUFBRSxDQUFDLENBQUMsQ0FBQzs7QUFFMUMsTUFBSSxLQUFLLEdBQUcsSUFBSSxDQUFDLEdBQUcsQ0FBQyxRQUFRLENBQUMsR0FBQyxHQUFHLEdBQUcsRUFBRSxDQUFDLENBQUMsQ0FBQztBQUMxQyxNQUFJLEtBQUssR0FBRyxJQUFJ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QUMsR0FBRyxJQUFJLENBQUMsTUFBTSxDQUFDLE1BQU0sRUFBRSxFQUFFLENBQUMsRUFBRTtBQUM1QyxPQUFJLEVBQUUsR0FBRyxJQUFJLENBQUMsTUFBTSxDQUFDLENBQUMsQ0FBQyxDQUFDLE1BQU0sQ0FBQztBQUMvQixPQUFJLEVBQUUsQ0FBQyxXQUFXLEVBQUUsRUFBRSxDQUFDLEtBQUssRUFBRSxDQUFDO0FBQy9CLE9BQUksQ0FBQyxNQUFNLENBQUMsQ0FBQyxDQUFDLENBQUMsS0FBSyxFQUFFLENBQUM7QUFDdkIsT0FBSSxDQUFDLE1BQU0sQ0FBQyxDQUFDLENBQUMsQ0FBQyxPQUFPLENBQUMsSUFBSSxFQUFFLENBQUM7QUFDOUIsT0FBSSxDQUFDLE1BQU0sQ0FBQyxDQUFDLENBQUMsQ0FBQyxPQUFPLENBQUMsU0FBUyxDQUFDLENBQUMsS0FBSyxFQUFFLENBQUMsS0FBSyxDQUFDLENBQUM7R0FDakQ7O0FBRUQsTUFBSSxDQUFDLFlBQVksQ0FBQyxJQUFJLEVBQUUsQ0FBQztBQUN6QixNQUFJLENBQUMsWUFBWSxDQUFDLEtBQUssQ0FBQyxNQUFNLENBQUMsS0FBSyxFQUFFLE1BQU0sQ0FBQyxLQUFLLENBQUMsQ0FBQztBQUNwRCxNQUFJLENBQUMsWUFBWSxDQUFDLFNBQVMsR0FBRyxDQUFDLEdBQUcsTUFBTSxDQUFDLEtBQUssQ0FBQztBQUMvQyxNQUFJLENBQUMsWUFBWSxDQUFDLFdBQVcsR0FBRyxLQUFLLENBQUM7QUFDdEMsTUFBSSxDQUFDLFlBQVksQ0FBQyxTQUFTLENBQUMsQ0FBQyxJQUFJLEVBQUUsQ0FBQyxJQUFJLENBQUMsQ0FBQzs7QUFFMUMsTUFBSSxRQUFRLEdBQUcsSUFBSSxDQUFDLEtBQUssQ0FBQyxJQUFJLENBQUMsS0FBSyxDQUFDLElBQUksR0FBQyxNQUFNLENBQUMsUUFBUSxDQUFDLEVBQUUsQ0FBQyxFQUFFLElBQUksQ0FBQyxTQUFTLEdBQUMsQ0FBQyxDQUFDLENBQUM7QUFDakYsTUFBSSxRQUFRLEdBQUcsSUFBSSxDQUFDLEtBQUssQ0FBQyxJQUFJLENBQUMsS0FB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SyxDQUFDO0FBQ2xDLFFBQUssSUFBSSxDQUFDLEdBQUcsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxDQUFDLENBQUM7QUFDcEIsUUFBSyxPQUFPLEdBQUcsSUFBSSxDQUFDO0FBQ3BCLFFBQUssS0FBSyxHQUFHLEdBQUcsQ0FBQyxZQUFZLENBQUMsVUFBVSxFQUFFLFVBQVUsQ0FBQztBQUFDO0VBQ3REOztBQVZJLEtBQUksV0FZVCxNQUFNLG1CQUFDLEVBQUUsRUFBRTtBQUNWLHNCQUFNLE1BQU0sS0FBQSxPQUFDLEVBQUUsQ0FBQyxDQUFDO0FBQ2pCLE1BQUksSUFBSSxDQUFDLEdBQUcsQ0FBQyxNQUFNLEVBQUUsR0FBRyxDQUFDLEVBQUU7QUFDMUIsT0FBSSxLQUFLLEdBQUcsSUFBSSxLQUFLLENBQUMsSUFBSSxDQUFDLElBQUksRUFBRSxJQUFJLENBQUMsR0FBRyxDQUFDLENBQUMsRUFBRSxJQUFJLENBQUMsR0FBRyxDQUFDLENBQUMsRUFBRSxJQUFJLENBQUMsR0FBRyxDQUFDLEdBQUcsRUFBRSxJQUFJLENBQUMsR0FBRyxDQUFDLENBQUMsR0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDO0FBQ3RGLFFBQUssQ0FBQyxJQUFJLEdBQUcsSUFBSSxDQUFDLElBQUksQ0FBQztBQUN2QixRQUFLLENBQUMsR0FBRyxDQUFDLENBQUMsSUFBSSxJQUFJLENBQUMsQUFBQyxLQUFLLENBQUMsR0FBRyxDQUFDLENBQUMsSUFBSSxJQUFJLENBQUMsR0FBRyxDQUFDLENBQUMsQ0FBQTtBQUM5QyxRQUFLLENBQUMsR0FBRyxDQUFDLENBQUMsSUFBSSxJQUFJLENBQUMsQUFBQyxLQUFLLENBQUMsR0FBRyxDQUFDLENBQUMsSUFBSSxJQUFJLENBQUMsR0FBRyxDQUFDLENBQUMsQ0FBQTtBQUM5QyxRQUFLLENBQUMsSUFBSSxJQUFJLElBQUksQ0FBQyxBQUFDLEtBQUssQ0FBQyxJQUFJLElBQUksSUFBSSxDQUFDLElBQUksQ0FBQTtBQUMzQyxPQUFJLENBQUMsSUFBSSxDQUFDLFNBQVMsQ0FBQyxLQUFLLENBQUMsQ0FBQztHQUMz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LENBQUMsRUFBRSxFQUFFLEVBQUUsQ0FBQyxFQUFFLEVBQUUsRUFBRSxDQUFDLEVBQUUsRUFBRSxFQUFFLENBQUMsRUFBRSxFQUFFLEVBQUUsQ0FBQyxFQUFFLEVBQUUsRUFBRSxDQUFDLEVBQUUsRUFBRSxFQUFFLENBQUMsRUFBRSxFQUFFLEVBQUUsQ0FBQyxFQUFFLEVBQUUsRUFBRSxDQUFDLEVBQUUsRUFBRSxFQUFFLENBQUMsRUFBRSxFQUFFLEVBQUUsQ0FBQyxFQUFFLEVBQUUsRUFBRSxDQUFDLEVBQUUsRUFBRSxFQUFFLENBQUMsRUFBRSxFQUFFLEVBQUUsQ0FBQyxFQUFFLEVBQUU7QUFDcEwsTUFBSSxFQUFFLEVBQUUsRUFBRSxFQUFFLEVBQUUsRUFBRSxFQUFFLEtBQUssRUFBRSxFQUFFLEVBQUUsSUFBSSxFQUFFLEVBQUU7QUFDckMsUUFBTSxFQUFFLEVBQUUsRUFBRSxNQUFNLEVBQUUsRUFBRTtBQUN0QixXQUFTLEVBQUUsQ0FBQyxFQUFFLEtBQUssRUFBRSxFQUFFLEVBQUUsR0FBRyxFQUFFLENBQUM7QUFDL0IsTUFBSSxFQUFFLEVBQUUsRUFBRSxJQUFJLEVBQUUsRUFBRSxFQUFFLElBQUksRUFBRSxFQUFFLEVBQUUsSUFBSSxFQUFFLEVBQUUsRUFBRSxJQUFJLEVBQUUsRUFBRSxFQUFFLElBQUksRUFBRSxFQUFFLEVBQUUsSUFBSSxFQUFFLEVBQUUsRUFBRSxJQUFJLEVBQUUsRUFBRSxFQUFFLElBQUksRUFBRSxFQUFFLEVBQUUsSUFBSSxFQUFFLEVBQUU7QUFDbEcsU0FBTyxFQUFFLEVBQUUsRUFBRSxPQUFPLEVBQUUsRUFBRSxFQUFFLE9BQU8sRUFBRSxFQUFFLEVBQUUsT0FBTyxFQUFFLEVBQUUsRUFBRSxPQUFPLEVBQUUsR0FBRyxFQUFFLE9BQU8sRUFBRSxHQUFHLEVBQUUsT0FBTyxFQUFFLEdBQUcsRUFBRSxPQUFPLEVBQUUsR0FBRyxFQUFFLE9BQU8sRUFBRSxHQUFHLEVBQUUsT0FBTyxFQUFFLEdBQUc7QUFDdEksYUFBVyxFQUFFLEdBQUcsRUFBRSxVQUFVLEVBQUUsR0FBRyxFQUFFLFdBQVcsRUFBRSxFQUFFLEVBQUUsV0FBVyxFQUFFLEdBQUc7QUFDcEUsSUFBRSxFQUFFLEdBQUcsRUFBRSxFQUFFLEVBQUUsR0FBRyxFQUFFLEVBQUUsRUFBRSxHQUFHLEVBQUUsRUFBRSxFQUFFLEdBQUcsRUFBRSxFQUFFLEVBQUUsR0FBRyxFQUFFLEVBQUUsRUFBRSxHQUFHLEVBQUUsRUFBRSxFQUFFLEdBQUcsRUFBRSxFQUFFLEVBQUUsR0FBRyxFQUFFLEVBQUUsRUFBRSxHQUFHLEVBQUUsR0FBRyxFQUFFLEdBQUcsRUFBRSxHQUFHLEVBQUUsR0FBRyxFQUFFLEdBQUcsRUFBRSxHQUFHO0FBQzdHLE9BQUssRUFBRSxHQUFHLEVBQUUsS0FBSyxFQUFFLEVBQUUsRUFBRSxJQUFJLEVBQUUsRUFBRSxFQUFFLEdBQUcsRUFBRSxFQUFFO0FBQ3hDLE9BQUssRUFBRSxHQUFHLEVBQUUsTUFBTSxFQUFFLEdBQUcsRUFBRSxLQUFLLEVBQUUsR0FBRyxFQUFFLEtBQUssRUFBRSxHQUFHLEVBQUUsTUFBTSxFQUFFLEdBQUcsRUFBRSxLQUFLLEVBQUUsR0FBRyxFQUFFLFdBQVcsRUFBRSxHQUFHLEVBQUUsWUFBWSxFQUFFLEdBQUcsRUFBRSxTQUFTLEVBQUUsR0FBRyxFQUFFLEtBQUssRUFBRSxHQUFHO0VBQ3pJLENBQUM7O0FBRUYsS0FBTSxTQUFTLEdBQUc7QUFDakIsT0FBSyxFQUFFLENBQUMsVUFBVSxDQUFDLEVBQUUsTUFBTSxFQUFFLENBQUMsT0FBTyxDQUFDLEVBQUUsTUFBTSxFQUFFLENBQUMsS0FBSyxDQUFDLEVBQUUsSUFBSSxFQUFFLENBQUMsU0FBUyxDQUFDLEVBQUUsR0FBRyxFQUFFLENBQUMsTUFBTSxDQUFDO0FBQ3pGLE1BQUksRUFBRSxDQUFDLE1BQU0sQ0FBQyxFQUFFLElBQUksRUFBRSxDQUFDLEtBQUssQ0FBQyxFQUFFLElBQUksRUFBRSxDQUFDLEtBQUssQ0FBQyxFQUFFLElBQUksRUFBRSxDQUFDLE9BQU8sQ0FBQyxFQUFFLElBQUksRUFBRSxDQUFDLE1BQU0sQ0FBQyxF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Q0FBQyxNQUFNLEVBQUU7QUFDbEQsT0FBSSxDQUFDLE1BQU0sRUFBRSxDQUFDO0dBQ2QsTUFBTSxJQUFJLElBQUksQ0FBQyxVQUFVLEdBQUcsSUFBSSxFQUFFO0FBQ2xDLE9BQUksSUFBSSxDQUFDLElBQUksQ0FBQyxNQUFNLENBQUMsR0FBRyxDQUFDLFFBQVEsQ0FBQyxJQUFJLENBQUMsR0FBRyxDQUFDLEdBQUcsRUFBRSxHQUFDLE1BQU0sQ0FBQyxRQUFRLEVBQUU7QUFDakUsVUFBTSxDQUFDLFVBQVUsQ0FBQyxJQUFJLENBQUMsT0FBTyxDQUFDLEVBQUUsQ0FBQyxDQUFDO0lBQ25DO0dBQ0Q7RUFDRDs7QUEvQkksSUFBRyxXQWtDUixNQUFNLG1CQUFDLEtBQUssRUFBRTtBQUNiLE1BQUksQ0FBQyxJQUFJLENBQUMsSUFBSSxDQUFDLE1BQU0sQ0FBQyxJQUFJLENBQUMsSUFBSSxDQUFDLE1BQU0sQ0FBQyxHQUFHLEVBQUUsSUFBSSxDQUFDLElBQUksQ0FBQyxJQUFJLENBQUMsR0FBRyxDQUFDLENBQUMsR0FBQyxJQUFJLENBQUMsTUFBTSxFQUFFLElBQUksQ0FBQyxHQUFHLENBQUMsQ0FBQyxHQUFDLElBQUksQ0FBQyxNQUFNLENBQUMsQ0FBQyxJQUNsRyxDQUFDLElBQUksQ0FBQyxJQUFJLENBQUMsTUFBTSxDQUFDLElBQUksQ0FBQyxJQUFJLENBQUMsTUFBTSxDQUFDLEdBQUcsRUFBRSxJQUFJLENBQUMsSUFBSSxDQUFDLElBQUksQ0FBQyxHQUFHLENBQUMsQ0FBQyxHQUFDLElBQUksQ0FBQyxNQUFNLEVBQUUsSUFBSSxDQUFDLEdBQUcsQ0FBQyxDQUFDLEdBQUMsSUFBSSxDQUFDLE1BQU0sQ0FBQyxDQUFDLElBQ2xHLENBQUMsSUFBSSxDQUFDLElBQUksQ0FBQyxNQUFNLENBQUMsSUFBSSxDQUFDLElBQUksQ0FBQyxNQUFNLENBQUMsR0FBRyxFQUFFLElBQUksQ0FBQyxJQUFJLENBQUMsSUFBSSxDQUFDLEdBQUcsQ0FBQyxDQUFDLEdBQUMsSUFBSSxDQUFDLE1BQU0sRUFBRSxJQUFJLENBQUMs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NUMsUUFBUSxDQUFDLENBQUMsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxDQUFDLENBQUMsRUFBRSxDQUFDLENBQUMsRUFBRSxDQUFDLENBQUMsQ0FBQyxFQUFFLENBQUMsQ0FBQyxDQUFDLEVBQ25DLFFBQVEsQ0FBQyxDQUFDLENBQUMsQ0FBQyxFQUFFLENBQUMsQ0FBQyxFQUFFLENBQUMsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxDQUFDLENBQUMsRUFBRSxDQUFDLENBQUMsQ0FBQyxFQUNuQyxRQUFRLENBQUMsQ0FBQyxDQUFDLENBQUMsRUFBRSxDQUFDLENBQUMsRUFBRSxDQUFDLENBQUMsQ0FBQyxFQUFFLENBQUMsQ0FBQyxFQUFFLENBQUMsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxDQUFDLENBQUMsRUFDbkMsUUFBUSxDQUFDLENBQUMsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxDQUFDLENBQUMsRUFBRSxDQUFDLENBQUMsRUFBRSxDQUFDLENBQUMsQ0FBQyxFQUFFLENBQUMsQ0FBQyxFQUFFLENBQUMsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxDQUFDLENBQUMsRUFDNUMsUUFBUSxDQUFDLENBQUMsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxDQUFDLENBQUMsRUFBRSxDQUFDLENBQUMsRUFBRSxDQUFDLENBQUMsQ0FBQyxFQUFFLENBQUMsQ0FBQyxFQUFFLENBQUMsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxDQUFDLENBQUMsRUFHNUMsUUFBUSxDQUFDLENBQUMsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxDQUFDLENBQUMsRUFBRSxDQUFDLENBQUMsRUFBRSxDQUFDLENBQUMsQ0FBQyxFQUFFLENBQUMsQ0FBQyxDQUFDLEVBQ25DLFFBQVEsQ0FBQyxDQUFDLENBQUMsQ0FBQyxFQUFFLENBQUMsQ0FBQyxFQUFFLENBQUMsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxDQUFDLENBQUMsRUFBRSxDQUFDLENBQUMsQ0FBQyxFQUNuQyxRQUFRLENBQUMsQ0FBQyxDQUFDLENBQUMsRUFBRSxDQUFDLENBQUMsRUFBRSxDQUFDLENBQUMsQ0FBQyxFQUFFLENBQUMsQ0FBQyxFQUFFLENBQUMsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxDQUFDLENBQUMsRUFDbkMsUUFBUSxDQUFDLENBQUMsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxDQUFDLENBQUMsRUFBRSxDQUFDLENBQUMsRUFBRSxDQUFDLENBQUMsQ0FBQyxFQUFFLENBQUMsQ0FBQyxFQUFFLENBQUMsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxDQUFDLENBQUMsRUFFNUMsVUFBVSxDQUFDLENBQUMsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxDQUFDLENBQUMsRUFBRSxDQUFDLENBQUMsRUFBRSxDQUFDLENBQUMsQ0FBQyxFQUFFLENBQUMsQ0FBQyxFQUFFLENBQUMsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxDQUFDLENBQUMsRUFFOUMsU0FBUyxDQUFDLENBQUMsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxDQUFDLENBQUMsRUFBRSxDQUFDLENBQUMsRUFBRSxDQUFDLENBQUMsQ0FBQyxFQUFFLENBQUMsQ0FBQyxFQUFFLENBQUMsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxDQUFDLENBQUMsRUFBRSxDQUFDLENBQUMsRUFBRSxDQUFDLENBQUMsQ0FBQyxFQUFFLENBQUMsQ0FBQyxDQUFDLEVBQy9ELFFBQVEsQ0FBQyxDQUFDLENBQUMsQ0FBQyxFQUFFLENBQUMsQ0FBQyxFQUFFLENBQUMsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxDQUFDLENBQUMsRUFBRSxDQUFDLENBQUMsRUFBRSxDQUFDLENBQUMsQ0FBQyxFQUFFLENBQUMsQ0FBQyxFQUFFLENBQUMsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxDQUFDLENBQUMsRUFBRSxDQUFDLENBQUMsQ0FBQyxFQUM5RCxRQUFRLENBQUMsQ0FBQyxDQUFDLENBQUMsRUFBRSxDQUFDLENBQUMsRUFBRSxDQUFDLENBQUMsQ0FBQyxFQUFFLENBQUMsQ0FBQyxFQUFFLENBQUMsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxDQUFDLENBQUMsRUFBRSxDQUFDLENBQUMsRUFBRSxDQUFDLENBQUMsQ0FBQyxFQUFFLENBQUMsQ0FBQzs7O0FBQUMsQ0FHckQsQ0FBQzs7QUFHRixJQUFNLFNBQVMsR0FBRztBQUNqQixNQUFLLEVBQUUsRUFBRTtBQUNULE9BQU0sRUFBRSxFQUFFO0FBQ1YsT0FBTSxFQUFFLENBQUM7QUFDVCxPQUFNLEVBQUUsQ0FBQztBQUNULE1BQUssRUFBRSxDQUNSLENBQUMsRUFBQyxDQUFDLEVBQUMsQ0FBQyxFQUFDLENBQUMsRUFBQyxDQUFDLEVBQUMsQ0FBQyxFQUFDLENBQUMsRUFBQyxDQUFDLEVBQUMsQ0FBQyxFQUFDLENBQUMsRUFBQyxDQUFDLEVBQUMsQ0FBQyxFQUFDLENBQUMsRUFBQyxDQUFDLEVBQUMsQ0FBQyxFQUFDLENBQUMsRUFBQyxDQUFDLEVBQUMsQ0FBQyxFQUFDLENBQUMsRUFBQyxDQUFDLEVBQUMsQ0FBQyxFQUFDLENBQUMsRUFBQyxDQUFDLEVBQUMsQ0FBQyxFQUFDLENBQUMsRUFBQyxDQUFDLEVBQUMsQ0FBQyxFQUFDLENBQUMsRUFBQyxDQUFDLEVBQUMsQ0FBQyxFQUMzRCxDQUFDLEVBQUMsQ0FBQyxFQUFDLENBQUMsRUFBQyxDQUFDLEVBQUMsRUFBRSxFQUFDLENBQUMsRUFBQyxDQUFDLEVBQUMsQ0FBQyxFQUFDLENBQUMsRUFBQyxFQUFFLEVBQUMsQ0FBQyxFQUFDLENBQUMsRUFBQyxDQUFDLEVBQUMsQ0FBQyxFQUFDLENBQUMsRUFBQyxDQUFDLEVBQUMsQ0FBQyxFQUFDLEVBQUUsRUFBQyxDQUFDLEVBQUMsQ0FBQyxFQUFDLENBQUMsRUFBQyxFQUFFLEVBQUMsQ0FBQyxFQUFDLENBQUMsRUFBQyxFQUFFLEVBQUMsRUFBRSxFQUFDLENBQUMsRUFBQyxDQUFDLEVBQUMsQ0FBQyxFQUFDLENBQUMsRUFDakUsQ0FBQyxFQUFDLENBQUMsRUFBQyxDQUFDLEVBQUMsQ0FBQyxFQUFDLEVBQUUsRUFBQyxDQUFDLEVBQUMsQ0FBQyxFQUFDLENBQUMsRUFBQyxDQUFDLEVBQUMsQ0FBQyxFQUFDLEVBQUUsRUFBQyxDQUFDLEVBQUMsQ0FBQyxFQUFDLENBQUMsRUFBQyxDQUFDLEVBQUMsQ0FBQyxFQUFDLENBQUMsRUFBQyxFQUFFLEVBQUMsQ0FBQyxFQUFDLEVBQUUsRUFBQyxDQUFDLEVBQUMsRUFBRSxFQUFDLENBQUMsRUFBQyxDQUFDLEVBQUMsQ0FBQyxFQUFDLENBQUMsRUFBQyxDQUFDLEVBQUMsQ0FBQyxFQUFDLENBQUMsRUFBQyxDQUFDLEVBQ2hFLENBQUMsRUFBQyxDQUFDLEVBQUMsQ0FBQyxFQUFDLENBQUMsRUFBQyxDQUFDLEVBQUMsRUFBRSxFQUFDLENBQUMsRUFBQyxDQUFDLEVBQUMsQ0FBQyxFQUFDLENBQUMsRUFBQyxDQUFDLEVBQUMsQ0FBQyxFQUFDLENBQUMsRUFBQyxDQUFDLEVBQUMsQ0FBQyxFQUFDLENBQUMsRUFBQyxDQUFDLEVBQUMsRUFBRSxFQUFDLEVBQUUsRUFBQyxFQUFFLEVBQUMsQ0FBQyxFQUFDLEVBQUUsRUFBQyxFQUFFLEVBQUMsQ0FBQyxFQUFDLENBQUMsRUFBQyxDQUFDLEVBQUMsRUFBRSxFQUFDLENBQUMsRUFBQyxDQUFDLEVBQUMsQ0FBQyxFQUNsRSxDQUFDLEVBQUMsQ0FBQyxFQUFDLENBQUMsRUFBQyxDQUFDLEVBQUMsQ0FBQyxFQUFDLENBQUMsRUFBQyxDQUFDLEVBQUMsQ0FBQyxFQUFDLENBQUMsRUFBQyxFQUFFLEVBQUMsQ0FBQyxFQUFDLENBQUMsRUFBQyxDQUFDLEVBQUMsQ0FBQyxFQUFDLENBQUMsRUFBQyxDQUFDLEVBQUMsQ0FBQyxFQUFDLEVBQUUsRUFBQyxDQUFDLEVBQUMsQ0FBQyxFQUFDLENBQUMsRUFBQyxDQUFDLEVBQUMsRUFBRSxFQUFDLENBQUMsRUFBQyxDQUFDLEVBQUMsRUFBRSxFQUFDLEVBQUUsRUFBQyxDQUFDLEVBQUMsQ0FBQyxFQUFDLENBQUMsRUFDaEUsQ0FBQyxFQUFDLEVBQUUsRUFBQyxFQUFFLEVBQUMsRUFBRSxFQUFDLEVBQUUsRUFBQyxDQUFDLEVBQUMsQ0FBQyxFQUFDLENBQUMsRUFBQyxDQUFDLEVBQUMsQ0FBQyxFQUFDLEVBQUUsRUFBQyxDQUFDLEVBQUMsQ0FBQyxFQUFDLENBQUMsRUFBQyxDQUFDLEVBQUMsQ0FBQyxFQUFDLENBQUMsRUFBQyxFQUFFLEVBQUMsQ0FBQyxFQUFDLENBQUMsRUFBQyxDQUFDLEVBQUMsQ0FBQyxFQUFDLENBQUMsRUFBQyxDQUFDLEVBQUMsQ0FBQyxFQUFDLENBQUMsRUFBQyxDQUFDLEVBQUMsQ0FBQyxFQUFDLENBQUMsRUFBQyxDQUFDLEVBQ2pFLENBQUMsRUFBQyxDQUFDLEVBQUMsQ0FBQyxFQUFDLENBQUMsRUFBQyxDQUFDLEVBQUMsQ0FBQyxFQUFDLENBQUMsRUFBQyxDQUFDLEVBQUMsQ0FBQyxFQUFDLENBQUMsRUFBQyxDQUFDLEVBQUMsQ0FBQyxFQUFDLENBQUMsRUFBQyxDQUFDLEVBQUMsQ0FBQyxFQUFDLENBQUMsRUFBQyxDQUFDLEVBQUMsRUFBRSxFQUFDLENBQUMsRUFBQyxDQUFDLEVBQUMsQ0FBQyxFQUFDLEVBQUUsRUFBQyxDQUFDLEVBQUMsRUFBRSxFQUFDLENBQUMsRUFBQyxDQUFDLEVBQUMsRUFBRSxFQUFDLEVBQUUsRUFBQyxDQUFDLEVBQUMsQ0FBQyxFQUNoRSxDQUFDLEVBQUMsQ0FBQyxFQUFDLENBQUMsRUFBQyxDQUFDLEVBQUMsQ0FBQyxFQUFDLENBQUMsRUFBQyxDQUFDLEVBQUMsQ0FBQyxFQUFDLENBQUMsRUFBQyxDQUFDLEVBQUMsQ0FBQyxFQUFDLEVBQUUsRUFBQyxDQUFDLEVBQUMsQ0FBQyxFQUFDLENBQUMsRUFBQyxDQUFDLEVBQUMsQ0FBQyxFQUFDLEVBQUUsRUFBQyxFQUFFLEVBQUMsRUFBRSxFQUFDLENBQUMsRUFBQyxDQUFDLEVBQUMsRUFBRSxFQUFDLEVBQUUsRUFBQyxDQUFDLEVBQUMsQ0FBQyxFQUFDLENBQUMsRUFBQyxDQUFDLEVBQUMsQ0FBQyxFQUFDLENBQUMsRUFDakUsQ0FBQyxFQUFDLENBQUMsRUFBQyxFQUFFLEVBQUMsQ0FBQyxFQUFDLENBQUMsRUFBQyxDQUFDLEVBQUMsQ0FBQyxFQUFDLENBQUMsRUFBQyxDQUFDLEVBQUMsQ0FBQyxFQUFDLENBQUMsRUFBQyxDQUFDLEVBQUMsRUFBRSxFQUFDLENBQUMsRUFBQyxDQUFDLEVBQUMsQ0FBQyxFQUFDLENBQUMsRUFBQyxFQUFFLEVBQUMsQ0FBQyxFQUFDLEVBQUUsRUFBQyxDQUFDLEVBQUMsQ0FBQyxFQUFDLEVBQUUsRUFBQyxDQUFDLEVBQUMsQ0FBQyxFQUFDLENBQUMsRUFBQyxDQUFDLEVBQUMsRUFBRSxFQUFDLENBQUMsRUFBQyxDQUFDLEVBQ2pFLENBQUMsRUFBQyxDQUFDLEVBQUMsQ0FBQyxFQUFDLENBQUMsRUFBQyxDQUFDLEVBQUMsQ0FBQyxFQUFDLENBQUMsRUFBQyxDQUFDLEVBQUMsQ0FBQyxFQUFDLENBQUMsRUFBQyxDQUFDLEVBQUMsQ0FBQyxFQUFDLENBQUMsRUFBQyxDQUFDLEVBQUMsQ0FBQyxFQUFDLENBQUMsRUFBQyxDQUFDLEVBQUMsRUFBRSxFQUFDLENBQUMsRUFBQyxDQUFDLEVBQUMsQ0FBQyxFQUFDLENBQUMsRUFBQyxDQUFDLEVBQUMsQ0FBQyxFQUFDLENBQUMsRUFBQyxFQUFFLEVBQUMsQ0FBQyxFQUFDLENBQUMsRUFBQyxDQUFDLEVBQUMsQ0FBQyxFQUM3RCxDQUFDLEVBQUMsQ0FBQyxFQUFDLEVBQUUsRUFBQyxDQUFDLEVBQUMsQ0FBQyxFQUFDLEVBQUUsRUFBQyxDQUFDLEVBQUMsQ0FBQyxFQUFDLENBQUMsRUFBQyxDQUFDLEVBQUMsQ0FBQyxFQUFDLENBQUMsRUFBQyxDQUFDLEVBQUMsQ0FBQyxFQUFDLENBQUMsRUFBQyxDQUFDLEVBQUMsQ0FBQyxFQUFDLENBQUMsRUFBQyxFQUFFLEVBQUMsQ0FBQyxFQUFDLENBQUMsRUFBQyxDQUFDLEVBQUMsQ0FBQyxFQUFDLENBQUMsRUFBQyxFQUFFLEVBQUMsRUFBRSxFQUFDLENBQUMsRUFBQyxDQUFDLEVBQUMsQ0FBQyxFQUFDLENBQUMsRUFDaEUsQ0FBQyxFQUFDLENBQUMsRUFBQyxDQUFDLEVBQUMsRUFBRSxFQUFDLENBQUMsRUFBQyxFQUFFLEVBQUMsQ0FBQyxFQUFDLENBQUMsRUFBQyxDQUFDLEVBQUMsQ0FBQyxFQUFDLENBQUMsRUFBQyxDQUFDLEVBQUMsQ0FBQyxFQUFDLENBQUMsRUFBQyxDQUFDLEVBQUMsQ0FBQyxFQUFDLENBQUMsRUFBQyxDQUFDLEVBQUMsQ0FBQyxFQUFDLENBQUMsRUFBQyxDQUFDLEVBQUMsQ0FBQyxFQUFDLENBQUMsRUFBQyxDQUFDLEVBQUMsRUFBRSxFQUFDLEVBQUUsRUFBQyxDQUFDLEVBQUMsQ0FBQyxFQUFDLENBQUMsRUFBQyxDQUFDLEVBQy9ELENBQUMsRUFBQyxDQUFDLEVBQUMsQ0FBQyxFQUFDLENBQUMsRUFBQyxDQUFDLEVBQUMsRUFBRSxFQUFDLENBQUMsRUFBQyxDQUFDLEVBQUMsQ0FBQyxFQUFDLENBQUMsRUFBQyxDQUFDLEVBQUMsQ0FBQyxFQUFDLENBQUMsRUFBQyxDQUFDLEVBQUMsQ0FBQyxFQUFDLENBQUMsRUFBQyxFQUFFLEVBQUMsQ0FBQyxFQUFDLENBQUMsRUFBQyxDQUFDLEVBQUMsQ0FBQyxFQUFDLENBQUMsRUFBQyxDQUFDLEVBQUMsQ0FBQyxFQUFDLENBQUMsRUFBQyxDQUFDLEVBQUMsQ0FBQyxFQUFDLENBQUMsRUFBQyxDQUFDLEVBQUMsQ0FBQyxFQUM3RCxDQUFDLEVBQUMsRUFBRSxFQUFDLENBQUMsRUFBQyxFQUFFLEVBQUMsQ0FBQyxFQUFDLENBQUMsRUFBQyxDQUFDLEVBQUMsQ0FBQyxFQUFDLENBQUMsRUFBQyxDQUFDLEVBQUMsRUFBRSxFQUFDLENBQUMsRUFBQyxDQUFDLEVBQUMsQ0FBQyxFQUFDLENBQUMsRUFBQyxDQUFDLEVBQUMsQ0FBQyxFQUFDLENBQUMsRUFBQyxDQUFDLEVBQUMsQ0FBQyxFQUFDLENBQUMsRUFBQyxDQUFDLEVBQUMsQ0FBQyxFQUFDLENBQUMsRUFBQyxDQUFDLEVBQUMsQ0FBQyxFQUFDLENBQUMsRUFBQyxDQUFDLEVBQUMsRUFBRSxFQUFDLENBQUMsRUFDL0QsQ0FBQyxFQUFDLENBQUMsRUFBQyxDQUFDLEVBQUMsQ0FBQyxFQUFDLENBQUMsRUFBQyxDQUFDLEVBQUMsQ0FBQyxFQUFDLENBQUMsRUFBQyxDQUFDLEVBQUMsRUFBRSxFQUFDLENBQUMsRUFBQyxDQUFDLEVBQUMsQ0FBQyxFQUFDLENBQUMsRUFBQyxDQUFDLEVBQUMsQ0FBQyxFQUFDLENBQUMsRUFBQyxDQUFDLEVBQUMsQ0FBQyxFQUFDLENBQUMsRUFBQyxDQUFDLEVBQUMsQ0FBQyxFQUFDLENBQUMsRUFBQyxDQUFDLEVBQUMsQ0FBQyxFQUFDLENBQUMsRUFBQyxDQUFDLEVBQUMsQ0FBQyxFQUFDLENBQUMsRUFBQyxDQUFDLEVBQzVELENBQUMsRUFBQyxDQUFDLEVBQUMsQ0FBQyxFQUFDLEVBQUUsRUFBQyxDQUFDLEVBQUMsQ0FBQyxFQUFDLENBQUMsRUFBQyxDQUFDLEVBQUMsQ0FBQyxFQUFDLENBQUMsRUFBQyxDQUFDLEVBQUMsQ0FBQyxFQUFDLENBQUMsRUFBQyxDQUFDLEVBQUMsQ0FBQyxFQUFDLENBQUMsRUFBQyxDQUFDLEVBQUMsQ0FBQyxFQUFDLENBQUMsRUFBQyxDQUFDLEVBQUMsQ0FBQyxFQUFDLENBQUMsRUFBQyxDQUFDLEVBQUMsQ0FBQyxFQUFDLENBQUMsRUFBQyxDQUFDLEVBQUMsQ0FBQyxFQUFDLENBQUMsRUFBQyxDQUFDLEVBQUMsQ0FBQyxFQUM1RCxDQUFDLEVBQUMsQ0FBQyxFQUFDLEVBQUUsRUFBQyxFQUFFLEVBQUMsQ0FBQyxFQUFDLENBQUMsRUFBQyxDQUFDLEVBQUMsQ0FBQyxFQUFDLENBQUMsRUFBQyxDQUFDLEVBQUMsQ0FBQyxFQUFDLENBQUMsRUFBQyxDQUFDLEVBQUMsQ0FBQyxFQUFDLENBQUMsRUFBQyxDQUFDLEVBQUMsQ0FBQyxFQUFDLENBQUMsRUFBQyxDQUFDLEVBQUMsQ0FBQyxFQUFDLENBQUMsRUFBQyxDQUFDLEVBQUMsQ0FBQyxFQUFDLENBQUMsRUFBQyxFQUFFLEVBQUMsQ0FBQyxFQUFDLEVBQUUsRUFBQyxDQUFDLEVBQUMsQ0FBQyxFQUFDLENBQUMsRUFDL0QsQ0FBQyxFQUFDLENBQUMsRUFBQyxDQUFDLEVBQUMsQ0FBQyxFQUFDLENBQUMsRUFBQyxDQUFDLEVBQUMsQ0FBQyxFQUFDLENBQUMsRUFBQyxDQUFDLEVBQUMsQ0FBQyxFQUFDLENBQUMsRUFBQyxDQUFDLEVBQUMsQ0FBQyxFQUFDLENBQUMsRUFBQyxDQUFDLEVBQUMsQ0FBQyxFQUFDLEVBQUUsRUFBQyxDQUFDLEVBQUMsQ0FBQyxFQUFDLENBQUMsRUFBQyxDQUFDLEVBQUMsQ0FBQyxFQUFDLEVBQUUsRUFBQyxDQUFDLEVBQUMsRUFBRSxFQUFDLENBQUMsRUFBQyxFQUFFLEVBQUMsQ0FBQyxFQUFDLENBQUMsRUFBQyxDQUFDLEVBQy9ELENBQUMsRUFBQyxDQUFDLEVBQUMsQ0FBQyxFQUFDLENBQUMsRUFBQyxFQUFFLEVBQUMsQ0FBQyxFQUFDLENBQUMsRUFBQyxDQUFDLEVBQUMsQ0FBQyxFQUFDLEVBQUUsRUFBQyxDQUFDLEVBQUMsRUFBRSxFQUFDLENBQUMsRUFBQyxDQUFDLEVBQUMsQ0FBQyxFQUFDLENBQUMsRUFBQyxDQUFDLEVBQUMsQ0FBQyxFQUFDLENBQUMsRUFBQyxDQUFDLEVBQUMsQ0FBQyxFQUFDLEVBQUUsRUFBQyxDQUFDLEVBQUMsQ0FBQyxFQUFDLENBQUMsRUFBQyxDQUFDLEVBQUMsQ0FBQyxFQUFDLENBQUMsRUFBQyxDQUFDLEVBQUMsQ0FBQyxFQUMvRCxDQUFDLEVBQUMsQ0FBQyxFQUFDLENBQUMsRUFBQyxDQUFDLEVBQUMsRUFBRSxFQUFDLENBQUMsRUFBQyxDQUFDLEVBQUMsQ0FBQyxFQUFDLENBQUMsRUFBQyxDQUFDLEVBQUMsQ0FBQyxFQUFDLENBQUMsRUFBQyxDQUFDLEVBQUMsQ0FBQyxFQUFDLENBQUMsRUFBQyxDQUFDLEVBQUMsQ0FBQyxFQUFDLENBQUMsRUFBQyxDQUFDLEVBQUMsQ0FBQyxFQUFDLENBQUMsRUFBQyxDQUFDLEVBQUMsQ0FBQyxFQUFDLENBQUMsRUFBQyxDQUFDLEVBQUMsQ0FBQyxFQUFDLENBQUMsRUFBQyxDQUFDLEVBQUMsQ0FBQyxFQUFDLENBQUMsRUFDNUQsQ0FBQyxFQUFDLENBQUMsRUFBQyxDQUFDLEVBQUMsQ0FBQyxFQUFDLEVBQUUsRUFBQyxDQUFDLEVBQUMsQ0FBQyxFQUFDLENBQUMsRUFBQyxDQUFDLEVBQUMsRUFBRSxFQUFDLENBQUMsRUFBQyxFQUFFLEVBQUMsQ0FBQyxFQUFDLENBQUMsRUFBQyxDQUFDLEVBQUMsQ0FBQyxFQUFDLENBQUMsRUFBQyxDQUFDLEVBQUMsQ0FBQyxFQUFDLENBQUMsRUFBQyxDQUFDLEVBQUMsQ0FBQyxFQUFDLENBQUMsRUFBQyxDQUFDLEVBQUMsQ0FBQyxFQUFDLENBQUMsRUFBQyxDQUFDLEVBQUMsQ0FBQyxFQUFDLENBQUMsRUFBQyxDQUFDLEVBQzlELENBQUMsRUFBQyxDQUFDLEVBQUMsQ0FBQyxFQUFDLENBQUMsRUFBQyxFQUFFLEVBQUMsRUFBRSxFQUFDLENBQUMsRUFBQyxDQUFDLEVBQUMsQ0FBQyxFQUFDLENBQUMsRUFBQyxDQUFDLEVBQUMsQ0FBQyxFQUFDLENBQUMsRUFBQyxDQUFDLEVBQUMsQ0FBQyxFQUFDLENBQUMsRUFBQyxDQUFDLEVBQUMsQ0FBQyxFQUFDLENBQUMsRUFBQyxDQUFDLEVBQUMsQ0FBQyxFQUFDLEVBQUUsRUFBQyxFQUFFLEVBQUMsQ0FBQyxFQUFDLENBQUMsRUFBQyxDQUFDLEVBQUMsQ0FBQyxFQUFDLENBQUMsRUFBQyxDQUFDLEVBQUMsQ0FBQyxFQUMvRCxDQUFDLEVBQUMsQ0FBQyxFQUFDLENBQUMsRUFBQyxDQUFDLEVBQUMsQ0FBQyxFQUFDLEVBQUUsRUFBQyxDQUFDLEVBQUMsQ0FBQyxFQUFDLENBQUMsRUFBQyxDQUFDLEVBQUMsQ0FBQyxFQUFDLENBQUMsRUFBQyxDQUFDLEVBQUMsQ0FBQyxFQUFDLENBQUMsRUFBQyxDQUFDLEVBQUMsQ0FBQyxFQUFDLEVBQUUsRUFBQyxDQUFDLEVBQUMsQ0FBQyxFQUFDLENBQUMsRUFBQyxDQUFDLEVBQUMsQ0FBQyxFQUFDLEVBQUUsRUFBQyxFQUFFLEVBQUMsQ0FBQyxFQUFDLENBQUMsRUFBQyxDQUFDLEVBQUMsQ0FBQyxFQUFDLENBQUMsRUFDL0QsQ0FBQyxFQUFDLENBQUMsRUFBQyxDQUFDLEVBQUMsQ0FBQyxFQUFDLENBQUMsRUFBQyxFQUFFLEVBQUMsQ0FBQyxFQUFDLENBQUMsRUFBQyxDQUFDLEVBQUMsQ0FBQyxFQUFDLENBQUMsRUFBQyxDQUFDLEVBQUMsQ0FBQyxFQUFDLENBQUMsRUFBQyxDQUFDLEVBQUMsQ0FBQyxFQUFDLENBQUMsRUFBQyxDQUFDLEVBQUMsQ0FBQyxFQUFDLENBQUMsRUFBQyxDQUFDLEVBQUMsQ0FBQyxFQUFDLENBQUMsRUFBQyxDQUFDLEVBQUMsQ0FBQyxFQUFDLENBQUMsRUFBQyxDQUFDLEVBQUMsQ0FBQyxFQUFDLENBQUMsRUFBQyxDQUFDLEVBQzVELENBQUMsRUFBQyxDQUFDLEVBQUMsQ0FBQyxFQUFDLENBQUMsRUFBQyxDQUFDLEVBQUMsQ0FBQyxFQUFDLENBQUMsRUFBQyxDQUFDLEVBQUMsQ0FBQyxFQUFDLENBQUMsRUFBQyxDQUFDLEVBQUMsQ0FBQyxFQUFDLENBQUMsRUFBQyxDQUFDLEVBQUMsQ0FBQyxFQUFDLENBQUMsRUFBQyxDQUFDLEVBQUMsRUFBRSxFQUFDLEVBQUUsRUFBQyxDQUFDLEVBQUMsQ0FBQyxFQUFDLENBQUMsRUFBQyxDQUFDLEVBQUMsQ0FBQyxFQUFDLENBQUMsRUFBQyxDQUFDLEVBQUMsQ0FBQyxFQUFDLENBQUMsRUFBQyxDQUFDLEVBQUMsQ0FBQyxFQUM3RCxDQUFDLEVBQUMsQ0FBQyxFQUFDLENBQUMsRUFBQyxDQUFDLEVBQUMsQ0FBQyxFQUFDLENBQUMsRUFBQyxDQUFDLEVBQUMsQ0FBQyxFQUFDLENBQUMsRUFBQyxDQUFDLEVBQUMsQ0FBQyxFQUFDLENBQUMsRUFBQyxDQUFDLEVBQUMsQ0FBQyxFQUFDLENBQUMsRUFBQyxDQUFDLEVBQUMsQ0FBQyxFQUFDLENBQUMsRUFBQyxDQUFDLEVBQUMsRUFBRSxFQUFDLEVBQUUsRUFBQyxFQUFFLEVBQUMsRUFBRSxFQUFDLEVBQUUsRUFBQyxFQUFFLEVBQUMsQ0FBQyxFQUFDLENBQUMsRUFBQyxDQUFDLEVBQUMsQ0FBQyxFQUFDLENBQUMsRUFDakUsQ0FBQyxFQUFDLENBQUMsRUFBQyxDQUFDLEVBQUMsQ0FBQyxFQUFDLENBQUMsRUFBQyxDQUFDLEVBQUMsQ0FBQyxFQUFDLENBQUMsRUFBQyxDQUFDLEVBQUMsQ0FBQyxFQUFDLENBQUMsRUFBQyxDQUFDLEVBQUMsQ0FBQyxFQUFDLENBQUMsRUFBQyxDQUFDLEVBQUMsQ0FBQyxFQUFDLENBQUMsRUFBQyxDQUFDLEVBQUMsQ0FBQyxFQUFDLENBQUMsRUFBQyxDQUFDLEVBQUMsQ0FBQyxFQUFDLENBQUMsRUFBQyxDQUFDLEVBQUMsQ0FBQyxFQUFDLENBQUMsRUFBQyxDQUFDLEVBQUMsQ0FBQyxFQUFDLENBQUMsRUFBQyxDQUFDLEVBQzNELENBQUMsRUFBQyxDQUFDLEVBQUMsQ0FBQyxFQUFDLENBQUMsRUFBQyxDQUFDLEVBQUMsQ0FBQyxFQUFDLENBQUMsRUFBQyxDQUFDLEVBQUMsQ0FBQyxFQUFDLENBQUMsRUFBQyxDQUFDLEVBQUMsQ0FBQyxFQUFDLENBQUMsRUFBQyxDQUFDLEVBQUMsQ0FBQyxFQUFDLENBQUMsRUFBQyxDQUFDLEVBQUMsRUFBRSxFQUFDLENBQUMsRUFBQyxFQUFFLEVBQUMsRUFBRSxFQUFDLEVBQUUsRUFBQyxFQUFFLEVBQUMsRUFBRSxFQUFDLEVBQUUsRUFBQyxDQUFDLEVBQUMsQ0FBQyxFQUFDLENBQUMsRUFBQyxDQUFDLEVBQUMsQ0FBQyxFQUNsRSxDQUFDLEVBQUMsQ0FBQyxFQUFDLENBQUMsRUFBQyxDQUFDLEVBQUMsQ0FBQyxFQUFDLENBQUMsRUFBQyxDQUFDLEVBQUMsQ0FBQyxFQUFDLENBQUMsRUFBQyxDQUFDLEVBQUMsQ0FBQyxFQUFDLENBQUMsRUFBQyxDQUFDLEVBQUMsQ0FBQyxFQUFDLENBQUMsRUFBQyxDQUFDLEVBQUMsQ0FBQyxFQUFDLENBQUMsRUFBQyxDQUFDLEVBQUMsQ0FBQyxFQUFDLENBQUMsRUFBQyxDQUFDLEVBQUMsQ0FBQyxFQUFDLENBQUMsRUFBQyxDQUFDLEVBQUMsQ0FBQyxFQUFDLENBQUMsRUFBQyxDQUFDLEVBQUMsQ0FBQyxFQUFDLENBQUMsRUFDM0QsQ0FBQyxFQUFDLENBQUMsRUFBQyxDQUFDLEVBQUMsQ0FBQyxFQUFDLENBQUMsRUFBQyxDQUFDLEVBQUMsQ0FBQyxFQUFDLENBQUMsRUFBQyxDQUFDLEVBQUMsQ0FBQyxFQUFDLENBQUMsRUFBQyxDQUFDLEVBQUMsQ0FBQyxFQUFDLENBQUMsRUFBQyxDQUFDLEVBQUMsQ0FBQyxFQUFDLENBQUMsRUFBQyxDQUFDLEVBQUMsQ0FBQyxFQUFDLENBQUMsRUFBQyxDQUFDLEVBQUMsQ0FBQyxFQUFDLENBQUMsRUFBQyxDQUFDLEVBQUMsQ0FBQyxFQUFDLENBQUMsRUFBQyxDQUFDLEVBQUMsQ0FBQyxFQUFDLENBQUMsRUFBQzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQUMsRUFpQzFEO0NBQ0EsQ0FBQTs7QUFFRCxPQUFPLENBQUMsU0FBUyxHQUFHLFNBQVMsQ0FBQzs7QUFFOUIsT0FBTyxDQUFDLEtBQUssR0FBRyxLQUFLLENBQUM7QUFDdEIsT0FBTyxDQUFDLFFBQVEsR0FBRyxRQUFRLENBQUM7OztBQzlLNUIsWUFBWSxDQUFDOzs7O0FBQ2IsSUFBTSxJQUFJLEdBQUcsT0FBTyxDQUFDLFFBQVEsQ0FBQzs7QUFBQyxBQUUvQixJQUFNLElBQUksR0FBRyxPQUFPLENBQUMsUUFBUSxDQUFDLENBQUM7O2VBQ2QsT0FBTyxDQUFDLFNBQVMsQ0FBQzs7SUFBNUIsTUFBTSxZQUFOLE1BQU07Ozs7OztBQU9iLFNBQVMsTUFBTSxPQUFlLENBQUMsRUFBRSxDQUFDLEVBQUU7S0FBbkIsS0FBSyxRQUFMLEtBQUs7S0FBRSxHQUFHLFFBQUgsR0FBRzs7QUFDMUIsUUFBTyxDQUFDLEdBQUcsQ0FBQyxDQUFDLEdBQUMsS0FBSyxDQUFDLENBQUMsQ0FBQSxJQUFHLENBQUMsR0FBQyxLQUFLLENBQUMsQ0FBQyxDQUFBLEFBQUMsR0FBRyxDQUFDLEdBQUcsQ0FBQyxDQUFDLEdBQUMsS0FBSyxDQUFDLENBQUMsQ0FBQSxJQUFHLENBQUMsR0FBQyxLQUFLLENBQUMsQ0FBQyxDQUFBLEFBQUMsR0FBRyxHQUFHLENBQUM7Q0FDdkU7O0FBRUQsU0FBUyxTQUFTLENBQUMsQ0FBQyxFQUFFLENBQUMsRUFBRSxNQUFNLEVBQUU7O0FBRWhDLEtBQUksRUFBRSxHQUFHLE1BQU0sQ0FBQyxDQUFDLEVBQUUsSUFBSSxDQUFDLElBQUksQ0FBQyxDQUFDLENBQUMsS0FBSyxDQUFDLENBQUMsRUFBRSxDQUFDLENBQUMsR0FBRyxDQUFDLENBQUMsRUFBRSxJQUFJLENBQUMsRUFDbkMsSUFBSSxDQUFDLElBQUksQ0FBQyxDQUFDLENBQUMsS0FBSyxDQUFDLENBQUMsRUFBRSxDQUFDLENBQUMsR0FBRyxDQUFDLENBQUMsRUFBRSxJQUFJLENBQUMsQ0FBQyxDQUFDO0FBQ3hELEtBQUksRUFBRSxHQUFHLE1BQU0sQ0FBQyxDQUFDLEVBQUUsSUFBSSxDQUFDLElBQUksQ0FBQyxDQUFDLENBQUMsR0FBRyxDQUFDLENBQUMsRUFBRSxDQUFDLENBQUMsS0FBSyxDQUFDLENBQUMsRUFBRSxJQUFJLENBQUMsRUFDbkMsSUFBSSxDQUFDLElBQUksQ0FBQyxDQUFDLENBQUMsR0FBRyxDQUFDLENBQUMsRUFBRSxDQUFDLENBQUMsS0FBSyxDQUFDLENBQUMsRUFBRSxJQUFJLENBQUMsQ0FBQyxDQUFDO0FBQ3hELEtBQUksRUFBRSxHQUFHLE1BQU0sQ0FBQyxDQUFDLEVBQUUsTUFBTSxDQUFDLENBQUMsRUFBRSxNQUFNLENBQUMsQ0FBQyxDQUFDLENBQUM7O0FBRXZDLEtBQUksRUFBRSxHQUFHLE1BQU0sQ0FBQyxDQUFDLEVBQUUsSUFBSSxDQUFDLElBQUksQ0FBQyxDQUFDLENBQUMsS0FBSyxDQUFDLENBQUMsRUFBRSxDQUFDLENBQUMsR0FBRyxDQUFDLENBQUMsRUFBRSxJQUFJLENBQUMsRUFDbkMsSUFBSSxDQUFDLElBQUksQ0FBQyxDQUFDLENBQUMsS0FBSyxDQUFDLENBQUMsRUFBRSxDQUFDLENBQUMsR0FBRyxDQUFDLENBQUMsRUFBRSxJQUFJLENB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QUFDLENBQUMsQ0FBQztBQUN0QixPQUFLLElBQUksQ0FBQyxHQUFHLENBQUMsRUFBRSxDQUFDLEdBQUcsSUFBSSxDQUFDLFFBQVEsQ0FBQyxNQUFNLEVBQUUsRUFBRSxDQUFDLEVBQUU7QUFDOUMsT0FBSSxHQUFHLEdBQUcsSUFBSSxDQUFDLFFBQVEsQ0FBQyxDQUFDLENBQUMsQ0FBQztBQUMzQixPQUFJLEVBQUUsR0FBRyxHQUFHLElBQUksR0FBRyxDQUFDLEtBQUssQ0FBQyxDQUFDLEdBQUcsR0FBRyxDQUFDLEdBQUcsQ0FBQyxDQUFDLENBQUEsQUFBQyxHQUFHLENBQUMsQ0FBQztBQUM3QyxPQUFJLEVBQUUsR0FBRyxHQUFHLElBQUksR0FBRyxDQUFDLEtBQUssQ0FBQyxDQUFDLEdBQUcsR0FBRyxDQUFDLEdBQUcsQ0FBQyxDQUFDLENBQUEsQUFBQyxHQUFHLENBQUMsQ0FBQztBQUM3QyxNQUFHLENBQUMsQ0FBQyxHQUFHLEVBQUUsR0FBQyxFQUFFLEdBQUcsRUFBRSxHQUFDLEVBQUUsQ0FBQztBQUN0QixNQUFHLENBQUMsS0FBSyxDQUFDLEtBQUssR0FBRyxJQUFJLENBQUMsS0FBSyxDQUFDLEdBQUcsQ0FBQyxLQUFLLENBQUMsQ0FBQyxHQUFDLENBQUMsRUFBRSxHQUFHLENBQUMsS0FBSyxDQUFDLENBQUMsR0FBQyxDQUFDLENBQUMsQ0FBQztBQUMzRCxNQUFHLENBQUMsR0FBRyxDQUFDLEtBQUssR0FBRyxJQUFJLENBQUMsS0FBSyxDQUFDLEdBQUcsQ0FBQyxHQUFHLENBQUMsQ0FBQyxHQUFDLENBQUMsRUFBRSxHQUFHLENBQUMsR0FBRyxDQUFDLENBQUMsR0FBQyxDQUFDLENBQUMsQ0FBQztBQUNyRCxPQUFJLEtBQUssR0FBRyxHQUFHLENBQUMsR0FBRyxDQUFDLEtBQUssR0FBRyxHQUFHLENBQUMsS0FBSyxDQUFDLEtBQUssQ0FBQztBQUM1QyxPQUFJLEtBQUssSUFBSSxDQUFDLElBQUksQ0FBQyxFQUFFLEVBQUU7QUFBRSxTQUFLLElBQUksQ0FBQyxHQUFDLElBQUksQ0FBQyxFQUFFLENB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QVUsQ0FBQyxDQUFDLEVBQWU7S0FBYixHQUFHLHlEQUFDLE9BQU87QUFBSSxRQUFPLENBQUMsSUFBSSxHQUFHLElBQUksQ0FBQyxJQUFJLENBQUMsR0FBRyxDQUFDO0NBQUU7O0FBRXJFLE9BQU8sQ0FBQyxXQUFXLEdBQUcsV0FBVyxDQUFDO0FBQ2xDLFNBQVMsV0FBVyxDQUFDLENBQUMsRUFBRSxDQUFDLEVBQWU7S0FBYixHQUFHLHlEQUFDLE9BQU87QUFBSSxRQUFPLElBQUksQ0FBQyxHQUFHLENBQUMsQ0FBQyxHQUFDLENBQUMsQ0FBQyxJQUFJLEdBQUcsR0FBRyxJQUFJLENBQUMsR0FBRyxDQUFDLEdBQUcsRUFBRSxJQUFJLENBQUMsR0FBRyxDQUFDLENBQUMsQ0FBQyxFQUFFLElBQUksQ0FBQyxHQUFHLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQztDQUFFOztBQUVsSCxPQUFPLENBQUMsT0FBTyxHQUFHLE9BQU8sQ0FBQztBQUMxQixTQUFTLE9BQU8sQ0FBQyxDQUFDLEVBQUUsQ0FBQyxFQUFFLENBQUMsRUFBRTtBQUFFLFFBQU8sQ0FBQyxLQUFLLEdBQUcsR0FBRyxDQUFDLEdBQUcsQ0FBQyxHQUFDLENBQUMsQ0FBQztDQUFFOztBQUV6RCxPQUFPLENBQUMsUUFBUSxHQUFHLFFBQVEsQ0FBQztBQUM1QixTQUFTLFFBQVEsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxFQUFFO0FBQUUsUUFBTyxPQUFPLENBQUMsQ0FBQyxFQUFFLENBQUMsRUFBRSxHQUFHLENBQUMsQ0FBQztDQUFFOztBQUV0RCxPQUFPLENBQUMsUUFBUSxHQUFHLFFBQVEsQ0FBQztBQUM1QixTQUFTLFFBQVEsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxFQUFFO0FBQUUsUUFBTyxPQUFPLENBQUMsQ0FBQyxFQUFFLENBQUMsRUFBRSxHQUFHLENBQUMsQ0FBQztDQUFFOztBQUV0RCxPQUFPLENBQUMsTUFBTSxHQUFHLE1BQU0sQ0FBQztBQUN4QixTQUFTLE1BQU0sQ0FBQyxDQUFDLEVBQUU7QUFBRSxRQUFPLENBQUMsR0FBRyxDQUFDLEdBQUcsQ0FBQyxDQUFDLEdBQUksQ0FBQyxHQUFHLENBQUMsR0FBRyxDQUFDLEdBQUcsQ0FBQyxBQUFDLENBQUM7Q0FBRTs7QUFFM0QsT0FBTyxDQUFDLFlBQVksR0FBRyxZQUFZLENBQUM7QUFDcEMsU0FBUyxZQUFZLENBQUMsQ0FBQyxFQUFFO0FBQUUsUUFBTyxDQUFDLEdBQUMsQ0FBQyxHQUFDLENBQUMsSUFBRSxDQUFDLElBQUUsQ0FBQyxHQUFDLEdBQUcsR0FBRyxJQUFJLENBQUEsQUFBQyxHQUFHLElBQUksQ0FBQSxBQUFDLENBQUM7Q0FBRTs7QUFFcEUsT0FBTyxDQUFDLFVBQVUsR0FBRyxVQUFVLENBQUM7QUFDaEMsU0FBUyxVQUFVLENBQUMsQ0FBQyxFQUFFLENBQUMsRUFBRSxDQUFDLEVBQUU7QUFBRSxRQUFPLFFBQVEsQ0FBQyxRQUFRLENBQUMsQ0FBQyxHQUFDLENBQUMsRUFBRSxDQUFDLEdBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQztDQUFFOztBQUVyRSxPQUFPLENBQUMsVUFBVSxHQUFHLFVBQVUsQ0FBQztBQUNoQyxTQUFTLFVBQVUsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxFQUFFLENBQUMsRUFBRTtBQUFFLFFBQU8sWUFBWSxDQUFDLFVBQVUsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxFQUFFLENBQUMsQ0FBQyxDQUFDLENBQUM7Q0FBRTs7QUFFMUUsT0FBTyxDQUFDLE1BQU0sR0FBRyxNQUFNLENBQUM7QUFDeEIsU0FBUyxNQUFNLENBQUMsQ0FBQyxFQUFFLEdBQUcsRUFBRTtBQUFFLFFBQU8sQ0FBQyxHQUFHLElBQUksQ0FBQyxLQUFLLENBQUMsQ0FBQyxHQUFDLEdBQUcsQ0FBQyxHQUFDLEdBQUcsQ0FBQztDQUFFOztBQUU3RCxPQUFPLENBQUMsUUFBUSxHQUFHLFFBQVEsQ0FBQztBQUM1QixTQUFTLFFBQVEsQ0FBQyxDQUFDLEVBQUUsR0FBRyxFQUFFO0FBQUUsUUFBTyxHQUFHLEdBQUcsSUFBSSxDQUFDLEdBQUcsQ0FBQyxNQUFNLENBQUMsQ0FBQyxFQUFFLEdBQUcsR0FBQyxDQUFDLENBQUMs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RUFBRSxHQUFJLElBQUksQ0FBQSxHQUFFLEtBQUssQ0FBQztBQUNwQyxLQUFJLEVBQUUsR0FBRyxDQUFDLEFBQUMsRUFBRSxLQUFLLENBQUMsR0FBSSxJQUFJLENBQUEsR0FBRSxLQUFLLENBQUM7QUFDbkMsS0FBSSxFQUFFLEdBQUcsQ0FBQyxBQUFDLEVBQUUsS0FBSyxDQUFDLEdBQUksSUFBSSxDQUFBLEdBQUUsS0FBSyxDQUFDO0FBQ25DLEtBQUksRUFBRSxHQUFHLENBQUMsQUFBQyxFQUFFLEtBQUssRUFBRSxHQUFJLElBQUksQ0FBQSxHQUFFLEtBQUssQ0FBQzs7QUFFcEMsS0FBSSxFQUFFLEdBQUcsQ0FBQyxBQUFDLEVBQUUsS0FBSyxFQUFFLEdBQUksSUFBSSxDQUFBLEdBQUUsS0FBSyxDQUFDO0FBQ3BDLEtBQUksRUFBRSxHQUFHLENBQUMsQUFBQyxFQUFFLEtBQUssQ0FBQyxHQUFJLElBQUksQ0FBQSxHQUFFLEtBQUssQ0FBQztBQUNuQyxLQUFJLEVBQUUsR0FBRyxDQUFDLEFBQUMsRUFBRSxLQUFLLENBQUMsR0FBSSxJQUFJLENBQUEsR0FBRSxLQUFLLENBQUM7QUFDbkMsS0FBSSxFQUFFLEdBQUcsQ0FBQyxBQUFDLEVBQUUsS0FBSyxFQUFFLEdBQUksSUFBSSxDQUFBLEdBQUUsS0FBSyxDQUFDOztBQUVwQyxLQUFJLEVBQUUsR0FBRyxBQUFDLElBQUksQ0FBQyxFQUFFLEVBQUUsRUFBRSxFQUFFLENBQUMsQ0FBQyxHQUFHLEdBQUcsR0FBRSxDQUFDLENBQUM7QUFDbkMsS0FBSSxFQUFFLEdBQUcsQUFBQyxJQUFJLENBQUMsRUFBRSxFQUFFLEVBQUUsRUFBRSxDQUFDLENBQUMsR0FBRyxHQUFHLEdBQUUsQ0FBQyxDQUFDO0FBQ25DLEtBQUksRUFBRSxHQUFHLEFBQUMsSUFBSSxDQUFDLEVBQUUsRUFBRSxFQUFFLEVBQUUsQ0FBQyxDQUFDLEdBQUcsR0FBRyxHQUFFLENBQUMsQ0FBQztBQUNuQyxLQUFJLEVBQUUsR0FBRyxZQUFZLEdBQUcsQUFBQyxJQUFJLENBQUMsRUFBRSxFQUFFLEVBQUUsRUFBRSxDQUFDLENBQUMsR0FBRyxHQUFHLEdBQUUsQ0FBQyxHQUFHLElBQUksQ0FBQzs7QUFFekQsUUFBTyxBQUFDLEVBQUUsSUFBSSxFQUFFLEdBQUcsRUFBRSxJQUFJLEVBQUUsQUFBQyxHQUFFLEVBQUUsSUFBSSxDQUFDLEFBQUMsR0FBQyxFQUFFLENBQUM7Q0FDMUMsQ0FBQzs7QUFFRixPQUFPLENBQUMsY0FBYyxHQUFHLGNBQWMsQ0FBQztBQUN4QyxTQUFTLGNBQWMsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxFQUFFLENBQUMsRUFBRSxDQUFDLEVBQUU7QUFDbkMsRUFBQyxHQUFHLENBQUMsR0FBQyxJQUFJLENBQUMsQUFBQyxDQUFDLEdBQUcsQ0FBQyxHQUFDLElBQUksQ0FBQyxBQUFDLENBQUMsR0FBRyxDQUFDLEdBQUMsSUFBSSxDQUFDLEFBQUMsQ0FBQyxHQUFHLENBQUMsR0FBQyxJQUFJLENBQUM7QUFDL0MsUUFBTyxBQUFDLENBQUMsSUFBSSxFQUFFLEdBQUcsQ0FBQyxJQUFJLEVBQUUsQUFBQyxHQUFFLENBQUMsSUFBSSxDQUFDLEFBQUMsR0FBQyxDQUFDLENBQUM7Q0FDdEM7O0FBRUQsT0FBTyxDQUFDLGFBQWEsR0FBRyxhQUFhLENBQUM7QUFDdEMsU0FBUyxhQUFhLENBQUMsQ0FBQyxFQUFFLENBQUMsRUFBRSxDQUFDLEVBQUU7QUFDL0IsRUFBQyxHQUFHLENBQUMsR0FBQyxJQUFJLENBQUMsQUFBQyxDQUFDLEdBQUcsQ0FBQyxHQUFDLElBQUksQ0FBQyxBQUFDLENBQUMsR0FBRyxDQUFDLEdBQUMsSUFBSSxDQUFDO0FBQ25DLFFBQU8sQUFBQyxDQUFDLElBQUksRUFBRSxHQUFHLENBQUMsSUFBSSxDQUFDLEFBQUMsR0FBQyxDQUFDLENBQUM7Q0FDNUI7O0FBRUQsT0FBTyxDQUFDLGVBQWUsR0FBRyxlQUFlLENBQUM7QUFDMUMsU0FBUyxlQUFlLENBQUMsS0FBSyxFQUFFO0FBQy9CLEtBQUksQ0FBQyxHQUFHLENBQUMsQUFBQyxLQUFLLEtBQUssRUFBRSxHQUFJLElBQUksQ0FBQSxHQUFFLEtBQUssQ0FBQztBQUN0QyxLQUFJLENBQUMsR0FBRyxDQUFDLEFBQUMsS0FBSyxLQUFLLENBQUMsR0FBSSxJQUFJLENBQUEsR0FBRSxLQUFLLENBQUM7QUFDckMsS0FBSSxDQUFDLEdBQUcsQ0FBQyxBQUFDLEtBQUssS0FBSyxDQUFDLEdBQUksSUFBSSxDQUFBLEdBQUUsS0FBSyxDQUFDOztBQUVyQyxLQUFJLEVBQUUsR0FBRyxBQUFDLEFBQUMsQ0FBQyxHQUFDLENBQUMsR0FBSSxHQUFHLEdBQUUsQ0FBQyxDQUFDO0FBQ3pCLEtBQUksRUFBRSxHQUFHLEFBQUMsQUFBQyxDQUFDLEdBQUMsQ0FBQyxHQUFJLEdBQUcsR0FBRSxDQUFDLENBQUM7QUFDekIsS0FBSSxFQUFFLEdBQUcsQUFBQyxBQUFDLENBQUMsR0FBQyxDQUFDLEdBQUksR0FBRyxHQUFFLENBQUMsQ0FBQzs7QUFFekIsUUFBTyxBQUFDLEtBQUssR0FBRyxVQUFVLEdBQUssRUFBRSxJQUFJLEVBQUUsQUFBQyxHQUFJLEVBQUUsSUFBSSxDQUFDLEFBQUMsR0FBRyxFQUFFLENBQUM7Q0FDMUQ7O0FBRUQsT0FBTyxDQUFDLGdCQUFnQixHQUFHLGdCQUFnQixDQUFDO0FBQzVDLFNBQVMsZ0JBQWdCLENBQUMsS0FBSyxFQUFFLEtBQUssRUFBRSxLQUFLLEVBQUU7QUFDOUMsS0FBSSxDQUFDLEdBQUcsQ0FBQyxBQUFDLEtBQUssS0FBSyxFQUFFLEdBQUksSUFBSSxDQUFBLEdBQUUsS0FBSyxDQUFDO0FBQ3RDLEtBQUksQ0FBQyxHQUFHLENBQUMsQUFBQyxLQUFLLEtBQUssQ0FBQyxHQUFJLElBQUksQ0FBQSxHQUFFLEtBQUssQ0FBQztBQUNyQyxLQUFJLENBQUMsR0FBRyxDQUFDLEFBQUMsS0FBSyxLQUFLLENBQUMsR0FBSSxJQUFJLENBQUEsR0FBRSxLQUFLLENBQUM7QUFDckMsS0FBSSxDQUFDLEdBQUcsS0FBSyxHQUFHLFVBQVUsQ0FBQzs7QUFFM0IsS0FBSSxLQUFLLEVBQUU7QUFDVixHQUFDLElBQUksQ0FBQyxDQUFDO0FBQ1AsR0FB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LEdBQUcsSUFBSSxDQUFDLEtBQUssQ0FBQyxFQUFFLEVBQUUsRUFBRSxDQUFDLENBQUM7QUFDbEMsT0FBSSxLQUFLLENBQUMsS0FBSyxDQUFDLFVBQVUsRUFBRSxJQUFJLEtBQUssQ0FBQyxRQUFRLENBQUMsTUFBTSxDQUFDLE9BQU8sQ0FBQyxFQUFFO0FBQy9ELFFBQUksTUFBTSxHQUFHLElBQUksTUFBTSxDQUFDLElBQUksQ0FBQyxJQUFJLEVBQUUsSUFBSSxFQUFFLEVBQUUsR0FBQyxHQUFHLEVBQUUsRUFBRSxHQUFDLEdBQUcsRUFBRSxFQUFFLENBQUMsQ0FBQztBQUM3RCxRQUFJLENBQUMsSUFBSSxDQUFDLFNBQVMsQ0FBQyxNQUFNLENBQUMsQ0FBQztJQUM1QjtHQUNEO0FBQ0QsTUFBSSxJQUFJLENBQUMsTUFBTSxJQUFJLElBQUksQ0FBQyxTQUFTLEVBQUU7QUFDbEMsT0FBSSxHQUFHLENBQUMsVUFBVSxDQUFDLElBQUksQ0FBQyxTQUFTLEdBQUMsSUFBSSxDQUFDLE1BQU0sRUFBRSxJQUFJLENBQUMsU0FBUyxDQUFDLEVBQUU7QUFDL0QsUUFBSSxLQUFLLEdBQUcsSUFBSSxLQUFLLENBQUMsSUFBSSxDQUFDLElBQUksRUFBRSxJQUFJLENBQUMsR0FBRyxDQUFDLENBQUMsRUFBRSxJQUFJLENBQUMsR0FBRyxDQUFDLENBQUMsQ0FBQyxDQUFDO0FBQ3pELFNBQUssQ0FBQyxJQUFJLEdBQUcsQ0FBQyxDQUFDO0FBQ2YsU0FBSyxDQUFDLEdBQUcsQ0FBQyxDQUFDLElBQUksSUFBSSxDQUFDLEFBQUMsS0FBSyxDQUFDLEdBQUcsQ0FBQyxDQUFDLElBQUksSUFBSSxDQUFDLEdBQUcsQ0FBQyxDQUFDLENBQUM7QUFDL0MsU0FBSyxDQUFDLEdBQUcsQ0FBQyxDQUFDLElBQUksSUFBSSxDQUFDLEFBQUMsS0FBSyxDQUFDLEdBQUcsQ0FBQyxDQUFDLElBQUksSUFBSSxDQUFDLEdBQUcsQ0FBQyxDQUFDLENBQUM7QUFDL0MsUUFBSSxDQUFDLElBQUksQ0FBQyxTQUFTLENBQUMsS0FBSyxDQUFDLENBQUM7SUFDM0I7QUFDRCxPQUFJLEdBQUcsQ0FBQyxXQUFXLENBQUMsRUFBRSxDQUFDLEVBQUU7QUFDeEIsUUFBSSxDQUFDLE1BQU0sR0FBRyxJQUFJLENBQUMsR0FBRyxDQUFDLElBQUksQ0FBQyxNQUFNLEdBQUMsQ0FBQyxFQUFFLElBQUksQ0FBQyxTQUFTLENBQUMsQ0FBQztJQUN0RDtHQUNEO0VBQ0Q7O0FBaEVJLE9BQU0sV0FrRVgsTUFBTSxtQkFBQyxLQUFLLEVBQUUsR0FBRyxFQUFFLElBQUksRUFBRSxJQUFJLEVBQUU7QUFDOUIsTUFBSSxJQUFJLENBQUMsTUFBTSxJQUFJLENBQUMsRUFBRTtBQUNyQixRQUFLLENBQUMsT0FBTyxDQUFDLFNBQVMsQ0FBQyxJQUFJLENBQUMsSUFBSSxDQUFDLE1BQU0sQ0FBQyxJQUFJLEVBQzVDLENBQUMsRUFBRSxDQUFDLEVBQUUsRUFBRSxFQUFFLEVBQUUsRUFBRSxJQUFJLENBQUMsS0FBSyxDQUFDLElBQUksQ0FBQyxHQUFHLENBQUMsQ0FBQyxHQUFDLEVBQUUsQ0FBQyxFQUFFLElBQUksQ0FBQyxLQUFLLENBQUMsSUFBSSxDQUFDLEdBQUcsQ0FBQyxDQUFDLEdBQUMsQ0FBQyxDQUFDLEVBQUUsRUFBRSxFQUFFLEVBQUUsQ0FBQyxDQUFDO0FBQzVFLFFBQUssQ0FBQyxPQUFPLENBQUMsU0FBUyxDQUFDLElBQUksQ0FBQyxJQUFJLENBQUMsTUFBTSxDQUFDLElBQUksRUFDNUMsQ0FBQyxFQUFFLEVBQUUsRUFBRSxFQUFFLEVBQUUsRUFBRSxFQUFFLElBQUksQ0FBQyxLQUFLLENBQUMsSUFBSSxDQUFDLEdBQUcsQ0FBQyxDQUFDLEdBQUMsRUFBRSxDQUFDLEVBQUUsSUFBSSxDQUFDLEtBQUssQ0FBQyxJQUFJLENBQUMsR0FBRyxDQUFDLENBQUMsR0FBQyxDQUFDLENBQUMsRUFBRSxFQUFFLEVBQUUsRUFBRSxDQUFDLENBQUM7QUFDN0UsVUFBTztHQUNQO0FBQ0QsTUFBSSxRQUFRLEdBQUcsSUFBSSxDQUFDLEtBQUssQ0FBQyxJQUFJLENBQUMsT0FBTyxJQUFJLElBQUksQ0FBQyxFQUFFLEdBQUMsQ0FBQyxDQUFBLEFBQUMsR0FBQyxFQUFFLENBQUMsR0FBQyxFQUFFLENBQUM7QUFDNUQsTUFBSSxJQUFJLEdBQUcsQ0FBQyxJQUFJLENBQUMsT0FBTyxHQUFHLElBQUksQ0FBQyxLQUFLLENBQUMsSUFBSSxDQUFDLFlBQVksR0FBQyxDQUFDLENBQUMsR0FBRyxDQUFDLENBQUEsR0FBSSxDQUFDLENBQUE7QUFDbkUsT0FBSyxDQUFDLE9BQU8sQ0FBQyxXQUFXLEdBQUcsT0FBTyxDQUFDO0FBQ3BDLE9BQUssQ0FBQyxPQUFPLENBQUMsU0FBUyxDQUFDLElBQUksQ0FBQyxJQUFJLENBQUMsTUFBTSxDQUFDLGVBQWUsQ0FBQyxNQUFNLEVBQzlELEVBQUUsR0FBQyxJQUFJLEVBQUUsRUFBRSxHQUFDLFFBQVEsRUFBRSxFQUFFLEVBQUUsRUFBRSxFQUM1QixJQUFJLENBQUMsS0FBSyxDQUFDLElBQUksQ0FBQyxHQUFHLENBQUMsQ0FBQyxHQUFDLENBQUMsQ0FBQyxFQUN4QixJQUFJLENBQUMsS0FBSyxDQUFDLElBQUksQ0FBQyxHQUFHLENBQUMsQ0FBQyxHQUFDLENBQUMsQ0FBQyxFQUN4QixFQUFFLEVBQUUsRUFBRSxDQUFDOzs7O0FBQUMsRUFLVDs7UUF0RkksTUFBTTtHQUFTLE1BQU07O0FBMEYzQixNQUFNLENBQUMsT0FBTyxHQUFHLE1BQU0sQ0FBQzs7O0FDdkd4QixZQUFZLENBQUM7O0FBRWIsSUFBTSxTQUFTLEdBQUcsT0FBTyxDQUFDLFlBQVksQ0FBQyxDQUFDO0FBQ3hDLElBQU0sVUFBVSxHQUFHLE9BQU8sQ0FBQyxnQkFBZ0IsQ0FBQyxDQUFDOztBQUU3QyxJQUFNLFNBQVMsR0FBRztBQUNqQixRQUFPLG1CQUFDLENBQUMsRUFBRTtBQUFFLFNBQU8sSUFBSSxDQUFDLE9BQU8sQ0FBQyxDQUFDLENBQUMsQ0FBQztFQUFFO0FBQ3RDLE9BQU0sb0JBQUc7QUFBRSxTQUFPLElBQUksQ0FBQyxNQUFNLEVBQUUsQ0FBQztFQUFFO0FBRWxDLEtBQUksZ0JBQUMsQ0FBQyxFQUFFO0FBQUUsU0FBTyxJQUFJLENBQUMsT0FBTyxDQUFDLENBQUMsQ0FBQyxDQUFDO0VBQUU7QUFDbkMsTUFBSyxpQkFBQyxDQUFDLEVBQUU7QUFBRSxTQUFPLElBQUksQ0FBQyxJQUFJLENBQUMsQ0FBQyxHQUFDLENBQUMsQ0FBQyxDQUFDO0VBQUU7O0FBQ25DLE1BQUssaUJBQUMsQ0FBQyxFQUFFO0FBQUUsU0FBTyxJQUFJLENBQUMsTUFBTSxFQUFFLEdBQUcsQ0FBQyxDQUFDO0VBQUU7QUFFdEMsU0FBUSxvQkFBQyxHQUFHLEVBQUUsR0FBRyxFQUFFO0FBQUUsU0FBTyxHQUFHLEdBQUcsSUFBSSxDQUFDLE1BQU0sRUFBRSxJQUFJLEdBQUcsR0FBQyxHQUFHLENBQUEsQUFBQyxDQUFDO0VBQUU7QUFDOUQsU0FBUSxvQkFBQyxHQUFHLEVBQUUsR0FBRyxFQUFFO0FBQUUsU0FBTyxHQUFHLEdBQUcsSUFBSSxDQUFDLElBQUksQ0FBQyxHQUFHLEdBQUMsR0FBRyxHQUFDLENBQUMsQ0FBQyxDQUFDO0VBQUU7QUFDekQsU0FBUSxvQkFBQyxHQUFHLEVBQUUsR0FBRyxFQUFFO0FBQUUsU0FBTyxHQUFHLEdBQUcsSUFBSSxDQUFDLElBQUksQ0FBQyxHQUFHLEdBQUMsR0FBRyxDQUFDLENBQUM7RUFBRTtBQUd2RCxZQUFXLHVCQUFDLENBQUMsRUFBRTtBQUFFLFNBQU8sSUFBSSxDQUFDLElBQUksQ0FBQyxDQUFDLENBQUMsS0FBSyxDQUFDLENBQUM7RUFBRTtBQUM3QyxTQUFRLHNCQUFHO0FBQUUsU0FBTyxJQUFJLENBQUMsV0FBVyxDQUFDLENBQUMsQ0FBQyxDQUFDO0VBQUU7QUFDMUMsWUFBVyx1QkFBQyxDQUFDLEVBQUU7QUFBRSxTQUFPLElBQUksQ0FBQyxNQUFNLEVBQUUsR0FBRyxDQUFDLENBQUM7RUFBRTtBQUU1QyxXQUFVLHNCQUFDLENBQUMsRUFBRSxDQUFDLEVBQUU7QUFBRSxTQUFPLElBQUksQ0FBQyxJQUFJLENBQUMsQ0FBQyxDQUFDLEdBQUcsQ0FBQyxDQUFDO0VBQUU7QUFFN0MsT0FBTSxrQkFBQyxHQUFHLEVBQUU7QUFDWCxNQUFJLEdBQUcsQ0FBQyxNQUFNLEtBQUssQ0FBQyxFQUFFO0FBQ3JCLFVBQU8sQ0FBQyxLQUFLLENBQUMsdUJBQXVCLENBQUMsQ0FBQztBQUN2QyxVQUFPLElBQUksQ0FBQztHQUNaO0FBQ0QsU0FBTyxHQUFHLENBQUMsSUFBSSxDQUFDLElBQUksQ0FBQyxHQUFHLENBQUMsTUFBTSxDQUFDLENBQUMsQ0FBQztFQUNsQztBQUVELE1BQUssaUJBQUMsQ0FBQyxFQUFFO0FBQ1IsTUFBTSxFQUFFLEdBQUcsSUFBSSxDQUFDLEtBQUssQ0FBQyxDQUFDLENBQUMsQ0FBQztBQUN6QixTQUFPLEVBQUUsR0FBRyxJQUFJLENBQUMsV0FBVyxDQUFDLENBQUMsR0FBQyxFQUFFLENBQUMsR0FBRyxDQUFDLEdBQUcsQ0FBQyxDQUFDO0VBQzNDO0FBRUQsU0FBUSxvQkFBQyxLQUFLLEVBQUUsSUFBSSxFQUFFO0FBQ3JCLE1BQUksS0FBSyxJQUFJLENBQUMsSUFBSSxJQUFJLElBQUksQ0FBQyxFQUFFLE9BQU8sQ0FBQyxDQUFDO0FBQ3RDLE1BQUksTUFBTSxHQUFHLEtBQUssQ0FBQztBQUNuQixPQUFLLElBQUksQ0FBQyxHQUFHLENBQUMsRUFBRSxDQUFDLEdBQUcsS0FBSyxFQUFFLEVBQUUsQ0FBQyxFQUFFO0FBQy9CLFNBQU0sSUFBSSxJQUFJLENBQUMsSUFBSSxDQUFDLElBQUksQ0FBQyxDQUFDO0dBQzFCO0FBQ0QsU0FBTyxNQUFNLENBQUM7RUFDZDtBQUVELFNBQVEsb0JBQUMsR0FBRyxFQUFFLEtBQUssRUFBRTtBQUNwQixNQUFJLElBQUksR0FBRyxDQUFDLENBQUM7QUFDYixPQUFLLElBQUksQ0FBQyxHQUFHLENBQUMsRUFBRSxDQUFDLEdBQUcsS0FBSyxFQUFFLEVBQUUsQ0FBQyxFQUFFO0FBQy9CLE9BQUksR0FBRyxJQUFJLENBQUMsR0FBRyxDQUFDLElBQUksQ0FBQyxJQUFJLENBQUMsR0FBRyxDQUFDLEVBQUUsSUFBSSxDQUFDLENBQUM7R0FDdEM7QUFDRCxTQUFPLElBQUksQ0FBQztFQUNaO0FBRUQsV0FBVSx3QkFBRztBQUNaLE1BQUksQ0FBQyxHQUFHLEdBQUc7TUFBRSxDQUFDLEdBQUcsR0FBRztNQUFFLENBQUMsR0FBRyxHQUFHLENBQUM7QUFDOUIsS0FBRztBQUNGLElBQUMsR0FBRyxJQUFJLENBQUMsTUFBTSxFQUFFLEdBQUcsR0FBRyxHQUFHLEdBQUcsQ0FBQztBQUM5QixJQUFDLEdBQUcsSUFBSSxDQUFDLE1BQU0sRUFBRSxHQUFHLEdBQUcsR0FBRyxHQUFHLENBQUM7QUFDOUIsSUFBQyxHQUFHLENBQUMsR0FBQyxDQUFDLEdBQUcsQ0FBQyxHQUFDLENBQUMsQ0FBQztHQUNkLFFBQVEsQ0FBQyxLQUFLLEdBQUcsSUFBSSxDQUFDLEdBQUcsR0FBRyxFQUFFO0FBQy9CLE1BQU0sR0FBRyxHQUFHLElBQUksQ0FBQyxJQUFJLENBQUMsQ0FBQyxHQUFHLEdBQUcsSUFBSSxDQUFDLEdBQUcsQ0FBQyxDQUFDLENBQUMsR0FBRyxDQUFDLENBQUMsQ0FBQztBQUM5QyxTQUFPLENBQUMsR0FBRyxHQUFHLENBQUM7RUFDZjtBQUVELFNBQVEsb0JBQUMsSUFBSSxFQUFFLE1BQU0sRUFBRTtBQUN0QixTQUFPLElBQUksQ0FBQyxVQUFVLEVBQUUsR0FBRyxNQUFNLEdBQUcsSUFBSSxDQUFDO0VBQ3pDO0FBRUQsUUFBTyxxQkFBMEI7TUFBekIsSUFBSSx5REFBQyxHQUFHO01BQUUsU0FBUyx5REFBQyxHQUFHOztBQUM5QixTQUFPLElBQUksQ0FBQyxNQUFNLEVBQUUsSUFBSSxTQUFTLEdBQUMsR0FBRyxDQUFBLEFBQUMsSUFBSSxJQUFJLEdBQUcsR0FBRyxDQUFBLEFBQUMsQ0FBQztFQUN0RDtBQUVELG9CQUFtQiwrQkFBQyxPQUFPLEVBQUU7QUFDNUIsTUFBSSxDQUFDLEdBQUcsT0FBTyxDQUFDLE1BQU0sQ0FBQztBQUN2QixNQUFJLENBQUMsS0FBSyxDQUFDLEVBQUU7QUFDWixVQUFPLENBQUMsS0FBSyxDQUFDLDJDQUEyQyxDQUFDLENBQUM7QUFDM0QsVUFBTyxDQUFDLENBQUMsQ0FBQztHQUNWO0FBQ0QsTUFBSSxHQUFHLEdBQUcsQ0FBQyxDQUFDO0FBQ1osT0FBSyxJQUFJLENBQUMsR0FBRyxDQUFDLEVBQUUsQ0FBQyxHQUFHLENBQUMsRUFBRSxFQUFFLENBQUM7QUFDekIsTUFBRyxJQUFJLE9BQU8sQ0FBQyxDQUFDLENBQUMsQ0FBQztHQUFBLEFBQ25CLEdBQUcsSUFBSSxJQUFJLENBQUMsTUFBTSxFQUFFLENBQUM7QUFDckIsT0FBSyxJQUFJLENBQUMsR0FBRyxDQUFDLEVBQUUsQ0FBQyxHQUFHLENBQUMsRUFBRSxFQUFFLENBQUMsRUFBRTtBQUMzQixNQUFHLElBQUksT0FBTyxDQUFDLENBQUMsQ0FBQyxDQUFDO0FBQ2xCLE9BQUksR0FBRyxJQUFJLEdBQUcsRUFDYixPQUFPLENBQUMsQ0FBQztHQUNWO0FBQ0QsU0FBTyxDQUFDLEtBQUssQ0FBQywwQkFBMEIsRUFBRSxPQUFPLENBQUMsQ0FBQztBQUNuRCxTQUFPLElBQUksQ0FBQyxJQUFJLENBQUMsT0FBTyxDQUFDLE1BQU0sQ0FBQyxDQUFDO0VBQ2pDO0FBRUQsaUJBQWdCLDRCQUFDLEdBQUcsRUFBRSxTQUFTLEVBQUU7QUFDaEMsTUFBSSxDQUFDLEdBQUcsR0FBRyxDQUFDLE1BQU0sQ0FBQztBQUNuQixNQUFJLENBQUMsS0FBSyxDQUFDLEVBQUU7QUFDWixVQUFPLENBQUMsS0FBSyxDQUFDLHdDQUF3QyxDQUFDLENBQUM7QUFDeEQsVUFBTyxDQUFDLENBQUMsQ0FBQztHQUNWO0FBQ0QsTUFBSSxHQUFHLEdBQUcsQ0FBQyxDQUFDO0FBQ1osT0FBSyxJQUFJLENBQUMsR0FBRyxDQUFDLEVBQUUsQ0FBQyxHQUFHLENBQUMsRUFBRSxFQUFFLENBQUM7QUFDekIsTUFBRyxJQUFJLFNBQVMsQ0FBQyxHQUFHLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQztHQUFBLEFBQzFCLEdBQUcsSUFBSSxJQUFJLENBQUMsTUFBTSxFQUFFLENBQUM7QUFDckIsT0FBSyxJQUFJLENBQUMsR0FBRyxDQUFDLEVBQUUsQ0FBQyxHQUFHLENBQUMsRUFBRSxFQUFFLENBQUMsRUFBRTtBQUMzQixNQUFHLElBQUksU0FBUyxDQUFDLEdBQUcsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDO0FBQ3pCLE9BQUksR0FBRyxJQUFJLEdBQUcsRUFBRSxPQUFPLENBQUMsQ0FBQztHQUN6QjtBQUNELFNBQU8sQ0FBQyxLQUFLLENBQUMsMEJBQTBCLEVBQUUsR0FBRyxDQUFDLENBQUM7QUFDL0MsU0FBTyxJQUFJLENBQUMsSUFBSSxDQUFDLEdBQUcsQ0FBQyxNQUFNLENBQUMsQ0FBQztFQUM3QjtBQUVELFFBQU8sbUJBQUMsR0FBRyxFQUFFO0FBQ1osT0FBSyxJQUFJLENBQUMsR0FBRyxHQUFHLENBQUMsTUFBTSxHQUFDLENBQUMsRUFBRSxDQUFDLEdBQUcsQ0FBQyxFQUFFLEVBQUUsQ0FBQyxFQUFFO0FBQ3RDLE9BQUksQ0FBQyxHQUFHLElBQUksQ0FBQyxLQUFLLENBQUMsQ0FBQyxDQUFDLENBQUM7QUFDdEIsT0FBSSxHQUFHLEdBQUcsR0FBRyxDQUFDLENBQUMsQ0FBQyxDQUFDLEFBQUMsR0FBRyxDQUFDLENBQUMsQ0FBQyxHQUFHLEdBQUcsQ0FBQyxDQUFDLENBQUMsQ0FBQyxBQUFDLEdBQUcsQ0FBQyxDQUFDLENBQUMsR0FBRyxHQUFHLENBQUM7R0FDaEQ7QUFDRCxTQUFPLEdBQUcsQ0FBQztFQUNYO0FBRUQsYUFBWSx3QkFBQyxFQUFFLEVBQUUsRUFBRSxFQUFFO0FBQ3BCLE1BQUksRUFBRSxHQUFHLEVBQUUsS0FBSyxFQUFFLENBQUM7QUFDbkIsTUFBSSxFQUFFLEdBQUcsQUFBQyxFQUFFLEtBQUssRUFBRSxHQUFFLElBQUksQ0FBQztBQUMxQixNQUFJLEVBQUUsR0FBRyxBQUFDLEVBQUUsS0FBSyxDQUFDLEdBQUUsSUFBSSxDQUFDO0FBQ3pCLE1BQUksRUFBRSxHQUFHLEVBQUUsR0FBRyxJQUFJLENBQUM7O0FBRW5CLE1BQUksRUFBRSxHQUFHLEVBQUUsS0FBSyxFQUFFLENBQUM7QUFDbkIsTUFBSSxFQUFFLEdBQUcsQUFBQyxFQUFFLEtBQUssRUFBRSxHQUFFLElBQUksQ0FBQztBQUMxQixNQUFJLEVBQUUsR0FBRyxBQUFDLEVBQUUsS0FBSyxDQUFDLEdBQUUsSUFBSSxDQUFDO0FBQ3pCLE1BQUksRUFBRSxHQUFHLEVBQUUsR0FBRyxJQUFJLENBQUM7O0FBRW5CLFNBQVEsQUFBQyxHQUFHLENBQUMsUUFBUSxDQUFDLEVBQUUsRUFBRSxFQUFFLENBQUMsSUFBSSxFQUFFLEdBQzFCLEdBQUcsQ0FBQyxRQUFRLENBQUMsRUFBRSxFQUFFLEVBQUUsQ0FBQyxJQUFJLEVBQUUsQUFBQyxHQUMzQixHQUFHLENBQUMsUUFBUSxDQUFDLEVBQUUsRUFBRSxFQUFFLENBQUMsSUFBSSxDQUFDLEFBQUMsR0FDMUIsR0FBRyxDQUFDLFFBQVEsQ0FBQyxFQUFFLEVBQUUsRUFBRSxDQUFDLEFBQUMsQ0FBRTtFQUNoQztDQUNELENBQUE7O0FBRUQsTUFBTSxDQUFDLE1BQU0sQ0FBQyxTQUFTLENBQUMsU0FBUyxFQUFFLFNBQVMsQ0FBQyxDQUFDOztBQUU5QyxJQUFNLEdBQUcsR0FBRyxJQUFJLFNBQVMsRUFBRSxDQUFDO0FBQzVCLE9BQU8sQ0FBQyxHQUFHLEdBQUcsR0FBRyxDQUFDO0FBQ2xCLE9BQU8sQ0FBQyxPQUFPLEdBQUcsU0FBUyxDQUFDOztBQUU1QixJQUFNLFdBQVcsR0FBRyxVQUFVLENBQUMsS0FBSyxDQUFDOztBQUVyQyxPQUFPLENBQUMsV0FBVyxHQUFHLFdBQVcsQ0FBQztBQUNsQyxPQUFPLENBQUMsV0FBVyxHQUFHLFdBQVcsQ0FBQzs7QUFFbEMsU0FBUyxXQUFXLENBQUMsQ0FBQyxFQUFFLENBQUMsRUFBRSxDQUFDLEVBQThCO0tBQTVCLE9BQU8seURBQUMsQ0FBQztLQUFFLFdBQVcseURBQUMsR0FBRzs7QUFDdkQsS0FBSSxLQUFLLEdBQUcsR0FBRyxDQUFDO0FBQ2hCLEtBQUksU0FBUyxHQUFHLEdBQUcsQ0FBQztBQUNwQixLQUFJLFNBQVMsR0FBRyxHQUFHLENBQUM7QUFDcEIsS0FBSSxRQUFRLEdBQUcsR0FBRyxDQUFDO0FBQ25CLE1BQUssSUFBSSxDQUFDLEdBQUcsQ0FBQyxFQUFFLENBQUMsR0FBRyxPQUFPLEVBQUUsRUFBRSxDQUFDLEVBQUU7QUFDakMsT0FBSyxJQUFJLFdBQVcsQ0FBQyxDQUFDLEdBQUcsU0FBUyxFQUFFLENBQUMsR0FBRyxTQUFTLEVBQUUsQ0FBQyxHQUFHLFNBQVMsQ0FBQyxHQUFHLFNBQVMsQ0FBQztBQUM5RSxVQUFRLElBQUksU0FBUyxDQUFDO0FBQ3RCLFdBQVMsSUFBSSxXQUFXLENBQUM7QUFDekIsV0FBUyxJQUFJLEdBQUcsQ0FBQztFQUNqQjtBQUNELFFBQU8sS0FBSyxHQUFHLFFBQVEsQ0FBQztDQUN4Qjs7O0FDL0pELFlBQVksQ0FBQzs7OztZQUNxQixJQUFJO0lBQS9CLEdBQUcsU0FBSCxHQUFHO0lBQUUsR0FBRyxTQUFILEdBQUc7SUFBRSxFQUFFLFNBQUYsRUFBRTtJQUFFLEdBQUcsU0FBSCxHQUFHO0lBQUUsSUFBSSxTQUFKLElBQUk7O2VBQ2hCLE9BQU8sQ0FBQyxRQUFRLENBQUM7O0lBQXhCLEdBQUcsWUFBSCxHQUFHOztBQUNWLElBQU0sT0FBTyxHQUFHLE9BQU8sQ0FBQyxVQUFVLENBQUMsQ0FBQzs7QUFFcEMsSUFBTSxPQUFPLEdBQUcsRUFBRSxHQUFHLEdBQUcsQ0FBQztBQUN6QixJQUFNLE1BQU0sR0FBRyxFQUFFLEdBQUcsR0FBRyxDQUFDOztBQUV4QixJQUFNLFVBQVUsR0FBRyxDQUFDLENBQUM7QUFDckIsSUFBTSxXQUFXLEdBQUcsQ0FBQyxDQUFDO0FBQ3RCLElBQU0sYUFBYSxHQUFHLENBQUMsQ0FBQztBQUN4QixJQUFNLGFBQWEsR0FBRyxDQUFDLENBQUM7O0FBRXhCLE9BQU8sQ0FBQyxRQUFRLEdBQUcsRUFBRSxFQUFFLEVBQUUsVUFBVSxFQUFFLEdBQUcsRUFBRSxXQUFXLEVBQUUsS0FBSyxFQUFFLGFBQWEsRUFBRSxLQUFLLEVBQUUsYUFBYSxFQUFFLENBQUM7O0FBRXBHLFNBQVMsYUFBYSxDQUFDLENBQUMsRUFBRTtBQUN6QixLQUFJLENBQUMsR0FBRyxHQUFHLEdBQUcsSUFBSSxFQUFFLE9BQU8sTUFBTSxHQUFDLENBQUMsR0FBQyxDQUFDLENBQUMsS0FDakMsSUFBSSxDQUFDLEdBQUcsR0FBRyxHQUFDLElBQUksRUFBRTtBQUFFLEdBQUMsSUFBSSxJQUFJLEdBQUMsSUFBSSxDQUFDLEFBQUMsT0FBTyxNQUFNLEdBQUMsQ0FBQyxHQUFDLENBQUMsR0FBRyxJQUFJLENBQUM7RUFBRSxNQUMvRCxJQUFJLENBQUMsR0FBRyxHQUFHLEdBQUMsSUFBSSxFQUFFO0FBQUUsR0FBQyxJQUFJLElBQUksR0FBQyxJQUFJLENBQUMsQUFBQyxPQUFPLE1BQU0sR0FBQyxDQUFDLEdBQUMsQ0FBQyxHQUFHLE1BQU0sQ0FBQztFQUFFLE1BQ2pFO0FBQUUsR0FBQyxJQUFJLEtBQUssR0FBQyxJQUFJLENBQUMsQUFBQyxPQUFPLE1BQU0sR0FBQyxDQUFDLEdBQUMsQ0FBQyxHQUFHLFFBQVEsQ0FBQztFQUFFO0NBQ3ZEOztBQUVELFNBQVMsTUFBTSxDQUFDLENBQUMsRUFBRSxFQUFFLEVBQUUsRUFBRSxFQUFFLEVBQUUsRUFBRSxFQUFFLEVBQUU7QUFDbEMsS0FBTSxDQUFDLEdBQUcsR0FBRyxHQUFHLENBQUMsQ0FBQztBQUNsQixRQUFPLENBQUMsR0FBQyxDQUFDLEdBQUMsQ0FBQyxHQUFDLEVBQUUsR0FBRyxHQUFHLEdBQUMsQ0FBQyxHQUFDLENBQUMsR0FBQyxDQUFDLEdBQUMsRUFBRSxHQUFHLEdBQUcsR0FBQyxDQUFDLEdBQUMsQ0FBQyxHQUFDLENBQUMsR0FBQyxFQUFFLEdBQUcsQ0FBQyxHQUFDLENBQUMsR0FBQyxDQUFDLEdBQUMsRUFBRSxDQUFDO0NBQ3pEOztBQUVELFNBQVMsVUFBVSxDQUFDLENBQUMsRUFBRTtBQUFFLFFBQU8sQ0FBQyxDQUFDO0NBQUU7QUFDcEMsU0FBUyxRQUFRLENBQUMsQ0FBQyxFQUFFO0FBQUUsUUFBTyxDQUFDLEdBQUMsQ0FBQyxDQUFDO0NBQUU7QUFDcEMsU0FBUyxTQUFTLENBQUMsQ0FBQyxFQUFFO0FBQUUsUUFBTyxDQUFDLEdBQUMsQ0FBQyxHQUFDLENBQUMsQ0FBQztDQUFFO0FBQ3ZDLFNBQVMsU0FBUyxDQUFDLENBQUMsRUFBRTtBQUFFLFFBQU8sQ0FBQyxHQUFDLENBQUMsR0FBQyxDQUFDLEdBQUMsQ0FBQyxDQUFDO0NBQUU7QUFDekMsU0FBUyxTQUFTLENBQUMsQ0FBQyxFQUFFO0FBQUUsUUFBTyxDQUFDLEdBQUMsQ0FBQyxHQUFDLENBQUMsR0FBQyxDQUFDLEdBQUMsQ0FBQyxDQUFDO0NBQUU7QUFDM0MsU0FBUyxRQUFRLENBQUMsQ0FBQyxFQUFFO0FBQUUsUUFBTyxHQUFHLENBQUMsR0FBRyxFQUFFLElBQUksSUFBSSxDQUFDLEdBQUcsR0FBRyxDQUFBLEFBQUMsQ0FBQyxDQUFDO0NBQUU7QUFDM0QsU0FBUyxRQUFRLENBQUMsQ0FBQyxFQUFFO0FBQUUsUUFBTyxDQUFDLEdBQUcsQ0FBQyxDQUFDLEdBQUcsT0FBTyxDQUFDLEdBQUcsR0FBRyxDQUFDO0NBQUU7QUFDeEQsU0FBUyxRQUFRLENBQUMsQ0FBQyxFQUFFO0FBQUUsUUFBTyxFQUFFLElBQUksQ0FBQyxHQUFHLEdBQUksQ0FBQyxHQUFHLENBQUMsQUFBQyxDQUFDLEdBQUcsR0FBRyxDQUFBLEFBQUMsQ0FBQztDQUFFO0FBQzdELFNBQVMsUUFBUSxDQUFDLENBQUMsRUFBRTtBQUFFLFFBQU8sQ0FBQyxHQUFHLENBQUMsSUFBSSxHQUFHLEdBQUcsQ0FBQyxHQUFHLEdBQUcsQ0FBQSxBQUFDLENBQUM7Q0FBRTtBQUN4RCxTQUFTLFdBQVcsQ0FBQyxDQUFDLEVBQUU7QUFBRSxRQUFPLEVBQUUsR0FBRyxDQUFDLEdBQUcsRUFBRSxJQUFJLElBQUksQ0FBQyxHQUFHLEdBQUcsQ0FBQSxBQUFDLENBQUMsR0FBRyxHQUFHLENBQUMsQ0FBQyxDQUFDLEdBQUcsS0FBSyxDQUFBLEdBQUksTUFBTSxHQUFHLEdBQUcsQ0FBQyxDQUFBLEFBQUMsQ0FBQztDQUFFO0FBQ25HLFNBQVMsVUFBVSxDQUFDLENBQUMsRUFBRTtBQUFFLFFBQU8sR0FBRyxHQUFHLGFBQWEsQ0FBQyxHQUFHLEdBQUMsQ0FBQyxDQUFDLENB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QUUsQ0FBQztBQUMvRSxJQUFJLENBQUMsU0FBUyxHQUFHLFVBQVMsRUFBRSxFQUFFLEVBQUUsRUFBRSxFQUFFLEVBQUUsRUFBRSxFQUFFO0FBQUUsUUFBTyxJQUFJLElBQUksQ0FBQyxFQUFFLEdBQUcsRUFBRSxFQUFFLEVBQUUsR0FBRyxFQUFFLENBQUMsQ0FBQztDQUFFLENBQUM7O0FBRWpGLElBQUksQ0FBQyxJQUFJLEdBQUc7QUFDWCxNQUFLLEVBQUUsRUFBRTtBQUNULE1BQUssRUFBRSxDQUFDO0FBQ1IsSUFBRyxlQUFDLENBQUMsRUFBRSxDQUFDLEVBQUU7QUFDVCxNQUFJLElBQUksQ0FBQyxLQUFLLEtBQUssSUFBSSxDQUFDLEtBQUssQ0FBQyxNQUFNLEVBQ25DLElBQUksQ0FBQyxLQUFLLENBQUMsSUFBSSxDQUFDLElBQUksSUFBSSxDQUFDLEdBQUcsRUFBRSxHQUFHLENBQUMsQ0FBQyxDQUFDO0FBQ3JDLFNBQU8sSUFBSSxDQUFDLEtBQUssQ0FBQyxJQUFJLENBQUMsS0FBSyxFQUFFLENBQUMsQ0FBQyxHQUFHLENBQUMsQ0FBQyxDQUFDLElBQUUsR0FBRyxFQUFFLENBQUMsQ0FBQyxJQUFFLEdBQUcsQ0FBQyxDQUFDO0VBQ3REO0FBQ0QsTUFBSyxtQkFBRztBQUFFLE1BQUksQ0FBQyxLQUFLLEdBQUcsQ0FBQyxDQUFDO0VBQUU7QUFDM0IsT0FBTSxvQkFBRztBQUFFLE1BQUksQ0FBQyxLQUFLLEdBQUcsQ0FBQyxDQUFDO0VBQUU7Q0FDNUIsQ0FBQTs7QUFFRCxJQUFJLENBQUMsSUFBSSxHQUFHLFVBQVMsQ0FBQyxFQUFFLENBQUMsRUFBRTtBQUFFLFFBQU8sSUFBSSxDQUFDLElBQUksQ0FBQyxHQUFHLENBQUMsQ0FBQyxFQUFFLENBQUMsQ0FBQyxDQUFDO0NBQUUsQ0FBQzs7QUFHM0QsTUFBTSxDQUFDLE9BQU8sR0FBRyxJQUFJLENBQUMiLCJmaWxlIjoiZ2VuZXJhdGVkLmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXNDb250ZW50IjpbIihmdW5jdGlvbiBlKHQsbixyKXtmdW5jdGlvbiBzKG8sdSl7aWYoIW5bb10pe2lmKCF0W29dKXt2YXIgYT10eXBlb2YgcmVxdWlyZT09XCJmdW5jdGlvblwiJiZyZXF1aXJlO2lmKCF1JiZhKXJldHVybiBhKG8sITApO2lmKGkpcmV0dXJuIGkobywhMCk7dmFyIGY9bmV3IEVycm9yKFwiQ2Fubm90IGZpbmQgbW9kdWxlICdcIitvK1wiJ1wiKTt0aHJvdyBmLmNvZGU9XCJNT0RVTEVfTk9UX0ZPVU5EXCIsZn12YXIgbD1uW29dPXtleHBvcnRzOnt9fTt0W29dWzBdLmNhbGwobC5leHBvcnRzLGZ1bmN0aW9uKGUpe3ZhciBuPXRbb11bMV1bZV07cmV0dXJuIHMobj9uOmUpfSxsLGwuZXhwb3J0cyxlLHQsbixyKX1yZXR1cm4gbltvXS5leHBvcnRzfXZhciBpPXR5cGVvZiByZXF1aXJlPT1cImZ1bmN0aW9uXCImJnJlcXVpcmU7Zm9yKHZhciBvPTA7bzxyLmxlbmd0aDtvKyspcyhyW29dKTtyZXR1cm4gc30pIiwiLyogQHByZXNlcnZlXG4gKiBUaGUgTUlUIExpY2Vuc2UgKE1JVClcbiAqIFxuICogQ29weXJpZ2h0IChjKSAyMDEzLTIwMTUgUGV0a2EgQW50b25vdlxuICogXG4gKiBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmcgYSBjb3B5XG4gKiBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZSBcIlNvZnR3YXJlXCIpLCB0byBkZWFsXG4gKiBpbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbiwgaW5jbHVkaW5nIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzXG4gKiB0byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsXG4gKiBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG8gcGVybWl0IHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXNcbiAqIGZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdCB0byB0aGUgZm9sbG93aW5nIGNvbmRpdGlvbnM6XG4gKiBcbiAqIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlIGluY2x1ZGVkIGluXG4gKiBhbGwgY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cbiAqIFxuICogVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCwgRVhQUkVTUyBPUlxuICogSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRiBNRVJDSEFOVEFCSUxJVFksXG4gKiBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkQgTk9OSU5GUklOR0VNRU5ULiAgSU4gTk8gRVZFTlQgU0hBTEwgVEhFXG4gKiBBVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLCBEQU1BR0VTIE9SIE9USEVSXG4gKiBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLFxuICogT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTlxuICogVEhFIFNPRlRXQVJFLlxuICogXG4gKi9cbi8qKlxuICogYmx1ZWJpcmQgYnVpbGQgdmVyc2lvbiAzLjAuNlxuICogRmVhdHVyZXMgZW5hYmxlZDogY29yZSwgcmFjZSwgY2FsbF9nZXQsIGdlbmVyYXRvcnMsIG1hcCwgbm9kZWlmeSwgcHJvbWlzaWZ5LCBwcm9wcywgcmVkdWNlLCBzZXR0bGUsIHNvbWUsIHVzaW5nLCB0aW1lcnMsIGZpbHRlciwgYW55LCBlYWNoXG4qL1xuIWZ1bmN0aW9uKGUpe2lmKFwib2JqZWN0XCI9PXR5cGVvZiBleHBvcnRzJiZcInVuZGVmaW5lZFwiIT10eXBlb2YgbW9kdWxlKW1vZHVsZS5leHBvcnRzPWUoKTtlbHNlIGlmKFwiZnVuY3Rpb25cIj09dHlwZW9mIGRlZmluZSYmZGVmaW5lLmFtZClkZWZpbmUoW10sZSk7ZWxzZXt2YXIgZjtcInVuZGVmaW5lZFwiIT10eXBlb2Ygd2luZG93P2Y9d2luZG93OlwidW5kZWZpbmVkXCIhPXR5cGVvZiBnbG9iYWw/Zj1nbG9iYWw6XCJ1bmRlZmluZWRcIiE9dHlwZW9mIHNlbGYmJihmPXNlbGYpLGYuUHJvbWlzZT1lKCl9fShmdW5jdGlvbigpe3ZhciBkZWZpbmUsbW9kdWxlLGV4cG9ydHM7cmV0dXJuIChmdW5jdGlvbiBlKHQsbixyKXtmdW5jdGlvbiBzKG8sdSl7aWYoIW5bb10pe2lmKCF0W29dKXt2YXIgYT10eXBlb2YgX2RlcmVxXz09XCJmdW5jdGlvblwiJiZfZGVyZXFfO2lmKCF1JiZhKXJldHVybiBhKG8sITApO2lmKGkpcmV0dXJuIGkobywhMCk7dmFyIGY9bmV3IEVycm9yKFwiQ2Fubm90IGZpbmQgbW9kdWxlICdcIitvK1wiJ1wiKTt0aHJvdyBmLmNvZGU9XCJNT0RVTEVfTk9UX0ZPVU5EXCIsZn12YXIgbD1uW29dPXtleHBvcnRzOnt9fTt0W29dWzBdLmNhbGwobC5leHBvcnRzLGZ1bmN0aW9uKGUpe3ZhciBuPXRbb11bMV1bZV07cmV0dXJuIHMobj9uOmUpfSxsLGwuZXhwb3J0cyxlLHQsbixyKX1yZXR1cm4gbltvXS5leHBvcnRzfXZhciBpPXR5cGVvZiBfZGVyZXFfPT1cImZ1bmN0aW9uXCImJl9kZXJlcV87Zm9yKHZhciBvPTA7bzxyLmxlbmd0aDtvKyspcyhyW29dKTtyZXR1cm4gc30pKHsxOltmdW5jdGlvbihfZGVyZXFfLG1vZHVsZSxleHBvcnRzKXtcblwidXNlIHN0cmljdFwiO1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihQcm9taXNlKSB7XG52YXIgU29tZVByb21pc2VBcnJheSA9IFByb21pc2UuX1NvbWVQcm9taXNlQXJyYXk7XG5mdW5jdGlvbiBhbnkocHJvbWlzZXMpIHtcbiAgICB2YXIgcmV0ID0gbmV3IFNvbWVQcm9taXNlQXJyYXkocHJvbWlzZXMpO1xuICAgIHZhciBwcm9taXNlID0gcmV0LnByb21pc2UoKTtcbiAgICByZXQuc2V0SG93TWFueSgxKTtcbiAgICByZXQuc2V0VW53cmFwKCk7XG4gICAgcmV0LmluaXQoKTtcbiAgICByZXR1cm4gcHJvbWlzZTtcbn1cblxuUHJvbWlzZS5hbnkgPSBmdW5jdGlvbiAocHJvbWlzZXMpIHtcbiAgICByZXR1cm4gYW55KHByb21pc2VzKTtcbn07XG5cblByb21pc2UucHJvdG90eXBlLmFueSA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gYW55KHRoaXMpO1xufTtcblxufTtcblxufSx7fV0sMjpbZnVuY3Rpb24oX2RlcmVxXyxtb2R1bGUsZXhwb3J0cyl7XG5cInVzZSBzdHJpY3RcIjtcbnZhciBmaXJzdExpbmVFcnJvcjtcbnRyeSB7dGhyb3cgbmV3IEVycm9yKCk7IH0gY2F0Y2ggKGUpIHtmaXJzdExpbmVFcnJvciA9IGU7fVxudmFyIHNjaGVkdWxlID0gX2RlcmVxXyhcIi4vc2NoZWR1bGVcIik7XG52YXIgUXVldWUgPSBfZGVyZXFfKFwiLi9xdWV1ZVwiKTtcbnZhciB1dGlsID0gX2RlcmVxXyhcIi4vdXRpbFwiKTtcblxuZnVuY3Rpb24gQXN5bmMoKSB7XG4gICAgdGhpcy5faXNUaWNrVXNlZCA9IGZhbHNlO1xuICAgIHRoaXMuX2xhdGVRdWV1ZSA9IG5ldyBRdWV1ZSgxNik7XG4gICAgdGhpcy5fbm9ybWFsUXVldWUgPSBuZXcgUXVldWUoMTYpO1xuICAgIHRoaXMuX2hhdmVEcmFpbmVkUXVldWVzID0gZmFsc2U7XG4gICAgdGhpcy5fdHJhbXBvbGluZUVuYWJsZWQgPSB0cnVlO1xuICAgIHZhciBzZWxmID0gdGhpcztcbiAgICB0aGlzLmRyYWluUXVldWVzID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBzZWxmLl9kcmFpblF1ZXVlcygpO1xuICAgIH07XG4gICAgdGhpcy5fc2NoZWR1bGUgPVxuICAgICAgICBzY2hlZHVsZS5pc1N0YXRpYyA/IHNjaGVkdWxlKHRoaXMuZHJhaW5RdWV1ZXMpIDogc2NoZWR1bGU7XG59XG5cbkFzeW5jLnByb3RvdHlwZS5lbmFibGVUcmFtcG9saW5lID0gZnVuY3Rpb24oKSB7XG4gICAgdGhpcy5fdHJhbXBvbGluZUVuYWJsZWQgPSB0cnVlO1xufTtcblxuQXN5bmMucHJvdG90eXBlLmRpc2FibGVUcmFtcG9saW5lSWZOZWNlc3NhcnkgPSBmdW5jdGlvbigpIHtcbiAgICBpZiAodXRpbC5oYXNEZXZUb29scykge1xuICAgICAgICB0aGlzLl90cmFtcG9saW5lRW5hYmxlZCA9IGZhbHNlO1xuICAgIH1cbn07XG5cbkFzeW5jLnByb3RvdHlwZS5oYXZlSXRlbXNRdWV1ZWQgPSBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2lzVGlja1VzZWQgfHwgdGhpcy5faGF2ZURyYWluZWRRdWV1ZXM7XG59O1xuXG5cbkFzeW5jLnByb3RvdHlwZS5mYXRhbEVycm9yID0gZnVuY3Rpb24oZSwgaXNOb2RlKSB7XG4gICAgaWYgKGlzTm9kZSkge1xuICAgICAgICBwcm9jZXNzLnN0ZGVyci53cml0ZShcIkZhdGFsIFwiICsgKGUgaW5zdGFuY2VvZiBFcnJvciA/IGUuc3RhY2sgOiBlKSk7XG4gICAgICAgIHByb2Nlc3MuZXhpdCgyKTtcbiAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLnRocm93TGF0ZXIoZSk7XG4gICAgfVxufTtcblxuQXN5bmMucHJvdG90eXBlLnRocm93TGF0ZXIgPSBmdW5jdGlvbihmbiwgYXJnKSB7XG4gICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDEpIHtcbiAgICAgICAgYXJnID0gZm47XG4gICAgICAgIGZuID0gZnVuY3Rpb24gKCkgeyB0aHJvdyBhcmc7IH07XG4gICAgfVxuICAgIGlmICh0eXBlb2Ygc2V0VGltZW91dCAhPT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgZm4oYXJnKTtcbiAgICAgICAgfSwgMCk7XG4gICAgfSBlbHNlIHRyeSB7XG4gICAgICAgIHRoaXMuX3NjaGVkdWxlKGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgZm4oYXJnKTtcbiAgICAgICAgfSk7XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJObyBhc3luYyBzY2hlZHVsZXIgYXZhaWxhYmxlXFx1MDAwYVxcdTAwMGEgICAgU2VlIGh0dHA6Ly9nb28uZ2wvTXFyRm1YXFx1MDAwYVwiKTtcbiAgICB9XG59O1xuXG5mdW5jdGlvbiBBc3luY0ludm9rZUxhdGVyKGZuLCByZWNlaXZlciwgYXJnKSB7XG4gICAgdGhpcy5fbGF0ZVF1ZXVlLnB1c2goZm4sIHJlY2VpdmVyLCBhcmcpO1xuICAgIHRoaXMuX3F1ZXVlVGljaygpO1xufVxuXG5mdW5jdGlvbiBBc3luY0ludm9rZShmbiwgcmVjZWl2ZXIsIGFyZykge1xuICAgIHRoaXMuX25vcm1hbFF1ZXVlLnB1c2goZm4sIHJlY2VpdmVyLCBhcmcpO1xuICAgIHRoaXMuX3F1ZXVlVGljaygpO1xufVxuXG5mdW5jdGlvbiBBc3luY1NldHRsZVByb21pc2VzKHByb21pc2UpIHtcbiAgICB0aGlzLl9ub3JtYWxRdWV1ZS5fcHVzaE9uZShwcm9taXNlKTtcbiAgICB0aGlzLl9xdWV1ZVRpY2soKTtcbn1cblxuaWYgKCF1dGlsLmhhc0RldlRvb2xzKSB7XG4gICAgQXN5bmMucHJvdG90eXBlLmludm9rZUxhdGVyID0gQXN5bmNJbnZva2VMYXRlcjtcbiAgICBBc3luYy5wcm90b3R5cGUuaW52b2tlID0gQXN5bmNJbnZva2U7XG4gICAgQXN5bmMucHJvdG90eXBlLnNldHRsZVByb21pc2VzID0gQXN5bmNTZXR0bGVQcm9taXNlcztcbn0gZWxzZSB7XG4gICAgaWYgKHNjaGVkdWxlLmlzU3RhdGljKSB7XG4gICAgICAgIHNjaGVkdWxlID0gZnVuY3Rpb24oZm4pIHsgc2V0VGltZW91dChmbiwgMCk7IH07XG4gICAgfVxuICAgIEFzeW5jLnByb3RvdHlwZS5pbnZva2VMYXRlciA9IGZ1bmN0aW9uIChmbiwgcmVjZWl2ZXIsIGFyZykge1xuICAgICAgICBpZiAodGhpcy5fdHJhbXBvbGluZUVuYWJsZWQpIHtcbiAgICAgICAgICAgIEFzeW5jSW52b2tlTGF0ZXIuY2FsbCh0aGlzLCBmbiwgcmVjZWl2ZXIsIGFyZyk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aGlzLl9zY2hlZHVsZShmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICBmbi5jYWxsKHJlY2VpdmVyLCBhcmcpO1xuICAgICAgICAgICAgICAgIH0sIDEwMCk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH07XG5cbiAgICBBc3luYy5wcm90b3R5cGUuaW52b2tlID0gZnVuY3Rpb24gKGZuLCByZWNlaXZlciwgYXJnKSB7XG4gICAgICAgIGlmICh0aGlzLl90cmFtcG9saW5lRW5hYmxlZCkge1xuICAgICAgICAgICAgQXN5bmNJbnZva2UuY2FsbCh0aGlzLCBmbiwgcmVjZWl2ZXIsIGFyZyk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aGlzLl9zY2hlZHVsZShmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICBmbi5jYWxsKHJlY2VpdmVyLCBhcmcpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgQXN5bmMucHJvdG90eXBlLnNldHRsZVByb21pc2VzID0gZnVuY3Rpb24ocHJvbWlzZSkge1xuICAgICAgICBpZiAodGhpcy5fdHJhbXBvbGluZUVuYWJsZWQpIHtcbiAgICAgICAgICAgIEFzeW5jU2V0dGxlUHJvbWlzZXMuY2FsbCh0aGlzLCBwcm9taXNlKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuX3NjaGVkdWxlKGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgIHByb21pc2UuX3NldHRsZVByb21pc2VzKCk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH07XG59XG5cbkFzeW5jLnByb3RvdHlwZS5pbnZva2VGaXJzdCA9IGZ1bmN0aW9uIChmbiwgcmVjZWl2ZXIsIGFyZykge1xuICAgIHRoaXMuX25vcm1hbFF1ZXVlLnVuc2hpZnQoZm4sIHJlY2VpdmVyLCBhcmcpO1xuICAgIHRoaXMuX3F1ZXVlVGljaygpO1xufTtcblxuQXN5bmMucHJvdG90eXBlLl9kcmFpblF1ZXVlID0gZnVuY3Rpb24ocXVldWUpIHtcbiAgICB3aGlsZSAocXVldWUubGVuZ3RoKCkgPiAwKSB7XG4gICAgICAgIHZhciBmbiA9IHF1ZXVlLnNoaWZ0KCk7XG4gICAgICAgIGlmICh0eXBlb2YgZm4gIT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICAgICAgZm4uX3NldHRsZVByb21pc2VzKCk7XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgcmVjZWl2ZXIgPSBxdWV1ZS5zaGlmdCgpO1xuICAgICAgICB2YXIgYXJnID0gcXVldWUuc2hpZnQoKTtcbiAgICAgICAgZm4uY2FsbChyZWNlaXZlciwgYXJnKTtcbiAgICB9XG59O1xuXG5Bc3luYy5wcm90b3R5cGUuX2RyYWluUXVldWVzID0gZnVuY3Rpb24gKCkge1xuICAgIHRoaXMuX2RyYWluUXVldWUodGhpcy5fbm9ybWFsUXVldWUpO1xuICAgIHRoaXMuX3Jlc2V0KCk7XG4gICAgdGhpcy5faGF2ZURyYWluZWRRdWV1ZXMgPSB0cnVlO1xuICAgIHRoaXMuX2RyYWluUXVldWUodGhpcy5fbGF0ZVF1ZXVlKTtcbn07XG5cbkFzeW5jLnByb3RvdHlwZS5fcXVldWVUaWNrID0gZnVuY3Rpb24gKCkge1xuICAgIGlmICghdGhpcy5faXNUaWNrVXNlZCkge1xuICAgICAgICB0aGlzLl9pc1RpY2tVc2VkID0gdHJ1ZTtcbiAgICAgICAgdGhpcy5fc2NoZWR1bGUodGhpcy5kcmFpblF1ZXVlcyk7XG4gICAgfVxufTtcblxuQXN5bmMucHJvdG90eXBlLl9yZXNldCA9IGZ1bmN0aW9uICgpIHtcbiAgICB0aGlzLl9pc1RpY2tVc2VkID0gZmFsc2U7XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IEFzeW5jO1xubW9kdWxlLmV4cG9ydHMuZmlyc3RMaW5lRXJyb3IgPSBmaXJzdExpbmVFcnJvcjtcblxufSx7XCIuL3F1ZXVlXCI6MjYsXCIuL3NjaGVkdWxlXCI6MjksXCIuL3V0aWxcIjozNn1dLDM6W2Z1bmN0aW9uKF9kZXJlcV8sbW9kdWxlLGV4cG9ydHMpe1xuXCJ1c2Ugc3RyaWN0XCI7XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKFByb21pc2UsIElOVEVSTkFMLCB0cnlDb252ZXJ0VG9Qcm9taXNlLCBkZWJ1Zykge1xudmFyIGNhbGxlZEJpbmQgPSBmYWxzZTtcbnZhciByZWplY3RUaGlzID0gZnVuY3Rpb24oXywgZSkge1xuICAgIHRoaXMuX3JlamVjdChlKTtcbn07XG5cbnZhciB0YXJnZXRSZWplY3RlZCA9IGZ1bmN0aW9uKGUsIGNvbnRleHQpIHtcbiAgICBjb250ZXh0LnByb21pc2VSZWplY3Rpb25RdWV1ZWQgPSB0cnVlO1xuICAgIGNvbnRleHQuYmluZGluZ1Byb21pc2UuX3RoZW4ocmVqZWN0VGhpcywgcmVqZWN0VGhpcywgbnVsbCwgdGhpcywgZSk7XG59O1xuXG52YXIgYmluZGluZ1Jlc29sdmVkID0gZnVuY3Rpb24odGhpc0FyZywgY29udGV4dCkge1xuICAgIGlmICgoKHRoaXMuX2JpdEZpZWxkICYgNTAzOTcxODQpID09PSAwKSkge1xuICAgICAgICB0aGlzLl9yZXNvbHZlQ2FsbGJhY2soY29udGV4dC50YXJnZXQpO1xuICAgIH1cbn07XG5cbnZhciBiaW5kaW5nUmVqZWN0ZWQgPSBmdW5jdGlvbihlLCBjb250ZXh0KSB7XG4gICAgaWYgKCFjb250ZXh0LnByb21pc2VSZWplY3Rpb25RdWV1ZWQpIHRoaXMuX3JlamVjdChlKTtcbn07XG5cblByb21pc2UucHJvdG90eXBlLmJpbmQgPSBmdW5jdGlvbiAodGhpc0FyZykge1xuICAgIGlmICghY2FsbGVkQmluZCkge1xuICAgICAgICBjYWxsZWRCaW5kID0gdHJ1ZTtcbiAgICAgICAgUHJvbWlzZS5wcm90b3R5cGUuX3Byb3BhZ2F0ZUZyb20gPSBkZWJ1Zy5wcm9wYWdhdGVGcm9tRnVuY3Rpb24oKTtcbiAgICAgICAgUHJvbWlzZS5wcm90b3R5cGUuX2JvdW5kVmFsdWUgPSBkZWJ1Zy5ib3VuZFZhbHVlRnVuY3Rpb24oKTtcbiAgICB9XG4gICAgdmFyIG1heWJlUHJvbWlzZSA9IHRyeUNvbnZlcnRUb1Byb21pc2UodGhpc0FyZyk7XG4gICAgdmFyIHJldCA9IG5ldyBQcm9taXNlKElOVEVSTkFMKTtcbiAgICByZXQuX3Byb3BhZ2F0ZUZyb20odGhpcywgMSk7XG4gICAgdmFyIHRhcmdldCA9IHRoaXMuX3RhcmdldCgpO1xuICAgIHJldC5fc2V0Qm91bmRUbyhtYXliZVByb21pc2UpO1xuICAgIGlmIChtYXliZVByb21pc2UgaW5zdGFuY2VvZiBQcm9taXNlKSB7XG4gICAgICAgIHZhciBjb250ZXh0ID0ge1xuICAgICAgICAgICAgcHJvbWlzZVJlamVjdGlvblF1ZXVlZDogZmFsc2UsXG4gICAgICAgICAgICBwcm9taXNlOiByZXQsXG4gICAgICAgICAgICB0YXJnZXQ6IHRhcmdldCxcbiAgICAgICAgICAgIGJpbmRpbmdQcm9taXNlOiBtYXliZVByb21pc2VcbiAgICAgICAgfTtcbiAgICAgICAgdGFyZ2V0Ll90aGVuKElOVEVSTkFMLCB0YXJnZXRSZWplY3RlZCwgdW5kZWZpbmVkLCByZXQsIGNvbnRleHQpO1xuICAgICAgICBtYXliZVByb21pc2UuX3RoZW4oXG4gICAgICAgICAgICBiaW5kaW5nUmVzb2x2ZWQsIGJpbmRpbmdSZWplY3RlZCwgdW5kZWZpbmVkLCByZXQsIGNvbnRleHQpO1xuICAgICAgICByZXQuX3NldE9uQ2FuY2VsKG1heWJlUHJvbWlzZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgcmV0Ll9yZXNvbHZlQ2FsbGJhY2sodGFyZ2V0KTtcbiAgICB9XG4gICAgcmV0dXJuIHJldDtcbn07XG5cblByb21pc2UucHJvdG90eXBlLl9zZXRCb3VuZFRvID0gZnVuY3Rpb24gKG9iaikge1xuICAgIGlmIChvYmogIT09IHVuZGVmaW5lZCkge1xuICAgICAgICB0aGlzLl9iaXRGaWVsZCA9IHRoaXMuX2JpdEZpZWxkIHwgMjA5NzE1MjtcbiAgICAgICAgdGhpcy5fYm91bmRUbyA9IG9iajtcbiAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLl9iaXRGaWVsZCA9IHRoaXMuX2JpdEZpZWxkICYgKH4yMDk3MTUyKTtcbiAgICB9XG59O1xuXG5Qcm9taXNlLnByb3RvdHlwZS5faXNCb3VuZCA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gKHRoaXMuX2JpdEZpZWxkICYgMjA5NzE1MikgPT09IDIwOTcxNTI7XG59O1xuXG5Qcm9taXNlLmJpbmQgPSBmdW5jdGlvbiAodGhpc0FyZywgdmFsdWUpIHtcbiAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKHZhbHVlKS5iaW5kKHRoaXNBcmcpO1xufTtcbn07XG5cbn0se31dLDQ6W2Z1bmN0aW9uKF9kZXJlcV8sbW9kdWxlLGV4cG9ydHMpe1xuXCJ1c2Ugc3RyaWN0XCI7XG52YXIgb2xkO1xuaWYgKHR5cGVvZiBQcm9taXNlICE9PSBcInVuZGVmaW5lZFwiKSBvbGQgPSBQcm9taXNlO1xuZnVuY3Rpb24gbm9Db25mbGljdCgpIHtcbiAgICB0cnkgeyBpZiAoUHJvbWlzZSA9PT0gYmx1ZWJpcmQpIFByb21pc2UgPSBvbGQ7IH1cbiAgICBjYXRjaCAoZSkge31cbiAgICByZXR1cm4gYmx1ZWJpcmQ7XG59XG52YXIgYmx1ZWJpcmQgPSBfZGVyZXFfKFwiLi9wcm9taXNlXCIpKCk7XG5ibHVlYmlyZC5ub0NvbmZsaWN0ID0gbm9Db25mbGljdDtcbm1vZHVsZS5leHBvcnRzID0gYmx1ZWJpcmQ7XG5cbn0se1wiLi9wcm9taXNlXCI6MjJ9XSw1OltmdW5jdGlvbihfZGVyZXFfLG1vZHVsZSxleHBvcnRzKXtcblwidXNlIHN0cmljdFwiO1xudmFyIGNyID0gT2JqZWN0LmNyZWF0ZTtcbmlmIChjcikge1xuICAgIHZhciBjYWxsZXJDYWNoZSA9IGNyKG51bGwpO1xuICAgIHZhciBnZXR0ZXJDYWNoZSA9IGNyKG51bGwpO1xuICAgIGNhbGxlckNhY2hlW1wiIHNpemVcIl0gPSBnZXR0ZXJDYWNoZVtcIiBzaXplXCJdID0gMDtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihQcm9taXNlKSB7XG52YXIgdXRpbCA9IF9kZXJlcV8oXCIuL3V0aWxcIik7XG52YXIgY2FuRXZhbHVhdGUgPSB1dGlsLmNhbkV2YWx1YXRlO1xudmFyIGlzSWRlbnRpZmllciA9IHV0aWwuaXNJZGVudGlmaWVyO1xuXG52YXIgZ2V0TWV0aG9kQ2FsbGVyO1xudmFyIGdldEdldHRlcjtcbmlmICghdHJ1ZSkge1xudmFyIG1ha2VNZXRob2RDYWxsZXIgPSBmdW5jdGlvbiAobWV0aG9kTmFtZSkge1xuICAgIHJldHVybiBuZXcgRnVuY3Rpb24oXCJlbnN1cmVNZXRob2RcIiwgXCIgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcXG5cXFxuICAgICAgICByZXR1cm4gZnVuY3Rpb24ob2JqKSB7ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcXG5cXFxuICAgICAgICAgICAgJ3VzZSBzdHJpY3QnICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcXG5cXFxuICAgICAgICAgICAgdmFyIGxlbiA9IHRoaXMubGVuZ3RoOyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcXG5cXFxuICAgICAgICAgICAgZW5zdXJlTWV0aG9kKG9iaiwgJ21ldGhvZE5hbWUnKTsgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcXG5cXFxuICAgICAgICAgICAgc3dpdGNoKGxlbikgeyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcXG5cXFxuICAgICAgICAgICAgICAgIGNhc2UgMTogcmV0dXJuIG9iai5tZXRob2ROYW1lKHRoaXNbMF0pOyAgICAgICAgICAgICAgICAgICAgICBcXG5cXFxuICAgICAgICAgICAgICAgIGNhc2UgMjogcmV0dXJuIG9iai5tZXRob2ROYW1lKHRoaXNbMF0sIHRoaXNbMV0pOyAgICAgICAgICAgICBcXG5cXFxuICAgICAgICAgICAgICAgIGNhc2UgMzogcmV0dXJuIG9iai5tZXRob2ROYW1lKHRoaXNbMF0sIHRoaXNbMV0sIHRoaXNbMl0pOyAgICBcXG5cXFxuICAgICAgICAgICAgICAgIGNhc2UgMDogcmV0dXJuIG9iai5tZXRob2ROYW1lKCk7ICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcXG5cXFxuICAgICAgICAgICAgICAgIGRlZmF1bHQ6ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcXG5cXFxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gb2JqLm1ldGhvZE5hbWUuYXBwbHkob2JqLCB0aGlzKTsgICAgICAgICAgICAgICAgICBcXG5cXFxuICAgICAgICAgICAgfSAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcXG5cXFxuICAgICAgICB9OyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcXG5cXFxuICAgICAgICBcIi5yZXBsYWNlKC9tZXRob2ROYW1lL2csIG1ldGhvZE5hbWUpKShlbnN1cmVNZXRob2QpO1xufTtcblxudmFyIG1ha2VHZXR0ZXIgPSBmdW5jdGlvbiAocHJvcGVydHlOYW1lKSB7XG4gICAgcmV0dXJuIG5ldyBGdW5jdGlvbihcIm9ialwiLCBcIiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFxcblxcXG4gICAgICAgICd1c2Ugc3RyaWN0JzsgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFxcblxcXG4gICAgICAgIHJldHVybiBvYmoucHJvcGVydHlOYW1lOyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFxcblxcXG4gICAgICAgIFwiLnJlcGxhY2UoXCJwcm9wZXJ0eU5hbWVcIiwgcHJvcGVydHlOYW1lKSk7XG59O1xuXG52YXIgZ2V0Q29tcGlsZWQgPSBmdW5jdGlvbihuYW1lLCBjb21waWxlciwgY2FjaGUpIHtcbiAgICB2YXIgcmV0ID0gY2FjaGVbbmFtZV07XG4gICAgaWYgKHR5cGVvZiByZXQgIT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICBpZiAoIWlzSWRlbnRpZmllcihuYW1lKSkge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgcmV0ID0gY29tcGlsZXIobmFtZSk7XG4gICAgICAgIGNhY2hlW25hbWVdID0gcmV0O1xuICAgICAgICBjYWNoZVtcIiBzaXplXCJdKys7XG4gICAgICAgIGlmIChjYWNoZVtcIiBzaXplXCJdID4gNTEyKSB7XG4gICAgICAgICAgICB2YXIga2V5cyA9IE9iamVjdC5rZXlzKGNhY2hlKTtcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgMjU2OyArK2kpIGRlbGV0ZSBjYWNoZVtrZXlzW2ldXTtcbiAgICAgICAgICAgIGNhY2hlW1wiIHNpemVcIl0gPSBrZXlzLmxlbmd0aCAtIDI1NjtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gcmV0O1xufTtcblxuZ2V0TWV0aG9kQ2FsbGVyID0gZnVuY3Rpb24obmFtZSkge1xuICAgIHJldHVybiBnZXRDb21waWxlZChuYW1lLCBtYWtlTWV0aG9kQ2FsbGVyLCBjYWxsZXJDYWNoZSk7XG59O1xuXG5nZXRHZXR0ZXIgPSBmdW5jdGlvbihuYW1lKSB7XG4gICAgcmV0dXJuIGdldENvbXBpbGVkKG5hbWUsIG1ha2VHZXR0ZXIsIGdldHRlckNhY2hlKTtcbn07XG59XG5cbmZ1bmN0aW9uIGVuc3VyZU1ldGhvZChvYmosIG1ldGhvZE5hbWUpIHtcbiAgICB2YXIgZm47XG4gICAgaWYgKG9iaiAhPSBudWxsKSBmbiA9IG9ialttZXRob2ROYW1lXTtcbiAgICBpZiAodHlwZW9mIGZuICE9PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgdmFyIG1lc3NhZ2UgPSBcIk9iamVjdCBcIiArIHV0aWwuY2xhc3NTdHJpbmcob2JqKSArIFwiIGhhcyBubyBtZXRob2QgJ1wiICtcbiAgICAgICAgICAgIHV0aWwudG9TdHJpbmcobWV0aG9kTmFtZSkgKyBcIidcIjtcbiAgICAgICAgdGhyb3cgbmV3IFByb21pc2UuVHlwZUVycm9yKG1lc3NhZ2UpO1xuICAgIH1cbiAgICByZXR1cm4gZm47XG59XG5cbmZ1bmN0aW9uIGNhbGxlcihvYmopIHtcbiAgICB2YXIgbWV0aG9kTmFtZSA9IHRoaXMucG9wKCk7XG4gICAgdmFyIGZuID0gZW5zdXJlTWV0aG9kKG9iaiwgbWV0aG9kTmFtZSk7XG4gICAgcmV0dXJuIGZuLmFwcGx5KG9iaiwgdGhpcyk7XG59XG5Qcm9taXNlLnByb3RvdHlwZS5jYWxsID0gZnVuY3Rpb24gKG1ldGhvZE5hbWUpIHtcbiAgICB2YXIgYXJncyA9IFtdLnNsaWNlLmNhbGwoYXJndW1lbnRzLCAxKTs7XG4gICAgaWYgKCF0cnVlKSB7XG4gICAgICAgIGlmIChjYW5FdmFsdWF0ZSkge1xuICAgICAgICAgICAgdmFyIG1heWJlQ2FsbGVyID0gZ2V0TWV0aG9kQ2FsbGVyKG1ldGhvZE5hbWUpO1xuICAgICAgICAgICAgaWYgKG1heWJlQ2FsbGVyICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3RoZW4oXG4gICAgICAgICAgICAgICAgICAgIG1heWJlQ2FsbGVyLCB1bmRlZmluZWQsIHVuZGVmaW5lZCwgYXJncywgdW5kZWZpbmVkKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICBhcmdzLnB1c2gobWV0aG9kTmFtZSk7XG4gICAgcmV0dXJuIHRoaXMuX3RoZW4oY2FsbGVyLCB1bmRlZmluZWQsIHVuZGVmaW5lZCwgYXJncywgdW5kZWZpbmVkKTtcbn07XG5cbmZ1bmN0aW9uIG5hbWVkR2V0dGVyKG9iaikge1xuICAgIHJldHVybiBvYmpbdGhpc107XG59XG5mdW5jdGlvbiBpbmRleGVkR2V0dGVyKG9iaikge1xuICAgIHZhciBpbmRleCA9ICt0aGlzO1xuICAgIGlmIChpbmRleCA8IDApIGluZGV4ID0gTWF0aC5tYXgoMCwgaW5kZXggKyBvYmoubGVuZ3RoKTtcbiAgICByZXR1cm4gb2JqW2luZGV4XTtcbn1cblByb21pc2UucHJvdG90eXBlLmdldCA9IGZ1bmN0aW9uIChwcm9wZXJ0eU5hbWUpIHtcbiAgICB2YXIgaXNJbmRleCA9ICh0eXBlb2YgcHJvcGVydHlOYW1lID09PSBcIm51bWJlclwiKTtcbiAgICB2YXIgZ2V0dGVyO1xuICAgIGlmICghaXNJbmRleCkge1xuICAgICAgICBpZiAoY2FuRXZhbHVhdGUpIHtcbiAgICAgICAgICAgIHZhciBtYXliZUdldHRlciA9IGdldEdldHRlcihwcm9wZXJ0eU5hbWUpO1xuICAgICAgICAgICAgZ2V0dGVyID0gbWF5YmVHZXR0ZXIgIT09IG51bGwgPyBtYXliZUdldHRlciA6IG5hbWVkR2V0dGVyO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgZ2V0dGVyID0gbmFtZWRHZXR0ZXI7XG4gICAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgICBnZXR0ZXIgPSBpbmRleGVkR2V0dGVyO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5fdGhlbihnZXR0ZXIsIHVuZGVmaW5lZCwgdW5kZWZpbmVkLCBwcm9wZXJ0eU5hbWUsIHVuZGVmaW5lZCk7XG59O1xufTtcblxufSx7XCIuL3V0aWxcIjozNn1dLDY6W2Z1bmN0aW9uKF9kZXJlcV8sbW9kdWxlLGV4cG9ydHMpe1xuXCJ1c2Ugc3RyaWN0XCI7XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKFByb21pc2UsIFByb21pc2VBcnJheSwgYXBpUmVqZWN0aW9uLCBkZWJ1Zykge1xudmFyIHV0aWwgPSBfZGVyZXFfKFwiLi91dGlsXCIpO1xudmFyIHRyeUNhdGNoID0gdXRpbC50cnlDYXRjaDtcbnZhciBlcnJvck9iaiA9IHV0aWwuZXJyb3JPYmo7XG52YXIgYXN5bmMgPSBQcm9taXNlLl9hc3luYztcblxuUHJvbWlzZS5wcm90b3R5cGVbXCJicmVha1wiXSA9IFByb21pc2UucHJvdG90eXBlLmNhbmNlbCA9IGZ1bmN0aW9uKCkge1xuICAgIGlmICghZGVidWcuY2FuY2VsbGF0aW9uKCkpIHJldHVybiB0aGlzLl93YXJuKFwiY2FuY2VsbGF0aW9uIGlzIGRpc2FibGVkXCIpO1xuXG4gICAgdmFyIHByb21pc2UgPSB0aGlzO1xuICAgIHZhciBjaGlsZCA9IHByb21pc2U7XG4gICAgd2hpbGUgKHByb21pc2UuaXNDYW5jZWxsYWJsZSgpKSB7XG4gICAgICAgIGlmICghcHJvbWlzZS5fY2FuY2VsQnkoY2hpbGQpKSB7XG4gICAgICAgICAgICBpZiAoY2hpbGQuX2lzRm9sbG93aW5nKCkpIHtcbiAgICAgICAgICAgICAgICBjaGlsZC5fZm9sbG93ZWUoKS5jYW5jZWwoKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgY2hpbGQuX2NhbmNlbEJyYW5jaGVkKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBwYXJlbnQgPSBwcm9taXNlLl9jYW5jZWxsYXRpb25QYXJlbnQ7XG4gICAgICAgIGlmIChwYXJlbnQgPT0gbnVsbCB8fCAhcGFyZW50LmlzQ2FuY2VsbGFibGUoKSkge1xuICAgICAgICAgICAgaWYgKHByb21pc2UuX2lzRm9sbG93aW5nKCkpIHtcbiAgICAgICAgICAgICAgICBwcm9taXNlLl9mb2xsb3dlZSgpLmNhbmNlbCgpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBwcm9taXNlLl9jYW5jZWxCcmFuY2hlZCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBpZiAocHJvbWlzZS5faXNGb2xsb3dpbmcoKSkgcHJvbWlzZS5fZm9sbG93ZWUoKS5jYW5jZWwoKTtcbiAgICAgICAgICAgIGNoaWxkID0gcHJvbWlzZTtcbiAgICAgICAgICAgIHByb21pc2UgPSBwYXJlbnQ7XG4gICAgICAgIH1cbiAgICB9XG59O1xuXG5Qcm9taXNlLnByb3RvdHlwZS5fYnJhbmNoSGFzQ2FuY2VsbGVkID0gZnVuY3Rpb24oKSB7XG4gICAgdGhpcy5fYnJhbmNoZXNSZW1haW5pbmdUb0NhbmNlbC0tO1xufTtcblxuUHJvbWlzZS5wcm90b3R5cGUuX2Vub3VnaEJyYW5jaGVzSGF2ZUNhbmNlbGxlZCA9IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiB0aGlzLl9icmFuY2hlc1JlbWFpbmluZ1RvQ2FuY2VsID09PSB1bmRlZmluZWQgfHxcbiAgICAgICAgICAgdGhpcy5fYnJhbmNoZXNSZW1haW5pbmdUb0NhbmNlbCA8PSAwO1xufTtcblxuUHJvbWlzZS5wcm90b3R5cGUuX2NhbmNlbEJ5ID0gZnVuY3Rpb24oY2FuY2VsbGVyKSB7XG4gICAgaWYgKGNhbmNlbGxlciA9PT0gdGhpcykge1xuICAgICAgICB0aGlzLl9icmFuY2hlc1JlbWFpbmluZ1RvQ2FuY2VsID0gMDtcbiAgICAgICAgdGhpcy5faW52b2tlT25DYW5jZWwoKTtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5fYnJhbmNoSGFzQ2FuY2VsbGVkKCk7XG4gICAgICAgIGlmICh0aGlzLl9lbm91Z2hCcmFuY2hlc0hhdmVDYW5jZWxsZWQoKSkge1xuICAgICAgICAgICAgdGhpcy5faW52b2tlT25DYW5jZWwoKTtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBmYWxzZTtcbn07XG5cblByb21pc2UucHJvdG90eXBlLl9jYW5jZWxCcmFuY2hlZCA9IGZ1bmN0aW9uKCkge1xuICAgIGlmICh0aGlzLl9lbm91Z2hCcmFuY2hlc0hhdmVDYW5jZWxsZWQoKSkge1xuICAgICAgICB0aGlzLl9jYW5jZWwoKTtcbiAgICB9XG59O1xuXG5Qcm9taXNlLnByb3RvdHlwZS5fY2FuY2VsID0gZnVuY3Rpb24oKSB7XG4gICAgaWYgKCF0aGlzLmlzQ2FuY2VsbGFibGUoKSkgcmV0dXJuO1xuXG4gICAgdGhpcy5fc2V0Q2FuY2VsbGVkKCk7XG4gICAgYXN5bmMuaW52b2tlKHRoaXMuX2NhbmNlbFByb21pc2VzLCB0aGlzLCB1bmRlZmluZWQpO1xufTtcblxuUHJvbWlzZS5wcm90b3R5cGUuX2NhbmNlbFByb21pc2VzID0gZnVuY3Rpb24oKSB7XG4gICAgaWYgKHRoaXMuX2xlbmd0aCgpID4gMCkgdGhpcy5fc2V0dGxlUHJvbWlzZXMoKTtcbn07XG5cblByb21pc2UucHJvdG90eXBlLl91bnNldE9uQ2FuY2VsID0gZnVuY3Rpb24oKSB7XG4gICAgdGhpcy5fb25DYW5jZWxGaWVsZCA9IHVuZGVmaW5lZDtcbn07XG5cblByb21pc2UucHJvdG90eXBlLmlzQ2FuY2VsbGFibGUgPSBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gdGhpcy5pc1BlbmRpbmcoKSAmJiAhdGhpcy5pc0NhbmNlbGxlZCgpO1xufTtcblxuUHJvbWlzZS5wcm90b3R5cGUuX2RvSW52b2tlT25DYW5jZWwgPSBmdW5jdGlvbihvbkNhbmNlbENhbGxiYWNrLCBpbnRlcm5hbE9ubHkpIHtcbiAgICBpZiAodXRpbC5pc0FycmF5KG9uQ2FuY2VsQ2FsbGJhY2spKSB7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgb25DYW5jZWxDYWxsYmFjay5sZW5ndGg7ICsraSkge1xuICAgICAgICAgICAgdGhpcy5fZG9JbnZva2VPbkNhbmNlbChvbkNhbmNlbENhbGxiYWNrW2ldLCBpbnRlcm5hbE9ubHkpO1xuICAgICAgICB9XG4gICAgfSBlbHNlIGlmIChvbkNhbmNlbENhbGxiYWNrICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBvbkNhbmNlbENhbGxiYWNrID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgICAgIGlmICghaW50ZXJuYWxPbmx5KSB7XG4gICAgICAgICAgICAgICAgdmFyIGUgPSB0cnlDYXRjaChvbkNhbmNlbENhbGxiYWNrKS5jYWxsKHRoaXMuX2JvdW5kVmFsdWUoKSk7XG4gICAgICAgICAgICAgICAgaWYgKGUgPT09IGVycm9yT2JqKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2F0dGFjaEV4dHJhVHJhY2UoZS5lKTtcbiAgICAgICAgICAgICAgICAgICAgYXN5bmMudGhyb3dMYXRlcihlLmUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIG9uQ2FuY2VsQ2FsbGJhY2suX3Jlc3VsdENhbmNlbGxlZCh0aGlzKTtcbiAgICAgICAgfVxuICAgIH1cbn07XG5cblByb21pc2UucHJvdG90eXBlLl9pbnZva2VPbkNhbmNlbCA9IGZ1bmN0aW9uKCkge1xuICAgIHZhciBvbkNhbmNlbENhbGxiYWNrID0gdGhpcy5fb25DYW5jZWwoKTtcbiAgICB0aGlzLl91bnNldE9uQ2FuY2VsKCk7XG4gICAgYXN5bmMuaW52b2tlKHRoaXMuX2RvSW52b2tlT25DYW5jZWwsIHRoaXMsIG9uQ2FuY2VsQ2FsbGJhY2spO1xufTtcblxuUHJvbWlzZS5wcm90b3R5cGUuX2ludm9rZUludGVybmFsT25DYW5jZWwgPSBmdW5jdGlvbigpIHtcbiAgICBpZiAodGhpcy5pc0NhbmNlbGxhYmxlKCkpIHtcbiAgICAgICAgdGhpcy5fZG9JbnZva2VPbkNhbmNlbCh0aGlzLl9vbkNhbmNlbCgpLCB0cnVlKTtcbiAgICAgICAgdGhpcy5fdW5zZXRPbkNhbmNlbCgpO1xuICAgIH1cbn07XG5cblByb21pc2UucHJvdG90eXBlLl9yZXN1bHRDYW5jZWxsZWQgPSBmdW5jdGlvbigpIHtcbiAgICB0aGlzLmNhbmNlbCgpO1xufTtcblxufTtcblxufSx7XCIuL3V0aWxcIjozNn1dLDc6W2Z1bmN0aW9uKF9kZXJlcV8sbW9kdWxlLGV4cG9ydHMpe1xuXCJ1c2Ugc3RyaWN0XCI7XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKE5FWFRfRklMVEVSKSB7XG52YXIgdXRpbCA9IF9kZXJlcV8oXCIuL3V0aWxcIik7XG52YXIgZ2V0S2V5cyA9IF9kZXJlcV8oXCIuL2VzNVwiKS5rZXlzO1xudmFyIHRyeUNhdGNoID0gdXRpbC50cnlDYXRjaDtcbnZhciBlcnJvck9iaiA9IHV0aWwuZXJyb3JPYmo7XG5cbmZ1bmN0aW9uIGNhdGNoRmlsdGVyKGluc3RhbmNlcywgY2IsIHByb21pc2UpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24oZSkge1xuICAgICAgICB2YXIgYm91bmRUbyA9IHByb21pc2UuX2JvdW5kVmFsdWUoKTtcbiAgICAgICAgcHJlZGljYXRlTG9vcDogZm9yICh2YXIgaSA9IDA7IGkgPCBpbnN0YW5jZXMubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgICAgIHZhciBpdGVtID0gaW5zdGFuY2VzW2ldO1xuXG4gICAgICAgICAgICBpZiAoaXRlbSA9PT0gRXJyb3IgfHxcbiAgICAgICAgICAgICAgICAoaXRlbSAhPSBudWxsICYmIGl0ZW0ucHJvdG90eXBlIGluc3RhbmNlb2YgRXJyb3IpKSB7XG4gICAgICAgICAgICAgICAgaWYgKGUgaW5zdGFuY2VvZiBpdGVtKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0cnlDYXRjaChjYikuY2FsbChib3VuZFRvLCBlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2UgaWYgKHR5cGVvZiBpdGVtID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgICAgICAgICB2YXIgbWF0Y2hlc1ByZWRpY2F0ZSA9IHRyeUNhdGNoKGl0ZW0pLmNhbGwoYm91bmRUbywgZSk7XG4gICAgICAgICAgICAgICAgaWYgKG1hdGNoZXNQcmVkaWNhdGUgPT09IGVycm9yT2JqKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBtYXRjaGVzUHJlZGljYXRlO1xuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAobWF0Y2hlc1ByZWRpY2F0ZSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdHJ5Q2F0Y2goY2IpLmNhbGwoYm91bmRUbywgZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIGlmICh1dGlsLmlzT2JqZWN0KGUpKSB7XG4gICAgICAgICAgICAgICAgdmFyIGtleXMgPSBnZXRLZXlzKGl0ZW0pO1xuICAgICAgICAgICAgICAgIGZvciAodmFyIGogPSAwOyBqIDwga2V5cy5sZW5ndGg7ICsraikge1xuICAgICAgICAgICAgICAgICAgICB2YXIga2V5ID0ga2V5c1tqXTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGl0ZW1ba2V5XSAhPSBlW2tleV0pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlIHByZWRpY2F0ZUxvb3A7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRyeUNhdGNoKGNiKS5jYWxsKGJvdW5kVG8sIGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBORVhUX0ZJTFRFUjtcbiAgICB9O1xufVxuXG5yZXR1cm4gY2F0Y2hGaWx0ZXI7XG59O1xuXG59LHtcIi4vZXM1XCI6MTMsXCIuL3V0aWxcIjozNn1dLDg6W2Z1bmN0aW9uKF9kZXJlcV8sbW9kdWxlLGV4cG9ydHMpe1xuXCJ1c2Ugc3RyaWN0XCI7XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKFByb21pc2UpIHtcbnZhciBsb25nU3RhY2tUcmFjZXMgPSBmYWxzZTtcbnZhciBjb250ZXh0U3RhY2sgPSBbXTtcblxuUHJvbWlzZS5wcm90b3R5cGUuX3Byb21pc2VDcmVhdGVkID0gZnVuY3Rpb24oKSB7fTtcblByb21pc2UucHJvdG90eXBlLl9wdXNoQ29udGV4dCA9IGZ1bmN0aW9uKCkge307XG5Qcm9taXNlLnByb3RvdHlwZS5fcG9wQ29udGV4dCA9IGZ1bmN0aW9uKCkge3JldHVybiBudWxsO307XG5Qcm9taXNlLl9wZWVrQ29udGV4dCA9IFByb21pc2UucHJvdG90eXBlLl9wZWVrQ29udGV4dCA9IGZ1bmN0aW9uKCkge307XG5cbmZ1bmN0aW9uIENvbnRleHQoKSB7XG4gICAgdGhpcy5fdHJhY2UgPSBuZXcgQ29udGV4dC5DYXB0dXJlZFRyYWNlKHBlZWtDb250ZXh0KCkpO1xufVxuQ29udGV4dC5wcm90b3R5cGUuX3B1c2hDb250ZXh0ID0gZnVuY3Rpb24gKCkge1xuICAgIGlmICh0aGlzLl90cmFjZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHRoaXMuX3RyYWNlLl9wcm9taXNlQ3JlYXRlZCA9IG51bGw7XG4gICAgICAgIGNvbnRleHRTdGFjay5wdXNoKHRoaXMuX3RyYWNlKTtcbiAgICB9XG59O1xuXG5Db250ZXh0LnByb3RvdHlwZS5fcG9wQ29udGV4dCA9IGZ1bmN0aW9uICgpIHtcbiAgICBpZiAodGhpcy5fdHJhY2UgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICB2YXIgdHJhY2UgPSBjb250ZXh0U3RhY2sucG9wKCk7XG4gICAgICAgIHZhciByZXQgPSB0cmFjZS5fcHJvbWlzZUNyZWF0ZWQ7XG4gICAgICAgIHRyYWNlLl9wcm9taXNlQ3JlYXRlZCA9IG51bGw7XG4gICAgICAgIHJldHVybiByZXQ7XG4gICAgfVxuICAgIHJldHVybiBudWxsO1xufTtcblxuZnVuY3Rpb24gY3JlYXRlQ29udGV4dCgpIHtcbiAgICBpZiAobG9uZ1N0YWNrVHJhY2VzKSByZXR1cm4gbmV3IENvbnRleHQoKTtcbn1cblxuZnVuY3Rpb24gcGVla0NvbnRleHQoKSB7XG4gICAgdmFyIGxhc3RJbmRleCA9IGNvbnRleHRTdGFjay5sZW5ndGggLSAxO1xuICAgIGlmIChsYXN0SW5kZXggPj0gMCkge1xuICAgICAgICByZXR1cm4gY29udGV4dFN0YWNrW2xhc3RJbmRleF07XG4gICAgfVxuICAgIHJldHVybiB1bmRlZmluZWQ7XG59XG5Db250ZXh0LkNhcHR1cmVkVHJhY2UgPSBudWxsO1xuQ29udGV4dC5jcmVhdGUgPSBjcmVhdGVDb250ZXh0O1xuQ29udGV4dC5kZWFjdGl2YXRlTG9uZ1N0YWNrVHJhY2VzID0gZnVuY3Rpb24oKSB7fTtcbkNvbnRleHQuYWN0aXZhdGVMb25nU3RhY2tUcmFjZXMgPSBmdW5jdGlvbigpIHtcbiAgICB2YXIgUHJvbWlzZV9wdXNoQ29udGV4dCA9IFByb21pc2UucHJvdG90eXBlLl9wdXNoQ29udGV4dDtcbiAgICB2YXIgUHJvbWlzZV9wb3BDb250ZXh0ID0gUHJvbWlzZS5wcm90b3R5cGUuX3BvcENvbnRleHQ7XG4gICAgdmFyIFByb21pc2VfUGVla0NvbnRleHQgPSBQcm9taXNlLl9wZWVrQ29udGV4dDtcbiAgICB2YXIgUHJvbWlzZV9wZWVrQ29udGV4dCA9IFByb21pc2UucHJvdG90eXBlLl9wZWVrQ29udGV4dDtcbiAgICB2YXIgUHJvbWlzZV9wcm9taXNlQ3JlYXRlZCA9IFByb21pc2UucHJvdG90eXBlLl9wcm9taXNlQ3JlYXRlZDtcbiAgICBDb250ZXh0LmRlYWN0aXZhdGVMb25nU3RhY2tUcmFjZXMgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgUHJvbWlzZS5wcm90b3R5cGUuX3B1c2hDb250ZXh0ID0gUHJvbWlzZV9wdXNoQ29udGV4dDtcbiAgICAgICAgUHJvbWlzZS5wcm90b3R5cGUuX3BvcENvbnRleHQgPSBQcm9taXNlX3BvcENvbnRleHQ7XG4gICAgICAgIFByb21pc2UuX3BlZWtDb250ZXh0ID0gUHJvbWlzZV9QZWVrQ29udGV4dDtcbiAgICAgICAgUHJvbWlzZS5wcm90b3R5cGUuX3BlZWtDb250ZXh0ID0gUHJvbWlzZV9wZWVrQ29udGV4dDtcbiAgICAgICAgUHJvbWlzZS5wcm90b3R5cGUuX3Byb21pc2VDcmVhdGVkID0gUHJvbWlzZV9wcm9taXNlQ3JlYXRlZDtcbiAgICAgICAgbG9uZ1N0YWNrVHJhY2VzID0gZmFsc2U7XG4gICAgfTtcbiAgICBsb25nU3RhY2tUcmFjZXMgPSB0cnVlO1xuICAgIFByb21pc2UucHJvdG90eXBlLl9wdXNoQ29udGV4dCA9IENvbnRleHQucHJvdG90eXBlLl9wdXNoQ29udGV4dDtcbiAgICBQcm9taXNlLnByb3RvdHlwZS5fcG9wQ29udGV4dCA9IENvbnRleHQucHJvdG90eXBlLl9wb3BDb250ZXh0O1xuICAgIFByb21pc2UuX3BlZWtDb250ZXh0ID0gUHJvbWlzZS5wcm90b3R5cGUuX3BlZWtDb250ZXh0ID0gcGVla0NvbnRleHQ7XG4gICAgUHJvbWlzZS5wcm90b3R5cGUuX3Byb21pc2VDcmVhdGVkID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBjdHggPSB0aGlzLl9wZWVrQ29udGV4dCgpO1xuICAgICAgICBpZiAoY3R4ICYmIGN0eC5fcHJvbWlzZUNyZWF0ZWQgPT0gbnVsbCkgY3R4Ll9wcm9taXNlQ3JlYXRlZCA9IHRoaXM7XG4gICAgfTtcbn07XG5yZXR1cm4gQ29udGV4dDtcbn07XG5cbn0se31dLDk6W2Z1bmN0aW9uKF9kZXJlcV8sbW9kdWxlLGV4cG9ydHMpe1xuXCJ1c2Ugc3RyaWN0XCI7XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKFByb21pc2UsIENvbnRleHQpIHtcbnZhciBnZXREb21haW4gPSBQcm9taXNlLl9nZXREb21haW47XG52YXIgYXN5bmMgPSBQcm9taXNlLl9hc3luYztcbnZhciBXYXJuaW5nID0gX2RlcmVxXyhcIi4vZXJyb3JzXCIpLldhcm5pbmc7XG52YXIgdXRpbCA9IF9kZXJlcV8oXCIuL3V0aWxcIik7XG52YXIgY2FuQXR0YWNoVHJhY2UgPSB1dGlsLmNhbkF0dGFjaFRyYWNlO1xudmFyIHVuaGFuZGxlZFJlamVjdGlvbkhhbmRsZWQ7XG52YXIgcG9zc2libHlVbmhhbmRsZWRSZWplY3Rpb247XG52YXIgYmx1ZWJpcmRGcmFtZVBhdHRlcm4gPVxuICAgIC9bXFxcXFxcL11ibHVlYmlyZFtcXFxcXFwvXWpzW1xcXFxcXC9dKHJlbGVhc2V8ZGVidWd8aW5zdHJ1bWVudGVkKS87XG52YXIgc3RhY2tGcmFtZVBhdHRlcm4gPSBudWxsO1xudmFyIGZvcm1hdFN0YWNrID0gbnVsbDtcbnZhciBpbmRlbnRTdGFja0ZyYW1lcyA9IGZhbHNlO1xudmFyIHByaW50V2FybmluZztcbnZhciBkZWJ1Z2dpbmcgPSAhISh1dGlsLmVudihcIkJMVUVCSVJEX0RFQlVHXCIpICE9IDAgJiZcbiAgICAgICAgICAgICAgICAgICAgICAgICh0cnVlIHx8XG4gICAgICAgICAgICAgICAgICAgICAgICAgdXRpbC5lbnYoXCJCTFVFQklSRF9ERUJVR1wiKSB8fFxuICAgICAgICAgICAgICAgICAgICAgICAgIHV0aWwuZW52KFwiTk9ERV9FTlZcIikgPT09IFwiZGV2ZWxvcG1lbnRcIikpO1xudmFyIHdhcm5pbmdzID0gISEodXRpbC5lbnYoXCJCTFVFQklSRF9XQVJOSU5HU1wiKSAhPSAwICYmXG4gICAgKGRlYnVnZ2luZyB8fCB1dGlsLmVudihcIkJMVUVCSVJEX1dBUk5JTkdTXCIpKSk7XG52YXIgbG9uZ1N0YWNrVHJhY2VzID0gISEodXRpbC5lbnYoXCJCTFVFQklSRF9MT05HX1NUQUNLX1RSQUNFU1wiKSAhPSAwICYmXG4gICAgKGRlYnVnZ2luZyB8fCB1dGlsLmVudihcIkJMVUVCSVJEX0xPTkdfU1RBQ0tfVFJBQ0VTXCIpKSk7XG5cblByb21pc2UucHJvdG90eXBlLnN1cHByZXNzVW5oYW5kbGVkUmVqZWN0aW9ucyA9IGZ1bmN0aW9uKCkge1xuICAgIHZhciB0YXJnZXQgPSB0aGlzLl90YXJnZXQoKTtcbiAgICB0YXJnZXQuX2JpdEZpZWxkID0gKCh0YXJnZXQuX2JpdEZpZWxkICYgKH4xMDQ4NTc2KSkgfFxuICAgICAgICAgICAgICAgICAgICAgIDIwOTcxNTIpO1xufTtcblxuUHJvbWlzZS5wcm90b3R5cGUuX2Vuc3VyZVBvc3NpYmxlUmVqZWN0aW9uSGFuZGxlZCA9IGZ1bmN0aW9uICgpIHtcbiAgICBpZiAoKHRoaXMuX2JpdEZpZWxkICYgMjA5NzE1MikgIT09IDApIHJldHVybjtcbiAgICB0aGlzLl9zZXRSZWplY3Rpb25Jc1VuaGFuZGxlZCgpO1xuICAgIGFzeW5jLmludm9rZUxhdGVyKHRoaXMuX25vdGlmeVVuaGFuZGxlZFJlamVjdGlvbiwgdGhpcywgdW5kZWZpbmVkKTtcbn07XG5cblByb21pc2UucHJvdG90eXBlLl9ub3RpZnlVbmhhbmRsZWRSZWplY3Rpb25Jc0hhbmRsZWQgPSBmdW5jdGlvbiAoKSB7XG4gICAgZmlyZVJlamVjdGlvbkV2ZW50KFwicmVqZWN0aW9uSGFuZGxlZFwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHVuaGFuZGxlZFJlamVjdGlvbkhhbmRsZWQsIHVuZGVmaW5lZCwgdGhpcyk7XG59O1xuXG5Qcm9taXNlLnByb3RvdHlwZS5fbm90aWZ5VW5oYW5kbGVkUmVqZWN0aW9uID0gZnVuY3Rpb24gKCkge1xuICAgIGlmICh0aGlzLl9pc1JlamVjdGlvblVuaGFuZGxlZCgpKSB7XG4gICAgICAgIHZhciByZWFzb24gPSB0aGlzLl9zZXR0bGVkVmFsdWUoKTtcbiAgICAgICAgdGhpcy5fc2V0VW5oYW5kbGVkUmVqZWN0aW9uSXNOb3RpZmllZCgpO1xuICAgICAgICBmaXJlUmVqZWN0aW9uRXZlbnQoXCJ1bmhhbmRsZWRSZWplY3Rpb25cIixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcG9zc2libHlVbmhhbmRsZWRSZWplY3Rpb24sIHJlYXNvbiwgdGhpcyk7XG4gICAgfVxufTtcblxuUHJvbWlzZS5wcm90b3R5cGUuX3NldFVuaGFuZGxlZFJlamVjdGlvbklzTm90aWZpZWQgPSBmdW5jdGlvbiAoKSB7XG4gICAgdGhpcy5fYml0RmllbGQgPSB0aGlzLl9iaXRGaWVsZCB8IDI2MjE0NDtcbn07XG5cblByb21pc2UucHJvdG90eXBlLl91bnNldFVuaGFuZGxlZFJlamVjdGlvbklzTm90aWZpZWQgPSBmdW5jdGlvbiAoKSB7XG4gICAgdGhpcy5fYml0RmllbGQgPSB0aGlzLl9iaXRGaWVsZCAmICh+MjYyMTQ0KTtcbn07XG5cblByb21pc2UucHJvdG90eXBlLl9pc1VuaGFuZGxlZFJlamVjdGlvbk5vdGlmaWVkID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiAodGhpcy5fYml0RmllbGQgJiAyNjIxNDQpID4gMDtcbn07XG5cblByb21pc2UucHJvdG90eXBlLl9zZXRSZWplY3Rpb25Jc1VuaGFuZGxlZCA9IGZ1bmN0aW9uICgpIHtcbiAgICB0aGlzLl9iaXRGaWVsZCA9IHRoaXMuX2JpdEZpZWxkIHwgMTA0ODU3Njtcbn07XG5cblByb21pc2UucHJvdG90eXBlLl91bnNldFJlamVjdGlvbklzVW5oYW5kbGVkID0gZnVuY3Rpb24gKCkge1xuICAgIHRoaXMuX2JpdEZpZWxkID0gdGhpcy5fYml0RmllbGQgJiAofjEwNDg1NzYpO1xuICAgIGlmICh0aGlzLl9pc1VuaGFuZGxlZFJlamVjdGlvbk5vdGlmaWVkKCkpIHtcbiAgICAgICAgdGhpcy5fdW5zZXRVbmhhbmRsZWRSZWplY3Rpb25Jc05vdGlmaWVkKCk7XG4gICAgICAgIHRoaXMuX25vdGlmeVVuaGFuZGxlZFJlamVjdGlvbklzSGFuZGxlZCgpO1xuICAgIH1cbn07XG5cblByb21pc2UucHJvdG90eXBlLl9pc1JlamVjdGlvblVuaGFuZGxlZCA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gKHRoaXMuX2JpdEZpZWxkICYgMTA0ODU3NikgPiAwO1xufTtcblxuUHJvbWlzZS5wcm90b3R5cGUuX3dhcm4gPSBmdW5jdGlvbihtZXNzYWdlLCBzaG91bGRVc2VPd25UcmFjZSwgcHJvbWlzZSkge1xuICAgIHJldHVybiB3YXJuKG1lc3NhZ2UsIHNob3VsZFVzZU93blRyYWNlLCBwcm9taXNlIHx8IHRoaXMpO1xufTtcblxuUHJvbWlzZS5vblBvc3NpYmx5VW5oYW5kbGVkUmVqZWN0aW9uID0gZnVuY3Rpb24gKGZuKSB7XG4gICAgdmFyIGRvbWFpbiA9IGdldERvbWFpbigpO1xuICAgIHBvc3NpYmx5VW5oYW5kbGVkUmVqZWN0aW9uID1cbiAgICAgICAgdHlwZW9mIGZuID09PSBcImZ1bmN0aW9uXCIgPyAoZG9tYWluID09PSBudWxsID8gZm4gOiBkb21haW4uYmluZChmbikpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA6IHVuZGVmaW5lZDtcbn07XG5cblByb21pc2Uub25VbmhhbmRsZWRSZWplY3Rpb25IYW5kbGVkID0gZnVuY3Rpb24gKGZuKSB7XG4gICAgdmFyIGRvbWFpbiA9IGdldERvbWFpbigpO1xuICAgIHVuaGFuZGxlZFJlamVjdGlvbkhhbmRsZWQgPVxuICAgICAgICB0eXBlb2YgZm4gPT09IFwiZnVuY3Rpb25cIiA/IChkb21haW4gPT09IG51bGwgPyBmbiA6IGRvbWFpbi5iaW5kKGZuKSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDogdW5kZWZpbmVkO1xufTtcblxudmFyIGRpc2FibGVMb25nU3RhY2tUcmFjZXMgPSBmdW5jdGlvbigpIHt9O1xuUHJvbWlzZS5sb25nU3RhY2tUcmFjZXMgPSBmdW5jdGlvbiAoKSB7XG4gICAgaWYgKGFzeW5jLmhhdmVJdGVtc1F1ZXVlZCgpICYmICFjb25maWcubG9uZ1N0YWNrVHJhY2VzKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcImNhbm5vdCBlbmFibGUgbG9uZyBzdGFjayB0cmFjZXMgYWZ0ZXIgcHJvbWlzZXMgaGF2ZSBiZWVuIGNyZWF0ZWRcXHUwMDBhXFx1MDAwYSAgICBTZWUgaHR0cDovL2dvby5nbC9NcXJGbVhcXHUwMDBhXCIpO1xuICAgIH1cbiAgICBpZiAoIWNvbmZpZy5sb25nU3RhY2tUcmFjZXMgJiYgbG9uZ1N0YWNrVHJhY2VzSXNTdXBwb3J0ZWQoKSkge1xuICAgICAgICB2YXIgUHJvbWlzZV9jYXB0dXJlU3RhY2tUcmFjZSA9IFByb21pc2UucHJvdG90eXBlLl9jYXB0dXJlU3RhY2tUcmFjZTtcbiAgICAgICAgdmFyIFByb21pc2VfYXR0YWNoRXh0cmFUcmFjZSA9IFByb21pc2UucHJvdG90eXBlLl9hdHRhY2hFeHRyYVRyYWNlO1xuICAgICAgICBjb25maWcubG9uZ1N0YWNrVHJhY2VzID0gdHJ1ZTtcbiAgICAgICAgZGlzYWJsZUxvbmdTdGFja1RyYWNlcyA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgaWYgKGFzeW5jLmhhdmVJdGVtc1F1ZXVlZCgpICYmICFjb25maWcubG9uZ1N0YWNrVHJhY2VzKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiY2Fubm90IGVuYWJsZSBsb25nIHN0YWNrIHRyYWNlcyBhZnRlciBwcm9taXNlcyBoYXZlIGJlZW4gY3JlYXRlZFxcdTAwMGFcXHUwMDBhICAgIFNlZSBodHRwOi8vZ29vLmdsL01xckZtWFxcdTAwMGFcIik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBQcm9taXNlLnByb3RvdHlwZS5fY2FwdHVyZVN0YWNrVHJhY2UgPSBQcm9taXNlX2NhcHR1cmVTdGFja1RyYWNlO1xuICAgICAgICAgICAgUHJvbWlzZS5wcm90b3R5cGUuX2F0dGFjaEV4dHJhVHJhY2UgPSBQcm9taXNlX2F0dGFjaEV4dHJhVHJhY2U7XG4gICAgICAgICAgICBDb250ZXh0LmRlYWN0aXZhdGVMb25nU3RhY2tUcmFjZXMoKTtcbiAgICAgICAgICAgIGFzeW5jLmVuYWJsZVRyYW1wb2xpbmUoKTtcbiAgICAgICAgICAgIGNvbmZpZy5sb25nU3RhY2tUcmFjZXMgPSBmYWxzZTtcbiAgICAgICAgfTtcbiAgICAgICAgUHJvbWlzZS5wcm90b3R5cGUuX2NhcHR1cmVTdGFja1RyYWNlID0gbG9uZ1N0YWNrVHJhY2VzQ2FwdHVyZVN0YWNrVHJhY2U7XG4gICAgICAgIFByb21pc2UucHJvdG90eXBlLl9hdHRhY2hFeHRyYVRyYWNlID0gbG9uZ1N0YWNrVHJhY2VzQXR0YWNoRXh0cmFUcmFjZTtcbiAgICAgICAgQ29udGV4dC5hY3RpdmF0ZUxvbmdTdGFja1RyYWNlcygpO1xuICAgICAgICBhc3luYy5kaXNhYmxlVHJhbXBvbGluZUlmTmVjZXNzYXJ5KCk7XG4gICAgfVxufTtcblxuUHJvbWlzZS5oYXNMb25nU3RhY2tUcmFjZXMgPSBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIGNvbmZpZy5sb25nU3RhY2tUcmFjZXMgJiYgbG9uZ1N0YWNrVHJhY2VzSXNTdXBwb3J0ZWQoKTtcbn07XG5cblByb21pc2UuY29uZmlnID0gZnVuY3Rpb24ob3B0cykge1xuICAgIG9wdHMgPSBPYmplY3Qob3B0cyk7XG4gICAgaWYgKFwibG9uZ1N0YWNrVHJhY2VzXCIgaW4gb3B0cykge1xuICAgICAgICBpZiAob3B0cy5sb25nU3RhY2tUcmFjZXMpIHtcbiAgICAgICAgICAgIFByb21pc2UubG9uZ1N0YWNrVHJhY2VzKCk7XG4gICAgICAgIH0gZWxzZSBpZiAoIW9wdHMubG9uZ1N0YWNrVHJhY2VzICYmIFByb21pc2UuaGFzTG9uZ1N0YWNrVHJhY2VzKCkpIHtcbiAgICAgICAgICAgIGRpc2FibGVMb25nU3RhY2tUcmFjZXMoKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBpZiAoXCJ3YXJuaW5nc1wiIGluIG9wdHMpIHtcbiAgICAgICAgY29uZmlnLndhcm5pbmdzID0gISFvcHRzLndhcm5pbmdzO1xuICAgIH1cbiAgICBpZiAoXCJjYW5jZWxsYXRpb25cIiBpbiBvcHRzICYmIG9wdHMuY2FuY2VsbGF0aW9uICYmICFjb25maWcuY2FuY2VsbGF0aW9uKSB7XG4gICAgICAgIGlmIChhc3luYy5oYXZlSXRlbXNRdWV1ZWQoKSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICAgICAgICAgIFwiY2Fubm90IGVuYWJsZSBjYW5jZWxsYXRpb24gYWZ0ZXIgcHJvbWlzZXMgYXJlIGluIHVzZVwiKTtcbiAgICAgICAgfVxuICAgICAgICBQcm9taXNlLnByb3RvdHlwZS5fY2xlYXJDYW5jZWxsYXRpb25EYXRhID1cbiAgICAgICAgICAgIGNhbmNlbGxhdGlvbkNsZWFyQ2FuY2VsbGF0aW9uRGF0YTtcbiAgICAgICAgUHJvbWlzZS5wcm90b3R5cGUuX3Byb3BhZ2F0ZUZyb20gPSBjYW5jZWxsYXRpb25Qcm9wYWdhdGVGcm9tO1xuICAgICAgICBQcm9taXNlLnByb3RvdHlwZS5fb25DYW5jZWwgPSBjYW5jZWxsYXRpb25PbkNhbmNlbDtcbiAgICAgICAgUHJvbWlzZS5wcm90b3R5cGUuX3NldE9uQ2FuY2VsID0gY2FuY2VsbGF0aW9uU2V0T25DYW5jZWw7XG4gICAgICAgIFByb21pc2UucHJvdG90eXBlLl9hdHRhY2hDYW5jZWxsYXRpb25DYWxsYmFjayA9XG4gICAgICAgICAgICBjYW5jZWxsYXRpb25BdHRhY2hDYW5jZWxsYXRpb25DYWxsYmFjaztcbiAgICAgICAgUHJvbWlzZS5wcm90b3R5cGUuX2V4ZWN1dGUgPSBjYW5jZWxsYXRpb25FeGVjdXRlO1xuICAgICAgICBwcm9wYWdhdGVGcm9tRnVuY3Rpb24gPSBjYW5jZWxsYXRpb25Qcm9wYWdhdGVGcm9tO1xuICAgICAgICBjb25maWcuY2FuY2VsbGF0aW9uID0gdHJ1ZTtcbiAgICB9XG59O1xuXG5Qcm9taXNlLnByb3RvdHlwZS5fZXhlY3V0ZSA9IGZ1bmN0aW9uKGV4ZWN1dG9yLCByZXNvbHZlLCByZWplY3QpIHtcbiAgICB0cnkge1xuICAgICAgICBleGVjdXRvcihyZXNvbHZlLCByZWplY3QpO1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgcmV0dXJuIGU7XG4gICAgfVxufTtcblByb21pc2UucHJvdG90eXBlLl9vbkNhbmNlbCA9IGZ1bmN0aW9uICgpIHt9O1xuUHJvbWlzZS5wcm90b3R5cGUuX3NldE9uQ2FuY2VsID0gZnVuY3Rpb24gKGhhbmRsZXIpIHsgOyB9O1xuUHJvbWlzZS5wcm90b3R5cGUuX2F0dGFjaENhbmNlbGxhdGlvbkNhbGxiYWNrID0gZnVuY3Rpb24ob25DYW5jZWwpIHtcbiAgICA7XG59O1xuUHJvbWlzZS5wcm90b3R5cGUuX2NhcHR1cmVTdGFja1RyYWNlID0gZnVuY3Rpb24gKCkge307XG5Qcm9taXNlLnByb3RvdHlwZS5fYXR0YWNoRXh0cmFUcmFjZSA9IGZ1bmN0aW9uICgpIHt9O1xuUHJvbWlzZS5wcm90b3R5cGUuX2NsZWFyQ2FuY2VsbGF0aW9uRGF0YSA9IGZ1bmN0aW9uKCkge307XG5Qcm9taXNlLnByb3RvdHlwZS5fcHJvcGFnYXRlRnJvbSA9IGZ1bmN0aW9uIChwYXJlbnQsIGZsYWdzKSB7XG4gICAgO1xuICAgIDtcbn07XG5cbmZ1bmN0aW9uIGNhbmNlbGxhdGlvbkV4ZWN1dGUoZXhlY3V0b3IsIHJlc29sdmUsIHJlamVjdCkge1xuICAgIHZhciBwcm9taXNlID0gdGhpcztcbiAgICB0cnkge1xuICAgICAgICBleGVjdXRvcihyZXNvbHZlLCByZWplY3QsIGZ1bmN0aW9uKG9uQ2FuY2VsKSB7XG4gICAgICAgICAgICBpZiAodHlwZW9mIG9uQ2FuY2VsICE9PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwib25DYW5jZWwgbXVzdCBiZSBhIGZ1bmN0aW9uLCBnb3Q6IFwiICtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHV0aWwudG9TdHJpbmcob25DYW5jZWwpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHByb21pc2UuX2F0dGFjaENhbmNlbGxhdGlvbkNhbGxiYWNrKG9uQ2FuY2VsKTtcbiAgICAgICAgfSk7XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgICByZXR1cm4gZTtcbiAgICB9XG59XG5cbmZ1bmN0aW9uIGNhbmNlbGxhdGlvbkF0dGFjaENhbmNlbGxhdGlvbkNhbGxiYWNrKG9uQ2FuY2VsKSB7XG4gICAgaWYgKCF0aGlzLmlzQ2FuY2VsbGFibGUoKSkgcmV0dXJuIHRoaXM7XG5cbiAgICB2YXIgcHJldmlvdXNPbkNhbmNlbCA9IHRoaXMuX29uQ2FuY2VsKCk7XG4gICAgaWYgKHByZXZpb3VzT25DYW5jZWwgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICBpZiAodXRpbC5pc0FycmF5KHByZXZpb3VzT25DYW5jZWwpKSB7XG4gICAgICAgICAgICBwcmV2aW91c09uQ2FuY2VsLnB1c2gob25DYW5jZWwpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5fc2V0T25DYW5jZWwoW3ByZXZpb3VzT25DYW5jZWwsIG9uQ2FuY2VsXSk7XG4gICAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLl9zZXRPbkNhbmNlbChvbkNhbmNlbCk7XG4gICAgfVxufVxuXG5mdW5jdGlvbiBjYW5jZWxsYXRpb25PbkNhbmNlbCgpIHtcbiAgICByZXR1cm4gdGhpcy5fb25DYW5jZWxGaWVsZDtcbn1cblxuZnVuY3Rpb24gY2FuY2VsbGF0aW9uU2V0T25DYW5jZWwob25DYW5jZWwpIHtcbiAgICB0aGlzLl9vbkNhbmNlbEZpZWxkID0gb25DYW5jZWw7XG59XG5cbmZ1bmN0aW9uIGNhbmNlbGxhdGlvbkNsZWFyQ2FuY2VsbGF0aW9uRGF0YSgpIHtcbiAgICB0aGlzLl9jYW5jZWxsYXRpb25QYXJlbnQgPSB1bmRlZmluZWQ7XG4gICAgdGhpcy5fb25DYW5jZWxGaWVsZCA9IHVuZGVmaW5lZDtcbn1cblxuZnVuY3Rpb24gY2FuY2VsbGF0aW9uUHJvcGFnYXRlRnJvbShwYXJlbnQsIGZsYWdzKSB7XG4gICAgaWYgKChmbGFncyAmIDEpICE9PSAwKSB7XG4gICAgICAgIHRoaXMuX2NhbmNlbGxhdGlvblBhcmVudCA9IHBhcmVudDtcbiAgICAgICAgdmFyIGJyYW5jaGVzUmVtYWluaW5nVG9DYW5jZWwgPSBwYXJlbnQuX2JyYW5jaGVzUmVtYWluaW5nVG9DYW5jZWw7XG4gICAgICAgIGlmIChicmFuY2hlc1JlbWFpbmluZ1RvQ2FuY2VsID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIGJyYW5jaGVzUmVtYWluaW5nVG9DYW5jZWwgPSAwO1xuICAgICAgICB9XG4gICAgICAgIHBhcmVudC5fYnJhbmNoZXNSZW1haW5pbmdUb0NhbmNlbCA9IGJyYW5jaGVzUmVtYWluaW5nVG9DYW5jZWwgKyAxO1xuICAgIH1cbiAgICBpZiAoKGZsYWdzICYgMikgIT09IDAgJiYgcGFyZW50Ll9pc0JvdW5kKCkpIHtcbiAgICAgICAgdGhpcy5fc2V0Qm91bmRUbyhwYXJlbnQuX2JvdW5kVG8pO1xuICAgIH1cbn1cblxuZnVuY3Rpb24gYmluZGluZ1Byb3BhZ2F0ZUZyb20ocGFyZW50LCBmbGFncykge1xuICAgIGlmICgoZmxhZ3MgJiAyKSAhPT0gMCAmJiBwYXJlbnQuX2lzQm91bmQoKSkge1xuICAgICAgICB0aGlzLl9zZXRCb3VuZFRvKHBhcmVudC5fYm91bmRUbyk7XG4gICAgfVxufVxudmFyIHByb3BhZ2F0ZUZyb21GdW5jdGlvbiA9IGJpbmRpbmdQcm9wYWdhdGVGcm9tO1xuXG5mdW5jdGlvbiBib3VuZFZhbHVlRnVuY3Rpb24oKSB7XG4gICAgdmFyIHJldCA9IHRoaXMuX2JvdW5kVG87XG4gICAgaWYgKHJldCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGlmIChyZXQgaW5zdGFuY2VvZiBQcm9taXNlKSB7XG4gICAgICAgICAgICBpZiAocmV0LmlzRnVsZmlsbGVkKCkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gcmV0LnZhbHVlKCk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHJldDtcbn1cblxuZnVuY3Rpb24gbG9uZ1N0YWNrVHJhY2VzQ2FwdHVyZVN0YWNrVHJhY2UoKSB7XG4gICAgdGhpcy5fdHJhY2UgPSBuZXcgQ2FwdHVyZWRUcmFjZSh0aGlzLl9wZWVrQ29udGV4dCgpKTtcbn1cblxuZnVuY3Rpb24gbG9uZ1N0YWNrVHJhY2VzQXR0YWNoRXh0cmFUcmFjZShlcnJvciwgaWdub3JlU2VsZikge1xuICAgIGlmIChjYW5BdHRhY2hUcmFjZShlcnJvcikpIHtcbiAgICAgICAgdmFyIHRyYWNlID0gdGhpcy5fdHJhY2U7XG4gICAgICAgIGlmICh0cmFjZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBpZiAoaWdub3JlU2VsZikgdHJhY2UgPSB0cmFjZS5fcGFyZW50O1xuICAgICAgICB9XG4gICAgICAgIGlmICh0cmFjZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICB0cmFjZS5hdHRhY2hFeHRyYVRyYWNlKGVycm9yKTtcbiAgICAgICAgfSBlbHNlIGlmICghZXJyb3IuX19zdGFja0NsZWFuZWRfXykge1xuICAgICAgICAgICAgdmFyIHBhcnNlZCA9IHBhcnNlU3RhY2tBbmRNZXNzYWdlKGVycm9yKTtcbiAgICAgICAgICAgIHV0aWwubm90RW51bWVyYWJsZVByb3AoZXJyb3IsIFwic3RhY2tcIixcbiAgICAgICAgICAgICAgICBwYXJzZWQubWVzc2FnZSArIFwiXFxuXCIgKyBwYXJzZWQuc3RhY2suam9pbihcIlxcblwiKSk7XG4gICAgICAgICAgICB1dGlsLm5vdEVudW1lcmFibGVQcm9wKGVycm9yLCBcIl9fc3RhY2tDbGVhbmVkX19cIiwgdHJ1ZSk7XG4gICAgICAgIH1cbiAgICB9XG59XG5cbmZ1bmN0aW9uIGNoZWNrRm9yZ290dGVuUmV0dXJucyhyZXR1cm5WYWx1ZSwgcHJvbWlzZUNyZWF0ZWQsIG5hbWUsIHByb21pc2UpIHtcbiAgICBpZiAocmV0dXJuVmFsdWUgPT09IHVuZGVmaW5lZCAmJlxuICAgICAgICBwcm9taXNlQ3JlYXRlZCAhPT0gbnVsbCAmJlxuICAgICAgICBjb25maWcubG9uZ1N0YWNrVHJhY2VzICYmXG4gICAgICAgIGNvbmZpZy53YXJuaW5ncykge1xuICAgICAgICB2YXIgbXNnID0gXCJhIHByb21pc2Ugd2FzIGNyZWF0ZWQgaW4gYSBcIiArIG5hbWUgK1xuICAgICAgICAgICAgXCIgaGFuZGxlciBidXQgd2FzIG5vdCByZXR1cm5lZCBmcm9tIGl0XCI7XG4gICAgICAgIHByb21pc2UuX3dhcm4obXNnLCB0cnVlLCBwcm9taXNlQ3JlYXRlZCk7XG4gICAgfVxufVxuXG5mdW5jdGlvbiBkZXByZWNhdGVkKG5hbWUsIHJlcGxhY2VtZW50KSB7XG4gICAgdmFyIG1lc3NhZ2UgPSBuYW1lICtcbiAgICAgICAgXCIgaXMgZGVwcmVjYXRlZCBhbmQgd2lsbCBiZSByZW1vdmVkIGluIGEgZnV0dXJlIHZlcnNpb24uXCI7XG4gICAgaWYgKHJlcGxhY2VtZW50KSBtZXNzYWdlICs9IFwiIFVzZSBcIiArIHJlcGxhY2VtZW50ICsgXCIgaW5zdGVhZC5cIjtcbiAgICByZXR1cm4gd2FybihtZXNzYWdlKTtcbn1cblxuZnVuY3Rpb24gd2FybihtZXNzYWdlLCBzaG91bGRVc2VPd25UcmFjZSwgcHJvbWlzZSkge1xuICAgIGlmICghY29uZmlnLndhcm5pbmdzKSByZXR1cm47XG4gICAgdmFyIHdhcm5pbmcgPSBuZXcgV2FybmluZyhtZXNzYWdlKTtcbiAgICB2YXIgY3R4O1xuICAgIGlmIChzaG91bGRVc2VPd25UcmFjZSkge1xuICAgICAgICBwcm9taXNlLl9hdHRhY2hFeHRyYVRyYWNlKHdhcm5pbmcpO1xuICAgIH0gZWxzZSBpZiAoY29uZmlnLmxvbmdTdGFja1RyYWNlcyAmJiAoY3R4ID0gUHJvbWlzZS5fcGVla0NvbnRleHQoKSkpIHtcbiAgICAgICAgY3R4LmF0dGFjaEV4dHJhVHJhY2Uod2FybmluZyk7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgdmFyIHBhcnNlZCA9IHBhcnNlU3RhY2tBbmRNZXNzYWdlKHdhcm5pbmcpO1xuICAgICAgICB3YXJuaW5nLnN0YWNrID0gcGFyc2VkLm1lc3NhZ2UgKyBcIlxcblwiICsgcGFyc2VkLnN0YWNrLmpvaW4oXCJcXG5cIik7XG4gICAgfVxuICAgIGZvcm1hdEFuZExvZ0Vycm9yKHdhcm5pbmcsIFwiXCIsIHRydWUpO1xufVxuXG5mdW5jdGlvbiByZWNvbnN0cnVjdFN0YWNrKG1lc3NhZ2UsIHN0YWNrcykge1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgc3RhY2tzLmxlbmd0aCAtIDE7ICsraSkge1xuICAgICAgICBzdGFja3NbaV0ucHVzaChcIkZyb20gcHJldmlvdXMgZXZlbnQ6XCIpO1xuICAgICAgICBzdGFja3NbaV0gPSBzdGFja3NbaV0uam9pbihcIlxcblwiKTtcbiAgICB9XG4gICAgaWYgKGkgPCBzdGFja3MubGVuZ3RoKSB7XG4gICAgICAgIHN0YWNrc1tpXSA9IHN0YWNrc1tpXS5qb2luKFwiXFxuXCIpO1xuICAgIH1cbiAgICByZXR1cm4gbWVzc2FnZSArIFwiXFxuXCIgKyBzdGFja3Muam9pbihcIlxcblwiKTtcbn1cblxuZnVuY3Rpb24gcmVtb3ZlRHVwbGljYXRlT3JFbXB0eUp1bXBzKHN0YWNrcykge1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgc3RhY2tzLmxlbmd0aDsgKytpKSB7XG4gICAgICAgIGlmIChzdGFja3NbaV0ubGVuZ3RoID09PSAwIHx8XG4gICAgICAgICAgICAoKGkgKyAxIDwgc3RhY2tzLmxlbmd0aCkgJiYgc3RhY2tzW2ldWzBdID09PSBzdGFja3NbaSsxXVswXSkpIHtcbiAgICAgICAgICAgIHN0YWNrcy5zcGxpY2UoaSwgMSk7XG4gICAgICAgICAgICBpLS07XG4gICAgICAgIH1cbiAgICB9XG59XG5cbmZ1bmN0aW9uIHJlbW92ZUNvbW1vblJvb3RzKHN0YWNrcykge1xuICAgIHZhciBjdXJyZW50ID0gc3RhY2tzWzBdO1xuICAgIGZvciAodmFyIGkgPSAxOyBpIDwgc3RhY2tzLmxlbmd0aDsgKytpKSB7XG4gICAgICAgIHZhciBwcmV2ID0gc3RhY2tzW2ldO1xuICAgICAgICB2YXIgY3VycmVudExhc3RJbmRleCA9IGN1cnJlbnQubGVuZ3RoIC0gMTtcbiAgICAgICAgdmFyIGN1cnJlbnRMYXN0TGluZSA9IGN1cnJlbnRbY3VycmVudExhc3RJbmRleF07XG4gICAgICAgIHZhciBjb21tb25Sb290TWVldFBvaW50ID0gLTE7XG5cbiAgICAgICAgZm9yICh2YXIgaiA9IHByZXYubGVuZ3RoIC0gMTsgaiA+PSAwOyAtLWopIHtcbiAgICAgICAgICAgIGlmIChwcmV2W2pdID09PSBjdXJyZW50TGFzdExpbmUpIHtcbiAgICAgICAgICAgICAgICBjb21tb25Sb290TWVldFBvaW50ID0gajtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGZvciAodmFyIGogPSBjb21tb25Sb290TWVldFBvaW50OyBqID49IDA7IC0taikge1xuICAgICAgICAgICAgdmFyIGxpbmUgPSBwcmV2W2pdO1xuICAgICAgICAgICAgaWYgKGN1cnJlbnRbY3VycmVudExhc3RJbmRleF0gPT09IGxpbmUpIHtcbiAgICAgICAgICAgICAgICBjdXJyZW50LnBvcCgpO1xuICAgICAgICAgICAgICAgIGN1cnJlbnRMYXN0SW5kZXgtLTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgY3VycmVudCA9IHByZXY7XG4gICAgfVxufVxuXG5mdW5jdGlvbiBjbGVhblN0YWNrKHN0YWNrKSB7XG4gICAgdmFyIHJldCA9IFtdO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgc3RhY2subGVuZ3RoOyArK2kpIHtcbiAgICAgICAgdmFyIGxpbmUgPSBzdGFja1tpXTtcbiAgICAgICAgdmFyIGlzVHJhY2VMaW5lID0gXCIgICAgKE5vIHN0YWNrIHRyYWNlKVwiID09PSBsaW5lIHx8XG4gICAgICAgICAgICBzdGFja0ZyYW1lUGF0dGVybi50ZXN0KGxpbmUpO1xuICAgICAgICB2YXIgaXNJbnRlcm5hbEZyYW1lID0gaXNUcmFjZUxpbmUgJiYgc2hvdWxkSWdub3JlKGxpbmUpO1xuICAgICAgICBpZiAoaXNUcmFjZUxpbmUgJiYgIWlzSW50ZXJuYWxGcmFtZSkge1xuICAgICAgICAgICAgaWYgKGluZGVudFN0YWNrRnJhbWVzICYmIGxpbmUuY2hhckF0KDApICE9PSBcIiBcIikge1xuICAgICAgICAgICAgICAgIGxpbmUgPSBcIiAgICBcIiArIGxpbmU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXQucHVzaChsaW5lKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gcmV0O1xufVxuXG5mdW5jdGlvbiBzdGFja0ZyYW1lc0FzQXJyYXkoZXJyb3IpIHtcbiAgICB2YXIgc3RhY2sgPSBlcnJvci5zdGFjay5yZXBsYWNlKC9cXHMrJC9nLCBcIlwiKS5zcGxpdChcIlxcblwiKTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHN0YWNrLmxlbmd0aDsgKytpKSB7XG4gICAgICAgIHZhciBsaW5lID0gc3RhY2tbaV07XG4gICAgICAgIGlmIChcIiAgICAoTm8gc3RhY2sgdHJhY2UpXCIgPT09IGxpbmUgfHwgc3RhY2tGcmFtZVBhdHRlcm4udGVzdChsaW5lKSkge1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICB9XG4gICAgaWYgKGkgPiAwKSB7XG4gICAgICAgIHN0YWNrID0gc3RhY2suc2xpY2UoaSk7XG4gICAgfVxuICAgIHJldHVybiBzdGFjaztcbn1cblxuZnVuY3Rpb24gcGFyc2VTdGFja0FuZE1lc3NhZ2UoZXJyb3IpIHtcbiAgICB2YXIgc3RhY2sgPSBlcnJvci5zdGFjaztcbiAgICB2YXIgbWVzc2FnZSA9IGVycm9yLnRvU3RyaW5nKCk7XG4gICAgc3RhY2sgPSB0eXBlb2Ygc3RhY2sgPT09IFwic3RyaW5nXCIgJiYgc3RhY2subGVuZ3RoID4gMFxuICAgICAgICAgICAgICAgID8gc3RhY2tGcmFtZXNBc0FycmF5KGVycm9yKSA6IFtcIiAgICAoTm8gc3RhY2sgdHJhY2UpXCJdO1xuICAgIHJldHVybiB7XG4gICAgICAgIG1lc3NhZ2U6IG1lc3NhZ2UsXG4gICAgICAgIHN0YWNrOiBjbGVhblN0YWNrKHN0YWNrKVxuICAgIH07XG59XG5cbmZ1bmN0aW9uIGZvcm1hdEFuZExvZ0Vycm9yKGVycm9yLCB0aXRsZSwgaXNTb2Z0KSB7XG4gICAgaWYgKHR5cGVvZiBjb25zb2xlICE9PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICAgIHZhciBtZXNzYWdlO1xuICAgICAgICBpZiAodXRpbC5pc09iamVjdChlcnJvcikpIHtcbiAgICAgICAgICAgIHZhciBzdGFjayA9IGVycm9yLnN0YWNrO1xuICAgICAgICAgICAgbWVzc2FnZSA9IHRpdGxlICsgZm9ybWF0U3RhY2soc3RhY2ssIGVycm9yKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIG1lc3NhZ2UgPSB0aXRsZSArIFN0cmluZyhlcnJvcik7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHR5cGVvZiBwcmludFdhcm5pbmcgPT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICAgICAgcHJpbnRXYXJuaW5nKG1lc3NhZ2UsIGlzU29mdCk7XG4gICAgICAgIH0gZWxzZSBpZiAodHlwZW9mIGNvbnNvbGUubG9nID09PSBcImZ1bmN0aW9uXCIgfHxcbiAgICAgICAgICAgIHR5cGVvZiBjb25zb2xlLmxvZyA9PT0gXCJvYmplY3RcIikge1xuICAgICAgICAgICAgY29uc29sZS5sb2cobWVzc2FnZSk7XG4gICAgICAgIH1cbiAgICB9XG59XG5cbmZ1bmN0aW9uIGZpcmVSZWplY3Rpb25FdmVudChuYW1lLCBsb2NhbEhhbmRsZXIsIHJlYXNvbiwgcHJvbWlzZSkge1xuICAgIHZhciBsb2NhbEV2ZW50RmlyZWQgPSBmYWxzZTtcbiAgICB0cnkge1xuICAgICAgICBpZiAodHlwZW9mIGxvY2FsSGFuZGxlciA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgICAgICBsb2NhbEV2ZW50RmlyZWQgPSB0cnVlO1xuICAgICAgICAgICAgaWYgKG5hbWUgPT09IFwicmVqZWN0aW9uSGFuZGxlZFwiKSB7XG4gICAgICAgICAgICAgICAgbG9jYWxIYW5kbGVyKHByb21pc2UpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBsb2NhbEhhbmRsZXIocmVhc29uLCBwcm9taXNlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgYXN5bmMudGhyb3dMYXRlcihlKTtcbiAgICB9XG5cbiAgICB2YXIgZ2xvYmFsRXZlbnRGaXJlZCA9IGZhbHNlO1xuICAgIHRyeSB7XG4gICAgICAgIGdsb2JhbEV2ZW50RmlyZWQgPSBmaXJlR2xvYmFsRXZlbnQobmFtZSwgcmVhc29uLCBwcm9taXNlKTtcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIGdsb2JhbEV2ZW50RmlyZWQgPSB0cnVlO1xuICAgICAgICBhc3luYy50aHJvd0xhdGVyKGUpO1xuICAgIH1cblxuICAgIHZhciBkb21FdmVudEZpcmVkID0gZmFsc2U7XG4gICAgaWYgKGZpcmVEb21FdmVudCkge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgZG9tRXZlbnRGaXJlZCA9IGZpcmVEb21FdmVudChuYW1lLnRvTG93ZXJDYXNlKCksIHtcbiAgICAgICAgICAgICAgICByZWFzb246IHJlYXNvbixcbiAgICAgICAgICAgICAgICBwcm9taXNlOiBwcm9taXNlXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgICAgZG9tRXZlbnRGaXJlZCA9IHRydWU7XG4gICAgICAgICAgICBhc3luYy50aHJvd0xhdGVyKGUpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgaWYgKCFnbG9iYWxFdmVudEZpcmVkICYmICFsb2NhbEV2ZW50RmlyZWQgJiYgIWRvbUV2ZW50RmlyZWQgJiZcbiAgICAgICAgbmFtZSA9PT0gXCJ1bmhhbmRsZWRSZWplY3Rpb25cIikge1xuICAgICAgICBmb3JtYXRBbmRMb2dFcnJvcihyZWFzb24sIFwiVW5oYW5kbGVkIHJlamVjdGlvbiBcIik7XG4gICAgfVxufVxuXG5mdW5jdGlvbiBmb3JtYXROb25FcnJvcihvYmopIHtcbiAgICB2YXIgc3RyO1xuICAgIGlmICh0eXBlb2Ygb2JqID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgc3RyID0gXCJbZnVuY3Rpb24gXCIgK1xuICAgICAgICAgICAgKG9iai5uYW1lIHx8IFwiYW5vbnltb3VzXCIpICtcbiAgICAgICAgICAgIFwiXVwiO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHN0ciA9IG9iaiAmJiB0eXBlb2Ygb2JqLnRvU3RyaW5nID09PSBcImZ1bmN0aW9uXCJcbiAgICAgICAgICAgID8gb2JqLnRvU3RyaW5nKCkgOiB1dGlsLnRvU3RyaW5nKG9iaik7XG4gICAgICAgIHZhciBydXNlbGVzc1RvU3RyaW5nID0gL1xcW29iamVjdCBbYS16QS1aMC05JF9dK1xcXS87XG4gICAgICAgIGlmIChydXNlbGVzc1RvU3RyaW5nLnRlc3Qoc3RyKSkge1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICB2YXIgbmV3U3RyID0gSlNPTi5zdHJpbmdpZnkob2JqKTtcbiAgICAgICAgICAgICAgICBzdHIgPSBuZXdTdHI7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXRjaChlKSB7XG5cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoc3RyLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgc3RyID0gXCIoZW1wdHkgYXJyYXkpXCI7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIChcIig8XCIgKyBzbmlwKHN0cikgKyBcIj4sIG5vIHN0YWNrIHRyYWNlKVwiKTtcbn1cblxuZnVuY3Rpb24gc25pcChzdHIpIHtcbiAgICB2YXIgbWF4Q2hhcnMgPSA0MTtcbiAgICBpZiAoc3RyLmxlbmd0aCA8IG1heENoYXJzKSB7XG4gICAgICAgIHJldHVybiBzdHI7XG4gICAgfVxuICAgIHJldHVybiBzdHIuc3Vic3RyKDAsIG1heENoYXJzIC0gMykgKyBcIi4uLlwiO1xufVxuXG5mdW5jdGlvbiBsb25nU3RhY2tUcmFjZXNJc1N1cHBvcnRlZCgpIHtcbiAgICByZXR1cm4gdHlwZW9mIGNhcHR1cmVTdGFja1RyYWNlID09PSBcImZ1bmN0aW9uXCI7XG59XG5cbnZhciBzaG91bGRJZ25vcmUgPSBmdW5jdGlvbigpIHsgcmV0dXJuIGZhbHNlOyB9O1xudmFyIHBhcnNlTGluZUluZm9SZWdleCA9IC9bXFwvPFxcKF0oW146XFwvXSspOihcXGQrKTooPzpcXGQrKVxcKT9cXHMqJC87XG5mdW5jdGlvbiBwYXJzZUxpbmVJbmZvKGxpbmUpIHtcbiAgICB2YXIgbWF0Y2hlcyA9IGxpbmUubWF0Y2gocGFyc2VMaW5lSW5mb1JlZ2V4KTtcbiAgICBpZiAobWF0Y2hlcykge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgZmlsZU5hbWU6IG1hdGNoZXNbMV0sXG4gICAgICAgICAgICBsaW5lOiBwYXJzZUludChtYXRjaGVzWzJdLCAxMClcbiAgICAgICAgfTtcbiAgICB9XG59XG5cbmZ1bmN0aW9uIHNldEJvdW5kcyhmaXJzdExpbmVFcnJvciwgbGFzdExpbmVFcnJvcikge1xuICAgIGlmICghbG9uZ1N0YWNrVHJhY2VzSXNTdXBwb3J0ZWQoKSkgcmV0dXJuO1xuICAgIHZhciBmaXJzdFN0YWNrTGluZXMgPSBmaXJzdExpbmVFcnJvci5zdGFjay5zcGxpdChcIlxcblwiKTtcbiAgICB2YXIgbGFzdFN0YWNrTGluZXMgPSBsYXN0TGluZUVycm9yLnN0YWNrLnNwbGl0KFwiXFxuXCIpO1xuICAgIHZhciBmaXJzdEluZGV4ID0gLTE7XG4gICAgdmFyIGxhc3RJbmRleCA9IC0xO1xuICAgIHZhciBmaXJzdEZpbGVOYW1lO1xuICAgIHZhciBsYXN0RmlsZU5hbWU7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBmaXJzdFN0YWNrTGluZXMubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgdmFyIHJlc3VsdCA9IHBhcnNlTGluZUluZm8oZmlyc3RTdGFja0xpbmVzW2ldKTtcbiAgICAgICAgaWYgKHJlc3VsdCkge1xuICAgICAgICAgICAgZmlyc3RGaWxlTmFtZSA9IHJlc3VsdC5maWxlTmFtZTtcbiAgICAgICAgICAgIGZpcnN0SW5kZXggPSByZXN1bHQubGluZTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgfVxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGFzdFN0YWNrTGluZXMubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgdmFyIHJlc3VsdCA9IHBhcnNlTGluZUluZm8obGFzdFN0YWNrTGluZXNbaV0pO1xuICAgICAgICBpZiAocmVzdWx0KSB7XG4gICAgICAgICAgICBsYXN0RmlsZU5hbWUgPSByZXN1bHQuZmlsZU5hbWU7XG4gICAgICAgICAgICBsYXN0SW5kZXggPSByZXN1bHQubGluZTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgfVxuICAgIGlmIChmaXJzdEluZGV4IDwgMCB8fCBsYXN0SW5kZXggPCAwIHx8ICFmaXJzdEZpbGVOYW1lIHx8ICFsYXN0RmlsZU5hbWUgfHxcbiAgICAgICAgZmlyc3RGaWxlTmFtZSAhPT0gbGFzdEZpbGVOYW1lIHx8IGZpcnN0SW5kZXggPj0gbGFzdEluZGV4KSB7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBzaG91bGRJZ25vcmUgPSBmdW5jdGlvbihsaW5lKSB7XG4gICAgICAgIGlmIChibHVlYmlyZEZyYW1lUGF0dGVybi50ZXN0KGxpbmUpKSByZXR1cm4gdHJ1ZTtcbiAgICAgICAgdmFyIGluZm8gPSBwYXJzZUxpbmVJbmZvKGxpbmUpO1xuICAgICAgICBpZiAoaW5mbykge1xuICAgICAgICAgICAgaWYgKGluZm8uZmlsZU5hbWUgPT09IGZpcnN0RmlsZU5hbWUgJiZcbiAgICAgICAgICAgICAgICAoZmlyc3RJbmRleCA8PSBpbmZvLmxpbmUgJiYgaW5mby5saW5lIDw9IGxhc3RJbmRleCkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfTtcbn1cblxuZnVuY3Rpb24gQ2FwdHVyZWRUcmFjZShwYXJlbnQpIHtcbiAgICB0aGlzLl9wYXJlbnQgPSBwYXJlbnQ7XG4gICAgdGhpcy5fcHJvbWlzZXNDcmVhdGVkID0gMDtcbiAgICB2YXIgbGVuZ3RoID0gdGhpcy5fbGVuZ3RoID0gMSArIChwYXJlbnQgPT09IHVuZGVmaW5lZCA/IDAgOiBwYXJlbnQuX2xlbmd0aCk7XG4gICAgY2FwdHVyZVN0YWNrVHJhY2UodGhpcywgQ2FwdHVyZWRUcmFjZSk7XG4gICAgaWYgKGxlbmd0aCA+IDMyKSB0aGlzLnVuY3ljbGUoKTtcbn1cbnV0aWwuaW5oZXJpdHMoQ2FwdHVyZWRUcmFjZSwgRXJyb3IpO1xuQ29udGV4dC5DYXB0dXJlZFRyYWNlID0gQ2FwdHVyZWRUcmFjZTtcblxuQ2FwdHVyZWRUcmFjZS5wcm90b3R5cGUudW5jeWNsZSA9IGZ1bmN0aW9uKCkge1xuICAgIHZhciBsZW5ndGggPSB0aGlzLl9sZW5ndGg7XG4gICAgaWYgKGxlbmd0aCA8IDIpIHJldHVybjtcbiAgICB2YXIgbm9kZXMgPSBbXTtcbiAgICB2YXIgc3RhY2tUb0luZGV4ID0ge307XG5cbiAgICBmb3IgKHZhciBpID0gMCwgbm9kZSA9IHRoaXM7IG5vZGUgIT09IHVuZGVmaW5lZDsgKytpKSB7XG4gICAgICAgIG5vZGVzLnB1c2gobm9kZSk7XG4gICAgICAgIG5vZGUgPSBub2RlLl9wYXJlbnQ7XG4gICAgfVxuICAgIGxlbmd0aCA9IHRoaXMuX2xlbmd0aCA9IGk7XG4gICAgZm9yICh2YXIgaSA9IGxlbmd0aCAtIDE7IGkgPj0gMDsgLS1pKSB7XG4gICAgICAgIHZhciBzdGFjayA9IG5vZGVzW2ldLnN0YWNrO1xuICAgICAgICBpZiAoc3RhY2tUb0luZGV4W3N0YWNrXSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBzdGFja1RvSW5kZXhbc3RhY2tdID0gaTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbmd0aDsgKytpKSB7XG4gICAgICAgIHZhciBjdXJyZW50U3RhY2sgPSBub2Rlc1tpXS5zdGFjaztcbiAgICAgICAgdmFyIGluZGV4ID0gc3RhY2tUb0luZGV4W2N1cnJlbnRTdGFja107XG4gICAgICAgIGlmIChpbmRleCAhPT0gdW5kZWZpbmVkICYmIGluZGV4ICE9PSBpKSB7XG4gICAgICAgICAgICBpZiAoaW5kZXggPiAwKSB7XG4gICAgICAgICAgICAgICAgbm9kZXNbaW5kZXggLSAxXS5fcGFyZW50ID0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgICAgIG5vZGVzW2luZGV4IC0gMV0uX2xlbmd0aCA9IDE7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBub2Rlc1tpXS5fcGFyZW50ID0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgbm9kZXNbaV0uX2xlbmd0aCA9IDE7XG4gICAgICAgICAgICB2YXIgY3ljbGVFZGdlTm9kZSA9IGkgPiAwID8gbm9kZXNbaSAtIDFdIDogdGhpcztcblxuICAgICAgICAgICAgaWYgKGluZGV4IDwgbGVuZ3RoIC0gMSkge1xuICAgICAgICAgICAgICAgIGN5Y2xlRWRnZU5vZGUuX3BhcmVudCA9IG5vZGVzW2luZGV4ICsgMV07XG4gICAgICAgICAgICAgICAgY3ljbGVFZGdlTm9kZS5fcGFyZW50LnVuY3ljbGUoKTtcbiAgICAgICAgICAgICAgICBjeWNsZUVkZ2VOb2RlLl9sZW5ndGggPVxuICAgICAgICAgICAgICAgICAgICBjeWNsZUVkZ2VOb2RlLl9wYXJlbnQuX2xlbmd0aCArIDE7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGN5Y2xlRWRnZU5vZGUuX3BhcmVudCA9IHVuZGVmaW5lZDtcbiAgICAgICAgICAgICAgICBjeWNsZUVkZ2VOb2RlLl9sZW5ndGggPSAxO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFyIGN1cnJlbnRDaGlsZExlbmd0aCA9IGN5Y2xlRWRnZU5vZGUuX2xlbmd0aCArIDE7XG4gICAgICAgICAgICBmb3IgKHZhciBqID0gaSAtIDI7IGogPj0gMDsgLS1qKSB7XG4gICAgICAgICAgICAgICAgbm9kZXNbal0uX2xlbmd0aCA9IGN1cnJlbnRDaGlsZExlbmd0aDtcbiAgICAgICAgICAgICAgICBjdXJyZW50Q2hpbGRMZW5ndGgrKztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgIH1cbn07XG5cbkNhcHR1cmVkVHJhY2UucHJvdG90eXBlLmF0dGFjaEV4dHJhVHJhY2UgPSBmdW5jdGlvbihlcnJvcikge1xuICAgIGlmIChlcnJvci5fX3N0YWNrQ2xlYW5lZF9fKSByZXR1cm47XG4gICAgdGhpcy51bmN5Y2xlKCk7XG4gICAgdmFyIHBhcnNlZCA9IHBhcnNlU3RhY2tBbmRNZXNzYWdlKGVycm9yKTtcbiAgICB2YXIgbWVzc2FnZSA9IHBhcnNlZC5tZXNzYWdlO1xuICAgIHZhciBzdGFja3MgPSBbcGFyc2VkLnN0YWNrXTtcblxuICAgIHZhciB0cmFjZSA9IHRoaXM7XG4gICAgd2hpbGUgKHRyYWNlICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgc3RhY2tzLnB1c2goY2xlYW5TdGFjayh0cmFjZS5zdGFjay5zcGxpdChcIlxcblwiKSkpO1xuICAgICAgICB0cmFjZSA9IHRyYWNlLl9wYXJlbnQ7XG4gICAgfVxuICAgIHJlbW92ZUNvbW1vblJvb3RzKHN0YWNrcyk7XG4gICAgcmVtb3ZlRHVwbGljYXRlT3JFbXB0eUp1bXBzKHN0YWNrcyk7XG4gICAgdXRpbC5ub3RFbnVtZXJhYmxlUHJvcChlcnJvciwgXCJzdGFja1wiLCByZWNvbnN0cnVjdFN0YWNrKG1lc3NhZ2UsIHN0YWNrcykpO1xuICAgIHV0aWwubm90RW51bWVyYWJsZVByb3AoZXJyb3IsIFwiX19zdGFja0NsZWFuZWRfX1wiLCB0cnVlKTtcbn07XG5cbnZhciBjYXB0dXJlU3RhY2tUcmFjZSA9IChmdW5jdGlvbiBzdGFja0RldGVjdGlvbigpIHtcbiAgICB2YXIgdjhzdGFja0ZyYW1lUGF0dGVybiA9IC9eXFxzKmF0XFxzKi87XG4gICAgdmFyIHY4c3RhY2tGb3JtYXR0ZXIgPSBmdW5jdGlvbihzdGFjaywgZXJyb3IpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBzdGFjayA9PT0gXCJzdHJpbmdcIikgcmV0dXJuIHN0YWNrO1xuXG4gICAgICAgIGlmIChlcnJvci5uYW1lICE9PSB1bmRlZmluZWQgJiZcbiAgICAgICAgICAgIGVycm9yLm1lc3NhZ2UgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgcmV0dXJuIGVycm9yLnRvU3RyaW5nKCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGZvcm1hdE5vbkVycm9yKGVycm9yKTtcbiAgICB9O1xuXG4gICAgaWYgKHR5cGVvZiBFcnJvci5zdGFja1RyYWNlTGltaXQgPT09IFwibnVtYmVyXCIgJiZcbiAgICAgICAgdHlwZW9mIEVycm9yLmNhcHR1cmVTdGFja1RyYWNlID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgRXJyb3Iuc3RhY2tUcmFjZUxpbWl0ICs9IDY7XG4gICAgICAgIHN0YWNrRnJhbWVQYXR0ZXJuID0gdjhzdGFja0ZyYW1lUGF0dGVybjtcbiAgICAgICAgZm9ybWF0U3RhY2sgPSB2OHN0YWNrRm9ybWF0dGVyO1xuICAgICAgICB2YXIgY2FwdHVyZVN0YWNrVHJhY2UgPSBFcnJvci5jYXB0dXJlU3RhY2tUcmFjZTtcblxuICAgICAgICBzaG91bGRJZ25vcmUgPSBmdW5jdGlvbihsaW5lKSB7XG4gICAgICAgICAgICByZXR1cm4gYmx1ZWJpcmRGcmFtZVBhdHRlcm4udGVzdChsaW5lKTtcbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uKHJlY2VpdmVyLCBpZ25vcmVVbnRpbCkge1xuICAgICAgICAgICAgRXJyb3Iuc3RhY2tUcmFjZUxpbWl0ICs9IDY7XG4gICAgICAgICAgICBjYXB0dXJlU3RhY2tUcmFjZShyZWNlaXZlciwgaWdub3JlVW50aWwpO1xuICAgICAgICAgICAgRXJyb3Iuc3RhY2tUcmFjZUxpbWl0IC09IDY7XG4gICAgICAgIH07XG4gICAgfVxuICAgIHZhciBlcnIgPSBuZXcgRXJyb3IoKTtcblxuICAgIGlmICh0eXBlb2YgZXJyLnN0YWNrID09PSBcInN0cmluZ1wiICYmXG4gICAgICAgIGVyci5zdGFjay5zcGxpdChcIlxcblwiKVswXS5pbmRleE9mKFwic3RhY2tEZXRlY3Rpb25AXCIpID49IDApIHtcbiAgICAgICAgc3RhY2tGcmFtZVBhdHRlcm4gPSAvQC87XG4gICAgICAgIGZvcm1hdFN0YWNrID0gdjhzdGFja0Zvcm1hdHRlcjtcbiAgICAgICAgaW5kZW50U3RhY2tGcmFtZXMgPSB0cnVlO1xuICAgICAgICByZXR1cm4gZnVuY3Rpb24gY2FwdHVyZVN0YWNrVHJhY2Uobykge1xuICAgICAgICAgICAgby5zdGFjayA9IG5ldyBFcnJvcigpLnN0YWNrO1xuICAgICAgICB9O1xuICAgIH1cblxuICAgIHZhciBoYXNTdGFja0FmdGVyVGhyb3c7XG4gICAgdHJ5IHsgdGhyb3cgbmV3IEVycm9yKCk7IH1cbiAgICBjYXRjaChlKSB7XG4gICAgICAgIGhhc1N0YWNrQWZ0ZXJUaHJvdyA9IChcInN0YWNrXCIgaW4gZSk7XG4gICAgfVxuICAgIGlmICghKFwic3RhY2tcIiBpbiBlcnIpICYmIGhhc1N0YWNrQWZ0ZXJUaHJvdyAmJlxuICAgICAgICB0eXBlb2YgRXJyb3Iuc3RhY2tUcmFjZUxpbWl0ID09PSBcIm51bWJlclwiKSB7XG4gICAgICAgIHN0YWNrRnJhbWVQYXR0ZXJuID0gdjhzdGFja0ZyYW1lUGF0dGVybjtcbiAgICAgICAgZm9ybWF0U3RhY2sgPSB2OHN0YWNrRm9ybWF0dGVyO1xuICAgICAgICByZXR1cm4gZnVuY3Rpb24gY2FwdHVyZVN0YWNrVHJhY2Uobykge1xuICAgICAgICAgICAgRXJyb3Iuc3RhY2tUcmFjZUxpbWl0ICs9IDY7XG4gICAgICAgICAgICB0cnkgeyB0aHJvdyBuZXcgRXJyb3IoKTsgfVxuICAgICAgICAgICAgY2F0Y2goZSkgeyBvLnN0YWNrID0gZS5zdGFjazsgfVxuICAgICAgICAgICAgRXJyb3Iuc3RhY2tUcmFjZUxpbWl0IC09IDY7XG4gICAgICAgIH07XG4gICAgfVxuXG4gICAgZm9ybWF0U3RhY2sgPSBmdW5jdGlvbihzdGFjaywgZXJyb3IpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBzdGFjayA9PT0gXCJzdHJpbmdcIikgcmV0dXJuIHN0YWNrO1xuXG4gICAgICAgIGlmICgodHlwZW9mIGVycm9yID09PSBcIm9iamVjdFwiIHx8XG4gICAgICAgICAgICB0eXBlb2YgZXJyb3IgPT09IFwiZnVuY3Rpb25cIikgJiZcbiAgICAgICAgICAgIGVycm9yLm5hbWUgIT09IHVuZGVmaW5lZCAmJlxuICAgICAgICAgICAgZXJyb3IubWVzc2FnZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICByZXR1cm4gZXJyb3IudG9TdHJpbmcoKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZm9ybWF0Tm9uRXJyb3IoZXJyb3IpO1xuICAgIH07XG5cbiAgICByZXR1cm4gbnVsbDtcblxufSkoW10pO1xuXG52YXIgZmlyZURvbUV2ZW50O1xudmFyIGZpcmVHbG9iYWxFdmVudCA9IChmdW5jdGlvbigpIHtcbiAgICBpZiAodXRpbC5pc05vZGUpIHtcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uKG5hbWUsIHJlYXNvbiwgcHJvbWlzZSkge1xuICAgICAgICAgICAgaWYgKG5hbWUgPT09IFwicmVqZWN0aW9uSGFuZGxlZFwiKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHByb2Nlc3MuZW1pdChuYW1lLCBwcm9taXNlKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHByb2Nlc3MuZW1pdChuYW1lLCByZWFzb24sIHByb21pc2UpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHZhciBjdXN0b21FdmVudFdvcmtzID0gZmFsc2U7XG4gICAgICAgIHZhciBhbnlFdmVudFdvcmtzID0gdHJ1ZTtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHZhciBldiA9IG5ldyBzZWxmLkN1c3RvbUV2ZW50KFwidGVzdFwiKTtcbiAgICAgICAgICAgIGN1c3RvbUV2ZW50V29ya3MgPSBldiBpbnN0YW5jZW9mIEN1c3RvbUV2ZW50O1xuICAgICAgICB9IGNhdGNoIChlKSB7fVxuICAgICAgICBpZiAoIWN1c3RvbUV2ZW50V29ya3MpIHtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgdmFyIGV2ZW50ID0gZG9jdW1lbnQuY3JlYXRlRXZlbnQoXCJDdXN0b21FdmVudFwiKTtcbiAgICAgICAgICAgICAgICBldmVudC5pbml0Q3VzdG9tRXZlbnQoXCJ0ZXN0aW5ndGhlZXZlbnRcIiwgZmFsc2UsIHRydWUsIHt9KTtcbiAgICAgICAgICAgICAgICBzZWxmLmRpc3BhdGNoRXZlbnQoZXZlbnQpO1xuICAgICAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgICAgICAgIGFueUV2ZW50V29ya3MgPSBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoYW55RXZlbnRXb3Jrcykge1xuICAgICAgICAgICAgZmlyZURvbUV2ZW50ID0gZnVuY3Rpb24odHlwZSwgZGV0YWlsKSB7XG4gICAgICAgICAgICAgICAgdmFyIGV2ZW50O1xuICAgICAgICAgICAgICAgIGlmIChjdXN0b21FdmVudFdvcmtzKSB7XG4gICAgICAgICAgICAgICAgICAgIGV2ZW50ID0gbmV3IHNlbGYuQ3VzdG9tRXZlbnQodHlwZSwge1xuICAgICAgICAgICAgICAgICAgICAgICAgZGV0YWlsOiBkZXRhaWwsXG4gICAgICAgICAgICAgICAgICAgICAgICBidWJibGVzOiBmYWxzZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhbmNlbGFibGU6IHRydWVcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmIChzZWxmLmRpc3BhdGNoRXZlbnQpIHtcbiAgICAgICAgICAgICAgICAgICAgZXZlbnQgPSBkb2N1bWVudC5jcmVhdGVFdmVudChcIkN1c3RvbUV2ZW50XCIpO1xuICAgICAgICAgICAgICAgICAgICBldmVudC5pbml0Q3VzdG9tRXZlbnQodHlwZSwgZmFsc2UsIHRydWUsIGRldGFpbCk7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgcmV0dXJuIGV2ZW50ID8gIXNlbGYuZGlzcGF0Y2hFdmVudChldmVudCkgOiBmYWxzZTtcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgdG9XaW5kb3dNZXRob2ROYW1lTWFwID0ge307XG4gICAgICAgIHRvV2luZG93TWV0aG9kTmFtZU1hcFtcInVuaGFuZGxlZFJlamVjdGlvblwiXSA9IChcIm9uXCIgK1xuICAgICAgICAgICAgXCJ1bmhhbmRsZWRSZWplY3Rpb25cIikudG9Mb3dlckNhc2UoKTtcbiAgICAgICAgdG9XaW5kb3dNZXRob2ROYW1lTWFwW1wicmVqZWN0aW9uSGFuZGxlZFwiXSA9IChcIm9uXCIgK1xuICAgICAgICAgICAgXCJyZWplY3Rpb25IYW5kbGVkXCIpLnRvTG93ZXJDYXNlKCk7XG5cbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uKG5hbWUsIHJlYXNvbiwgcHJvbWlzZSkge1xuICAgICAgICAgICAgdmFyIG1ldGhvZE5hbWUgPSB0b1dpbmRvd01ldGhvZE5hbWVNYXBbbmFtZV07XG4gICAgICAgICAgICB2YXIgbWV0aG9kID0gc2VsZlttZXRob2ROYW1lXTtcbiAgICAgICAgICAgIGlmICghbWV0aG9kKSByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICBpZiAobmFtZSA9PT0gXCJyZWplY3Rpb25IYW5kbGVkXCIpIHtcbiAgICAgICAgICAgICAgICBtZXRob2QuY2FsbChzZWxmLCBwcm9taXNlKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgbWV0aG9kLmNhbGwoc2VsZiwgcmVhc29uLCBwcm9taXNlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9O1xuICAgIH1cbn0pKCk7XG5cbmlmICh0eXBlb2YgY29uc29sZSAhPT0gXCJ1bmRlZmluZWRcIiAmJiB0eXBlb2YgY29uc29sZS53YXJuICE9PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgcHJpbnRXYXJuaW5nID0gZnVuY3Rpb24gKG1lc3NhZ2UpIHtcbiAgICAgICAgY29uc29sZS53YXJuKG1lc3NhZ2UpO1xuICAgIH07XG4gICAgaWYgKHV0aWwuaXNOb2RlICYmIHByb2Nlc3Muc3RkZXJyLmlzVFRZKSB7XG4gICAgICAgIHByaW50V2FybmluZyA9IGZ1bmN0aW9uKG1lc3NhZ2UsIGlzU29mdCkge1xuICAgICAgICAgICAgdmFyIGNvbG9yID0gaXNTb2Z0ID8gXCJcXHUwMDFiWzMzbVwiIDogXCJcXHUwMDFiWzMxbVwiO1xuICAgICAgICAgICAgY29uc29sZS53YXJuKGNvbG9yICsgbWVzc2FnZSArIFwiXFx1MDAxYlswbVxcblwiKTtcbiAgICAgICAgfTtcbiAgICB9IGVsc2UgaWYgKCF1dGlsLmlzTm9kZSAmJiB0eXBlb2YgKG5ldyBFcnJvcigpLnN0YWNrKSA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgICBwcmludFdhcm5pbmcgPSBmdW5jdGlvbihtZXNzYWdlLCBpc1NvZnQpIHtcbiAgICAgICAgICAgIGNvbnNvbGUud2FybihcIiVjXCIgKyBtZXNzYWdlLFxuICAgICAgICAgICAgICAgICAgICAgICAgaXNTb2Z0ID8gXCJjb2xvcjogZGFya29yYW5nZVwiIDogXCJjb2xvcjogcmVkXCIpO1xuICAgICAgICB9O1xuICAgIH1cbn1cblxudmFyIGNvbmZpZyA9IHtcbiAgICB3YXJuaW5nczogd2FybmluZ3MsXG4gICAgbG9uZ1N0YWNrVHJhY2VzOiBmYWxzZSxcbiAgICBjYW5jZWxsYXRpb246IGZhbHNlXG59O1xuXG5pZiAobG9uZ1N0YWNrVHJhY2VzKSBQcm9taXNlLmxvbmdTdGFja1RyYWNlcygpO1xuXG5yZXR1cm4ge1xuICAgIGxvbmdTdGFja1RyYWNlczogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiBjb25maWcubG9uZ1N0YWNrVHJhY2VzO1xuICAgIH0sXG4gICAgd2FybmluZ3M6IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gY29uZmlnLndhcm5pbmdzO1xuICAgIH0sXG4gICAgY2FuY2VsbGF0aW9uOiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIGNvbmZpZy5jYW5jZWxsYXRpb247XG4gICAgfSxcbiAgICBwcm9wYWdhdGVGcm9tRnVuY3Rpb246IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gcHJvcGFnYXRlRnJvbUZ1bmN0aW9uO1xuICAgIH0sXG4gICAgYm91bmRWYWx1ZUZ1bmN0aW9uOiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIGJvdW5kVmFsdWVGdW5jdGlvbjtcbiAgICB9LFxuICAgIGNoZWNrRm9yZ290dGVuUmV0dXJuczogY2hlY2tGb3Jnb3R0ZW5SZXR1cm5zLFxuICAgIHNldEJvdW5kczogc2V0Qm91bmRzLFxuICAgIHdhcm46IHdhcm4sXG4gICAgZGVwcmVjYXRlZDogZGVwcmVjYXRlZCxcbiAgICBDYXB0dXJlZFRyYWNlOiBDYXB0dXJlZFRyYWNlXG59O1xufTtcblxufSx7XCIuL2Vycm9yc1wiOjEyLFwiLi91dGlsXCI6MzZ9XSwxMDpbZnVuY3Rpb24oX2RlcmVxXyxtb2R1bGUsZXhwb3J0cyl7XG5cInVzZSBzdHJpY3RcIjtcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oUHJvbWlzZSkge1xuZnVuY3Rpb24gcmV0dXJuZXIoKSB7XG4gICAgcmV0dXJuIHRoaXMudmFsdWU7XG59XG5mdW5jdGlvbiB0aHJvd2VyKCkge1xuICAgIHRocm93IHRoaXMucmVhc29uO1xufVxuXG5Qcm9taXNlLnByb3RvdHlwZVtcInJldHVyblwiXSA9XG5Qcm9taXNlLnByb3RvdHlwZS50aGVuUmV0dXJuID0gZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgaWYgKHZhbHVlIGluc3RhbmNlb2YgUHJvbWlzZSkgdmFsdWUuc3VwcHJlc3NVbmhhbmRsZWRSZWplY3Rpb25zKCk7XG4gICAgcmV0dXJuIHRoaXMuX3RoZW4oXG4gICAgICAgIHJldHVybmVyLCB1bmRlZmluZWQsIHVuZGVmaW5lZCwge3ZhbHVlOiB2YWx1ZX0sIHVuZGVmaW5lZCk7XG59O1xuXG5Qcm9taXNlLnByb3RvdHlwZVtcInRocm93XCJdID1cblByb21pc2UucHJvdG90eXBlLnRoZW5UaHJvdyA9IGZ1bmN0aW9uIChyZWFzb24pIHtcbiAgICByZXR1cm4gdGhpcy5fdGhlbihcbiAgICAgICAgdGhyb3dlciwgdW5kZWZpbmVkLCB1bmRlZmluZWQsIHtyZWFzb246IHJlYXNvbn0sIHVuZGVmaW5lZCk7XG59O1xuXG5Qcm9taXNlLnByb3RvdHlwZS5jYXRjaFRocm93ID0gZnVuY3Rpb24gKHJlYXNvbikge1xuICAgIGlmIChhcmd1bWVudHMubGVuZ3RoIDw9IDEpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3RoZW4oXG4gICAgICAgICAgICB1bmRlZmluZWQsIHRocm93ZXIsIHVuZGVmaW5lZCwge3JlYXNvbjogcmVhc29ufSwgdW5kZWZpbmVkKTtcbiAgICB9IGVsc2Uge1xuICAgICAgICB2YXIgX3JlYXNvbiA9IGFyZ3VtZW50c1sxXTtcbiAgICAgICAgdmFyIGhhbmRsZXIgPSBmdW5jdGlvbigpIHt0aHJvdyBfcmVhc29uO307XG4gICAgICAgIHJldHVybiB0aGlzLmNhdWdodChyZWFzb24sIGhhbmRsZXIpO1xuICAgIH1cbn07XG5cblByb21pc2UucHJvdG90eXBlLmNhdGNoUmV0dXJuID0gZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPD0gMSkge1xuICAgICAgICBpZiAodmFsdWUgaW5zdGFuY2VvZiBQcm9taXNlKSB2YWx1ZS5zdXBwcmVzc1VuaGFuZGxlZFJlamVjdGlvbnMoKTtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3RoZW4oXG4gICAgICAgICAgICB1bmRlZmluZWQsIHJldHVybmVyLCB1bmRlZmluZWQsIHt2YWx1ZTogdmFsdWV9LCB1bmRlZmluZWQpO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHZhciBfdmFsdWUgPSBhcmd1bWVudHNbMV07XG4gICAgICAgIGlmIChfdmFsdWUgaW5zdGFuY2VvZiBQcm9taXNlKSBfdmFsdWUuc3VwcHJlc3NVbmhhbmRsZWRSZWplY3Rpb25zKCk7XG4gICAgICAgIHZhciBoYW5kbGVyID0gZnVuY3Rpb24oKSB7cmV0dXJuIF92YWx1ZTt9O1xuICAgICAgICByZXR1cm4gdGhpcy5jYXVnaHQodmFsdWUsIGhhbmRsZXIpO1xuICAgIH1cbn07XG59O1xuXG59LHt9XSwxMTpbZnVuY3Rpb24oX2RlcmVxXyxtb2R1bGUsZXhwb3J0cyl7XG5cInVzZSBzdHJpY3RcIjtcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oUHJvbWlzZSwgSU5URVJOQUwpIHtcbnZhciBQcm9taXNlUmVkdWNlID0gUHJvbWlzZS5yZWR1Y2U7XG52YXIgUHJvbWlzZUFsbCA9IFByb21pc2UuYWxsO1xuXG5mdW5jdGlvbiBwcm9taXNlQWxsVGhpcygpIHtcbiAgICByZXR1cm4gUHJvbWlzZUFsbCh0aGlzKTtcbn1cblxuZnVuY3Rpb24gUHJvbWlzZU1hcFNlcmllcyhwcm9taXNlcywgZm4pIHtcbiAgICByZXR1cm4gUHJvbWlzZVJlZHVjZShwcm9taXNlcywgZm4sIElOVEVSTkFMLCBJTlRFUk5BTCk7XG59XG5cblByb21pc2UucHJvdG90eXBlLmVhY2ggPSBmdW5jdGlvbiAoZm4pIHtcbiAgICByZXR1cm4gdGhpcy5tYXBTZXJpZXMoZm4pXG4gICAgICAgICAgICAuX3RoZW4ocHJvbWlzZUFsbFRoaXMsIHVuZGVmaW5lZCwgdW5kZWZpbmVkLCB0aGlzLCB1bmRlZmluZWQpO1xufTtcblxuUHJvbWlzZS5wcm90b3R5cGUubWFwU2VyaWVzID0gZnVuY3Rpb24gKGZuKSB7XG4gICAgcmV0dXJuIFByb21pc2VSZWR1Y2UodGhpcywgZm4sIElOVEVSTkFMLCBJTlRFUk5BTCk7XG59O1xuXG5Qcm9taXNlLmVhY2ggPSBmdW5jdGlvbiAocHJvbWlzZXMsIGZuKSB7XG4gICAgcmV0dXJuIFByb21pc2VNYXBTZXJpZXMocHJvbWlzZXMsIGZuKVxuICAgICAgICAgICAgLl90aGVuKHByb21pc2VBbGxUaGlzLCB1bmRlZmluZWQsIHVuZGVmaW5lZCwgcHJvbWlzZXMsIHVuZGVmaW5lZCk7XG59O1xuXG5Qcm9taXNlLm1hcFNlcmllcyA9IFByb21pc2VNYXBTZXJpZXM7XG59O1xuXG59LHt9XSwxMjpbZnVuY3Rpb24oX2RlcmVxXyxtb2R1bGUsZXhwb3J0cyl7XG5cInVzZSBzdHJpY3RcIjtcbnZhciBlczUgPSBfZGVyZXFfKFwiLi9lczVcIik7XG52YXIgT2JqZWN0ZnJlZXplID0gZXM1LmZyZWV6ZTtcbnZhciB1dGlsID0gX2RlcmVxXyhcIi4vdXRpbFwiKTtcbnZhciBpbmhlcml0cyA9IHV0aWwuaW5oZXJpdHM7XG52YXIgbm90RW51bWVyYWJsZVByb3AgPSB1dGlsLm5vdEVudW1lcmFibGVQcm9wO1xuXG5mdW5jdGlvbiBzdWJFcnJvcihuYW1lUHJvcGVydHksIGRlZmF1bHRNZXNzYWdlKSB7XG4gICAgZnVuY3Rpb24gU3ViRXJyb3IobWVzc2FnZSkge1xuICAgICAgICBpZiAoISh0aGlzIGluc3RhbmNlb2YgU3ViRXJyb3IpKSByZXR1cm4gbmV3IFN1YkVycm9yKG1lc3NhZ2UpO1xuICAgICAgICBub3RFbnVtZXJhYmxlUHJvcCh0aGlzLCBcIm1lc3NhZ2VcIixcbiAgICAgICAgICAgIHR5cGVvZiBtZXNzYWdlID09PSBcInN0cmluZ1wiID8gbWVzc2FnZSA6IGRlZmF1bHRNZXNzYWdlKTtcbiAgICAgICAgbm90RW51bWVyYWJsZVByb3AodGhpcywgXCJuYW1lXCIsIG5hbWVQcm9wZXJ0eSk7XG4gICAgICAgIGlmIChFcnJvci5jYXB0dXJlU3RhY2tUcmFjZSkge1xuICAgICAgICAgICAgRXJyb3IuY2FwdHVyZVN0YWNrVHJhY2UodGhpcywgdGhpcy5jb25zdHJ1Y3Rvcik7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBFcnJvci5jYWxsKHRoaXMpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGluaGVyaXRzKFN1YkVycm9yLCBFcnJvcik7XG4gICAgcmV0dXJuIFN1YkVycm9yO1xufVxuXG52YXIgX1R5cGVFcnJvciwgX1JhbmdlRXJyb3I7XG52YXIgV2FybmluZyA9IHN1YkVycm9yKFwiV2FybmluZ1wiLCBcIndhcm5pbmdcIik7XG52YXIgQ2FuY2VsbGF0aW9uRXJyb3IgPSBzdWJFcnJvcihcIkNhbmNlbGxhdGlvbkVycm9yXCIsIFwiY2FuY2VsbGF0aW9uIGVycm9yXCIpO1xudmFyIFRpbWVvdXRFcnJvciA9IHN1YkVycm9yKFwiVGltZW91dEVycm9yXCIsIFwidGltZW91dCBlcnJvclwiKTtcbnZhciBBZ2dyZWdhdGVFcnJvciA9IHN1YkVycm9yKFwiQWdncmVnYXRlRXJyb3JcIiwgXCJhZ2dyZWdhdGUgZXJyb3JcIik7XG50cnkge1xuICAgIF9UeXBlRXJyb3IgPSBUeXBlRXJyb3I7XG4gICAgX1JhbmdlRXJyb3IgPSBSYW5nZUVycm9yO1xufSBjYXRjaChlKSB7XG4gICAgX1R5cGVFcnJvciA9IHN1YkVycm9yKFwiVHlwZUVycm9yXCIsIFwidHlwZSBlcnJvclwiKTtcbiAgICBfUmFuZ2VFcnJvciA9IHN1YkVycm9yKFwiUmFuZ2VFcnJvclwiLCBcInJhbmdlIGVycm9yXCIpO1xufVxuXG52YXIgbWV0aG9kcyA9IChcImpvaW4gcG9wIHB1c2ggc2hpZnQgdW5zaGlmdCBzbGljZSBmaWx0ZXIgZm9yRWFjaCBzb21lIFwiICtcbiAgICBcImV2ZXJ5IG1hcCBpbmRleE9mIGxhc3RJbmRleE9mIHJlZHVjZSByZWR1Y2VSaWdodCBzb3J0IHJldmVyc2VcIikuc3BsaXQoXCIgXCIpO1xuXG5mb3IgKHZhciBpID0gMDsgaSA8IG1ldGhvZHMubGVuZ3RoOyArK2kpIHtcbiAgICBpZiAodHlwZW9mIEFycmF5LnByb3RvdHlwZVttZXRob2RzW2ldXSA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgIEFnZ3JlZ2F0ZUVycm9yLnByb3RvdHlwZVttZXRob2RzW2ldXSA9IEFycmF5LnByb3RvdHlwZVttZXRob2RzW2ldXTtcbiAgICB9XG59XG5cbmVzNS5kZWZpbmVQcm9wZXJ0eShBZ2dyZWdhdGVFcnJvci5wcm90b3R5cGUsIFwibGVuZ3RoXCIsIHtcbiAgICB2YWx1ZTogMCxcbiAgICBjb25maWd1cmFibGU6IGZhbHNlLFxuICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgIGVudW1lcmFibGU6IHRydWVcbn0pO1xuQWdncmVnYXRlRXJyb3IucHJvdG90eXBlW1wiaXNPcGVyYXRpb25hbFwiXSA9IHRydWU7XG52YXIgbGV2ZWwgPSAwO1xuQWdncmVnYXRlRXJyb3IucHJvdG90eXBlLnRvU3RyaW5nID0gZnVuY3Rpb24oKSB7XG4gICAgdmFyIGluZGVudCA9IEFycmF5KGxldmVsICogNCArIDEpLmpvaW4oXCIgXCIpO1xuICAgIHZhciByZXQgPSBcIlxcblwiICsgaW5kZW50ICsgXCJBZ2dyZWdhdGVFcnJvciBvZjpcIiArIFwiXFxuXCI7XG4gICAgbGV2ZWwrKztcbiAgICBpbmRlbnQgPSBBcnJheShsZXZlbCAqIDQgKyAxKS5qb2luKFwiIFwiKTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgdmFyIHN0ciA9IHRoaXNbaV0gPT09IHRoaXMgPyBcIltDaXJjdWxhciBBZ2dyZWdhdGVFcnJvcl1cIiA6IHRoaXNbaV0gKyBcIlwiO1xuICAgICAgICB2YXIgbGluZXMgPSBzdHIuc3BsaXQoXCJcXG5cIik7XG4gICAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgbGluZXMubGVuZ3RoOyArK2opIHtcbiAgICAgICAgICAgIGxpbmVzW2pdID0gaW5kZW50ICsgbGluZXNbal07XG4gICAgICAgIH1cbiAgICAgICAgc3RyID0gbGluZXMuam9pbihcIlxcblwiKTtcbiAgICAgICAgcmV0ICs9IHN0ciArIFwiXFxuXCI7XG4gICAgfVxuICAgIGxldmVsLS07XG4gICAgcmV0dXJuIHJldDtcbn07XG5cbmZ1bmN0aW9uIE9wZXJhdGlvbmFsRXJyb3IobWVzc2FnZSkge1xuICAgIGlmICghKHRoaXMgaW5zdGFuY2VvZiBPcGVyYXRpb25hbEVycm9yKSlcbiAgICAgICAgcmV0dXJuIG5ldyBPcGVyYXRpb25hbEVycm9yKG1lc3NhZ2UpO1xuICAgIG5vdEVudW1lcmFibGVQcm9wKHRoaXMsIFwibmFtZVwiLCBcIk9wZXJhdGlvbmFsRXJyb3JcIik7XG4gICAgbm90RW51bWVyYWJsZVByb3AodGhpcywgXCJtZXNzYWdlXCIsIG1lc3NhZ2UpO1xuICAgIHRoaXMuY2F1c2UgPSBtZXNzYWdlO1xuICAgIHRoaXNbXCJpc09wZXJhdGlvbmFsXCJdID0gdHJ1ZTtcblxuICAgIGlmIChtZXNzYWdlIGluc3RhbmNlb2YgRXJyb3IpIHtcbiAgICAgICAgbm90RW51bWVyYWJsZVByb3AodGhpcywgXCJtZXNzYWdlXCIsIG1lc3NhZ2UubWVzc2FnZSk7XG4gICAgICAgIG5vdEVudW1lcmFibGVQcm9wKHRoaXMsIFwic3RhY2tcIiwgbWVzc2FnZS5zdGFjayk7XG4gICAgfSBlbHNlIGlmIChFcnJvci5jYXB0dXJlU3RhY2tUcmFjZSkge1xuICAgICAgICBFcnJvci5jYXB0dXJlU3RhY2tUcmFjZSh0aGlzLCB0aGlzLmNvbnN0cnVjdG9yKTtcbiAgICB9XG5cbn1cbmluaGVyaXRzKE9wZXJhdGlvbmFsRXJyb3IsIEVycm9yKTtcblxudmFyIGVycm9yVHlwZXMgPSBFcnJvcltcIl9fQmx1ZWJpcmRFcnJvclR5cGVzX19cIl07XG5pZiAoIWVycm9yVHlwZXMpIHtcbiAgICBlcnJvclR5cGVzID0gT2JqZWN0ZnJlZXplKHtcbiAgICAgICAgQ2FuY2VsbGF0aW9uRXJyb3I6IENhbmNlbGxhdGlvbkVycm9yLFxuICAgICAgICBUaW1lb3V0RXJyb3I6IFRpbWVvdXRFcnJvcixcbiAgICAgICAgT3BlcmF0aW9uYWxFcnJvcjogT3BlcmF0aW9uYWxFcnJvcixcbiAgICAgICAgUmVqZWN0aW9uRXJyb3I6IE9wZXJhdGlvbmFsRXJyb3IsXG4gICAgICAgIEFnZ3JlZ2F0ZUVycm9yOiBBZ2dyZWdhdGVFcnJvclxuICAgIH0pO1xuICAgIG5vdEVudW1lcmFibGVQcm9wKEVycm9yLCBcIl9fQmx1ZWJpcmRFcnJvclR5cGVzX19cIiwgZXJyb3JUeXBlcyk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICAgIEVycm9yOiBFcnJvcixcbiAgICBUeXBlRXJyb3I6IF9UeXBlRXJyb3IsXG4gICAgUmFuZ2VFcnJvcjogX1JhbmdlRXJyb3IsXG4gICAgQ2FuY2VsbGF0aW9uRXJyb3I6IGVycm9yVHlwZXMuQ2FuY2VsbGF0aW9uRXJyb3IsXG4gICAgT3BlcmF0aW9uYWxFcnJvcjogZXJyb3JUeXBlcy5PcGVyYXRpb25hbEVycm9yLFxuICAgIFRpbWVvdXRFcnJvcjogZXJyb3JUeXBlcy5UaW1lb3V0RXJyb3IsXG4gICAgQWdncmVnYXRlRXJyb3I6IGVycm9yVHlwZXMuQWdncmVnYXRlRXJyb3IsXG4gICAgV2FybmluZzogV2FybmluZ1xufTtcblxufSx7XCIuL2VzNVwiOjEzLFwiLi91dGlsXCI6MzZ9XSwxMzpbZnVuY3Rpb24oX2RlcmVxXyxtb2R1bGUsZXhwb3J0cyl7XG52YXIgaXNFUzUgPSAoZnVuY3Rpb24oKXtcbiAgICBcInVzZSBzdHJpY3RcIjtcbiAgICByZXR1cm4gdGhpcyA9PT0gdW5kZWZpbmVkO1xufSkoKTtcblxuaWYgKGlzRVM1KSB7XG4gICAgbW9kdWxlLmV4cG9ydHMgPSB7XG4gICAgICAgIGZyZWV6ZTogT2JqZWN0LmZyZWV6ZSxcbiAgICAgICAgZGVmaW5lUHJvcGVydHk6IE9iamVjdC5kZWZpbmVQcm9wZXJ0eSxcbiAgICAgICAgZ2V0RGVzY3JpcHRvcjogT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcixcbiAgICAgICAga2V5czogT2JqZWN0LmtleXMsXG4gICAgICAgIG5hbWVzOiBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyxcbiAgICAgICAgZ2V0UHJvdG90eXBlT2Y6IE9iamVjdC5nZXRQcm90b3R5cGVPZixcbiAgICAgICAgaXNBcnJheTogQXJyYXkuaXNBcnJheSxcbiAgICAgICAgaXNFUzU6IGlzRVM1LFxuICAgICAgICBwcm9wZXJ0eUlzV3JpdGFibGU6IGZ1bmN0aW9uKG9iaiwgcHJvcCkge1xuICAgICAgICAgICAgdmFyIGRlc2NyaXB0b3IgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKG9iaiwgcHJvcCk7XG4gICAgICAgICAgICByZXR1cm4gISEoIWRlc2NyaXB0b3IgfHwgZGVzY3JpcHRvci53cml0YWJsZSB8fCBkZXNjcmlwdG9yLnNldCk7XG4gICAgICAgIH1cbiAgICB9O1xufSBlbHNlIHtcbiAgICB2YXIgaGFzID0ge30uaGFzT3duUHJvcGVydHk7XG4gICAgdmFyIHN0ciA9IHt9LnRvU3RyaW5nO1xuICAgIHZhciBwcm90byA9IHt9LmNvbnN0cnVjdG9yLnByb3RvdHlwZTtcblxuICAgIHZhciBPYmplY3RLZXlzID0gZnVuY3Rpb24gKG8pIHtcbiAgICAgICAgdmFyIHJldCA9IFtdO1xuICAgICAgICBmb3IgKHZhciBrZXkgaW4gbykge1xuICAgICAgICAgICAgaWYgKGhhcy5jYWxsKG8sIGtleSkpIHtcbiAgICAgICAgICAgICAgICByZXQucHVzaChrZXkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXQ7XG4gICAgfTtcblxuICAgIHZhciBPYmplY3RHZXREZXNjcmlwdG9yID0gZnVuY3Rpb24obywga2V5KSB7XG4gICAgICAgIHJldHVybiB7dmFsdWU6IG9ba2V5XX07XG4gICAgfTtcblxuICAgIHZhciBPYmplY3REZWZpbmVQcm9wZXJ0eSA9IGZ1bmN0aW9uIChvLCBrZXksIGRlc2MpIHtcbiAgICAgICAgb1trZXldID0gZGVzYy52YWx1ZTtcbiAgICAgICAgcmV0dXJuIG87XG4gICAgfTtcblxuICAgIHZhciBPYmplY3RGcmVlemUgPSBmdW5jdGlvbiAob2JqKSB7XG4gICAgICAgIHJldHVybiBvYmo7XG4gICAgfTtcblxuICAgIHZhciBPYmplY3RHZXRQcm90b3R5cGVPZiA9IGZ1bmN0aW9uIChvYmopIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHJldHVybiBPYmplY3Qob2JqKS5jb25zdHJ1Y3Rvci5wcm90b3R5cGU7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgIHJldHVybiBwcm90bztcbiAgICAgICAgfVxuICAgIH07XG5cbiAgICB2YXIgQXJyYXlJc0FycmF5ID0gZnVuY3Rpb24gKG9iaikge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgcmV0dXJuIHN0ci5jYWxsKG9iaikgPT09IFwiW29iamVjdCBBcnJheV1cIjtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaChlKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgbW9kdWxlLmV4cG9ydHMgPSB7XG4gICAgICAgIGlzQXJyYXk6IEFycmF5SXNBcnJheSxcbiAgICAgICAga2V5czogT2JqZWN0S2V5cyxcbiAgICAgICAgbmFtZXM6IE9iamVjdEtleXMsXG4gICAgICAgIGRlZmluZVByb3BlcnR5OiBPYmplY3REZWZpbmVQcm9wZXJ0eSxcbiAgICAgICAgZ2V0RGVzY3JpcHRvcjogT2JqZWN0R2V0RGVzY3JpcHRvcixcbiAgICAgICAgZnJlZXplOiBPYmplY3RGcmVlemUsXG4gICAgICAgIGdldFByb3RvdHlwZU9mOiBPYmplY3RHZXRQcm90b3R5cGVPZixcbiAgICAgICAgaXNFUzU6IGlzRVM1LFxuICAgICAgICBwcm9wZXJ0eUlzV3JpdGFibGU6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICB9O1xufVxuXG59LHt9XSwxNDpbZnVuY3Rpb24oX2RlcmVxXyxtb2R1bGUsZXhwb3J0cyl7XG5cInVzZSBzdHJpY3RcIjtcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oUHJvbWlzZSwgSU5URVJOQUwpIHtcbnZhciBQcm9taXNlTWFwID0gUHJvbWlzZS5tYXA7XG5cblByb21pc2UucHJvdG90eXBlLmZpbHRlciA9IGZ1bmN0aW9uIChmbiwgb3B0aW9ucykge1xuICAgIHJldHVybiBQcm9taXNlTWFwKHRoaXMsIGZuLCBvcHRpb25zLCBJTlRFUk5BTCk7XG59O1xuXG5Qcm9taXNlLmZpbHRlciA9IGZ1bmN0aW9uIChwcm9taXNlcywgZm4sIG9wdGlvbnMpIHtcbiAgICByZXR1cm4gUHJvbWlzZU1hcChwcm9taXNlcywgZm4sIG9wdGlvbnMsIElOVEVSTkFMKTtcbn07XG59O1xuXG59LHt9XSwxNTpbZnVuY3Rpb24oX2RlcmVxXyxtb2R1bGUsZXhwb3J0cyl7XG5cInVzZSBzdHJpY3RcIjtcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oUHJvbWlzZSwgdHJ5Q29udmVydFRvUHJvbWlzZSkge1xudmFyIHV0aWwgPSBfZGVyZXFfKFwiLi91dGlsXCIpO1xudmFyIENhbmNlbGxhdGlvbkVycm9yID0gUHJvbWlzZS5DYW5jZWxsYXRpb25FcnJvcjtcbnZhciBlcnJvck9iaiA9IHV0aWwuZXJyb3JPYmo7XG5cbmZ1bmN0aW9uIEZpbmFsbHlIYW5kbGVyQ2FuY2VsUmVhY3Rpb24oZmluYWxseUhhbmRsZXIpIHtcbiAgICB0aGlzLmZpbmFsbHlIYW5kbGVyID0gZmluYWxseUhhbmRsZXI7XG59XG5cbkZpbmFsbHlIYW5kbGVyQ2FuY2VsUmVhY3Rpb24ucHJvdG90eXBlLl9yZXN1bHRDYW5jZWxsZWQgPSBmdW5jdGlvbigpIHtcbiAgICBjaGVja0NhbmNlbCh0aGlzLmZpbmFsbHlIYW5kbGVyKTtcbn07XG5cbmZ1bmN0aW9uIGNoZWNrQ2FuY2VsKGN0eCwgcmVhc29uKSB7XG4gICAgaWYgKGN0eC5jYW5jZWxQcm9taXNlICE9IG51bGwpIHtcbiAgICAgICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPiAxKSB7XG4gICAgICAgICAgICBjdHguY2FuY2VsUHJvbWlzZS5fcmVqZWN0KHJlYXNvbik7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBjdHguY2FuY2VsUHJvbWlzZS5fY2FuY2VsKCk7XG4gICAgICAgIH1cbiAgICAgICAgY3R4LmNhbmNlbFByb21pc2UgPSBudWxsO1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlO1xufVxuXG5mdW5jdGlvbiBzdWNjZWVkKCkge1xuICAgIHJldHVybiBmaW5hbGx5SGFuZGxlci5jYWxsKHRoaXMsIHRoaXMucHJvbWlzZS5fdGFyZ2V0KCkuX3NldHRsZWRWYWx1ZSgpKTtcbn1cbmZ1bmN0aW9uIGZhaWwocmVhc29uKSB7XG4gICAgaWYgKGNoZWNrQ2FuY2VsKHRoaXMsIHJlYXNvbikpIHJldHVybjtcbiAgICBlcnJvck9iai5lID0gcmVhc29uO1xuICAgIHJldHVybiBlcnJvck9iajtcbn1cbmZ1bmN0aW9uIGZpbmFsbHlIYW5kbGVyKHJlYXNvbk9yVmFsdWUpIHtcbiAgICB2YXIgcHJvbWlzZSA9IHRoaXMucHJvbWlzZTtcbiAgICB2YXIgaGFuZGxlciA9IHRoaXMuaGFuZGxlcjtcblxuICAgIGlmICghdGhpcy5jYWxsZWQpIHtcbiAgICAgICAgdGhpcy5jYWxsZWQgPSB0cnVlO1xuICAgICAgICB2YXIgcmV0ID0gdGhpcy50eXBlID09PSAwXG4gICAgICAgICAgICA/IGhhbmRsZXIuY2FsbChwcm9taXNlLl9ib3VuZFZhbHVlKCkpXG4gICAgICAgICAgICA6IGhhbmRsZXIuY2FsbChwcm9taXNlLl9ib3VuZFZhbHVlKCksIHJlYXNvbk9yVmFsdWUpO1xuICAgICAgICBpZiAocmV0ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHZhciBtYXliZVByb21pc2UgPSB0cnlDb252ZXJ0VG9Qcm9taXNlKHJldCwgcHJvbWlzZSk7XG4gICAgICAgICAgICBpZiAobWF5YmVQcm9taXNlIGluc3RhbmNlb2YgUHJvbWlzZSkge1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLmNhbmNlbFByb21pc2UgIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICBpZiAobWF5YmVQcm9taXNlLmlzQ2FuY2VsbGVkKCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciByZWFzb24gPVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5ldyBDYW5jZWxsYXRpb25FcnJvcihcImxhdGUgY2FuY2VsbGF0aW9uIG9ic2VydmVyXCIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgcHJvbWlzZS5fYXR0YWNoRXh0cmFUcmFjZShyZWFzb24pO1xuICAgICAgICAgICAgICAgICAgICAgICAgZXJyb3JPYmouZSA9IHJlYXNvbjtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBlcnJvck9iajtcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmIChtYXliZVByb21pc2UuaXNQZW5kaW5nKCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG1heWJlUHJvbWlzZS5fYXR0YWNoQ2FuY2VsbGF0aW9uQ2FsbGJhY2soXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbmV3IEZpbmFsbHlIYW5kbGVyQ2FuY2VsUmVhY3Rpb24odGhpcykpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiBtYXliZVByb21pc2UuX3RoZW4oXG4gICAgICAgICAgICAgICAgICAgIHN1Y2NlZWQsIGZhaWwsIHVuZGVmaW5lZCwgdGhpcywgdW5kZWZpbmVkKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIGlmIChwcm9taXNlLmlzUmVqZWN0ZWQoKSkge1xuICAgICAgICBjaGVja0NhbmNlbCh0aGlzKTtcbiAgICAgICAgZXJyb3JPYmouZSA9IHJlYXNvbk9yVmFsdWU7XG4gICAgICAgIHJldHVybiBlcnJvck9iajtcbiAgICB9IGVsc2Uge1xuICAgICAgICBjaGVja0NhbmNlbCh0aGlzKTtcbiAgICAgICAgcmV0dXJuIHJlYXNvbk9yVmFsdWU7XG4gICAgfVxufVxuXG5Qcm9taXNlLnByb3RvdHlwZS5fcGFzc1Rocm91Z2ggPSBmdW5jdGlvbihoYW5kbGVyLCB0eXBlLCBzdWNjZXNzLCBmYWlsKSB7XG4gICAgaWYgKHR5cGVvZiBoYW5kbGVyICE9PSBcImZ1bmN0aW9uXCIpIHJldHVybiB0aGlzLnRoZW4oKTtcbiAgICByZXR1cm4gdGhpcy5fdGhlbihzdWNjZXNzLCBmYWlsLCB1bmRlZmluZWQsIHtcbiAgICAgICAgcHJvbWlzZTogdGhpcyxcbiAgICAgICAgaGFuZGxlcjogaGFuZGxlcixcbiAgICAgICAgY2FsbGVkOiBmYWxzZSxcbiAgICAgICAgY2FuY2VsUHJvbWlzZTogbnVsbCxcbiAgICAgICAgdHlwZTogdHlwZVxuICAgIH0sIHVuZGVmaW5lZCk7XG59O1xuXG5Qcm9taXNlLnByb3RvdHlwZS5sYXN0bHkgPVxuUHJvbWlzZS5wcm90b3R5cGVbXCJmaW5hbGx5XCJdID0gZnVuY3Rpb24gKGhhbmRsZXIpIHtcbiAgICByZXR1cm4gdGhpcy5fcGFzc1Rocm91Z2goaGFuZGxlcixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgMCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZmluYWxseUhhbmRsZXIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZpbmFsbHlIYW5kbGVyKTtcbn07XG5cblByb21pc2UucHJvdG90eXBlLnRhcCA9IGZ1bmN0aW9uIChoYW5kbGVyKSB7XG4gICAgcmV0dXJuIHRoaXMuX3Bhc3NUaHJvdWdoKGhhbmRsZXIsIDEsIGZpbmFsbHlIYW5kbGVyKTtcbn07XG5cbnJldHVybiBmaW5hbGx5SGFuZGxlcjtcbn07XG5cbn0se1wiLi91dGlsXCI6MzZ9XSwxNjpbZnVuY3Rpb24oX2RlcmVxXyxtb2R1bGUsZXhwb3J0cyl7XG5cInVzZSBzdHJpY3RcIjtcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oUHJvbWlzZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgYXBpUmVqZWN0aW9uLFxuICAgICAgICAgICAgICAgICAgICAgICAgICBJTlRFUk5BTCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgdHJ5Q29udmVydFRvUHJvbWlzZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgUHJveHlhYmxlLFxuICAgICAgICAgICAgICAgICAgICAgICAgICBkZWJ1Zykge1xudmFyIGVycm9ycyA9IF9kZXJlcV8oXCIuL2Vycm9yc1wiKTtcbnZhciBUeXBlRXJyb3IgPSBlcnJvcnMuVHlwZUVycm9yO1xudmFyIHV0aWwgPSBfZGVyZXFfKFwiLi91dGlsXCIpO1xudmFyIGVycm9yT2JqID0gdXRpbC5lcnJvck9iajtcbnZhciB0cnlDYXRjaCA9IHV0aWwudHJ5Q2F0Y2g7XG52YXIgeWllbGRIYW5kbGVycyA9IFtdO1xuXG5mdW5jdGlvbiBwcm9taXNlRnJvbVlpZWxkSGFuZGxlcih2YWx1ZSwgeWllbGRIYW5kbGVycywgdHJhY2VQYXJlbnQpIHtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHlpZWxkSGFuZGxlcnMubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgdHJhY2VQYXJlbnQuX3B1c2hDb250ZXh0KCk7XG4gICAgICAgIHZhciByZXN1bHQgPSB0cnlDYXRjaCh5aWVsZEhhbmRsZXJzW2ldKSh2YWx1ZSk7XG4gICAgICAgIHRyYWNlUGFyZW50Ll9wb3BDb250ZXh0KCk7XG4gICAgICAgIGlmIChyZXN1bHQgPT09IGVycm9yT2JqKSB7XG4gICAgICAgICAgICB0cmFjZVBhcmVudC5fcHVzaENvbnRleHQoKTtcbiAgICAgICAgICAgIHZhciByZXQgPSBQcm9taXNlLnJlamVjdChlcnJvck9iai5lKTtcbiAgICAgICAgICAgIHRyYWNlUGFyZW50Ll9wb3BDb250ZXh0KCk7XG4gICAgICAgICAgICByZXR1cm4gcmV0O1xuICAgICAgICB9XG4gICAgICAgIHZhciBtYXliZVByb21pc2UgPSB0cnlDb252ZXJ0VG9Qcm9taXNlKHJlc3VsdCwgdHJhY2VQYXJlbnQpO1xuICAgICAgICBpZiAobWF5YmVQcm9taXNlIGluc3RhbmNlb2YgUHJvbWlzZSkgcmV0dXJuIG1heWJlUHJvbWlzZTtcbiAgICB9XG4gICAgcmV0dXJuIG51bGw7XG59XG5cbmZ1bmN0aW9uIFByb21pc2VTcGF3bihnZW5lcmF0b3JGdW5jdGlvbiwgcmVjZWl2ZXIsIHlpZWxkSGFuZGxlciwgc3RhY2spIHtcbiAgICB2YXIgcHJvbWlzZSA9IHRoaXMuX3Byb21pc2UgPSBuZXcgUHJvbWlzZShJTlRFUk5BTCk7XG4gICAgcHJvbWlzZS5fY2FwdHVyZVN0YWNrVHJhY2UoKTtcbiAgICBwcm9taXNlLl9zZXRPbkNhbmNlbCh0aGlzKTtcbiAgICB0aGlzLl9zdGFjayA9IHN0YWNrO1xuICAgIHRoaXMuX2dlbmVyYXRvckZ1bmN0aW9uID0gZ2VuZXJhdG9yRnVuY3Rpb247XG4gICAgdGhpcy5fcmVjZWl2ZXIgPSByZWNlaXZlcjtcbiAgICB0aGlzLl9nZW5lcmF0b3IgPSB1bmRlZmluZWQ7XG4gICAgdGhpcy5feWllbGRIYW5kbGVycyA9IHR5cGVvZiB5aWVsZEhhbmRsZXIgPT09IFwiZnVuY3Rpb25cIlxuICAgICAgICA/IFt5aWVsZEhhbmRsZXJdLmNvbmNhdCh5aWVsZEhhbmRsZXJzKVxuICAgICAgICA6IHlpZWxkSGFuZGxlcnM7XG4gICAgdGhpcy5feWllbGRlZFByb21pc2UgPSBudWxsO1xufVxudXRpbC5pbmhlcml0cyhQcm9taXNlU3Bhd24sIFByb3h5YWJsZSk7XG5cblByb21pc2VTcGF3bi5wcm90b3R5cGUuX2lzUmVzb2x2ZWQgPSBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gdGhpcy5wcm9taXNlID09PSBudWxsO1xufTtcblxuUHJvbWlzZVNwYXduLnByb3RvdHlwZS5fY2xlYW51cCA9IGZ1bmN0aW9uKCkge1xuICAgIHRoaXMuX3Byb21pc2UgPSB0aGlzLl9nZW5lcmF0b3IgPSBudWxsO1xufTtcblxuUHJvbWlzZVNwYXduLnByb3RvdHlwZS5fcHJvbWlzZUNhbmNlbGxlZCA9IGZ1bmN0aW9uKCkge1xuICAgIGlmICh0aGlzLl9pc1Jlc29sdmVkKCkpIHJldHVybjtcbiAgICB2YXIgaW1wbGVtZW50c1JldHVybiA9IHR5cGVvZiB0aGlzLl9nZW5lcmF0b3JbXCJyZXR1cm5cIl0gIT09IFwidW5kZWZpbmVkXCI7XG5cbiAgICB2YXIgcmVzdWx0O1xuICAgIGlmICghaW1wbGVtZW50c1JldHVybikge1xuICAgICAgICB2YXIgcmVhc29uID0gbmV3IFByb21pc2UuQ2FuY2VsbGF0aW9uRXJyb3IoXG4gICAgICAgICAgICBcImdlbmVyYXRvciAucmV0dXJuKCkgc2VudGluZWxcIik7XG4gICAgICAgIFByb21pc2UuY29yb3V0aW5lLnJldHVyblNlbnRpbmVsID0gcmVhc29uO1xuICAgICAgICB0aGlzLl9wcm9taXNlLl9hdHRhY2hFeHRyYVRyYWNlKHJlYXNvbik7XG4gICAgICAgIHRoaXMuX3Byb21pc2UuX3B1c2hDb250ZXh0KCk7XG4gICAgICAgIHJlc3VsdCA9IHRyeUNhdGNoKHRoaXMuX2dlbmVyYXRvcltcInRocm93XCJdKS5jYWxsKHRoaXMuX2dlbmVyYXRvcixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlYXNvbik7XG4gICAgICAgIHRoaXMuX3Byb21pc2UuX3BvcENvbnRleHQoKTtcbiAgICAgICAgaWYgKHJlc3VsdCA9PT0gZXJyb3JPYmogJiYgcmVzdWx0LmUgPT09IHJlYXNvbikge1xuICAgICAgICAgICAgcmVzdWx0ID0gbnVsbDtcbiAgICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMuX3Byb21pc2UuX3B1c2hDb250ZXh0KCk7XG4gICAgICAgIHJlc3VsdCA9IHRyeUNhdGNoKHRoaXMuX2dlbmVyYXRvcltcInJldHVyblwiXSkuY2FsbCh0aGlzLl9nZW5lcmF0b3IsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdW5kZWZpbmVkKTtcbiAgICAgICAgdGhpcy5fcHJvbWlzZS5fcG9wQ29udGV4dCgpO1xuICAgIH1cbiAgICB2YXIgcHJvbWlzZSA9IHRoaXMuX3Byb21pc2U7XG4gICAgdGhpcy5fY2xlYW51cCgpO1xuICAgIGlmIChyZXN1bHQgPT09IGVycm9yT2JqKSB7XG4gICAgICAgIHByb21pc2UuX3JlamVjdENhbGxiYWNrKHJlc3VsdC5lLCBmYWxzZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgcHJvbWlzZS5jYW5jZWwoKTtcbiAgICB9XG59O1xuXG5Qcm9taXNlU3Bhd24ucHJvdG90eXBlLl9wcm9taXNlRnVsZmlsbGVkID0gZnVuY3Rpb24odmFsdWUpIHtcbiAgICB0aGlzLl95aWVsZGVkUHJvbWlzZSA9IG51bGw7XG4gICAgdGhpcy5fcHJvbWlzZS5fcHVzaENvbnRleHQoKTtcbiAgICB2YXIgcmVzdWx0ID0gdHJ5Q2F0Y2godGhpcy5fZ2VuZXJhdG9yLm5leHQpLmNhbGwodGhpcy5fZ2VuZXJhdG9yLCB2YWx1ZSk7XG4gICAgdGhpcy5fcHJvbWlzZS5fcG9wQ29udGV4dCgpO1xuICAgIHRoaXMuX2NvbnRpbnVlKHJlc3VsdCk7XG59O1xuXG5Qcm9taXNlU3Bhd24ucHJvdG90eXBlLl9wcm9taXNlUmVqZWN0ZWQgPSBmdW5jdGlvbihyZWFzb24pIHtcbiAgICB0aGlzLl95aWVsZGVkUHJvbWlzZSA9IG51bGw7XG4gICAgdGhpcy5fcHJvbWlzZS5fYXR0YWNoRXh0cmFUcmFjZShyZWFzb24pO1xuICAgIHRoaXMuX3Byb21pc2UuX3B1c2hDb250ZXh0KCk7XG4gICAgdmFyIHJlc3VsdCA9IHRyeUNhdGNoKHRoaXMuX2dlbmVyYXRvcltcInRocm93XCJdKVxuICAgICAgICAuY2FsbCh0aGlzLl9nZW5lcmF0b3IsIHJlYXNvbik7XG4gICAgdGhpcy5fcHJvbWlzZS5fcG9wQ29udGV4dCgpO1xuICAgIHRoaXMuX2NvbnRpbnVlKHJlc3VsdCk7XG59O1xuXG5Qcm9taXNlU3Bhd24ucHJvdG90eXBlLl9yZXN1bHRDYW5jZWxsZWQgPSBmdW5jdGlvbigpIHtcbiAgICBpZiAodGhpcy5feWllbGRlZFByb21pc2UgaW5zdGFuY2VvZiBQcm9taXNlKSB7XG4gICAgICAgIHZhciBwcm9taXNlID0gdGhpcy5feWllbGRlZFByb21pc2U7XG4gICAgICAgIHRoaXMuX3lpZWxkZWRQcm9taXNlID0gbnVsbDtcbiAgICAgICAgcHJvbWlzZS5jYW5jZWwoKTtcbiAgICB9XG59O1xuXG5Qcm9taXNlU3Bhd24ucHJvdG90eXBlLnByb21pc2UgPSBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3Byb21pc2U7XG59O1xuXG5Qcm9taXNlU3Bhd24ucHJvdG90eXBlLl9ydW4gPSBmdW5jdGlvbiAoKSB7XG4gICAgdGhpcy5fZ2VuZXJhdG9yID0gdGhpcy5fZ2VuZXJhdG9yRnVuY3Rpb24uY2FsbCh0aGlzLl9yZWNlaXZlcik7XG4gICAgdGhpcy5fcmVjZWl2ZXIgPVxuICAgICAgICB0aGlzLl9nZW5lcmF0b3JGdW5jdGlvbiA9IHVuZGVmaW5lZDtcbiAgICB0aGlzLl9wcm9taXNlRnVsZmlsbGVkKHVuZGVmaW5lZCk7XG59O1xuXG5Qcm9taXNlU3Bhd24ucHJvdG90eXBlLl9jb250aW51ZSA9IGZ1bmN0aW9uIChyZXN1bHQpIHtcbiAgICB2YXIgcHJvbWlzZSA9IHRoaXMuX3Byb21pc2U7XG4gICAgaWYgKHJlc3VsdCA9PT0gZXJyb3JPYmopIHtcbiAgICAgICAgdGhpcy5fY2xlYW51cCgpO1xuICAgICAgICByZXR1cm4gcHJvbWlzZS5fcmVqZWN0Q2FsbGJhY2socmVzdWx0LmUsIGZhbHNlKTtcbiAgICB9XG5cbiAgICB2YXIgdmFsdWUgPSByZXN1bHQudmFsdWU7XG4gICAgaWYgKHJlc3VsdC5kb25lID09PSB0cnVlKSB7XG4gICAgICAgIHRoaXMuX2NsZWFudXAoKTtcbiAgICAgICAgcmV0dXJuIHByb21pc2UuX3Jlc29sdmVDYWxsYmFjayh2YWx1ZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgdmFyIG1heWJlUHJvbWlzZSA9IHRyeUNvbnZlcnRUb1Byb21pc2UodmFsdWUsIHRoaXMuX3Byb21pc2UpO1xuICAgICAgICBpZiAoIShtYXliZVByb21pc2UgaW5zdGFuY2VvZiBQcm9taXNlKSkge1xuICAgICAgICAgICAgbWF5YmVQcm9taXNlID1cbiAgICAgICAgICAgICAgICBwcm9taXNlRnJvbVlpZWxkSGFuZGxlcihtYXliZVByb21pc2UsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5feWllbGRIYW5kbGVycyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9wcm9taXNlKTtcbiAgICAgICAgICAgIGlmIChtYXliZVByb21pc2UgPT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9wcm9taXNlUmVqZWN0ZWQoXG4gICAgICAgICAgICAgICAgICAgIG5ldyBUeXBlRXJyb3IoXG4gICAgICAgICAgICAgICAgICAgICAgICBcIkEgdmFsdWUgJXMgd2FzIHlpZWxkZWQgdGhhdCBjb3VsZCBub3QgYmUgdHJlYXRlZCBhcyBhIHByb21pc2VcXHUwMDBhXFx1MDAwYSAgICBTZWUgaHR0cDovL2dvby5nbC9NcXJGbVhcXHUwMDBhXFx1MDAwYVwiLnJlcGxhY2UoXCIlc1wiLCB2YWx1ZSkgK1xuICAgICAgICAgICAgICAgICAgICAgICAgXCJGcm9tIGNvcm91dGluZTpcXHUwMDBhXCIgK1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fc3RhY2suc3BsaXQoXCJcXG5cIikuc2xpY2UoMSwgLTcpLmpvaW4oXCJcXG5cIilcbiAgICAgICAgICAgICAgICAgICAgKVxuICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIG1heWJlUHJvbWlzZSA9IG1heWJlUHJvbWlzZS5fdGFyZ2V0KCk7XG4gICAgICAgIHZhciBiaXRGaWVsZCA9IG1heWJlUHJvbWlzZS5fYml0RmllbGQ7XG4gICAgICAgIDtcbiAgICAgICAgaWYgKCgoYml0RmllbGQgJiA1MDM5NzE4NCkgPT09IDApKSB7XG4gICAgICAgICAgICB0aGlzLl95aWVsZGVkUHJvbWlzZSA9IG1heWJlUHJvbWlzZTtcbiAgICAgICAgICAgIG1heWJlUHJvbWlzZS5fcHJveHkodGhpcywgbnVsbCk7XG4gICAgICAgIH0gZWxzZSBpZiAoKChiaXRGaWVsZCAmIDMzNTU0NDMyKSAhPT0gMCkpIHtcbiAgICAgICAgICAgIHRoaXMuX3Byb21pc2VGdWxmaWxsZWQobWF5YmVQcm9taXNlLl92YWx1ZSgpKTtcbiAgICAgICAgfSBlbHNlIGlmICgoKGJpdEZpZWxkICYgMTY3NzcyMTYpICE9PSAwKSkge1xuICAgICAgICAgICAgdGhpcy5fcHJvbWlzZVJlamVjdGVkKG1heWJlUHJvbWlzZS5fcmVhc29uKCkpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5fcHJvbWlzZUNhbmNlbGxlZCgpO1xuICAgICAgICB9XG4gICAgfVxufTtcblxuUHJvbWlzZS5jb3JvdXRpbmUgPSBmdW5jdGlvbiAoZ2VuZXJhdG9yRnVuY3Rpb24sIG9wdGlvbnMpIHtcbiAgICBpZiAodHlwZW9mIGdlbmVyYXRvckZ1bmN0aW9uICE9PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcImdlbmVyYXRvckZ1bmN0aW9uIG11c3QgYmUgYSBmdW5jdGlvblxcdTAwMGFcXHUwMDBhICAgIFNlZSBodHRwOi8vZ29vLmdsL01xckZtWFxcdTAwMGFcIik7XG4gICAgfVxuICAgIHZhciB5aWVsZEhhbmRsZXIgPSBPYmplY3Qob3B0aW9ucykueWllbGRIYW5kbGVyO1xuICAgIHZhciBQcm9taXNlU3Bhd24kID0gUHJvbWlzZVNwYXduO1xuICAgIHZhciBzdGFjayA9IG5ldyBFcnJvcigpLnN0YWNrO1xuICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBnZW5lcmF0b3IgPSBnZW5lcmF0b3JGdW5jdGlvbi5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgICB2YXIgc3Bhd24gPSBuZXcgUHJvbWlzZVNwYXduJCh1bmRlZmluZWQsIHVuZGVmaW5lZCwgeWllbGRIYW5kbGVyLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdGFjayk7XG4gICAgICAgIHZhciByZXQgPSBzcGF3bi5wcm9taXNlKCk7XG4gICAgICAgIHNwYXduLl9nZW5lcmF0b3IgPSBnZW5lcmF0b3I7XG4gICAgICAgIHNwYXduLl9wcm9taXNlRnVsZmlsbGVkKHVuZGVmaW5lZCk7XG4gICAgICAgIHJldHVybiByZXQ7XG4gICAgfTtcbn07XG5cblByb21pc2UuY29yb3V0aW5lLmFkZFlpZWxkSGFuZGxlciA9IGZ1bmN0aW9uKGZuKSB7XG4gICAgaWYgKHR5cGVvZiBmbiAhPT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJleHBlY3RpbmcgYSBmdW5jdGlvbiBidXQgZ290IFwiICsgdXRpbC5jbGFzc1N0cmluZyhmbikpO1xuICAgIH1cbiAgICB5aWVsZEhhbmRsZXJzLnB1c2goZm4pO1xufTtcblxuUHJvbWlzZS5zcGF3biA9IGZ1bmN0aW9uIChnZW5lcmF0b3JGdW5jdGlvbikge1xuICAgIGRlYnVnLmRlcHJlY2F0ZWQoXCJQcm9taXNlLnNwYXduKClcIiwgXCJQcm9taXNlLmNvcm91dGluZSgpXCIpO1xuICAgIGlmICh0eXBlb2YgZ2VuZXJhdG9yRnVuY3Rpb24gIT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICByZXR1cm4gYXBpUmVqZWN0aW9uKFwiZ2VuZXJhdG9yRnVuY3Rpb24gbXVzdCBiZSBhIGZ1bmN0aW9uXFx1MDAwYVxcdTAwMGEgICAgU2VlIGh0dHA6Ly9nb28uZ2wvTXFyRm1YXFx1MDAwYVwiKTtcbiAgICB9XG4gICAgdmFyIHNwYXduID0gbmV3IFByb21pc2VTcGF3bihnZW5lcmF0b3JGdW5jdGlvbiwgdGhpcyk7XG4gICAgdmFyIHJldCA9IHNwYXduLnByb21pc2UoKTtcbiAgICBzcGF3bi5fcnVuKFByb21pc2Uuc3Bhd24pO1xuICAgIHJldHVybiByZXQ7XG59O1xufTtcblxufSx7XCIuL2Vycm9yc1wiOjEyLFwiLi91dGlsXCI6MzZ9XSwxNzpbZnVuY3Rpb24oX2RlcmVxXyxtb2R1bGUsZXhwb3J0cyl7XG5cInVzZSBzdHJpY3RcIjtcbm1vZHVsZS5leHBvcnRzID1cbmZ1bmN0aW9uKFByb21pc2UsIFByb21pc2VBcnJheSwgdHJ5Q29udmVydFRvUHJvbWlzZSwgSU5URVJOQUwpIHtcbnZhciB1dGlsID0gX2RlcmVxXyhcIi4vdXRpbFwiKTtcbnZhciBjYW5FdmFsdWF0ZSA9IHV0aWwuY2FuRXZhbHVhdGU7XG52YXIgdHJ5Q2F0Y2ggPSB1dGlsLnRyeUNhdGNoO1xudmFyIGVycm9yT2JqID0gdXRpbC5lcnJvck9iajtcbnZhciByZWplY3Q7XG5cbmlmICghdHJ1ZSkge1xuaWYgKGNhbkV2YWx1YXRlKSB7XG4gICAgdmFyIHRoZW5DYWxsYmFjayA9IGZ1bmN0aW9uKGkpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBGdW5jdGlvbihcInZhbHVlXCIsIFwiaG9sZGVyXCIsIFwiICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcXG5cXFxuICAgICAgICAgICAgJ3VzZSBzdHJpY3QnOyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcXG5cXFxuICAgICAgICAgICAgaG9sZGVyLnBJbmRleCA9IHZhbHVlOyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcXG5cXFxuICAgICAgICAgICAgaG9sZGVyLmNoZWNrRnVsZmlsbG1lbnQodGhpcyk7ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcXG5cXFxuICAgICAgICAgICAgXCIucmVwbGFjZSgvSW5kZXgvZywgaSkpO1xuICAgIH07XG5cbiAgICB2YXIgcHJvbWlzZVNldHRlciA9IGZ1bmN0aW9uKGkpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBGdW5jdGlvbihcInByb21pc2VcIiwgXCJob2xkZXJcIiwgXCIgICAgICAgICAgICAgICAgICAgICAgICAgICBcXG5cXFxuICAgICAgICAgICAgJ3VzZSBzdHJpY3QnOyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcXG5cXFxuICAgICAgICAgICAgaG9sZGVyLnBJbmRleCA9IHByb21pc2U7ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcXG5cXFxuICAgICAgICAgICAgXCIucmVwbGFjZSgvSW5kZXgvZywgaSkpO1xuICAgIH07XG5cbiAgICB2YXIgZ2VuZXJhdGVIb2xkZXJDbGFzcyA9IGZ1bmN0aW9uKHRvdGFsKSB7XG4gICAgICAgIHZhciBwcm9wcyA9IG5ldyBBcnJheSh0b3RhbCk7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcHJvcHMubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgICAgIHByb3BzW2ldID0gXCJ0aGlzLnBcIiArIChpKzEpO1xuICAgICAgICB9XG4gICAgICAgIHZhciBhc3NpZ25tZW50ID0gcHJvcHMuam9pbihcIiA9IFwiKSArIFwiID0gbnVsbDtcIjtcbiAgICAgICAgdmFyIGNhbmNlbGxhdGlvbkNvZGU9IFwidmFyIHByb21pc2U7XFxuXCIgKyBwcm9wcy5tYXAoZnVuY3Rpb24ocHJvcCkge1xuICAgICAgICAgICAgcmV0dXJuIFwiICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXFxuXFxcbiAgICAgICAgICAgICAgICBwcm9taXNlID0gXCIgKyBwcm9wICsgXCI7ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcXG5cXFxuICAgICAgICAgICAgICAgIGlmIChwcm9taXNlIGluc3RhbmNlb2YgUHJvbWlzZSkgeyAgICAgICAgICAgICAgICAgICAgICAgICAgICBcXG5cXFxuICAgICAgICAgICAgICAgICAgICBwcm9taXNlLmNhbmNlbCgpOyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcXG5cXFxuICAgICAgICAgICAgICAgIH0gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcXG5cXFxuICAgICAgICAgICAgXCI7XG4gICAgICAgIH0pLmpvaW4oXCJcXG5cIik7XG4gICAgICAgIHZhciBwYXNzZWRBcmd1bWVudHMgPSBwcm9wcy5qb2luKFwiLCBcIik7XG4gICAgICAgIHZhciBuYW1lID0gXCJIb2xkZXIkXCIgKyB0b3RhbDtcblxuXG4gICAgICAgIHZhciBjb2RlID0gXCJyZXR1cm4gZnVuY3Rpb24odHJ5Q2F0Y2gsIGVycm9yT2JqLCBQcm9taXNlKSB7ICAgICAgICAgICBcXG5cXFxuICAgICAgICAgICAgJ3VzZSBzdHJpY3QnOyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcXG5cXFxuICAgICAgICAgICAgZnVuY3Rpb24gW1RoZU5hbWVdKGZuKSB7ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcXG5cXFxuICAgICAgICAgICAgICAgIFtUaGVQcm9wZXJ0aWVzXSAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcXG5cXFxuICAgICAgICAgICAgICAgIHRoaXMuZm4gPSBmbjsgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcXG5cXFxuICAgICAgICAgICAgICAgIHRoaXMubm93ID0gMDsgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcXG5cXFxuICAgICAgICAgICAgfSAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcXG5cXFxuICAgICAgICAgICAgW1RoZU5hbWVdLnByb3RvdHlwZS5jaGVja0Z1bGZpbGxtZW50ID0gZnVuY3Rpb24ocHJvbWlzZSkgeyAgICAgICBcXG5cXFxuICAgICAgICAgICAgICAgIHZhciBub3cgPSArK3RoaXMubm93OyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcXG5cXFxuICAgICAgICAgICAgICAgIGlmIChub3cgPT09IFtUaGVUb3RhbF0pIHsgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcXG5cXFxuICAgICAgICAgICAgICAgICAgICBwcm9taXNlLl9wdXNoQ29udGV4dCgpOyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcXG5cXFxuICAgICAgICAgICAgICAgICAgICB2YXIgY2FsbGJhY2sgPSB0aGlzLmZuOyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcXG5cXFxuICAgICAgICAgICAgICAgICAgICB2YXIgcmV0ID0gdHJ5Q2F0Y2goY2FsbGJhY2spKFtUaGVQYXNzZWRBcmd1bWVudHNdKTsgICAgICBcXG5cXFxuICAgICAgICAgICAgICAgICAgICBwcm9taXNlLl9wb3BDb250ZXh0KCk7ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcXG5cXFxuICAgICAgICAgICAgICAgICAgICBpZiAocmV0ID09PSBlcnJvck9iaikgeyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcXG5cXFxuICAgICAgICAgICAgICAgICAgICAgICAgcHJvbWlzZS5fcmVqZWN0Q2FsbGJhY2socmV0LmUsIGZhbHNlKTsgICAgICAgICAgICAgICBcXG5cXFxuICAgICAgICAgICAgICAgICAgICB9IGVsc2UgeyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcXG5cXFxuICAgICAgICAgICAgICAgICAgICAgICAgcHJvbWlzZS5fcmVzb2x2ZUNhbGxiYWNrKHJldCk7ICAgICAgICAgICAgICAgICAgICAgICBcXG5cXFxuICAgICAgICAgICAgICAgICAgICB9ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcXG5cXFxuICAgICAgICAgICAgICAgIH0gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcXG5cXFxuICAgICAgICAgICAgfTsgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcXG5cXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcXG5cXFxuICAgICAgICAgICAgW1RoZU5hbWVdLnByb3RvdHlwZS5fcmVzdWx0Q2FuY2VsbGVkID0gZnVuY3Rpb24oKSB7ICAgICAgICAgICAgICBcXG5cXFxuICAgICAgICAgICAgICAgIFtDYW5jZWxsYXRpb25Db2RlXSAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcXG5cXFxuICAgICAgICAgICAgfTsgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcXG5cXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcXG5cXFxuICAgICAgICAgICAgcmV0dXJuIFtUaGVOYW1lXTsgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcXG5cXFxuICAgICAgICB9KHRyeUNhdGNoLCBlcnJvck9iaiwgUHJvbWlzZSk7ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcXG5cXFxuICAgICAgICBcIjtcblxuICAgICAgICBjb2RlID0gY29kZS5yZXBsYWNlKC9cXFtUaGVOYW1lXFxdL2csIG5hbWUpXG4gICAgICAgICAgICAucmVwbGFjZSgvXFxbVGhlVG90YWxcXF0vZywgdG90YWwpXG4gICAgICAgICAgICAucmVwbGFjZSgvXFxbVGhlUGFzc2VkQXJndW1lbnRzXFxdL2csIHBhc3NlZEFyZ3VtZW50cylcbiAgICAgICAgICAgIC5yZXBsYWNlKC9cXFtUaGVQcm9wZXJ0aWVzXFxdL2csIGFzc2lnbm1lbnQpXG4gICAgICAgICAgICAucmVwbGFjZSgvXFxbQ2FuY2VsbGF0aW9uQ29kZVxcXS9nLCBjYW5jZWxsYXRpb25Db2RlKTtcblxuICAgICAgICByZXR1cm4gbmV3IEZ1bmN0aW9uKFwidHJ5Q2F0Y2hcIiwgXCJlcnJvck9ialwiLCBcIlByb21pc2VcIiwgY29kZSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICh0cnlDYXRjaCwgZXJyb3JPYmosIFByb21pc2UpO1xuICAgIH07XG5cbiAgICB2YXIgaG9sZGVyQ2xhc3NlcyA9IFtdO1xuICAgIHZhciB0aGVuQ2FsbGJhY2tzID0gW107XG4gICAgdmFyIHByb21pc2VTZXR0ZXJzID0gW107XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IDg7ICsraSkge1xuICAgICAgICBob2xkZXJDbGFzc2VzLnB1c2goZ2VuZXJhdGVIb2xkZXJDbGFzcyhpICsgMSkpO1xuICAgICAgICB0aGVuQ2FsbGJhY2tzLnB1c2godGhlbkNhbGxiYWNrKGkgKyAxKSk7XG4gICAgICAgIHByb21pc2VTZXR0ZXJzLnB1c2gocHJvbWlzZVNldHRlcihpICsgMSkpO1xuICAgIH1cblxuICAgIHJlamVjdCA9IGZ1bmN0aW9uIChyZWFzb24pIHtcbiAgICAgICAgdGhpcy5fcmVqZWN0KHJlYXNvbik7XG4gICAgfTtcbn19XG5cblByb21pc2Uuam9pbiA9IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgbGFzdCA9IGFyZ3VtZW50cy5sZW5ndGggLSAxO1xuICAgIHZhciBmbjtcbiAgICBpZiAobGFzdCA+IDAgJiYgdHlwZW9mIGFyZ3VtZW50c1tsYXN0XSA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgIGZuID0gYXJndW1lbnRzW2xhc3RdO1xuICAgICAgICBpZiAoIXRydWUpIHtcbiAgICAgICAgICAgIGlmIChsYXN0IDw9IDggJiYgY2FuRXZhbHVhdGUpIHtcbiAgICAgICAgICAgICAgICB2YXIgcmV0ID0gbmV3IFByb21pc2UoSU5URVJOQUwpO1xuICAgICAgICAgICAgICAgIHJldC5fY2FwdHVyZVN0YWNrVHJhY2UoKTtcbiAgICAgICAgICAgICAgICB2YXIgSG9sZGVyQ2xhc3MgPSBob2xkZXJDbGFzc2VzW2xhc3QgLSAxXTtcbiAgICAgICAgICAgICAgICB2YXIgaG9sZGVyID0gbmV3IEhvbGRlckNsYXNzKGZuKTtcbiAgICAgICAgICAgICAgICB2YXIgY2FsbGJhY2tzID0gdGhlbkNhbGxiYWNrcztcblxuICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGFzdDsgKytpKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBtYXliZVByb21pc2UgPSB0cnlDb252ZXJ0VG9Qcm9taXNlKGFyZ3VtZW50c1tpXSwgcmV0KTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKG1heWJlUHJvbWlzZSBpbnN0YW5jZW9mIFByb21pc2UpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG1heWJlUHJvbWlzZSA9IG1heWJlUHJvbWlzZS5fdGFyZ2V0KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgYml0RmllbGQgPSBtYXliZVByb21pc2UuX2JpdEZpZWxkO1xuICAgICAgICAgICAgICAgICAgICAgICAgO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCgoYml0RmllbGQgJiA1MDM5NzE4NCkgPT09IDApKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbWF5YmVQcm9taXNlLl90aGVuKGNhbGxiYWNrc1tpXSwgcmVqZWN0LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB1bmRlZmluZWQsIHJldCwgaG9sZGVyKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBwcm9taXNlU2V0dGVyc1tpXShtYXliZVByb21pc2UsIGhvbGRlcik7XG4gICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKCgoYml0RmllbGQgJiAzMzU1NDQzMikgIT09IDApKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FsbGJhY2tzW2ldLmNhbGwocmV0LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1heWJlUHJvbWlzZS5fdmFsdWUoKSwgaG9sZGVyKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoKChiaXRGaWVsZCAmIDE2Nzc3MjE2KSAhPT0gMCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXQuX3JlamVjdChtYXliZVByb21pc2UuX3JlYXNvbigpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0Ll9jYW5jZWwoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhbGxiYWNrc1tpXS5jYWxsKHJldCwgbWF5YmVQcm9taXNlLCBob2xkZXIpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmICghcmV0Ll9pc0ZhdGVTZWFsZWQoKSkge1xuICAgICAgICAgICAgICAgICAgICByZXQuX3NldEFzeW5jR3VhcmFudGVlZCgpO1xuICAgICAgICAgICAgICAgICAgICByZXQuX3NldE9uQ2FuY2VsKGhvbGRlcik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiByZXQ7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgdmFyIGFyZ3MgPSBbXS5zbGljZS5jYWxsKGFyZ3VtZW50cyk7O1xuICAgIGlmIChmbikgYXJncy5wb3AoKTtcbiAgICB2YXIgcmV0ID0gbmV3IFByb21pc2VBcnJheShhcmdzKS5wcm9taXNlKCk7XG4gICAgcmV0dXJuIGZuICE9PSB1bmRlZmluZWQgPyByZXQuc3ByZWFkKGZuKSA6IHJldDtcbn07XG5cbn07XG5cbn0se1wiLi91dGlsXCI6MzZ9XSwxODpbZnVuY3Rpb24oX2RlcmVxXyxtb2R1bGUsZXhwb3J0cyl7XG5cInVzZSBzdHJpY3RcIjtcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oUHJvbWlzZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgUHJvbWlzZUFycmF5LFxuICAgICAgICAgICAgICAgICAgICAgICAgICBhcGlSZWplY3Rpb24sXG4gICAgICAgICAgICAgICAgICAgICAgICAgIHRyeUNvbnZlcnRUb1Byb21pc2UsXG4gICAgICAgICAgICAgICAgICAgICAgICAgIElOVEVSTkFMLFxuICAgICAgICAgICAgICAgICAgICAgICAgICBkZWJ1Zykge1xudmFyIGdldERvbWFpbiA9IFByb21pc2UuX2dldERvbWFpbjtcbnZhciB1dGlsID0gX2RlcmVxXyhcIi4vdXRpbFwiKTtcbnZhciB0cnlDYXRjaCA9IHV0aWwudHJ5Q2F0Y2g7XG52YXIgZXJyb3JPYmogPSB1dGlsLmVycm9yT2JqO1xudmFyIEVNUFRZX0FSUkFZID0gW107XG5cbmZ1bmN0aW9uIE1hcHBpbmdQcm9taXNlQXJyYXkocHJvbWlzZXMsIGZuLCBsaW1pdCwgX2ZpbHRlcikge1xuICAgIHRoaXMuY29uc3RydWN0b3IkKHByb21pc2VzKTtcbiAgICB0aGlzLl9wcm9taXNlLl9jYXB0dXJlU3RhY2tUcmFjZSgpO1xuICAgIHZhciBkb21haW4gPSBnZXREb21haW4oKTtcbiAgICB0aGlzLl9jYWxsYmFjayA9IGRvbWFpbiA9PT0gbnVsbCA/IGZuIDogZG9tYWluLmJpbmQoZm4pO1xuICAgIHRoaXMuX3ByZXNlcnZlZFZhbHVlcyA9IF9maWx0ZXIgPT09IElOVEVSTkFMXG4gICAgICAgID8gbmV3IEFycmF5KHRoaXMubGVuZ3RoKCkpXG4gICAgICAgIDogbnVsbDtcbiAgICB0aGlzLl9saW1pdCA9IGxpbWl0O1xuICAgIHRoaXMuX2luRmxpZ2h0ID0gMDtcbiAgICB0aGlzLl9xdWV1ZSA9IGxpbWl0ID49IDEgPyBbXSA6IEVNUFRZX0FSUkFZO1xuICAgIHRoaXMuX2luaXQkKHVuZGVmaW5lZCwgLTIpO1xufVxudXRpbC5pbmhlcml0cyhNYXBwaW5nUHJvbWlzZUFycmF5LCBQcm9taXNlQXJyYXkpO1xuXG5NYXBwaW5nUHJvbWlzZUFycmF5LnByb3RvdHlwZS5faW5pdCA9IGZ1bmN0aW9uICgpIHt9O1xuXG5NYXBwaW5nUHJvbWlzZUFycmF5LnByb3RvdHlwZS5fcHJvbWlzZUZ1bGZpbGxlZCA9IGZ1bmN0aW9uICh2YWx1ZSwgaW5kZXgpIHtcbiAgICB2YXIgdmFsdWVzID0gdGhpcy5fdmFsdWVzO1xuICAgIHZhciBsZW5ndGggPSB0aGlzLmxlbmd0aCgpO1xuICAgIHZhciBwcmVzZXJ2ZWRWYWx1ZXMgPSB0aGlzLl9wcmVzZXJ2ZWRWYWx1ZXM7XG4gICAgdmFyIGxpbWl0ID0gdGhpcy5fbGltaXQ7XG5cbiAgICBpZiAoaW5kZXggPCAwKSB7XG4gICAgICAgIGluZGV4ID0gKGluZGV4ICogLTEpIC0gMTtcbiAgICAgICAgdmFsdWVzW2luZGV4XSA9IHZhbHVlO1xuICAgICAgICBpZiAobGltaXQgPj0gMSkge1xuICAgICAgICAgICAgdGhpcy5faW5GbGlnaHQtLTtcbiAgICAgICAgICAgIHRoaXMuX2RyYWluUXVldWUoKTtcbiAgICAgICAgICAgIGlmICh0aGlzLl9pc1Jlc29sdmVkKCkpIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgICAgaWYgKGxpbWl0ID49IDEgJiYgdGhpcy5faW5GbGlnaHQgPj0gbGltaXQpIHtcbiAgICAgICAgICAgIHZhbHVlc1tpbmRleF0gPSB2YWx1ZTtcbiAgICAgICAgICAgIHRoaXMuX3F1ZXVlLnB1c2goaW5kZXgpO1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIGlmIChwcmVzZXJ2ZWRWYWx1ZXMgIT09IG51bGwpIHByZXNlcnZlZFZhbHVlc1tpbmRleF0gPSB2YWx1ZTtcblxuICAgICAgICB2YXIgcHJvbWlzZSA9IHRoaXMuX3Byb21pc2U7XG4gICAgICAgIHZhciBjYWxsYmFjayA9IHRoaXMuX2NhbGxiYWNrO1xuICAgICAgICB2YXIgcmVjZWl2ZXIgPSBwcm9taXNlLl9ib3VuZFZhbHVlKCk7XG4gICAgICAgIHByb21pc2UuX3B1c2hDb250ZXh0KCk7XG4gICAgICAgIHZhciByZXQgPSB0cnlDYXRjaChjYWxsYmFjaykuY2FsbChyZWNlaXZlciwgdmFsdWUsIGluZGV4LCBsZW5ndGgpO1xuICAgICAgICB2YXIgcHJvbWlzZUNyZWF0ZWQgPSBwcm9taXNlLl9wb3BDb250ZXh0KCk7XG4gICAgICAgIGRlYnVnLmNoZWNrRm9yZ290dGVuUmV0dXJucyhcbiAgICAgICAgICAgIHJldCxcbiAgICAgICAgICAgIHByb21pc2VDcmVhdGVkLFxuICAgICAgICAgICAgcHJlc2VydmVkVmFsdWVzICE9PSBudWxsID8gXCJQcm9taXNlLmZpbHRlclwiIDogXCJQcm9taXNlLm1hcFwiLFxuICAgICAgICAgICAgcHJvbWlzZVxuICAgICAgICApO1xuICAgICAgICBpZiAocmV0ID09PSBlcnJvck9iaikge1xuICAgICAgICAgICAgdGhpcy5fcmVqZWN0KHJldC5lKTtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIG1heWJlUHJvbWlzZSA9IHRyeUNvbnZlcnRUb1Byb21pc2UocmV0LCB0aGlzLl9wcm9taXNlKTtcbiAgICAgICAgaWYgKG1heWJlUHJvbWlzZSBpbnN0YW5jZW9mIFByb21pc2UpIHtcbiAgICAgICAgICAgIG1heWJlUHJvbWlzZSA9IG1heWJlUHJvbWlzZS5fdGFyZ2V0KCk7XG4gICAgICAgICAgICB2YXIgYml0RmllbGQgPSBtYXliZVByb21pc2UuX2JpdEZpZWxkO1xuICAgICAgICAgICAgO1xuICAgICAgICAgICAgaWYgKCgoYml0RmllbGQgJiA1MDM5NzE4NCkgPT09IDApKSB7XG4gICAgICAgICAgICAgICAgaWYgKGxpbWl0ID49IDEpIHRoaXMuX2luRmxpZ2h0Kys7XG4gICAgICAgICAgICAgICAgdmFsdWVzW2luZGV4XSA9IG1heWJlUHJvbWlzZTtcbiAgICAgICAgICAgICAgICBtYXliZVByb21pc2UuX3Byb3h5KHRoaXMsIChpbmRleCArIDEpICogLTEpO1xuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoKChiaXRGaWVsZCAmIDMzNTU0NDMyKSAhPT0gMCkpIHtcbiAgICAgICAgICAgICAgICByZXQgPSBtYXliZVByb21pc2UuX3ZhbHVlKCk7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKCgoYml0RmllbGQgJiAxNjc3NzIxNikgIT09IDApKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fcmVqZWN0KG1heWJlUHJvbWlzZS5fcmVhc29uKCkpO1xuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9jYW5jZWwoKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB2YWx1ZXNbaW5kZXhdID0gcmV0O1xuICAgIH1cbiAgICB2YXIgdG90YWxSZXNvbHZlZCA9ICsrdGhpcy5fdG90YWxSZXNvbHZlZDtcbiAgICBpZiAodG90YWxSZXNvbHZlZCA+PSBsZW5ndGgpIHtcbiAgICAgICAgaWYgKHByZXNlcnZlZFZhbHVlcyAhPT0gbnVsbCkge1xuICAgICAgICAgICAgdGhpcy5fZmlsdGVyKHZhbHVlcywgcHJlc2VydmVkVmFsdWVzKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuX3Jlc29sdmUodmFsdWVzKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlO1xufTtcblxuTWFwcGluZ1Byb21pc2VBcnJheS5wcm90b3R5cGUuX2RyYWluUXVldWUgPSBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIHF1ZXVlID0gdGhpcy5fcXVldWU7XG4gICAgdmFyIGxpbWl0ID0gdGhpcy5fbGltaXQ7XG4gICAgdmFyIHZhbHVlcyA9IHRoaXMuX3ZhbHVlcztcbiAgICB3aGlsZSAocXVldWUubGVuZ3RoID4gMCAmJiB0aGlzLl9pbkZsaWdodCA8IGxpbWl0KSB7XG4gICAgICAgIGlmICh0aGlzLl9pc1Jlc29sdmVkKCkpIHJldHVybjtcbiAgICAgICAgdmFyIGluZGV4ID0gcXVldWUucG9wKCk7XG4gICAgICAgIHRoaXMuX3Byb21pc2VGdWxmaWxsZWQodmFsdWVzW2luZGV4XSwgaW5kZXgpO1xuICAgIH1cbn07XG5cbk1hcHBpbmdQcm9taXNlQXJyYXkucHJvdG90eXBlLl9maWx0ZXIgPSBmdW5jdGlvbiAoYm9vbGVhbnMsIHZhbHVlcykge1xuICAgIHZhciBsZW4gPSB2YWx1ZXMubGVuZ3RoO1xuICAgIHZhciByZXQgPSBuZXcgQXJyYXkobGVuKTtcbiAgICB2YXIgaiA9IDA7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW47ICsraSkge1xuICAgICAgICBpZiAoYm9vbGVhbnNbaV0pIHJldFtqKytdID0gdmFsdWVzW2ldO1xuICAgIH1cbiAgICByZXQubGVuZ3RoID0gajtcbiAgICB0aGlzLl9yZXNvbHZlKHJldCk7XG59O1xuXG5NYXBwaW5nUHJvbWlzZUFycmF5LnByb3RvdHlwZS5wcmVzZXJ2ZWRWYWx1ZXMgPSBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3ByZXNlcnZlZFZhbHVlcztcbn07XG5cbmZ1bmN0aW9uIG1hcChwcm9taXNlcywgZm4sIG9wdGlvbnMsIF9maWx0ZXIpIHtcbiAgICBpZiAodHlwZW9mIGZuICE9PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgcmV0dXJuIGFwaVJlamVjdGlvbihcImV4cGVjdGluZyBhIGZ1bmN0aW9uIGJ1dCBnb3QgXCIgKyB1dGlsLmNsYXNzU3RyaW5nKGZuKSk7XG4gICAgfVxuICAgIHZhciBsaW1pdCA9IHR5cGVvZiBvcHRpb25zID09PSBcIm9iamVjdFwiICYmIG9wdGlvbnMgIT09IG51bGxcbiAgICAgICAgPyBvcHRpb25zLmNvbmN1cnJlbmN5XG4gICAgICAgIDogMDtcbiAgICBsaW1pdCA9IHR5cGVvZiBsaW1pdCA9PT0gXCJudW1iZXJcIiAmJlxuICAgICAgICBpc0Zpbml0ZShsaW1pdCkgJiYgbGltaXQgPj0gMSA/IGxpbWl0IDogMDtcbiAgICByZXR1cm4gbmV3IE1hcHBpbmdQcm9taXNlQXJyYXkocHJvbWlzZXMsIGZuLCBsaW1pdCwgX2ZpbHRlcikucHJvbWlzZSgpO1xufVxuXG5Qcm9taXNlLnByb3RvdHlwZS5tYXAgPSBmdW5jdGlvbiAoZm4sIG9wdGlvbnMpIHtcbiAgICByZXR1cm4gbWFwKHRoaXMsIGZuLCBvcHRpb25zLCBudWxsKTtcbn07XG5cblByb21pc2UubWFwID0gZnVuY3Rpb24gKHByb21pc2VzLCBmbiwgb3B0aW9ucywgX2ZpbHRlcikge1xuICAgIHJldHVybiBtYXAocHJvbWlzZXMsIGZuLCBvcHRpb25zLCBfZmlsdGVyKTtcbn07XG5cblxufTtcblxufSx7XCIuL3V0aWxcIjozNn1dLDE5OltmdW5jdGlvbihfZGVyZXFfLG1vZHVsZSxleHBvcnRzKXtcblwidXNlIHN0cmljdFwiO1xubW9kdWxlLmV4cG9ydHMgPVxuZnVuY3Rpb24oUHJvbWlzZSwgSU5URVJOQUwsIHRyeUNvbnZlcnRUb1Byb21pc2UsIGFwaVJlamVjdGlvbiwgZGVidWcpIHtcbnZhciB1dGlsID0gX2RlcmVxXyhcIi4vdXRpbFwiKTtcbnZhciB0cnlDYXRjaCA9IHV0aWwudHJ5Q2F0Y2g7XG5cblByb21pc2UubWV0aG9kID0gZnVuY3Rpb24gKGZuKSB7XG4gICAgaWYgKHR5cGVvZiBmbiAhPT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgIHRocm93IG5ldyBQcm9taXNlLlR5cGVFcnJvcihcImV4cGVjdGluZyBhIGZ1bmN0aW9uIGJ1dCBnb3QgXCIgKyB1dGlsLmNsYXNzU3RyaW5nKGZuKSk7XG4gICAgfVxuICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciByZXQgPSBuZXcgUHJvbWlzZShJTlRFUk5BTCk7XG4gICAgICAgIHJldC5fY2FwdHVyZVN0YWNrVHJhY2UoKTtcbiAgICAgICAgcmV0Ll9wdXNoQ29udGV4dCgpO1xuICAgICAgICB2YXIgdmFsdWUgPSB0cnlDYXRjaChmbikuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgICAgdmFyIHByb21pc2VDcmVhdGVkID0gcmV0Ll9wb3BDb250ZXh0KCk7XG4gICAgICAgIGRlYnVnLmNoZWNrRm9yZ290dGVuUmV0dXJucyhcbiAgICAgICAgICAgIHZhbHVlLCBwcm9taXNlQ3JlYXRlZCwgXCJQcm9taXNlLm1ldGhvZFwiLCByZXQpO1xuICAgICAgICByZXQuX3Jlc29sdmVGcm9tU3luY1ZhbHVlKHZhbHVlKTtcbiAgICAgICAgcmV0dXJuIHJldDtcbiAgICB9O1xufTtcblxuUHJvbWlzZS5hdHRlbXB0ID0gUHJvbWlzZVtcInRyeVwiXSA9IGZ1bmN0aW9uIChmbikge1xuICAgIGlmICh0eXBlb2YgZm4gIT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICByZXR1cm4gYXBpUmVqZWN0aW9uKFwiZXhwZWN0aW5nIGEgZnVuY3Rpb24gYnV0IGdvdCBcIiArIHV0aWwuY2xhc3NTdHJpbmcoZm4pKTtcbiAgICB9XG4gICAgdmFyIHJldCA9IG5ldyBQcm9taXNlKElOVEVSTkFMKTtcbiAgICByZXQuX2NhcHR1cmVTdGFja1RyYWNlKCk7XG4gICAgcmV0Ll9wdXNoQ29udGV4dCgpO1xuICAgIHZhciB2YWx1ZTtcbiAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA+IDEpIHtcbiAgICAgICAgZGVidWcuZGVwcmVjYXRlZChcImNhbGxpbmcgUHJvbWlzZS50cnkgd2l0aCBtb3JlIHRoYW4gMSBhcmd1bWVudFwiKTtcbiAgICAgICAgdmFyIGFyZyA9IGFyZ3VtZW50c1sxXTtcbiAgICAgICAgdmFyIGN0eCA9IGFyZ3VtZW50c1syXTtcbiAgICAgICAgdmFsdWUgPSB1dGlsLmlzQXJyYXkoYXJnKSA/IHRyeUNhdGNoKGZuKS5hcHBseShjdHgsIGFyZylcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA6IHRyeUNhdGNoKGZuKS5jYWxsKGN0eCwgYXJnKTtcbiAgICB9IGVsc2Uge1xuICAgICAgICB2YWx1ZSA9IHRyeUNhdGNoKGZuKSgpO1xuICAgIH1cbiAgICB2YXIgcHJvbWlzZUNyZWF0ZWQgPSByZXQuX3BvcENvbnRleHQoKTtcbiAgICBkZWJ1Zy5jaGVja0ZvcmdvdHRlblJldHVybnMoXG4gICAgICAgIHZhbHVlLCBwcm9taXNlQ3JlYXRlZCwgXCJQcm9taXNlLnRyeVwiLCByZXQpO1xuICAgIHJldC5fcmVzb2x2ZUZyb21TeW5jVmFsdWUodmFsdWUpO1xuICAgIHJldHVybiByZXQ7XG59O1xuXG5Qcm9taXNlLnByb3RvdHlwZS5fcmVzb2x2ZUZyb21TeW5jVmFsdWUgPSBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICBpZiAodmFsdWUgPT09IHV0aWwuZXJyb3JPYmopIHtcbiAgICAgICAgdGhpcy5fcmVqZWN0Q2FsbGJhY2sodmFsdWUuZSwgZmFsc2UpO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMuX3Jlc29sdmVDYWxsYmFjayh2YWx1ZSwgdHJ1ZSk7XG4gICAgfVxufTtcbn07XG5cbn0se1wiLi91dGlsXCI6MzZ9XSwyMDpbZnVuY3Rpb24oX2RlcmVxXyxtb2R1bGUsZXhwb3J0cyl7XG5cInVzZSBzdHJpY3RcIjtcbnZhciB1dGlsID0gX2RlcmVxXyhcIi4vdXRpbFwiKTtcbnZhciBtYXliZVdyYXBBc0Vycm9yID0gdXRpbC5tYXliZVdyYXBBc0Vycm9yO1xudmFyIGVycm9ycyA9IF9kZXJlcV8oXCIuL2Vycm9yc1wiKTtcbnZhciBPcGVyYXRpb25hbEVycm9yID0gZXJyb3JzLk9wZXJhdGlvbmFsRXJyb3I7XG52YXIgZXM1ID0gX2RlcmVxXyhcIi4vZXM1XCIpO1xuXG5mdW5jdGlvbiBpc1VudHlwZWRFcnJvcihvYmopIHtcbiAgICByZXR1cm4gb2JqIGluc3RhbmNlb2YgRXJyb3IgJiZcbiAgICAgICAgZXM1LmdldFByb3RvdHlwZU9mKG9iaikgPT09IEVycm9yLnByb3RvdHlwZTtcbn1cblxudmFyIHJFcnJvcktleSA9IC9eKD86bmFtZXxtZXNzYWdlfHN0YWNrfGNhdXNlKSQvO1xuZnVuY3Rpb24gd3JhcEFzT3BlcmF0aW9uYWxFcnJvcihvYmopIHtcbiAgICB2YXIgcmV0O1xuICAgIGlmIChpc1VudHlwZWRFcnJvcihvYmopKSB7XG4gICAgICAgIHJldCA9IG5ldyBPcGVyYXRpb25hbEVycm9yKG9iaik7XG4gICAgICAgIHJldC5uYW1lID0gb2JqLm5hbWU7XG4gICAgICAgIHJldC5tZXNzYWdlID0gb2JqLm1lc3NhZ2U7XG4gICAgICAgIHJldC5zdGFjayA9IG9iai5zdGFjaztcbiAgICAgICAgdmFyIGtleXMgPSBlczUua2V5cyhvYmopO1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGtleXMubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgICAgIHZhciBrZXkgPSBrZXlzW2ldO1xuICAgICAgICAgICAgaWYgKCFyRXJyb3JLZXkudGVzdChrZXkpKSB7XG4gICAgICAgICAgICAgICAgcmV0W2tleV0gPSBvYmpba2V5XTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmV0O1xuICAgIH1cbiAgICB1dGlsLm1hcmtBc09yaWdpbmF0aW5nRnJvbVJlamVjdGlvbihvYmopO1xuICAgIHJldHVybiBvYmo7XG59XG5cbmZ1bmN0aW9uIG5vZGViYWNrRm9yUHJvbWlzZShwcm9taXNlLCBtdWx0aUFyZ3MpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24oZXJyLCB2YWx1ZSkge1xuICAgICAgICBpZiAocHJvbWlzZSA9PT0gbnVsbCkgcmV0dXJuO1xuICAgICAgICBpZiAoZXJyKSB7XG4gICAgICAgICAgICB2YXIgd3JhcHBlZCA9IHdyYXBBc09wZXJhdGlvbmFsRXJyb3IobWF5YmVXcmFwQXNFcnJvcihlcnIpKTtcbiAgICAgICAgICAgIHByb21pc2UuX2F0dGFjaEV4dHJhVHJhY2Uod3JhcHBlZCk7XG4gICAgICAgICAgICBwcm9taXNlLl9yZWplY3Qod3JhcHBlZCk7XG4gICAgICAgIH0gZWxzZSBpZiAoIW11bHRpQXJncykge1xuICAgICAgICAgICAgcHJvbWlzZS5fZnVsZmlsbCh2YWx1ZSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB2YXIgYXJncyA9IFtdLnNsaWNlLmNhbGwoYXJndW1lbnRzLCAxKTs7XG4gICAgICAgICAgICBwcm9taXNlLl9mdWxmaWxsKGFyZ3MpO1xuICAgICAgICB9XG4gICAgICAgIHByb21pc2UgPSBudWxsO1xuICAgIH07XG59XG5cbm1vZHVsZS5leHBvcnRzID0gbm9kZWJhY2tGb3JQcm9taXNlO1xuXG59LHtcIi4vZXJyb3JzXCI6MTIsXCIuL2VzNVwiOjEzLFwiLi91dGlsXCI6MzZ9XSwyMTpbZnVuY3Rpb24oX2RlcmVxXyxtb2R1bGUsZXhwb3J0cyl7XG5cInVzZSBzdHJpY3RcIjtcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oUHJvbWlzZSkge1xudmFyIHV0aWwgPSBfZGVyZXFfKFwiLi91dGlsXCIpO1xudmFyIGFzeW5jID0gUHJvbWlzZS5fYXN5bmM7XG52YXIgdHJ5Q2F0Y2ggPSB1dGlsLnRyeUNhdGNoO1xudmFyIGVycm9yT2JqID0gdXRpbC5lcnJvck9iajtcblxuZnVuY3Rpb24gc3ByZWFkQWRhcHRlcih2YWwsIG5vZGViYWNrKSB7XG4gICAgdmFyIHByb21pc2UgPSB0aGlzO1xuICAgIGlmICghdXRpbC5pc0FycmF5KHZhbCkpIHJldHVybiBzdWNjZXNzQWRhcHRlci5jYWxsKHByb21pc2UsIHZhbCwgbm9kZWJhY2spO1xuICAgIHZhciByZXQgPVxuICAgICAgICB0cnlDYXRjaChub2RlYmFjaykuYXBwbHkocHJvbWlzZS5fYm91bmRWYWx1ZSgpLCBbbnVsbF0uY29uY2F0KHZhbCkpO1xuICAgIGlmIChyZXQgPT09IGVycm9yT2JqKSB7XG4gICAgICAgIGFzeW5jLnRocm93TGF0ZXIocmV0LmUpO1xuICAgIH1cbn1cblxuZnVuY3Rpb24gc3VjY2Vzc0FkYXB0ZXIodmFsLCBub2RlYmFjaykge1xuICAgIHZhciBwcm9taXNlID0gdGhpcztcbiAgICB2YXIgcmVjZWl2ZXIgPSBwcm9taXNlLl9ib3VuZFZhbHVlKCk7XG4gICAgdmFyIHJldCA9IHZhbCA9PT0gdW5kZWZpbmVkXG4gICAgICAgID8gdHJ5Q2F0Y2gobm9kZWJhY2spLmNhbGwocmVjZWl2ZXIsIG51bGwpXG4gICAgICAgIDogdHJ5Q2F0Y2gobm9kZWJhY2spLmNhbGwocmVjZWl2ZXIsIG51bGwsIHZhbCk7XG4gICAgaWYgKHJldCA9PT0gZXJyb3JPYmopIHtcbiAgICAgICAgYXN5bmMudGhyb3dMYXRlcihyZXQuZSk7XG4gICAgfVxufVxuZnVuY3Rpb24gZXJyb3JBZGFwdGVyKHJlYXNvbiwgbm9kZWJhY2spIHtcbiAgICB2YXIgcHJvbWlzZSA9IHRoaXM7XG4gICAgaWYgKCFyZWFzb24pIHtcbiAgICAgICAgdmFyIG5ld1JlYXNvbiA9IG5ldyBFcnJvcihyZWFzb24gKyBcIlwiKTtcbiAgICAgICAgbmV3UmVhc29uLmNhdXNlID0gcmVhc29uO1xuICAgICAgICByZWFzb24gPSBuZXdSZWFzb247XG4gICAgfVxuICAgIHZhciByZXQgPSB0cnlDYXRjaChub2RlYmFjaykuY2FsbChwcm9taXNlLl9ib3VuZFZhbHVlKCksIHJlYXNvbik7XG4gICAgaWYgKHJldCA9PT0gZXJyb3JPYmopIHtcbiAgICAgICAgYXN5bmMudGhyb3dMYXRlcihyZXQuZSk7XG4gICAgfVxufVxuXG5Qcm9taXNlLnByb3RvdHlwZS5hc0NhbGxiYWNrID0gUHJvbWlzZS5wcm90b3R5cGUubm9kZWlmeSA9IGZ1bmN0aW9uIChub2RlYmFjayxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9wdGlvbnMpIHtcbiAgICBpZiAodHlwZW9mIG5vZGViYWNrID09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICB2YXIgYWRhcHRlciA9IHN1Y2Nlc3NBZGFwdGVyO1xuICAgICAgICBpZiAob3B0aW9ucyAhPT0gdW5kZWZpbmVkICYmIE9iamVjdChvcHRpb25zKS5zcHJlYWQpIHtcbiAgICAgICAgICAgIGFkYXB0ZXIgPSBzcHJlYWRBZGFwdGVyO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX3RoZW4oXG4gICAgICAgICAgICBhZGFwdGVyLFxuICAgICAgICAgICAgZXJyb3JBZGFwdGVyLFxuICAgICAgICAgICAgdW5kZWZpbmVkLFxuICAgICAgICAgICAgdGhpcyxcbiAgICAgICAgICAgIG5vZGViYWNrXG4gICAgICAgICk7XG4gICAgfVxuICAgIHJldHVybiB0aGlzO1xufTtcbn07XG5cbn0se1wiLi91dGlsXCI6MzZ9XSwyMjpbZnVuY3Rpb24oX2RlcmVxXyxtb2R1bGUsZXhwb3J0cyl7XG5cInVzZSBzdHJpY3RcIjtcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oKSB7XG52YXIgbWFrZVNlbGZSZXNvbHV0aW9uRXJyb3IgPSBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIG5ldyBUeXBlRXJyb3IoXCJjaXJjdWxhciBwcm9taXNlIHJlc29sdXRpb24gY2hhaW5cXHUwMDBhXFx1MDAwYSAgICBTZWUgaHR0cDovL2dvby5nbC9NcXJGbVhcXHUwMDBhXCIpO1xufTtcbnZhciByZWZsZWN0SGFuZGxlciA9IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiBuZXcgUHJvbWlzZS5Qcm9taXNlSW5zcGVjdGlvbih0aGlzLl90YXJnZXQoKSk7XG59O1xudmFyIGFwaVJlamVjdGlvbiA9IGZ1bmN0aW9uKG1zZykge1xuICAgIHJldHVybiBQcm9taXNlLnJlamVjdChuZXcgVHlwZUVycm9yKG1zZykpO1xufTtcbmZ1bmN0aW9uIFByb3h5YWJsZSgpIHt9XG52YXIgVU5ERUZJTkVEX0JJTkRJTkcgPSB7fTtcbnZhciB1dGlsID0gX2RlcmVxXyhcIi4vdXRpbFwiKTtcblxudmFyIGdldERvbWFpbjtcbmlmICh1dGlsLmlzTm9kZSkge1xuICAgIGdldERvbWFpbiA9IGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgcmV0ID0gcHJvY2Vzcy5kb21haW47XG4gICAgICAgIGlmIChyZXQgPT09IHVuZGVmaW5lZCkgcmV0ID0gbnVsbDtcbiAgICAgICAgcmV0dXJuIHJldDtcbiAgICB9O1xufSBlbHNlIHtcbiAgICBnZXREb21haW4gPSBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfTtcbn1cbnV0aWwubm90RW51bWVyYWJsZVByb3AoUHJvbWlzZSwgXCJfZ2V0RG9tYWluXCIsIGdldERvbWFpbik7XG5cbnZhciBlczUgPSBfZGVyZXFfKFwiLi9lczVcIik7XG52YXIgQXN5bmMgPSBfZGVyZXFfKFwiLi9hc3luY1wiKTtcbnZhciBhc3luYyA9IG5ldyBBc3luYygpO1xuZXM1LmRlZmluZVByb3BlcnR5KFByb21pc2UsIFwiX2FzeW5jXCIsIHt2YWx1ZTogYXN5bmN9KTtcbnZhciBlcnJvcnMgPSBfZGVyZXFfKFwiLi9lcnJvcnNcIik7XG52YXIgVHlwZUVycm9yID0gUHJvbWlzZS5UeXBlRXJyb3IgPSBlcnJvcnMuVHlwZUVycm9yO1xuUHJvbWlzZS5SYW5nZUVycm9yID0gZXJyb3JzLlJhbmdlRXJyb3I7XG52YXIgQ2FuY2VsbGF0aW9uRXJyb3IgPSBQcm9taXNlLkNhbmNlbGxhdGlvbkVycm9yID0gZXJyb3JzLkNhbmNlbGxhdGlvbkVycm9yO1xuUHJvbWlzZS5UaW1lb3V0RXJyb3IgPSBlcnJvcnMuVGltZW91dEVycm9yO1xuUHJvbWlzZS5PcGVyYXRpb25hbEVycm9yID0gZXJyb3JzLk9wZXJhdGlvbmFsRXJyb3I7XG5Qcm9taXNlLlJlamVjdGlvbkVycm9yID0gZXJyb3JzLk9wZXJhdGlvbmFsRXJyb3I7XG5Qcm9taXNlLkFnZ3JlZ2F0ZUVycm9yID0gZXJyb3JzLkFnZ3JlZ2F0ZUVycm9yO1xudmFyIElOVEVSTkFMID0gZnVuY3Rpb24oKXt9O1xudmFyIEFQUExZID0ge307XG52YXIgTkVYVF9GSUxURVIgPSB7fTtcbnZhciB0cnlDb252ZXJ0VG9Qcm9taXNlID0gX2RlcmVxXyhcIi4vdGhlbmFibGVzXCIpKFByb21pc2UsIElOVEVSTkFMKTtcbnZhciBQcm9taXNlQXJyYXkgPVxuICAgIF9kZXJlcV8oXCIuL3Byb21pc2VfYXJyYXlcIikoUHJvbWlzZSwgSU5URVJOQUwsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdHJ5Q29udmVydFRvUHJvbWlzZSwgYXBpUmVqZWN0aW9uLCBQcm94eWFibGUpO1xudmFyIENvbnRleHQgPSBfZGVyZXFfKFwiLi9jb250ZXh0XCIpKFByb21pc2UpO1xuIC8qanNoaW50IHVudXNlZDpmYWxzZSovXG52YXIgY3JlYXRlQ29udGV4dCA9IENvbnRleHQuY3JlYXRlO1xudmFyIGRlYnVnID0gX2RlcmVxXyhcIi4vZGVidWdnYWJpbGl0eVwiKShQcm9taXNlLCBDb250ZXh0KTtcbnZhciBDYXB0dXJlZFRyYWNlID0gZGVidWcuQ2FwdHVyZWRUcmFjZTtcbnZhciBmaW5hbGx5SGFuZGxlciA9IF9kZXJlcV8oXCIuL2ZpbmFsbHlcIikoUHJvbWlzZSwgdHJ5Q29udmVydFRvUHJvbWlzZSk7XG52YXIgY2F0Y2hGaWx0ZXIgPSBfZGVyZXFfKFwiLi9jYXRjaF9maWx0ZXJcIikoTkVYVF9GSUxURVIpO1xudmFyIG5vZGViYWNrRm9yUHJvbWlzZSA9IF9kZXJlcV8oXCIuL25vZGViYWNrXCIpO1xudmFyIGVycm9yT2JqID0gdXRpbC5lcnJvck9iajtcbnZhciB0cnlDYXRjaCA9IHV0aWwudHJ5Q2F0Y2g7XG5mdW5jdGlvbiBjaGVjayhzZWxmLCBleGVjdXRvcikge1xuICAgIGlmICh0eXBlb2YgZXhlY3V0b3IgIT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiZXhwZWN0aW5nIGEgZnVuY3Rpb24gYnV0IGdvdCBcIiArIHV0aWwuY2xhc3NTdHJpbmcoZXhlY3V0b3IpKTtcbiAgICB9XG4gICAgaWYgKHNlbGYuY29uc3RydWN0b3IgIT09IFByb21pc2UpIHtcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcInRoZSBwcm9taXNlIGNvbnN0cnVjdG9yIGNhbm5vdCBiZSBpbnZva2VkIGRpcmVjdGx5XFx1MDAwYVxcdTAwMGEgICAgU2VlIGh0dHA6Ly9nb28uZ2wvTXFyRm1YXFx1MDAwYVwiKTtcbiAgICB9XG59XG5cbmZ1bmN0aW9uIFByb21pc2UoZXhlY3V0b3IpIHtcbiAgICB0aGlzLl9iaXRGaWVsZCA9IDA7XG4gICAgdGhpcy5fZnVsZmlsbG1lbnRIYW5kbGVyMCA9IHVuZGVmaW5lZDtcbiAgICB0aGlzLl9yZWplY3Rpb25IYW5kbGVyMCA9IHVuZGVmaW5lZDtcbiAgICB0aGlzLl9wcm9taXNlMCA9IHVuZGVmaW5lZDtcbiAgICB0aGlzLl9yZWNlaXZlcjAgPSB1bmRlZmluZWQ7XG4gICAgaWYgKGV4ZWN1dG9yICE9PSBJTlRFUk5BTCkge1xuICAgICAgICBjaGVjayh0aGlzLCBleGVjdXRvcik7XG4gICAgICAgIHRoaXMuX3Jlc29sdmVGcm9tRXhlY3V0b3IoZXhlY3V0b3IpO1xuICAgIH1cbiAgICB0aGlzLl9wcm9taXNlQ3JlYXRlZCgpO1xufVxuXG5Qcm9taXNlLnByb3RvdHlwZS50b1N0cmluZyA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gXCJbb2JqZWN0IFByb21pc2VdXCI7XG59O1xuXG5Qcm9taXNlLnByb3RvdHlwZS5jYXVnaHQgPSBQcm9taXNlLnByb3RvdHlwZVtcImNhdGNoXCJdID0gZnVuY3Rpb24gKGZuKSB7XG4gICAgdmFyIGxlbiA9IGFyZ3VtZW50cy5sZW5ndGg7XG4gICAgaWYgKGxlbiA+IDEpIHtcbiAgICAgICAgdmFyIGNhdGNoSW5zdGFuY2VzID0gbmV3IEFycmF5KGxlbiAtIDEpLFxuICAgICAgICAgICAgaiA9IDAsIGk7XG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCBsZW4gLSAxOyArK2kpIHtcbiAgICAgICAgICAgIHZhciBpdGVtID0gYXJndW1lbnRzW2ldO1xuICAgICAgICAgICAgaWYgKHV0aWwuaXNPYmplY3QoaXRlbSkpIHtcbiAgICAgICAgICAgICAgICBjYXRjaEluc3RhbmNlc1tqKytdID0gaXRlbTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGFwaVJlamVjdGlvbihcImV4cGVjdGluZyBhbiBvYmplY3QgYnV0IGdvdCBcIiArIHV0aWwuY2xhc3NTdHJpbmcoaXRlbSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGNhdGNoSW5zdGFuY2VzLmxlbmd0aCA9IGo7XG4gICAgICAgIGZuID0gYXJndW1lbnRzW2ldO1xuICAgICAgICByZXR1cm4gdGhpcy50aGVuKHVuZGVmaW5lZCwgY2F0Y2hGaWx0ZXIoY2F0Y2hJbnN0YW5jZXMsIGZuLCB0aGlzKSk7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLnRoZW4odW5kZWZpbmVkLCBmbik7XG59O1xuXG5Qcm9taXNlLnByb3RvdHlwZS5yZWZsZWN0ID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiB0aGlzLl90aGVuKHJlZmxlY3RIYW5kbGVyLFxuICAgICAgICByZWZsZWN0SGFuZGxlciwgdW5kZWZpbmVkLCB0aGlzLCB1bmRlZmluZWQpO1xufTtcblxuUHJvbWlzZS5wcm90b3R5cGUudGhlbiA9IGZ1bmN0aW9uIChkaWRGdWxmaWxsLCBkaWRSZWplY3QpIHtcbiAgICBpZiAoZGVidWcud2FybmluZ3MoKSAmJiBhcmd1bWVudHMubGVuZ3RoID4gMCAmJlxuICAgICAgICB0eXBlb2YgZGlkRnVsZmlsbCAhPT0gXCJmdW5jdGlvblwiICYmXG4gICAgICAgIHR5cGVvZiBkaWRSZWplY3QgIT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICB2YXIgbXNnID0gXCIudGhlbigpIG9ubHkgYWNjZXB0cyBmdW5jdGlvbnMgYnV0IHdhcyBwYXNzZWQ6IFwiICtcbiAgICAgICAgICAgICAgICB1dGlsLmNsYXNzU3RyaW5nKGRpZEZ1bGZpbGwpO1xuICAgICAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA+IDEpIHtcbiAgICAgICAgICAgIG1zZyArPSBcIiwgXCIgKyB1dGlsLmNsYXNzU3RyaW5nKGRpZFJlamVjdCk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fd2Fybihtc2cpO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5fdGhlbihkaWRGdWxmaWxsLCBkaWRSZWplY3QsIHVuZGVmaW5lZCwgdW5kZWZpbmVkLCB1bmRlZmluZWQpO1xufTtcblxuUHJvbWlzZS5wcm90b3R5cGUuZG9uZSA9IGZ1bmN0aW9uIChkaWRGdWxmaWxsLCBkaWRSZWplY3QpIHtcbiAgICB2YXIgcHJvbWlzZSA9XG4gICAgICAgIHRoaXMuX3RoZW4oZGlkRnVsZmlsbCwgZGlkUmVqZWN0LCB1bmRlZmluZWQsIHVuZGVmaW5lZCwgdW5kZWZpbmVkKTtcbiAgICBwcm9taXNlLl9zZXRJc0ZpbmFsKCk7XG59O1xuXG5Qcm9taXNlLnByb3RvdHlwZS5zcHJlYWQgPSBmdW5jdGlvbiAoZm4pIHtcbiAgICBpZiAodHlwZW9mIGZuICE9PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgcmV0dXJuIGFwaVJlamVjdGlvbihcImV4cGVjdGluZyBhIGZ1bmN0aW9uIGJ1dCBnb3QgXCIgKyB1dGlsLmNsYXNzU3RyaW5nKGZuKSk7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLmFsbCgpLl90aGVuKGZuLCB1bmRlZmluZWQsIHVuZGVmaW5lZCwgQVBQTFksIHVuZGVmaW5lZCk7XG59O1xuXG5Qcm9taXNlLnByb3RvdHlwZS50b0pTT04gPSBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIHJldCA9IHtcbiAgICAgICAgaXNGdWxmaWxsZWQ6IGZhbHNlLFxuICAgICAgICBpc1JlamVjdGVkOiBmYWxzZSxcbiAgICAgICAgZnVsZmlsbG1lbnRWYWx1ZTogdW5kZWZpbmVkLFxuICAgICAgICByZWplY3Rpb25SZWFzb246IHVuZGVmaW5lZFxuICAgIH07XG4gICAgaWYgKHRoaXMuaXNGdWxmaWxsZWQoKSkge1xuICAgICAgICByZXQuZnVsZmlsbG1lbnRWYWx1ZSA9IHRoaXMudmFsdWUoKTtcbiAgICAgICAgcmV0LmlzRnVsZmlsbGVkID0gdHJ1ZTtcbiAgICB9IGVsc2UgaWYgKHRoaXMuaXNSZWplY3RlZCgpKSB7XG4gICAgICAgIHJldC5yZWplY3Rpb25SZWFzb24gPSB0aGlzLnJlYXNvbigpO1xuICAgICAgICByZXQuaXNSZWplY3RlZCA9IHRydWU7XG4gICAgfVxuICAgIHJldHVybiByZXQ7XG59O1xuXG5Qcm9taXNlLnByb3RvdHlwZS5hbGwgPSBmdW5jdGlvbiAoKSB7XG4gICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPiAwKSB7XG4gICAgICAgIHRoaXMuX3dhcm4oXCIuYWxsKCkgd2FzIHBhc3NlZCBhcmd1bWVudHMgYnV0IGl0IGRvZXMgbm90IHRha2UgYW55XCIpO1xuICAgIH1cbiAgICByZXR1cm4gbmV3IFByb21pc2VBcnJheSh0aGlzKS5wcm9taXNlKCk7XG59O1xuXG5Qcm9taXNlLnByb3RvdHlwZS5lcnJvciA9IGZ1bmN0aW9uIChmbikge1xuICAgIHJldHVybiB0aGlzLmNhdWdodCh1dGlsLm9yaWdpbmF0ZXNGcm9tUmVqZWN0aW9uLCBmbik7XG59O1xuXG5Qcm9taXNlLmlzID0gZnVuY3Rpb24gKHZhbCkge1xuICAgIHJldHVybiB2YWwgaW5zdGFuY2VvZiBQcm9taXNlO1xufTtcblxuUHJvbWlzZS5mcm9tTm9kZSA9IFByb21pc2UuZnJvbUNhbGxiYWNrID0gZnVuY3Rpb24oZm4pIHtcbiAgICB2YXIgcmV0ID0gbmV3IFByb21pc2UoSU5URVJOQUwpO1xuICAgIHZhciBtdWx0aUFyZ3MgPSBhcmd1bWVudHMubGVuZ3RoID4gMSA/ICEhT2JqZWN0KGFyZ3VtZW50c1sxXSkubXVsdGlBcmdzXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDogZmFsc2U7XG4gICAgdmFyIHJlc3VsdCA9IHRyeUNhdGNoKGZuKShub2RlYmFja0ZvclByb21pc2UocmV0LCBtdWx0aUFyZ3MpKTtcbiAgICBpZiAocmVzdWx0ID09PSBlcnJvck9iaikge1xuICAgICAgICByZXQuX3JlamVjdENhbGxiYWNrKHJlc3VsdC5lLCB0cnVlKTtcbiAgICB9XG4gICAgaWYgKCFyZXQuX2lzRmF0ZVNlYWxlZCgpKSByZXQuX3NldEFzeW5jR3VhcmFudGVlZCgpO1xuICAgIHJldHVybiByZXQ7XG59O1xuXG5Qcm9taXNlLmFsbCA9IGZ1bmN0aW9uIChwcm9taXNlcykge1xuICAgIHJldHVybiBuZXcgUHJvbWlzZUFycmF5KHByb21pc2VzKS5wcm9taXNlKCk7XG59O1xuXG5Qcm9taXNlLmNhc3QgPSBmdW5jdGlvbiAob2JqKSB7XG4gICAgdmFyIHJldCA9IHRyeUNvbnZlcnRUb1Byb21pc2Uob2JqKTtcbiAgICBpZiAoIShyZXQgaW5zdGFuY2VvZiBQcm9taXNlKSkge1xuICAgICAgICByZXQgPSBuZXcgUHJvbWlzZShJTlRFUk5BTCk7XG4gICAgICAgIHJldC5fY2FwdHVyZVN0YWNrVHJhY2UoKTtcbiAgICAgICAgcmV0Ll9zZXRGdWxmaWxsZWQoKTtcbiAgICAgICAgcmV0Ll9yZWplY3Rpb25IYW5kbGVyMCA9IG9iajtcbiAgICB9XG4gICAgcmV0dXJuIHJldDtcbn07XG5cblByb21pc2UucmVzb2x2ZSA9IFByb21pc2UuZnVsZmlsbGVkID0gUHJvbWlzZS5jYXN0O1xuXG5Qcm9taXNlLnJlamVjdCA9IFByb21pc2UucmVqZWN0ZWQgPSBmdW5jdGlvbiAocmVhc29uKSB7XG4gICAgdmFyIHJldCA9IG5ldyBQcm9taXNlKElOVEVSTkFMKTtcbiAgICByZXQuX2NhcHR1cmVTdGFja1RyYWNlKCk7XG4gICAgcmV0Ll9yZWplY3RDYWxsYmFjayhyZWFzb24sIHRydWUpO1xuICAgIHJldHVybiByZXQ7XG59O1xuXG5Qcm9taXNlLnNldFNjaGVkdWxlciA9IGZ1bmN0aW9uKGZuKSB7XG4gICAgaWYgKHR5cGVvZiBmbiAhPT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJleHBlY3RpbmcgYSBmdW5jdGlvbiBidXQgZ290IFwiICsgdXRpbC5jbGFzc1N0cmluZyhmbikpO1xuICAgIH1cbiAgICB2YXIgcHJldiA9IGFzeW5jLl9zY2hlZHVsZTtcbiAgICBhc3luYy5fc2NoZWR1bGUgPSBmbjtcbiAgICByZXR1cm4gcHJldjtcbn07XG5cblByb21pc2UucHJvdG90eXBlLl90aGVuID0gZnVuY3Rpb24gKFxuICAgIGRpZEZ1bGZpbGwsXG4gICAgZGlkUmVqZWN0LFxuICAgIF8sICAgIHJlY2VpdmVyLFxuICAgIGludGVybmFsRGF0YVxuKSB7XG4gICAgdmFyIGhhdmVJbnRlcm5hbERhdGEgPSBpbnRlcm5hbERhdGEgIT09IHVuZGVmaW5lZDtcbiAgICB2YXIgcHJvbWlzZSA9IGhhdmVJbnRlcm5hbERhdGEgPyBpbnRlcm5hbERhdGEgOiBuZXcgUHJvbWlzZShJTlRFUk5BTCk7XG4gICAgdmFyIHRhcmdldCA9IHRoaXMuX3RhcmdldCgpO1xuICAgIHZhciBiaXRGaWVsZCA9IHRhcmdldC5fYml0RmllbGQ7XG5cbiAgICBpZiAoIWhhdmVJbnRlcm5hbERhdGEpIHtcbiAgICAgICAgcHJvbWlzZS5fcHJvcGFnYXRlRnJvbSh0aGlzLCAzKTtcbiAgICAgICAgcHJvbWlzZS5fY2FwdHVyZVN0YWNrVHJhY2UoKTtcbiAgICAgICAgaWYgKHJlY2VpdmVyID09PSB1bmRlZmluZWQgJiZcbiAgICAgICAgICAgICgodGhpcy5fYml0RmllbGQgJiAyMDk3MTUyKSAhPT0gMCkpIHtcbiAgICAgICAgICAgIGlmICghKChiaXRGaWVsZCAmIDUwMzk3MTg0KSA9PT0gMCkpIHtcbiAgICAgICAgICAgICAgICByZWNlaXZlciA9IHRoaXMuX2JvdW5kVmFsdWUoKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgcmVjZWl2ZXIgPSB0YXJnZXQgPT09IHRoaXMgPyB1bmRlZmluZWQgOiB0aGlzLl9ib3VuZFRvO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgdmFyIGRvbWFpbiA9IGdldERvbWFpbigpO1xuICAgIGlmICghKChiaXRGaWVsZCAmIDUwMzk3MTg0KSA9PT0gMCkpIHtcbiAgICAgICAgdmFyIGhhbmRsZXIsIHZhbHVlLCBzZXR0bGVyID0gdGFyZ2V0Ll9zZXR0bGVQcm9taXNlQ3R4O1xuICAgICAgICBpZiAoKChiaXRGaWVsZCAmIDMzNTU0NDMyKSAhPT0gMCkpIHtcbiAgICAgICAgICAgIHZhbHVlID0gdGFyZ2V0Ll9yZWplY3Rpb25IYW5kbGVyMDtcbiAgICAgICAgICAgIGhhbmRsZXIgPSBkaWRGdWxmaWxsO1xuICAgICAgICB9IGVsc2UgaWYgKCgoYml0RmllbGQgJiAxNjc3NzIxNikgIT09IDApKSB7XG4gICAgICAgICAgICB2YWx1ZSA9IHRhcmdldC5fZnVsZmlsbG1lbnRIYW5kbGVyMDtcbiAgICAgICAgICAgIGhhbmRsZXIgPSBkaWRSZWplY3Q7XG4gICAgICAgICAgICB0YXJnZXQuX3Vuc2V0UmVqZWN0aW9uSXNVbmhhbmRsZWQoKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHNldHRsZXIgPSB0YXJnZXQuX3NldHRsZVByb21pc2VMYXRlQ2FuY2VsbGF0aW9uT2JzZXJ2ZXI7XG4gICAgICAgICAgICB2YWx1ZSA9IG5ldyBDYW5jZWxsYXRpb25FcnJvcihcImxhdGUgY2FuY2VsbGF0aW9uIG9ic2VydmVyXCIpO1xuICAgICAgICAgICAgdGFyZ2V0Ll9hdHRhY2hFeHRyYVRyYWNlKHZhbHVlKTtcbiAgICAgICAgICAgIGhhbmRsZXIgPSBkaWRSZWplY3Q7XG4gICAgICAgIH1cblxuICAgICAgICBhc3luYy5pbnZva2Uoc2V0dGxlciwgdGFyZ2V0LCB7XG4gICAgICAgICAgICBoYW5kbGVyOiBkb21haW4gPT09IG51bGwgPyBoYW5kbGVyXG4gICAgICAgICAgICAgICAgOiAodHlwZW9mIGhhbmRsZXIgPT09IFwiZnVuY3Rpb25cIiAmJiBkb21haW4uYmluZChoYW5kbGVyKSksXG4gICAgICAgICAgICBwcm9taXNlOiBwcm9taXNlLFxuICAgICAgICAgICAgcmVjZWl2ZXI6IHJlY2VpdmVyLFxuICAgICAgICAgICAgdmFsdWU6IHZhbHVlXG4gICAgICAgIH0pO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHRhcmdldC5fYWRkQ2FsbGJhY2tzKGRpZEZ1bGZpbGwsIGRpZFJlamVjdCwgcHJvbWlzZSwgcmVjZWl2ZXIsIGRvbWFpbik7XG4gICAgfVxuXG4gICAgcmV0dXJuIHByb21pc2U7XG59O1xuXG5Qcm9taXNlLnByb3RvdHlwZS5fbGVuZ3RoID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiB0aGlzLl9iaXRGaWVsZCAmIDY1NTM1O1xufTtcblxuUHJvbWlzZS5wcm90b3R5cGUuX2lzRmF0ZVNlYWxlZCA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gKHRoaXMuX2JpdEZpZWxkICYgMTE3NTA2MDQ4KSAhPT0gMDtcbn07XG5cblByb21pc2UucHJvdG90eXBlLl9pc0ZvbGxvd2luZyA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gKHRoaXMuX2JpdEZpZWxkICYgNjcxMDg4NjQpID09PSA2NzEwODg2NDtcbn07XG5cblByb21pc2UucHJvdG90eXBlLl9zZXRMZW5ndGggPSBmdW5jdGlvbiAobGVuKSB7XG4gICAgdGhpcy5fYml0RmllbGQgPSAodGhpcy5fYml0RmllbGQgJiAtNjU1MzYpIHxcbiAgICAgICAgKGxlbiAmIDY1NTM1KTtcbn07XG5cblByb21pc2UucHJvdG90eXBlLl9zZXRGdWxmaWxsZWQgPSBmdW5jdGlvbiAoKSB7XG4gICAgdGhpcy5fYml0RmllbGQgPSB0aGlzLl9iaXRGaWVsZCB8IDMzNTU0NDMyO1xufTtcblxuUHJvbWlzZS5wcm90b3R5cGUuX3NldFJlamVjdGVkID0gZnVuY3Rpb24gKCkge1xuICAgIHRoaXMuX2JpdEZpZWxkID0gdGhpcy5fYml0RmllbGQgfCAxNjc3NzIxNjtcbn07XG5cblByb21pc2UucHJvdG90eXBlLl9zZXRGb2xsb3dpbmcgPSBmdW5jdGlvbiAoKSB7XG4gICAgdGhpcy5fYml0RmllbGQgPSB0aGlzLl9iaXRGaWVsZCB8IDY3MTA4ODY0O1xufTtcblxuUHJvbWlzZS5wcm90b3R5cGUuX3NldElzRmluYWwgPSBmdW5jdGlvbiAoKSB7XG4gICAgdGhpcy5fYml0RmllbGQgPSB0aGlzLl9iaXRGaWVsZCB8IDQxOTQzMDQ7XG59O1xuXG5Qcm9taXNlLnByb3RvdHlwZS5faXNGaW5hbCA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gKHRoaXMuX2JpdEZpZWxkICYgNDE5NDMwNCkgPiAwO1xufTtcblxuUHJvbWlzZS5wcm90b3R5cGUuX3Vuc2V0Q2FuY2VsbGVkID0gZnVuY3Rpb24oKSB7XG4gICAgdGhpcy5fYml0RmllbGQgPSB0aGlzLl9iaXRGaWVsZCAmICh+NjU1MzYpO1xufTtcblxuUHJvbWlzZS5wcm90b3R5cGUuX3NldENhbmNlbGxlZCA9IGZ1bmN0aW9uKCkge1xuICAgIHRoaXMuX2JpdEZpZWxkID0gdGhpcy5fYml0RmllbGQgfCA2NTUzNjtcbn07XG5cblByb21pc2UucHJvdG90eXBlLl9zZXRBc3luY0d1YXJhbnRlZWQgPSBmdW5jdGlvbigpIHtcbiAgICB0aGlzLl9iaXRGaWVsZCA9IHRoaXMuX2JpdEZpZWxkIHwgMTM0MjE3NzI4O1xufTtcblxuUHJvbWlzZS5wcm90b3R5cGUuX3JlY2VpdmVyQXQgPSBmdW5jdGlvbiAoaW5kZXgpIHtcbiAgICB2YXIgcmV0ID0gaW5kZXggPT09IDAgPyB0aGlzLl9yZWNlaXZlcjAgOiB0aGlzW1xuICAgICAgICAgICAgaW5kZXggKiA0IC0gNCArIDNdO1xuICAgIGlmIChyZXQgPT09IFVOREVGSU5FRF9CSU5ESU5HKSB7XG4gICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgfSBlbHNlIGlmIChyZXQgPT09IHVuZGVmaW5lZCAmJiB0aGlzLl9pc0JvdW5kKCkpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2JvdW5kVmFsdWUoKTtcbiAgICB9XG4gICAgcmV0dXJuIHJldDtcbn07XG5cblByb21pc2UucHJvdG90eXBlLl9wcm9taXNlQXQgPSBmdW5jdGlvbiAoaW5kZXgpIHtcbiAgICByZXR1cm4gdGhpc1tcbiAgICAgICAgICAgIGluZGV4ICogNCAtIDQgKyAyXTtcbn07XG5cblByb21pc2UucHJvdG90eXBlLl9mdWxmaWxsbWVudEhhbmRsZXJBdCA9IGZ1bmN0aW9uIChpbmRleCkge1xuICAgIHJldHVybiB0aGlzW1xuICAgICAgICAgICAgaW5kZXggKiA0IC0gNCArIDBdO1xufTtcblxuUHJvbWlzZS5wcm90b3R5cGUuX3JlamVjdGlvbkhhbmRsZXJBdCA9IGZ1bmN0aW9uIChpbmRleCkge1xuICAgIHJldHVybiB0aGlzW1xuICAgICAgICAgICAgaW5kZXggKiA0IC0gNCArIDFdO1xufTtcblxuUHJvbWlzZS5wcm90b3R5cGUuX2JvdW5kVmFsdWUgPSBmdW5jdGlvbigpIHt9O1xuXG5Qcm9taXNlLnByb3RvdHlwZS5fbWlncmF0ZUNhbGxiYWNrMCA9IGZ1bmN0aW9uIChmb2xsb3dlcikge1xuICAgIHZhciBiaXRGaWVsZCA9IGZvbGxvd2VyLl9iaXRGaWVsZDtcbiAgICB2YXIgZnVsZmlsbCA9IGZvbGxvd2VyLl9mdWxmaWxsbWVudEhhbmRsZXIwO1xuICAgIHZhciByZWplY3QgPSBmb2xsb3dlci5fcmVqZWN0aW9uSGFuZGxlcjA7XG4gICAgdmFyIHByb21pc2UgPSBmb2xsb3dlci5fcHJvbWlzZTA7XG4gICAgdmFyIHJlY2VpdmVyID0gZm9sbG93ZXIuX3JlY2VpdmVyQXQoMCk7XG4gICAgaWYgKHJlY2VpdmVyID09PSB1bmRlZmluZWQpIHJlY2VpdmVyID0gVU5ERUZJTkVEX0JJTkRJTkc7XG4gICAgdGhpcy5fYWRkQ2FsbGJhY2tzKGZ1bGZpbGwsIHJlamVjdCwgcHJvbWlzZSwgcmVjZWl2ZXIsIG51bGwpO1xufTtcblxuUHJvbWlzZS5wcm90b3R5cGUuX21pZ3JhdGVDYWxsYmFja0F0ID0gZnVuY3Rpb24gKGZvbGxvd2VyLCBpbmRleCkge1xuICAgIHZhciBmdWxmaWxsID0gZm9sbG93ZXIuX2Z1bGZpbGxtZW50SGFuZGxlckF0KGluZGV4KTtcbiAgICB2YXIgcmVqZWN0ID0gZm9sbG93ZXIuX3JlamVjdGlvbkhhbmRsZXJBdChpbmRleCk7XG4gICAgdmFyIHByb21pc2UgPSBmb2xsb3dlci5fcHJvbWlzZUF0KGluZGV4KTtcbiAgICB2YXIgcmVjZWl2ZXIgPSBmb2xsb3dlci5fcmVjZWl2ZXJBdChpbmRleCk7XG4gICAgaWYgKHJlY2VpdmVyID09PSB1bmRlZmluZWQpIHJlY2VpdmVyID0gVU5ERUZJTkVEX0JJTkRJTkc7XG4gICAgdGhpcy5fYWRkQ2FsbGJhY2tzKGZ1bGZpbGwsIHJlamVjdCwgcHJvbWlzZSwgcmVjZWl2ZXIsIG51bGwpO1xufTtcblxuUHJvbWlzZS5wcm90b3R5cGUuX2FkZENhbGxiYWNrcyA9IGZ1bmN0aW9uIChcbiAgICBmdWxmaWxsLFxuICAgIHJlamVjdCxcbiAgICBwcm9taXNlLFxuICAgIHJlY2VpdmVyLFxuICAgIGRvbWFpblxuKSB7XG4gICAgdmFyIGluZGV4ID0gdGhpcy5fbGVuZ3RoKCk7XG5cbiAgICBpZiAoaW5kZXggPj0gNjU1MzUgLSA0KSB7XG4gICAgICAgIGluZGV4ID0gMDtcbiAgICAgICAgdGhpcy5fc2V0TGVuZ3RoKDApO1xuICAgIH1cblxuICAgIGlmIChpbmRleCA9PT0gMCkge1xuICAgICAgICB0aGlzLl9wcm9taXNlMCA9IHByb21pc2U7XG4gICAgICAgIHRoaXMuX3JlY2VpdmVyMCA9IHJlY2VpdmVyO1xuICAgICAgICBpZiAodHlwZW9mIGZ1bGZpbGwgPT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICAgICAgdGhpcy5fZnVsZmlsbG1lbnRIYW5kbGVyMCA9XG4gICAgICAgICAgICAgICAgZG9tYWluID09PSBudWxsID8gZnVsZmlsbCA6IGRvbWFpbi5iaW5kKGZ1bGZpbGwpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0eXBlb2YgcmVqZWN0ID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgICAgIHRoaXMuX3JlamVjdGlvbkhhbmRsZXIwID1cbiAgICAgICAgICAgICAgICBkb21haW4gPT09IG51bGwgPyByZWplY3QgOiBkb21haW4uYmluZChyZWplY3QpO1xuICAgICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgICAgdmFyIGJhc2UgPSBpbmRleCAqIDQgLSA0O1xuICAgICAgICB0aGlzW2Jhc2UgKyAyXSA9IHByb21pc2U7XG4gICAgICAgIHRoaXNbYmFzZSArIDNdID0gcmVjZWl2ZXI7XG4gICAgICAgIGlmICh0eXBlb2YgZnVsZmlsbCA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgICAgICB0aGlzW2Jhc2UgKyAwXSA9XG4gICAgICAgICAgICAgICAgZG9tYWluID09PSBudWxsID8gZnVsZmlsbCA6IGRvbWFpbi5iaW5kKGZ1bGZpbGwpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0eXBlb2YgcmVqZWN0ID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgICAgIHRoaXNbYmFzZSArIDFdID1cbiAgICAgICAgICAgICAgICBkb21haW4gPT09IG51bGwgPyByZWplY3QgOiBkb21haW4uYmluZChyZWplY3QpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHRoaXMuX3NldExlbmd0aChpbmRleCArIDEpO1xuICAgIHJldHVybiBpbmRleDtcbn07XG5cblByb21pc2UucHJvdG90eXBlLl9wcm94eSA9IGZ1bmN0aW9uIChwcm94eWFibGUsIGFyZykge1xuICAgIHRoaXMuX2FkZENhbGxiYWNrcyh1bmRlZmluZWQsIHVuZGVmaW5lZCwgYXJnLCBwcm94eWFibGUsIG51bGwpO1xufTtcblxuUHJvbWlzZS5wcm90b3R5cGUuX3Jlc29sdmVDYWxsYmFjayA9IGZ1bmN0aW9uKHZhbHVlLCBzaG91bGRCaW5kKSB7XG4gICAgaWYgKCgodGhpcy5fYml0RmllbGQgJiAxMTc1MDYwNDgpICE9PSAwKSkgcmV0dXJuO1xuICAgIGlmICh2YWx1ZSA9PT0gdGhpcylcbiAgICAgICAgcmV0dXJuIHRoaXMuX3JlamVjdENhbGxiYWNrKG1ha2VTZWxmUmVzb2x1dGlvbkVycm9yKCksIGZhbHNlKTtcbiAgICB2YXIgbWF5YmVQcm9taXNlID0gdHJ5Q29udmVydFRvUHJvbWlzZSh2YWx1ZSwgdGhpcyk7XG4gICAgaWYgKCEobWF5YmVQcm9taXNlIGluc3RhbmNlb2YgUHJvbWlzZSkpIHJldHVybiB0aGlzLl9mdWxmaWxsKHZhbHVlKTtcblxuICAgIGlmIChzaG91bGRCaW5kKSB0aGlzLl9wcm9wYWdhdGVGcm9tKG1heWJlUHJvbWlzZSwgMik7XG5cbiAgICB2YXIgcHJvbWlzZSA9IG1heWJlUHJvbWlzZS5fdGFyZ2V0KCk7XG4gICAgdmFyIGJpdEZpZWxkID0gcHJvbWlzZS5fYml0RmllbGQ7XG4gICAgaWYgKCgoYml0RmllbGQgJiA1MDM5NzE4NCkgPT09IDApKSB7XG4gICAgICAgIHZhciBsZW4gPSB0aGlzLl9sZW5ndGgoKTtcbiAgICAgICAgaWYgKGxlbiA+IDApIHByb21pc2UuX21pZ3JhdGVDYWxsYmFjazAodGhpcyk7XG4gICAgICAgIGZvciAodmFyIGkgPSAxOyBpIDwgbGVuOyArK2kpIHtcbiAgICAgICAgICAgIHByb21pc2UuX21pZ3JhdGVDYWxsYmFja0F0KHRoaXMsIGkpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX3NldEZvbGxvd2luZygpO1xuICAgICAgICB0aGlzLl9zZXRMZW5ndGgoMCk7XG4gICAgICAgIHRoaXMuX3NldEZvbGxvd2VlKHByb21pc2UpO1xuICAgIH0gZWxzZSBpZiAoKChiaXRGaWVsZCAmIDMzNTU0NDMyKSAhPT0gMCkpIHtcbiAgICAgICAgdGhpcy5fZnVsZmlsbChwcm9taXNlLl92YWx1ZSgpKTtcbiAgICB9IGVsc2UgaWYgKCgoYml0RmllbGQgJiAxNjc3NzIxNikgIT09IDApKSB7XG4gICAgICAgIHRoaXMuX3JlamVjdChwcm9taXNlLl9yZWFzb24oKSk7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgdmFyIHJlYXNvbiA9IG5ldyBDYW5jZWxsYXRpb25FcnJvcihcImxhdGUgY2FuY2VsbGF0aW9uIG9ic2VydmVyXCIpO1xuICAgICAgICBwcm9taXNlLl9hdHRhY2hFeHRyYVRyYWNlKHJlYXNvbik7XG4gICAgICAgIHRoaXMuX3JlamVjdChyZWFzb24pO1xuICAgIH1cbn07XG5cblByb21pc2UucHJvdG90eXBlLl9yZWplY3RDYWxsYmFjayA9XG5mdW5jdGlvbihyZWFzb24sIHN5bmNocm9ub3VzLCBpZ25vcmVOb25FcnJvcldhcm5pbmdzKSB7XG4gICAgdmFyIHRyYWNlID0gdXRpbC5lbnN1cmVFcnJvck9iamVjdChyZWFzb24pO1xuICAgIHZhciBoYXNTdGFjayA9IHRyYWNlID09PSByZWFzb247XG4gICAgaWYgKCFoYXNTdGFjayAmJiAhaWdub3JlTm9uRXJyb3JXYXJuaW5ncyAmJiBkZWJ1Zy53YXJuaW5ncygpKSB7XG4gICAgICAgIHZhciBtZXNzYWdlID0gXCJhIHByb21pc2Ugd2FzIHJlamVjdGVkIHdpdGggYSBub24tZXJyb3I6IFwiICtcbiAgICAgICAgICAgIHV0aWwuY2xhc3NTdHJpbmcocmVhc29uKTtcbiAgICAgICAgdGhpcy5fd2FybihtZXNzYWdlLCB0cnVlKTtcbiAgICB9XG4gICAgdGhpcy5fYXR0YWNoRXh0cmFUcmFjZSh0cmFjZSwgc3luY2hyb25vdXMgPyBoYXNTdGFjayA6IGZhbHNlKTtcbiAgICB0aGlzLl9yZWplY3QocmVhc29uKTtcbn07XG5cblByb21pc2UucHJvdG90eXBlLl9yZXNvbHZlRnJvbUV4ZWN1dG9yID0gZnVuY3Rpb24gKGV4ZWN1dG9yKSB7XG4gICAgdmFyIHByb21pc2UgPSB0aGlzO1xuICAgIHRoaXMuX2NhcHR1cmVTdGFja1RyYWNlKCk7XG4gICAgdGhpcy5fcHVzaENvbnRleHQoKTtcbiAgICB2YXIgc3luY2hyb25vdXMgPSB0cnVlO1xuICAgIHZhciByID0gdGhpcy5fZXhlY3V0ZShleGVjdXRvciwgZnVuY3Rpb24odmFsdWUpIHtcbiAgICAgICAgcHJvbWlzZS5fcmVzb2x2ZUNhbGxiYWNrKHZhbHVlKTtcbiAgICB9LCBmdW5jdGlvbiAocmVhc29uKSB7XG4gICAgICAgIHByb21pc2UuX3JlamVjdENhbGxiYWNrKHJlYXNvbiwgc3luY2hyb25vdXMpO1xuICAgIH0pO1xuICAgIHN5bmNocm9ub3VzID0gZmFsc2U7XG4gICAgdGhpcy5fcG9wQ29udGV4dCgpO1xuXG4gICAgaWYgKHIgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICBwcm9taXNlLl9yZWplY3RDYWxsYmFjayhyLCB0cnVlKTtcbiAgICB9XG59O1xuXG5Qcm9taXNlLnByb3RvdHlwZS5fc2V0dGxlUHJvbWlzZUZyb21IYW5kbGVyID0gZnVuY3Rpb24gKFxuICAgIGhhbmRsZXIsIHJlY2VpdmVyLCB2YWx1ZSwgcHJvbWlzZVxuKSB7XG4gICAgdmFyIGJpdEZpZWxkID0gcHJvbWlzZS5fYml0RmllbGQ7XG4gICAgaWYgKCgoYml0RmllbGQgJiA2NTUzNikgIT09IDApKSByZXR1cm47XG4gICAgcHJvbWlzZS5fcHVzaENvbnRleHQoKTtcbiAgICB2YXIgeDtcbiAgICBpZiAocmVjZWl2ZXIgPT09IEFQUExZKSB7XG4gICAgICAgIGlmICghdmFsdWUgfHwgdHlwZW9mIHZhbHVlLmxlbmd0aCAhPT0gXCJudW1iZXJcIikge1xuICAgICAgICAgICAgeCA9IGVycm9yT2JqO1xuICAgICAgICAgICAgeC5lID0gbmV3IFR5cGVFcnJvcihcImNhbm5vdCAuc3ByZWFkKCkgYSBub24tYXJyYXk6IFwiICtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHV0aWwuY2xhc3NTdHJpbmcodmFsdWUpKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHggPSB0cnlDYXRjaChoYW5kbGVyKS5hcHBseSh0aGlzLl9ib3VuZFZhbHVlKCksIHZhbHVlKTtcbiAgICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICAgIHggPSB0cnlDYXRjaChoYW5kbGVyKS5jYWxsKHJlY2VpdmVyLCB2YWx1ZSk7XG4gICAgfVxuICAgIHZhciBwcm9taXNlQ3JlYXRlZCA9IHByb21pc2UuX3BvcENvbnRleHQoKTtcbiAgICBiaXRGaWVsZCA9IHByb21pc2UuX2JpdEZpZWxkO1xuICAgIGlmICgoKGJpdEZpZWxkICYgNjU1MzYpICE9PSAwKSkgcmV0dXJuO1xuXG4gICAgaWYgKHggPT09IE5FWFRfRklMVEVSKSB7XG4gICAgICAgIHByb21pc2UuX3JlamVjdCh2YWx1ZSk7XG4gICAgfSBlbHNlIGlmICh4ID09PSBlcnJvck9iaiB8fCB4ID09PSBwcm9taXNlKSB7XG4gICAgICAgIHZhciBlcnIgPSB4ID09PSBwcm9taXNlID8gbWFrZVNlbGZSZXNvbHV0aW9uRXJyb3IoKSA6IHguZTtcbiAgICAgICAgcHJvbWlzZS5fcmVqZWN0Q2FsbGJhY2soZXJyLCBmYWxzZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgZGVidWcuY2hlY2tGb3Jnb3R0ZW5SZXR1cm5zKHgsIHByb21pc2VDcmVhdGVkLCBcIlwiLCAgcHJvbWlzZSk7XG4gICAgICAgIHByb21pc2UuX3Jlc29sdmVDYWxsYmFjayh4KTtcbiAgICB9XG59O1xuXG5Qcm9taXNlLnByb3RvdHlwZS5fdGFyZ2V0ID0gZnVuY3Rpb24oKSB7XG4gICAgdmFyIHJldCA9IHRoaXM7XG4gICAgd2hpbGUgKHJldC5faXNGb2xsb3dpbmcoKSkgcmV0ID0gcmV0Ll9mb2xsb3dlZSgpO1xuICAgIHJldHVybiByZXQ7XG59O1xuXG5Qcm9taXNlLnByb3RvdHlwZS5fZm9sbG93ZWUgPSBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gdGhpcy5fcmVqZWN0aW9uSGFuZGxlcjA7XG59O1xuXG5Qcm9taXNlLnByb3RvdHlwZS5fc2V0Rm9sbG93ZWUgPSBmdW5jdGlvbihwcm9taXNlKSB7XG4gICAgdGhpcy5fcmVqZWN0aW9uSGFuZGxlcjAgPSBwcm9taXNlO1xufTtcblxuUHJvbWlzZS5wcm90b3R5cGUuX3NldHRsZVByb21pc2UgPSBmdW5jdGlvbihwcm9taXNlLCBoYW5kbGVyLCByZWNlaXZlciwgdmFsdWUpIHtcbiAgICB2YXIgaXNQcm9taXNlID0gcHJvbWlzZSBpbnN0YW5jZW9mIFByb21pc2U7XG4gICAgdmFyIGJpdEZpZWxkID0gdGhpcy5fYml0RmllbGQ7XG4gICAgdmFyIGFzeW5jR3VhcmFudGVlZCA9ICgoYml0RmllbGQgJiAxMzQyMTc3MjgpICE9PSAwKTtcbiAgICBpZiAoKChiaXRGaWVsZCAmIDY1NTM2KSAhPT0gMCkpIHtcbiAgICAgICAgaWYgKGlzUHJvbWlzZSkgcHJvbWlzZS5faW52b2tlSW50ZXJuYWxPbkNhbmNlbCgpO1xuXG4gICAgICAgIGlmIChoYW5kbGVyID09PSBmaW5hbGx5SGFuZGxlcikge1xuICAgICAgICAgICAgcmVjZWl2ZXIuY2FuY2VsUHJvbWlzZSA9IHByb21pc2U7XG4gICAgICAgICAgICBpZiAodHJ5Q2F0Y2goaGFuZGxlcikuY2FsbChyZWNlaXZlciwgdmFsdWUpID09PSBlcnJvck9iaikge1xuICAgICAgICAgICAgICAgIHByb21pc2UuX3JlamVjdChlcnJvck9iai5lKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIGlmIChoYW5kbGVyID09PSByZWZsZWN0SGFuZGxlcikge1xuICAgICAgICAgICAgcHJvbWlzZS5fZnVsZmlsbChyZWZsZWN0SGFuZGxlci5jYWxsKHJlY2VpdmVyKSk7XG4gICAgICAgIH0gZWxzZSBpZiAocmVjZWl2ZXIgaW5zdGFuY2VvZiBQcm94eWFibGUpIHtcbiAgICAgICAgICAgIHJlY2VpdmVyLl9wcm9taXNlQ2FuY2VsbGVkKHByb21pc2UpO1xuICAgICAgICB9IGVsc2UgaWYgKGlzUHJvbWlzZSB8fCBwcm9taXNlIGluc3RhbmNlb2YgUHJvbWlzZUFycmF5KSB7XG4gICAgICAgICAgICBwcm9taXNlLl9jYW5jZWwoKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJlY2VpdmVyLmNhbmNlbCgpO1xuICAgICAgICB9XG4gICAgfSBlbHNlIGlmICh0eXBlb2YgaGFuZGxlciA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgIGlmICghaXNQcm9taXNlKSB7XG4gICAgICAgICAgICBoYW5kbGVyLmNhbGwocmVjZWl2ZXIsIHZhbHVlLCBwcm9taXNlKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGlmIChhc3luY0d1YXJhbnRlZWQpIHByb21pc2UuX3NldEFzeW5jR3VhcmFudGVlZCgpO1xuICAgICAgICAgICAgdGhpcy5fc2V0dGxlUHJvbWlzZUZyb21IYW5kbGVyKGhhbmRsZXIsIHJlY2VpdmVyLCB2YWx1ZSwgcHJvbWlzZSk7XG4gICAgICAgIH1cbiAgICB9IGVsc2UgaWYgKHJlY2VpdmVyIGluc3RhbmNlb2YgUHJveHlhYmxlKSB7XG4gICAgICAgIGlmICghcmVjZWl2ZXIuX2lzUmVzb2x2ZWQoKSkge1xuICAgICAgICAgICAgaWYgKCgoYml0RmllbGQgJiAzMzU1NDQzMikgIT09IDApKSB7XG4gICAgICAgICAgICAgICAgcmVjZWl2ZXIuX3Byb21pc2VGdWxmaWxsZWQodmFsdWUsIHByb21pc2UpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICByZWNlaXZlci5fcHJvbWlzZVJlamVjdGVkKHZhbHVlLCBwcm9taXNlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH0gZWxzZSBpZiAoaXNQcm9taXNlKSB7XG4gICAgICAgIGlmIChhc3luY0d1YXJhbnRlZWQpIHByb21pc2UuX3NldEFzeW5jR3VhcmFudGVlZCgpO1xuICAgICAgICBpZiAoKChiaXRGaWVsZCAmIDMzNTU0NDMyKSAhPT0gMCkpIHtcbiAgICAgICAgICAgIHByb21pc2UuX2Z1bGZpbGwodmFsdWUpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcHJvbWlzZS5fcmVqZWN0KHZhbHVlKTtcbiAgICAgICAgfVxuICAgIH1cbn07XG5cblByb21pc2UucHJvdG90eXBlLl9zZXR0bGVQcm9taXNlTGF0ZUNhbmNlbGxhdGlvbk9ic2VydmVyID0gZnVuY3Rpb24oY3R4KSB7XG4gICAgdmFyIGhhbmRsZXIgPSBjdHguaGFuZGxlcjtcbiAgICB2YXIgcHJvbWlzZSA9IGN0eC5wcm9taXNlO1xuICAgIHZhciByZWNlaXZlciA9IGN0eC5yZWNlaXZlcjtcbiAgICB2YXIgdmFsdWUgPSBjdHgudmFsdWU7XG4gICAgaWYgKHR5cGVvZiBoYW5kbGVyID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgaWYgKCEocHJvbWlzZSBpbnN0YW5jZW9mIFByb21pc2UpKSB7XG4gICAgICAgICAgICBoYW5kbGVyLmNhbGwocmVjZWl2ZXIsIHZhbHVlLCBwcm9taXNlKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuX3NldHRsZVByb21pc2VGcm9tSGFuZGxlcihoYW5kbGVyLCByZWNlaXZlciwgdmFsdWUsIHByb21pc2UpO1xuICAgICAgICB9XG4gICAgfSBlbHNlIGlmIChwcm9taXNlIGluc3RhbmNlb2YgUHJvbWlzZSkge1xuICAgICAgICBwcm9taXNlLl9yZWplY3QodmFsdWUpO1xuICAgIH1cbn07XG5cblByb21pc2UucHJvdG90eXBlLl9zZXR0bGVQcm9taXNlQ3R4ID0gZnVuY3Rpb24oY3R4KSB7XG4gICAgdGhpcy5fc2V0dGxlUHJvbWlzZShjdHgucHJvbWlzZSwgY3R4LmhhbmRsZXIsIGN0eC5yZWNlaXZlciwgY3R4LnZhbHVlKTtcbn07XG5cblByb21pc2UucHJvdG90eXBlLl9zZXR0bGVQcm9taXNlMCA9IGZ1bmN0aW9uKGhhbmRsZXIsIHZhbHVlLCBiaXRGaWVsZCkge1xuICAgIHZhciBwcm9taXNlID0gdGhpcy5fcHJvbWlzZTA7XG4gICAgdmFyIHJlY2VpdmVyID0gdGhpcy5fcmVjZWl2ZXJBdCgwKTtcbiAgICB0aGlzLl9wcm9taXNlMCA9IHVuZGVmaW5lZDtcbiAgICB0aGlzLl9yZWNlaXZlcjAgPSB1bmRlZmluZWQ7XG4gICAgdGhpcy5fc2V0dGxlUHJvbWlzZShwcm9taXNlLCBoYW5kbGVyLCByZWNlaXZlciwgdmFsdWUpO1xufTtcblxuUHJvbWlzZS5wcm90b3R5cGUuX2NsZWFyQ2FsbGJhY2tEYXRhQXRJbmRleCA9IGZ1bmN0aW9uKGluZGV4KSB7XG4gICAgdmFyIGJhc2UgPSBpbmRleCAqIDQgLSA0O1xuICAgIHRoaXNbYmFzZSArIDJdID1cbiAgICB0aGlzW2Jhc2UgKyAzXSA9XG4gICAgdGhpc1tiYXNlICsgMF0gPVxuICAgIHRoaXNbYmFzZSArIDFdID0gdW5kZWZpbmVkO1xufTtcblxuUHJvbWlzZS5wcm90b3R5cGUuX2Z1bGZpbGwgPSBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICB2YXIgYml0RmllbGQgPSB0aGlzLl9iaXRGaWVsZDtcbiAgICBpZiAoKChiaXRGaWVsZCAmIDExNzUwNjA0OCkgPj4+IDE2KSkgcmV0dXJuO1xuICAgIGlmICh2YWx1ZSA9PT0gdGhpcykge1xuICAgICAgICB2YXIgZXJyID0gbWFrZVNlbGZSZXNvbHV0aW9uRXJyb3IoKTtcbiAgICAgICAgdGhpcy5fYXR0YWNoRXh0cmFUcmFjZShlcnIpO1xuICAgICAgICByZXR1cm4gdGhpcy5fcmVqZWN0KGVycik7XG4gICAgfVxuICAgIHRoaXMuX3NldEZ1bGZpbGxlZCgpO1xuICAgIHRoaXMuX3JlamVjdGlvbkhhbmRsZXIwID0gdmFsdWU7XG5cbiAgICBpZiAoKGJpdEZpZWxkICYgNjU1MzUpID4gMCkge1xuICAgICAgICBpZiAoKChiaXRGaWVsZCAmIDEzNDIxNzcyOCkgIT09IDApKSB7XG4gICAgICAgICAgICB0aGlzLl9zZXR0bGVQcm9taXNlcygpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgYXN5bmMuc2V0dGxlUHJvbWlzZXModGhpcyk7XG4gICAgICAgIH1cbiAgICB9XG59O1xuXG5Qcm9taXNlLnByb3RvdHlwZS5fcmVqZWN0ID0gZnVuY3Rpb24gKHJlYXNvbikge1xuICAgIHZhciBiaXRGaWVsZCA9IHRoaXMuX2JpdEZpZWxkO1xuICAgIGlmICgoKGJpdEZpZWxkICYgMTE3NTA2MDQ4KSA+Pj4gMTYpKSByZXR1cm47XG4gICAgdGhpcy5fc2V0UmVqZWN0ZWQoKTtcbiAgICB0aGlzLl9mdWxmaWxsbWVudEhhbmRsZXIwID0gcmVhc29uO1xuXG4gICAgaWYgKHRoaXMuX2lzRmluYWwoKSkge1xuICAgICAgICByZXR1cm4gYXN5bmMuZmF0YWxFcnJvcihyZWFzb24sIHV0aWwuaXNOb2RlKTtcbiAgICB9XG5cbiAgICBpZiAoKGJpdEZpZWxkICYgNjU1MzUpID4gMCkge1xuICAgICAgICBpZiAoKChiaXRGaWVsZCAmIDEzNDIxNzcyOCkgIT09IDApKSB7XG4gICAgICAgICAgICB0aGlzLl9zZXR0bGVQcm9taXNlcygpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgYXN5bmMuc2V0dGxlUHJvbWlzZXModGhpcyk7XG4gICAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLl9lbnN1cmVQb3NzaWJsZVJlamVjdGlvbkhhbmRsZWQoKTtcbiAgICB9XG59O1xuXG5Qcm9taXNlLnByb3RvdHlwZS5fZnVsZmlsbFByb21pc2VzID0gZnVuY3Rpb24gKGxlbiwgdmFsdWUpIHtcbiAgICBmb3IgKHZhciBpID0gMTsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgIHZhciBoYW5kbGVyID0gdGhpcy5fZnVsZmlsbG1lbnRIYW5kbGVyQXQoaSk7XG4gICAgICAgIHZhciBwcm9taXNlID0gdGhpcy5fcHJvbWlzZUF0KGkpO1xuICAgICAgICB2YXIgcmVjZWl2ZXIgPSB0aGlzLl9yZWNlaXZlckF0KGkpO1xuICAgICAgICB0aGlzLl9jbGVhckNhbGxiYWNrRGF0YUF0SW5kZXgoaSk7XG4gICAgICAgIHRoaXMuX3NldHRsZVByb21pc2UocHJvbWlzZSwgaGFuZGxlciwgcmVjZWl2ZXIsIHZhbHVlKTtcbiAgICB9XG59O1xuXG5Qcm9taXNlLnByb3RvdHlwZS5fcmVqZWN0UHJvbWlzZXMgPSBmdW5jdGlvbiAobGVuLCByZWFzb24pIHtcbiAgICBmb3IgKHZhciBpID0gMTsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgIHZhciBoYW5kbGVyID0gdGhpcy5fcmVqZWN0aW9uSGFuZGxlckF0KGkpO1xuICAgICAgICB2YXIgcHJvbWlzZSA9IHRoaXMuX3Byb21pc2VBdChpKTtcbiAgICAgICAgdmFyIHJlY2VpdmVyID0gdGhpcy5fcmVjZWl2ZXJBdChpKTtcbiAgICAgICAgdGhpcy5fY2xlYXJDYWxsYmFja0RhdGFBdEluZGV4KGkpO1xuICAgICAgICB0aGlzLl9zZXR0bGVQcm9taXNlKHByb21pc2UsIGhhbmRsZXIsIHJlY2VpdmVyLCByZWFzb24pO1xuICAgIH1cbn07XG5cblByb21pc2UucHJvdG90eXBlLl9zZXR0bGVQcm9taXNlcyA9IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgYml0RmllbGQgPSB0aGlzLl9iaXRGaWVsZDtcbiAgICB2YXIgbGVuID0gKGJpdEZpZWxkICYgNjU1MzUpO1xuXG4gICAgaWYgKGxlbiA+IDApIHtcbiAgICAgICAgaWYgKCgoYml0RmllbGQgJiAxNjg0Mjc1MikgIT09IDApKSB7XG4gICAgICAgICAgICB2YXIgcmVhc29uID0gdGhpcy5fZnVsZmlsbG1lbnRIYW5kbGVyMDtcbiAgICAgICAgICAgIHRoaXMuX3NldHRsZVByb21pc2UwKHRoaXMuX3JlamVjdGlvbkhhbmRsZXIwLCByZWFzb24sIGJpdEZpZWxkKTtcbiAgICAgICAgICAgIHRoaXMuX3JlamVjdFByb21pc2VzKGxlbiwgcmVhc29uKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHZhciB2YWx1ZSA9IHRoaXMuX3JlamVjdGlvbkhhbmRsZXIwO1xuICAgICAgICAgICAgdGhpcy5fc2V0dGxlUHJvbWlzZTAodGhpcy5fZnVsZmlsbG1lbnRIYW5kbGVyMCwgdmFsdWUsIGJpdEZpZWxkKTtcbiAgICAgICAgICAgIHRoaXMuX2Z1bGZpbGxQcm9taXNlcyhsZW4sIHZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLl9zZXRMZW5ndGgoMCk7XG4gICAgfVxuICAgIHRoaXMuX2NsZWFyQ2FuY2VsbGF0aW9uRGF0YSgpO1xufTtcblxuUHJvbWlzZS5wcm90b3R5cGUuX3NldHRsZWRWYWx1ZSA9IGZ1bmN0aW9uKCkge1xuICAgIHZhciBiaXRGaWVsZCA9IHRoaXMuX2JpdEZpZWxkO1xuICAgIGlmICgoKGJpdEZpZWxkICYgMzM1NTQ0MzIpICE9PSAwKSkge1xuICAgICAgICByZXR1cm4gdGhpcy5fcmVqZWN0aW9uSGFuZGxlcjA7XG4gICAgfSBlbHNlIGlmICgoKGJpdEZpZWxkICYgMTY3NzcyMTYpICE9PSAwKSkge1xuICAgICAgICByZXR1cm4gdGhpcy5fZnVsZmlsbG1lbnRIYW5kbGVyMDtcbiAgICB9XG59O1xuXG5mdW5jdGlvbiBkZWZlclJlc29sdmUodikge3RoaXMucHJvbWlzZS5fcmVzb2x2ZUNhbGxiYWNrKHYpO31cbmZ1bmN0aW9uIGRlZmVyUmVqZWN0KHYpIHt0aGlzLnByb21pc2UuX3JlamVjdENhbGxiYWNrKHYsIGZhbHNlKTt9XG5cblByb21pc2UuZGVmZXIgPSBQcm9taXNlLnBlbmRpbmcgPSBmdW5jdGlvbigpIHtcbiAgICBkZWJ1Zy5kZXByZWNhdGVkKFwiUHJvbWlzZS5kZWZlclwiLCBcIm5ldyBQcm9taXNlXCIpO1xuICAgIHZhciBwcm9taXNlID0gbmV3IFByb21pc2UoSU5URVJOQUwpO1xuICAgIHJldHVybiB7XG4gICAgICAgIHByb21pc2U6IHByb21pc2UsXG4gICAgICAgIHJlc29sdmU6IGRlZmVyUmVzb2x2ZSxcbiAgICAgICAgcmVqZWN0OiBkZWZlclJlamVjdFxuICAgIH07XG59O1xuXG51dGlsLm5vdEVudW1lcmFibGVQcm9wKFByb21pc2UsXG4gICAgICAgICAgICAgICAgICAgICAgIFwiX21ha2VTZWxmUmVzb2x1dGlvbkVycm9yXCIsXG4gICAgICAgICAgICAgICAgICAgICAgIG1ha2VTZWxmUmVzb2x1dGlvbkVycm9yKTtcblxuX2RlcmVxXyhcIi4vbWV0aG9kXCIpKFByb21pc2UsIElOVEVSTkFMLCB0cnlDb252ZXJ0VG9Qcm9taXNlLCBhcGlSZWplY3Rpb24sXG4gICAgZGVidWcpO1xuX2RlcmVxXyhcIi4vYmluZFwiKShQcm9taXNlLCBJTlRFUk5BTCwgdHJ5Q29udmVydFRvUHJvbWlzZSwgZGVidWcpO1xuX2RlcmVxXyhcIi4vY2FuY2VsXCIpKFByb21pc2UsIFByb21pc2VBcnJheSwgYXBpUmVqZWN0aW9uLCBkZWJ1Zyk7XG5fZGVyZXFfKFwiLi9kaXJlY3RfcmVzb2x2ZVwiKShQcm9taXNlKTtcbl9kZXJlcV8oXCIuL3N5bmNocm9ub3VzX2luc3BlY3Rpb25cIikoUHJvbWlzZSk7XG5fZGVyZXFfKFwiLi9qb2luXCIpKFxuICAgIFByb21pc2UsIFByb21pc2VBcnJheSwgdHJ5Q29udmVydFRvUHJvbWlzZSwgSU5URVJOQUwsIGRlYnVnKTtcblByb21pc2UuUHJvbWlzZSA9IFByb21pc2U7XG5fZGVyZXFfKCcuL21hcC5qcycpKFByb21pc2UsIFByb21pc2VBcnJheSwgYXBpUmVqZWN0aW9uLCB0cnlDb252ZXJ0VG9Qcm9taXNlLCBJTlRFUk5BTCwgZGVidWcpO1xuX2RlcmVxXygnLi91c2luZy5qcycpKFByb21pc2UsIGFwaVJlamVjdGlvbiwgdHJ5Q29udmVydFRvUHJvbWlzZSwgY3JlYXRlQ29udGV4dCwgSU5URVJOQUwsIGRlYnVnKTtcbl9kZXJlcV8oJy4vdGltZXJzLmpzJykoUHJvbWlzZSwgSU5URVJOQUwpO1xuX2RlcmVxXygnLi9nZW5lcmF0b3JzLmpzJykoUHJvbWlzZSwgYXBpUmVqZWN0aW9uLCBJTlRFUk5BTCwgdHJ5Q29udmVydFRvUHJvbWlzZSwgUHJveHlhYmxlLCBkZWJ1Zyk7XG5fZGVyZXFfKCcuL25vZGVpZnkuanMnKShQcm9taXNlKTtcbl9kZXJlcV8oJy4vY2FsbF9nZXQuanMnKShQcm9taXNlKTtcbl9kZXJlcV8oJy4vcHJvcHMuanMnKShQcm9taXNlLCBQcm9taXNlQXJyYXksIHRyeUNvbnZlcnRUb1Byb21pc2UsIGFwaVJlamVjdGlvbik7XG5fZGVyZXFfKCcuL3JhY2UuanMnKShQcm9taXNlLCBJTlRFUk5BTCwgdHJ5Q29udmVydFRvUHJvbWlzZSwgYXBpUmVqZWN0aW9uKTtcbl9kZXJlcV8oJy4vcmVkdWNlLmpzJykoUHJvbWlzZSwgUHJvbWlzZUFycmF5LCBhcGlSZWplY3Rpb24sIHRyeUNvbnZlcnRUb1Byb21pc2UsIElOVEVSTkFMLCBkZWJ1Zyk7XG5fZGVyZXFfKCcuL3NldHRsZS5qcycpKFByb21pc2UsIFByb21pc2VBcnJheSwgZGVidWcpO1xuX2RlcmVxXygnLi9zb21lLmpzJykoUHJvbWlzZSwgUHJvbWlzZUFycmF5LCBhcGlSZWplY3Rpb24pO1xuX2RlcmVxXygnLi9wcm9taXNpZnkuanMnKShQcm9taXNlLCBJTlRFUk5BTCk7XG5fZGVyZXFfKCcuL2FueS5qcycpKFByb21pc2UpO1xuX2RlcmVxXygnLi9lYWNoLmpzJykoUHJvbWlzZSwgSU5URVJOQUwpO1xuX2RlcmVxXygnLi9maWx0ZXIuanMnKShQcm9taXNlLCBJTlRFUk5BTCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcbiAgICB1dGlsLnRvRmFzdFByb3BlcnRpZXMoUHJvbWlzZSk7ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXG4gICAgdXRpbC50b0Zhc3RQcm9wZXJ0aWVzKFByb21pc2UucHJvdG90eXBlKTsgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFxuICAgIGZ1bmN0aW9uIGZpbGxUeXBlcyh2YWx1ZSkgeyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcbiAgICAgICAgdmFyIHAgPSBuZXcgUHJvbWlzZShJTlRFUk5BTCk7ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXG4gICAgICAgIHAuX2Z1bGZpbGxtZW50SGFuZGxlcjAgPSB2YWx1ZTsgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFxuICAgICAgICBwLl9yZWplY3Rpb25IYW5kbGVyMCA9IHZhbHVlOyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcbiAgICAgICAgcC5fcHJvbWlzZTAgPSB2YWx1ZTsgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXG4gICAgICAgIHAuX3JlY2VpdmVyMCA9IHZhbHVlOyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFxuICAgIH0gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcbiAgICAvLyBDb21wbGV0ZSBzbGFjayB0cmFja2luZywgb3B0IG91dCBvZiBmaWVsZC10eXBlIHRyYWNraW5nIGFuZCAgICAgICAgICAgXG4gICAgLy8gc3RhYmlsaXplIG1hcCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFxuICAgIGZpbGxUeXBlcyh7YTogMX0pOyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcbiAgICBmaWxsVHlwZXMoe2I6IDJ9KTsgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXG4gICAgZmlsbFR5cGVzKHtjOiAzfSk7ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFxuICAgIGZpbGxUeXBlcygxKTsgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcbiAgICBmaWxsVHlwZXMoZnVuY3Rpb24oKXt9KTsgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXG4gICAgZmlsbFR5cGVzKHVuZGVmaW5lZCk7ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFxuICAgIGZpbGxUeXBlcyhmYWxzZSk7ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcbiAgICBmaWxsVHlwZXMobmV3IFByb21pc2UoSU5URVJOQUwpKTsgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXG4gICAgZGVidWcuc2V0Qm91bmRzKEFzeW5jLmZpcnN0TGluZUVycm9yLCB1dGlsLmxhc3RMaW5lRXJyb3IpOyAgICAgICAgICAgICAgIFxuICAgIHJldHVybiBQcm9taXNlOyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcblxufTtcblxufSx7XCIuL2FueS5qc1wiOjEsXCIuL2FzeW5jXCI6MixcIi4vYmluZFwiOjMsXCIuL2NhbGxfZ2V0LmpzXCI6NSxcIi4vY2FuY2VsXCI6NixcIi4vY2F0Y2hfZmlsdGVyXCI6NyxcIi4vY29udGV4dFwiOjgsXCIuL2RlYnVnZ2FiaWxpdHlcIjo5LFwiLi9kaXJlY3RfcmVzb2x2ZVwiOjEwLFwiLi9lYWNoLmpzXCI6MTEsXCIuL2Vycm9yc1wiOjEyLFwiLi9lczVcIjoxMyxcIi4vZmlsdGVyLmpzXCI6MTQsXCIuL2ZpbmFsbHlcIjoxNSxcIi4vZ2VuZXJhdG9ycy5qc1wiOjE2LFwiLi9qb2luXCI6MTcsXCIuL21hcC5qc1wiOjE4LFwiLi9tZXRob2RcIjoxOSxcIi4vbm9kZWJhY2tcIjoyMCxcIi4vbm9kZWlmeS5qc1wiOjIxLFwiLi9wcm9taXNlX2FycmF5XCI6MjMsXCIuL3Byb21pc2lmeS5qc1wiOjI0LFwiLi9wcm9wcy5qc1wiOjI1LFwiLi9yYWNlLmpzXCI6MjcsXCIuL3JlZHVjZS5qc1wiOjI4LFwiLi9zZXR0bGUuanNcIjozMCxcIi4vc29tZS5qc1wiOjMxLFwiLi9zeW5jaHJvbm91c19pbnNwZWN0aW9uXCI6MzIsXCIuL3RoZW5hYmxlc1wiOjMzLFwiLi90aW1lcnMuanNcIjozNCxcIi4vdXNpbmcuanNcIjozNSxcIi4vdXRpbFwiOjM2fV0sMjM6W2Z1bmN0aW9uKF9kZXJlcV8sbW9kdWxlLGV4cG9ydHMpe1xuXCJ1c2Ugc3RyaWN0XCI7XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKFByb21pc2UsIElOVEVSTkFMLCB0cnlDb252ZXJ0VG9Qcm9taXNlLFxuICAgIGFwaVJlamVjdGlvbiwgUHJveHlhYmxlKSB7XG52YXIgdXRpbCA9IF9kZXJlcV8oXCIuL3V0aWxcIik7XG52YXIgaXNBcnJheSA9IHV0aWwuaXNBcnJheTtcblxuZnVuY3Rpb24gdG9SZXNvbHV0aW9uVmFsdWUodmFsKSB7XG4gICAgc3dpdGNoKHZhbCkge1xuICAgIGNhc2UgLTI6IHJldHVybiBbXTtcbiAgICBjYXNlIC0zOiByZXR1cm4ge307XG4gICAgfVxufVxuXG5mdW5jdGlvbiBQcm9taXNlQXJyYXkodmFsdWVzKSB7XG4gICAgdmFyIHByb21pc2UgPSB0aGlzLl9wcm9taXNlID0gbmV3IFByb21pc2UoSU5URVJOQUwpO1xuICAgIGlmICh2YWx1ZXMgaW5zdGFuY2VvZiBQcm9taXNlKSB7XG4gICAgICAgIHByb21pc2UuX3Byb3BhZ2F0ZUZyb20odmFsdWVzLCAzKTtcbiAgICB9XG4gICAgcHJvbWlzZS5fc2V0T25DYW5jZWwodGhpcyk7XG4gICAgdGhpcy5fdmFsdWVzID0gdmFsdWVzO1xuICAgIHRoaXMuX2xlbmd0aCA9IDA7XG4gICAgdGhpcy5fdG90YWxSZXNvbHZlZCA9IDA7XG4gICAgdGhpcy5faW5pdCh1bmRlZmluZWQsIC0yKTtcbn1cbnV0aWwuaW5oZXJpdHMoUHJvbWlzZUFycmF5LCBQcm94eWFibGUpO1xuXG5Qcm9taXNlQXJyYXkucHJvdG90eXBlLmxlbmd0aCA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gdGhpcy5fbGVuZ3RoO1xufTtcblxuUHJvbWlzZUFycmF5LnByb3RvdHlwZS5wcm9taXNlID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiB0aGlzLl9wcm9taXNlO1xufTtcblxuUHJvbWlzZUFycmF5LnByb3RvdHlwZS5faW5pdCA9IGZ1bmN0aW9uIGluaXQoXywgcmVzb2x2ZVZhbHVlSWZFbXB0eSkge1xuICAgIHZhciB2YWx1ZXMgPSB0cnlDb252ZXJ0VG9Qcm9taXNlKHRoaXMuX3ZhbHVlcywgdGhpcy5fcHJvbWlzZSk7XG4gICAgaWYgKHZhbHVlcyBpbnN0YW5jZW9mIFByb21pc2UpIHtcbiAgICAgICAgdmFsdWVzID0gdmFsdWVzLl90YXJnZXQoKTtcbiAgICAgICAgdmFyIGJpdEZpZWxkID0gdmFsdWVzLl9iaXRGaWVsZDtcbiAgICAgICAgO1xuICAgICAgICB0aGlzLl92YWx1ZXMgPSB2YWx1ZXM7XG5cbiAgICAgICAgaWYgKCgoYml0RmllbGQgJiA1MDM5NzE4NCkgPT09IDApKSB7XG4gICAgICAgICAgICB0aGlzLl9wcm9taXNlLl9zZXRBc3luY0d1YXJhbnRlZWQoKTtcbiAgICAgICAgICAgIHJldHVybiB2YWx1ZXMuX3RoZW4oXG4gICAgICAgICAgICAgICAgaW5pdCxcbiAgICAgICAgICAgICAgICB0aGlzLl9yZWplY3QsXG4gICAgICAgICAgICAgICAgdW5kZWZpbmVkLFxuICAgICAgICAgICAgICAgIHRoaXMsXG4gICAgICAgICAgICAgICAgcmVzb2x2ZVZhbHVlSWZFbXB0eVxuICAgICAgICAgICApO1xuICAgICAgICB9IGVsc2UgaWYgKCgoYml0RmllbGQgJiAzMzU1NDQzMikgIT09IDApKSB7XG4gICAgICAgICAgICB2YWx1ZXMgPSB2YWx1ZXMuX3ZhbHVlKCk7XG4gICAgICAgIH0gZWxzZSBpZiAoKChiaXRGaWVsZCAmIDE2Nzc3MjE2KSAhPT0gMCkpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9yZWplY3QodmFsdWVzLl9yZWFzb24oKSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fY2FuY2VsKCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgdmFsdWVzID0gdXRpbC5hc0FycmF5KHZhbHVlcyk7XG4gICAgaWYgKHZhbHVlcyA9PT0gbnVsbCkge1xuICAgICAgICB2YXIgZXJyID0gYXBpUmVqZWN0aW9uKFxuICAgICAgICAgICAgXCJleHBlY3RpbmcgYW4gYXJyYXkgb3IgYW4gaXRlcmFibGUgb2JqZWN0IGJ1dCBnb3QgXCIgKyB1dGlsLmNsYXNzU3RyaW5nKHZhbHVlcykpLnJlYXNvbigpO1xuICAgICAgICB0aGlzLl9wcm9taXNlLl9yZWplY3RDYWxsYmFjayhlcnIsIGZhbHNlKTtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGlmICh2YWx1ZXMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgIGlmIChyZXNvbHZlVmFsdWVJZkVtcHR5ID09PSAtNSkge1xuICAgICAgICAgICAgdGhpcy5fcmVzb2x2ZUVtcHR5QXJyYXkoKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuX3Jlc29sdmUodG9SZXNvbHV0aW9uVmFsdWUocmVzb2x2ZVZhbHVlSWZFbXB0eSkpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdGhpcy5faXRlcmF0ZSh2YWx1ZXMpO1xufTtcblxuUHJvbWlzZUFycmF5LnByb3RvdHlwZS5faXRlcmF0ZSA9IGZ1bmN0aW9uKHZhbHVlcykge1xuICAgIHZhciBsZW4gPSB0aGlzLmdldEFjdHVhbExlbmd0aCh2YWx1ZXMubGVuZ3RoKTtcbiAgICB0aGlzLl9sZW5ndGggPSBsZW47XG4gICAgdGhpcy5fdmFsdWVzID0gdGhpcy5zaG91bGRDb3B5VmFsdWVzKCkgPyBuZXcgQXJyYXkobGVuKSA6IHRoaXMuX3ZhbHVlcztcbiAgICB2YXIgcmVzdWx0ID0gdGhpcy5fcHJvbWlzZTtcbiAgICB2YXIgaXNSZXNvbHZlZCA9IGZhbHNlO1xuICAgIHZhciBiaXRGaWVsZCA9IG51bGw7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW47ICsraSkge1xuICAgICAgICB2YXIgbWF5YmVQcm9taXNlID0gdHJ5Q29udmVydFRvUHJvbWlzZSh2YWx1ZXNbaV0sIHJlc3VsdCk7XG5cbiAgICAgICAgaWYgKG1heWJlUHJvbWlzZSBpbnN0YW5jZW9mIFByb21pc2UpIHtcbiAgICAgICAgICAgIG1heWJlUHJvbWlzZSA9IG1heWJlUHJvbWlzZS5fdGFyZ2V0KCk7XG4gICAgICAgICAgICBiaXRGaWVsZCA9IG1heWJlUHJvbWlzZS5fYml0RmllbGQ7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBiaXRGaWVsZCA9IG51bGw7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoaXNSZXNvbHZlZCkge1xuICAgICAgICAgICAgaWYgKGJpdEZpZWxkICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgbWF5YmVQcm9taXNlLnN1cHByZXNzVW5oYW5kbGVkUmVqZWN0aW9ucygpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9IGVsc2UgaWYgKGJpdEZpZWxkICE9PSBudWxsKSB7XG4gICAgICAgICAgICBpZiAoKChiaXRGaWVsZCAmIDUwMzk3MTg0KSA9PT0gMCkpIHtcbiAgICAgICAgICAgICAgICBtYXliZVByb21pc2UuX3Byb3h5KHRoaXMsIGkpO1xuICAgICAgICAgICAgICAgIHRoaXMuX3ZhbHVlc1tpXSA9IG1heWJlUHJvbWlzZTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoKChiaXRGaWVsZCAmIDMzNTU0NDMyKSAhPT0gMCkpIHtcbiAgICAgICAgICAgICAgICBpc1Jlc29sdmVkID0gdGhpcy5fcHJvbWlzZUZ1bGZpbGxlZChtYXliZVByb21pc2UuX3ZhbHVlKCksIGkpO1xuICAgICAgICAgICAgfSBlbHNlIGlmICgoKGJpdEZpZWxkICYgMTY3NzcyMTYpICE9PSAwKSkge1xuICAgICAgICAgICAgICAgIGlzUmVzb2x2ZWQgPSB0aGlzLl9wcm9taXNlUmVqZWN0ZWQobWF5YmVQcm9taXNlLl9yZWFzb24oKSwgaSk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGlzUmVzb2x2ZWQgPSB0aGlzLl9wcm9taXNlQ2FuY2VsbGVkKGkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgaXNSZXNvbHZlZCA9IHRoaXMuX3Byb21pc2VGdWxmaWxsZWQobWF5YmVQcm9taXNlLCBpKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBpZiAoIWlzUmVzb2x2ZWQpIHJlc3VsdC5fc2V0QXN5bmNHdWFyYW50ZWVkKCk7XG59O1xuXG5Qcm9taXNlQXJyYXkucHJvdG90eXBlLl9pc1Jlc29sdmVkID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiB0aGlzLl92YWx1ZXMgPT09IG51bGw7XG59O1xuXG5Qcm9taXNlQXJyYXkucHJvdG90eXBlLl9yZXNvbHZlID0gZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgdGhpcy5fdmFsdWVzID0gbnVsbDtcbiAgICB0aGlzLl9wcm9taXNlLl9mdWxmaWxsKHZhbHVlKTtcbn07XG5cblByb21pc2VBcnJheS5wcm90b3R5cGUuX2NhbmNlbCA9IGZ1bmN0aW9uKCkge1xuICAgIGlmICh0aGlzLl9pc1Jlc29sdmVkKCkgfHwgIXRoaXMuX3Byb21pc2UuaXNDYW5jZWxsYWJsZSgpKSByZXR1cm47XG4gICAgdGhpcy5fdmFsdWVzID0gbnVsbDtcbiAgICB0aGlzLl9wcm9taXNlLl9jYW5jZWwoKTtcbn07XG5cblByb21pc2VBcnJheS5wcm90b3R5cGUuX3JlamVjdCA9IGZ1bmN0aW9uIChyZWFzb24pIHtcbiAgICB0aGlzLl92YWx1ZXMgPSBudWxsO1xuICAgIHRoaXMuX3Byb21pc2UuX3JlamVjdENhbGxiYWNrKHJlYXNvbiwgZmFsc2UpO1xufTtcblxuUHJvbWlzZUFycmF5LnByb3RvdHlwZS5fcHJvbWlzZUZ1bGZpbGxlZCA9IGZ1bmN0aW9uICh2YWx1ZSwgaW5kZXgpIHtcbiAgICB0aGlzLl92YWx1ZXNbaW5kZXhdID0gdmFsdWU7XG4gICAgdmFyIHRvdGFsUmVzb2x2ZWQgPSArK3RoaXMuX3RvdGFsUmVzb2x2ZWQ7XG4gICAgaWYgKHRvdGFsUmVzb2x2ZWQgPj0gdGhpcy5fbGVuZ3RoKSB7XG4gICAgICAgIHRoaXMuX3Jlc29sdmUodGhpcy5fdmFsdWVzKTtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIHJldHVybiBmYWxzZTtcbn07XG5cblByb21pc2VBcnJheS5wcm90b3R5cGUuX3Byb21pc2VDYW5jZWxsZWQgPSBmdW5jdGlvbigpIHtcbiAgICB0aGlzLl9jYW5jZWwoKTtcbiAgICByZXR1cm4gdHJ1ZTtcbn07XG5cblByb21pc2VBcnJheS5wcm90b3R5cGUuX3Byb21pc2VSZWplY3RlZCA9IGZ1bmN0aW9uIChyZWFzb24pIHtcbiAgICB0aGlzLl90b3RhbFJlc29sdmVkKys7XG4gICAgdGhpcy5fcmVqZWN0KHJlYXNvbik7XG4gICAgcmV0dXJuIHRydWU7XG59O1xuXG5Qcm9taXNlQXJyYXkucHJvdG90eXBlLl9yZXN1bHRDYW5jZWxsZWQgPSBmdW5jdGlvbigpIHtcbiAgICBpZiAodGhpcy5faXNSZXNvbHZlZCgpKSByZXR1cm47XG4gICAgdmFyIHZhbHVlcyA9IHRoaXMuX3ZhbHVlcztcbiAgICB0aGlzLl9jYW5jZWwoKTtcbiAgICBpZiAodmFsdWVzIGluc3RhbmNlb2YgUHJvbWlzZSkge1xuICAgICAgICB2YWx1ZXMuY2FuY2VsKCk7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB2YWx1ZXMubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgICAgIGlmICh2YWx1ZXNbaV0gaW5zdGFuY2VvZiBQcm9taXNlKSB7XG4gICAgICAgICAgICAgICAgdmFsdWVzW2ldLmNhbmNlbCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxufTtcblxuUHJvbWlzZUFycmF5LnByb3RvdHlwZS5zaG91bGRDb3B5VmFsdWVzID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiB0cnVlO1xufTtcblxuUHJvbWlzZUFycmF5LnByb3RvdHlwZS5nZXRBY3R1YWxMZW5ndGggPSBmdW5jdGlvbiAobGVuKSB7XG4gICAgcmV0dXJuIGxlbjtcbn07XG5cbnJldHVybiBQcm9taXNlQXJyYXk7XG59O1xuXG59LHtcIi4vdXRpbFwiOjM2fV0sMjQ6W2Z1bmN0aW9uKF9kZXJlcV8sbW9kdWxlLGV4cG9ydHMpe1xuXCJ1c2Ugc3RyaWN0XCI7XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKFByb21pc2UsIElOVEVSTkFMKSB7XG52YXIgVEhJUyA9IHt9O1xudmFyIHV0aWwgPSBfZGVyZXFfKFwiLi91dGlsXCIpO1xudmFyIG5vZGViYWNrRm9yUHJvbWlzZSA9IF9kZXJlcV8oXCIuL25vZGViYWNrXCIpO1xudmFyIHdpdGhBcHBlbmRlZCA9IHV0aWwud2l0aEFwcGVuZGVkO1xudmFyIG1heWJlV3JhcEFzRXJyb3IgPSB1dGlsLm1heWJlV3JhcEFzRXJyb3I7XG52YXIgY2FuRXZhbHVhdGUgPSB1dGlsLmNhbkV2YWx1YXRlO1xudmFyIFR5cGVFcnJvciA9IF9kZXJlcV8oXCIuL2Vycm9yc1wiKS5UeXBlRXJyb3I7XG52YXIgZGVmYXVsdFN1ZmZpeCA9IFwiQXN5bmNcIjtcbnZhciBkZWZhdWx0UHJvbWlzaWZpZWQgPSB7X19pc1Byb21pc2lmaWVkX186IHRydWV9O1xudmFyIG5vQ29weVByb3BzID0gW1xuICAgIFwiYXJpdHlcIiwgICAgXCJsZW5ndGhcIixcbiAgICBcIm5hbWVcIixcbiAgICBcImFyZ3VtZW50c1wiLFxuICAgIFwiY2FsbGVyXCIsXG4gICAgXCJjYWxsZWVcIixcbiAgICBcInByb3RvdHlwZVwiLFxuICAgIFwiX19pc1Byb21pc2lmaWVkX19cIlxuXTtcbnZhciBub0NvcHlQcm9wc1BhdHRlcm4gPSBuZXcgUmVnRXhwKFwiXig/OlwiICsgbm9Db3B5UHJvcHMuam9pbihcInxcIikgKyBcIikkXCIpO1xuXG52YXIgZGVmYXVsdEZpbHRlciA9IGZ1bmN0aW9uKG5hbWUpIHtcbiAgICByZXR1cm4gdXRpbC5pc0lkZW50aWZpZXIobmFtZSkgJiZcbiAgICAgICAgbmFtZS5jaGFyQXQoMCkgIT09IFwiX1wiICYmXG4gICAgICAgIG5hbWUgIT09IFwiY29uc3RydWN0b3JcIjtcbn07XG5cbmZ1bmN0aW9uIHByb3BzRmlsdGVyKGtleSkge1xuICAgIHJldHVybiAhbm9Db3B5UHJvcHNQYXR0ZXJuLnRlc3Qoa2V5KTtcbn1cblxuZnVuY3Rpb24gaXNQcm9taXNpZmllZChmbikge1xuICAgIHRyeSB7XG4gICAgICAgIHJldHVybiBmbi5fX2lzUHJvbWlzaWZpZWRfXyA9PT0gdHJ1ZTtcbiAgICB9XG4gICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbn1cblxuZnVuY3Rpb24gaGFzUHJvbWlzaWZpZWQob2JqLCBrZXksIHN1ZmZpeCkge1xuICAgIHZhciB2YWwgPSB1dGlsLmdldERhdGFQcm9wZXJ0eU9yRGVmYXVsdChvYmosIGtleSArIHN1ZmZpeCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZGVmYXVsdFByb21pc2lmaWVkKTtcbiAgICByZXR1cm4gdmFsID8gaXNQcm9taXNpZmllZCh2YWwpIDogZmFsc2U7XG59XG5mdW5jdGlvbiBjaGVja1ZhbGlkKHJldCwgc3VmZml4LCBzdWZmaXhSZWdleHApIHtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHJldC5sZW5ndGg7IGkgKz0gMikge1xuICAgICAgICB2YXIga2V5ID0gcmV0W2ldO1xuICAgICAgICBpZiAoc3VmZml4UmVnZXhwLnRlc3Qoa2V5KSkge1xuICAgICAgICAgICAgdmFyIGtleVdpdGhvdXRBc3luY1N1ZmZpeCA9IGtleS5yZXBsYWNlKHN1ZmZpeFJlZ2V4cCwgXCJcIik7XG4gICAgICAgICAgICBmb3IgKHZhciBqID0gMDsgaiA8IHJldC5sZW5ndGg7IGogKz0gMikge1xuICAgICAgICAgICAgICAgIGlmIChyZXRbal0gPT09IGtleVdpdGhvdXRBc3luY1N1ZmZpeCkge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IHByb21pc2lmeSBhbiBBUEkgdGhhdCBoYXMgbm9ybWFsIG1ldGhvZHMgd2l0aCAnJXMnLXN1ZmZpeFxcdTAwMGFcXHUwMDBhICAgIFNlZSBodHRwOi8vZ29vLmdsL01xckZtWFxcdTAwMGFcIlxuICAgICAgICAgICAgICAgICAgICAgICAgLnJlcGxhY2UoXCIlc1wiLCBzdWZmaXgpKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG59XG5cbmZ1bmN0aW9uIHByb21pc2lmaWFibGVNZXRob2RzKG9iaiwgc3VmZml4LCBzdWZmaXhSZWdleHAsIGZpbHRlcikge1xuICAgIHZhciBrZXlzID0gdXRpbC5pbmhlcml0ZWREYXRhS2V5cyhvYmopO1xuICAgIHZhciByZXQgPSBbXTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGtleXMubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgdmFyIGtleSA9IGtleXNbaV07XG4gICAgICAgIHZhciB2YWx1ZSA9IG9ialtrZXldO1xuICAgICAgICB2YXIgcGFzc2VzRGVmYXVsdEZpbHRlciA9IGZpbHRlciA9PT0gZGVmYXVsdEZpbHRlclxuICAgICAgICAgICAgPyB0cnVlIDogZGVmYXVsdEZpbHRlcihrZXksIHZhbHVlLCBvYmopO1xuICAgICAgICBpZiAodHlwZW9mIHZhbHVlID09PSBcImZ1bmN0aW9uXCIgJiZcbiAgICAgICAgICAgICFpc1Byb21pc2lmaWVkKHZhbHVlKSAmJlxuICAgICAgICAgICAgIWhhc1Byb21pc2lmaWVkKG9iaiwga2V5LCBzdWZmaXgpICYmXG4gICAgICAgICAgICBmaWx0ZXIoa2V5LCB2YWx1ZSwgb2JqLCBwYXNzZXNEZWZhdWx0RmlsdGVyKSkge1xuICAgICAgICAgICAgcmV0LnB1c2goa2V5LCB2YWx1ZSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgY2hlY2tWYWxpZChyZXQsIHN1ZmZpeCwgc3VmZml4UmVnZXhwKTtcbiAgICByZXR1cm4gcmV0O1xufVxuXG52YXIgZXNjYXBlSWRlbnRSZWdleCA9IGZ1bmN0aW9uKHN0cikge1xuICAgIHJldHVybiBzdHIucmVwbGFjZSgvKFskXSkvLCBcIlxcXFwkXCIpO1xufTtcblxudmFyIG1ha2VOb2RlUHJvbWlzaWZpZWRFdmFsO1xuaWYgKCF0cnVlKSB7XG52YXIgc3dpdGNoQ2FzZUFyZ3VtZW50T3JkZXIgPSBmdW5jdGlvbihsaWtlbHlBcmd1bWVudENvdW50KSB7XG4gICAgdmFyIHJldCA9IFtsaWtlbHlBcmd1bWVudENvdW50XTtcbiAgICB2YXIgbWluID0gTWF0aC5tYXgoMCwgbGlrZWx5QXJndW1lbnRDb3VudCAtIDEgLSAzKTtcbiAgICBmb3IodmFyIGkgPSBsaWtlbHlBcmd1bWVudENvdW50IC0gMTsgaSA+PSBtaW47IC0taSkge1xuICAgICAgICByZXQucHVzaChpKTtcbiAgICB9XG4gICAgZm9yKHZhciBpID0gbGlrZWx5QXJndW1lbnRDb3VudCArIDE7IGkgPD0gMzsgKytpKSB7XG4gICAgICAgIHJldC5wdXNoKGkpO1xuICAgIH1cbiAgICByZXR1cm4gcmV0O1xufTtcblxudmFyIGFyZ3VtZW50U2VxdWVuY2UgPSBmdW5jdGlvbihhcmd1bWVudENvdW50KSB7XG4gICAgcmV0dXJuIHV0aWwuZmlsbGVkUmFuZ2UoYXJndW1lbnRDb3VudCwgXCJfYXJnXCIsIFwiXCIpO1xufTtcblxudmFyIHBhcmFtZXRlckRlY2xhcmF0aW9uID0gZnVuY3Rpb24ocGFyYW1ldGVyQ291bnQpIHtcbiAgICByZXR1cm4gdXRpbC5maWxsZWRSYW5nZShcbiAgICAgICAgTWF0aC5tYXgocGFyYW1ldGVyQ291bnQsIDMpLCBcIl9hcmdcIiwgXCJcIik7XG59O1xuXG52YXIgcGFyYW1ldGVyQ291bnQgPSBmdW5jdGlvbihmbikge1xuICAgIGlmICh0eXBlb2YgZm4ubGVuZ3RoID09PSBcIm51bWJlclwiKSB7XG4gICAgICAgIHJldHVybiBNYXRoLm1heChNYXRoLm1pbihmbi5sZW5ndGgsIDEwMjMgKyAxKSwgMCk7XG4gICAgfVxuICAgIHJldHVybiAwO1xufTtcblxubWFrZU5vZGVQcm9taXNpZmllZEV2YWwgPVxuZnVuY3Rpb24oY2FsbGJhY2ssIHJlY2VpdmVyLCBvcmlnaW5hbE5hbWUsIGZuLCBfLCBtdWx0aUFyZ3MpIHtcbiAgICB2YXIgbmV3UGFyYW1ldGVyQ291bnQgPSBNYXRoLm1heCgwLCBwYXJhbWV0ZXJDb3VudChmbikgLSAxKTtcbiAgICB2YXIgYXJndW1lbnRPcmRlciA9IHN3aXRjaENhc2VBcmd1bWVudE9yZGVyKG5ld1BhcmFtZXRlckNvdW50KTtcbiAgICB2YXIgc2hvdWxkUHJveHlUaGlzID0gdHlwZW9mIGNhbGxiYWNrID09PSBcInN0cmluZ1wiIHx8IHJlY2VpdmVyID09PSBUSElTO1xuXG4gICAgZnVuY3Rpb24gZ2VuZXJhdGVDYWxsRm9yQXJndW1lbnRDb3VudChjb3VudCkge1xuICAgICAgICB2YXIgYXJncyA9IGFyZ3VtZW50U2VxdWVuY2UoY291bnQpLmpvaW4oXCIsIFwiKTtcbiAgICAgICAgdmFyIGNvbW1hID0gY291bnQgPiAwID8gXCIsIFwiIDogXCJcIjtcbiAgICAgICAgdmFyIHJldDtcbiAgICAgICAgaWYgKHNob3VsZFByb3h5VGhpcykge1xuICAgICAgICAgICAgcmV0ID0gXCJyZXQgPSBjYWxsYmFjay5jYWxsKHRoaXMsIHt7YXJnc319LCBub2RlYmFjayk7IGJyZWFrO1xcblwiO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0ID0gcmVjZWl2ZXIgPT09IHVuZGVmaW5lZFxuICAgICAgICAgICAgICAgID8gXCJyZXQgPSBjYWxsYmFjayh7e2FyZ3N9fSwgbm9kZWJhY2spOyBicmVhaztcXG5cIlxuICAgICAgICAgICAgICAgIDogXCJyZXQgPSBjYWxsYmFjay5jYWxsKHJlY2VpdmVyLCB7e2FyZ3N9fSwgbm9kZWJhY2spOyBicmVhaztcXG5cIjtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmV0LnJlcGxhY2UoXCJ7e2FyZ3N9fVwiLCBhcmdzKS5yZXBsYWNlKFwiLCBcIiwgY29tbWEpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGdlbmVyYXRlQXJndW1lbnRTd2l0Y2hDYXNlKCkge1xuICAgICAgICB2YXIgcmV0ID0gXCJcIjtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBhcmd1bWVudE9yZGVyLmxlbmd0aDsgKytpKSB7XG4gICAgICAgICAgICByZXQgKz0gXCJjYXNlIFwiICsgYXJndW1lbnRPcmRlcltpXSArXCI6XCIgK1xuICAgICAgICAgICAgICAgIGdlbmVyYXRlQ2FsbEZvckFyZ3VtZW50Q291bnQoYXJndW1lbnRPcmRlcltpXSk7XG4gICAgICAgIH1cblxuICAgICAgICByZXQgKz0gXCIgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXFxuXFxcbiAgICAgICAgZGVmYXVsdDogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXFxuXFxcbiAgICAgICAgICAgIHZhciBhcmdzID0gbmV3IEFycmF5KGxlbiArIDEpOyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXFxuXFxcbiAgICAgICAgICAgIHZhciBpID0gMDsgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXFxuXFxcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuOyArK2kpIHsgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXFxuXFxcbiAgICAgICAgICAgICAgIGFyZ3NbaV0gPSBhcmd1bWVudHNbaV07ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXFxuXFxcbiAgICAgICAgICAgIH0gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXFxuXFxcbiAgICAgICAgICAgIGFyZ3NbaV0gPSBub2RlYmFjazsgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXFxuXFxcbiAgICAgICAgICAgIFtDb2RlRm9yQ2FsbF0gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXFxuXFxcbiAgICAgICAgICAgIGJyZWFrOyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXFxuXFxcbiAgICAgICAgXCIucmVwbGFjZShcIltDb2RlRm9yQ2FsbF1cIiwgKHNob3VsZFByb3h5VGhpc1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA/IFwicmV0ID0gY2FsbGJhY2suYXBwbHkodGhpcywgYXJncyk7XFxuXCJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgOiBcInJldCA9IGNhbGxiYWNrLmFwcGx5KHJlY2VpdmVyLCBhcmdzKTtcXG5cIikpO1xuICAgICAgICByZXR1cm4gcmV0O1xuICAgIH1cblxuICAgIHZhciBnZXRGdW5jdGlvbkNvZGUgPSB0eXBlb2YgY2FsbGJhY2sgPT09IFwic3RyaW5nXCJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPyAoXCJ0aGlzICE9IG51bGwgPyB0aGlzWydcIitjYWxsYmFjaytcIiddIDogZm5cIilcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgOiBcImZuXCI7XG4gICAgdmFyIGJvZHkgPSBcIid1c2Ugc3RyaWN0JzsgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcXG5cXFxuICAgICAgICB2YXIgcmV0ID0gZnVuY3Rpb24gKFBhcmFtZXRlcnMpIHsgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcXG5cXFxuICAgICAgICAgICAgJ3VzZSBzdHJpY3QnOyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcXG5cXFxuICAgICAgICAgICAgdmFyIGxlbiA9IGFyZ3VtZW50cy5sZW5ndGg7ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcXG5cXFxuICAgICAgICAgICAgdmFyIHByb21pc2UgPSBuZXcgUHJvbWlzZShJTlRFUk5BTCk7ICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcXG5cXFxuICAgICAgICAgICAgcHJvbWlzZS5fY2FwdHVyZVN0YWNrVHJhY2UoKTsgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcXG5cXFxuICAgICAgICAgICAgdmFyIG5vZGViYWNrID0gbm9kZWJhY2tGb3JQcm9taXNlKHByb21pc2UsIFwiICsgbXVsdGlBcmdzICsgXCIpOyAgIFxcblxcXG4gICAgICAgICAgICB2YXIgcmV0OyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFxcblxcXG4gICAgICAgICAgICB2YXIgY2FsbGJhY2sgPSB0cnlDYXRjaChbR2V0RnVuY3Rpb25Db2RlXSk7ICAgICAgICAgICAgICAgICAgICAgIFxcblxcXG4gICAgICAgICAgICBzd2l0Y2gobGVuKSB7ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFxcblxcXG4gICAgICAgICAgICAgICAgW0NvZGVGb3JTd2l0Y2hDYXNlXSAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFxcblxcXG4gICAgICAgICAgICB9ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFxcblxcXG4gICAgICAgICAgICBpZiAocmV0ID09PSBlcnJvck9iaikgeyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFxcblxcXG4gICAgICAgICAgICAgICAgcHJvbWlzZS5fcmVqZWN0Q2FsbGJhY2sobWF5YmVXcmFwQXNFcnJvcihyZXQuZSksIHRydWUsIHRydWUpO1xcblxcXG4gICAgICAgICAgICB9ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFxcblxcXG4gICAgICAgICAgICBpZiAoIXByb21pc2UuX2lzRmF0ZVNlYWxlZCgpKSBwcm9taXNlLl9zZXRBc3luY0d1YXJhbnRlZWQoKTsgICAgIFxcblxcXG4gICAgICAgICAgICByZXR1cm4gcHJvbWlzZTsgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFxcblxcXG4gICAgICAgIH07ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFxcblxcXG4gICAgICAgIG5vdEVudW1lcmFibGVQcm9wKHJldCwgJ19faXNQcm9taXNpZmllZF9fJywgdHJ1ZSk7ICAgICAgICAgICAgICAgICAgIFxcblxcXG4gICAgICAgIHJldHVybiByZXQ7ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFxcblxcXG4gICAgXCIucmVwbGFjZShcIltDb2RlRm9yU3dpdGNoQ2FzZV1cIiwgZ2VuZXJhdGVBcmd1bWVudFN3aXRjaENhc2UoKSlcbiAgICAgICAgLnJlcGxhY2UoXCJbR2V0RnVuY3Rpb25Db2RlXVwiLCBnZXRGdW5jdGlvbkNvZGUpO1xuICAgIGJvZHkgPSBib2R5LnJlcGxhY2UoXCJQYXJhbWV0ZXJzXCIsIHBhcmFtZXRlckRlY2xhcmF0aW9uKG5ld1BhcmFtZXRlckNvdW50KSk7XG4gICAgcmV0dXJuIG5ldyBGdW5jdGlvbihcIlByb21pc2VcIixcbiAgICAgICAgICAgICAgICAgICAgICAgIFwiZm5cIixcbiAgICAgICAgICAgICAgICAgICAgICAgIFwicmVjZWl2ZXJcIixcbiAgICAgICAgICAgICAgICAgICAgICAgIFwid2l0aEFwcGVuZGVkXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICBcIm1heWJlV3JhcEFzRXJyb3JcIixcbiAgICAgICAgICAgICAgICAgICAgICAgIFwibm9kZWJhY2tGb3JQcm9taXNlXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICBcInRyeUNhdGNoXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICBcImVycm9yT2JqXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICBcIm5vdEVudW1lcmFibGVQcm9wXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICBcIklOVEVSTkFMXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICBib2R5KShcbiAgICAgICAgICAgICAgICAgICAgUHJvbWlzZSxcbiAgICAgICAgICAgICAgICAgICAgZm4sXG4gICAgICAgICAgICAgICAgICAgIHJlY2VpdmVyLFxuICAgICAgICAgICAgICAgICAgICB3aXRoQXBwZW5kZWQsXG4gICAgICAgICAgICAgICAgICAgIG1heWJlV3JhcEFzRXJyb3IsXG4gICAgICAgICAgICAgICAgICAgIG5vZGViYWNrRm9yUHJvbWlzZSxcbiAgICAgICAgICAgICAgICAgICAgdXRpbC50cnlDYXRjaCxcbiAgICAgICAgICAgICAgICAgICAgdXRpbC5lcnJvck9iaixcbiAgICAgICAgICAgICAgICAgICAgdXRpbC5ub3RFbnVtZXJhYmxlUHJvcCxcbiAgICAgICAgICAgICAgICAgICAgSU5URVJOQUwpO1xufTtcbn1cblxuZnVuY3Rpb24gbWFrZU5vZGVQcm9taXNpZmllZENsb3N1cmUoY2FsbGJhY2ssIHJlY2VpdmVyLCBfLCBmbiwgX18sIG11bHRpQXJncykge1xuICAgIHZhciBkZWZhdWx0VGhpcyA9IChmdW5jdGlvbigpIHtyZXR1cm4gdGhpczt9KSgpO1xuICAgIHZhciBtZXRob2QgPSBjYWxsYmFjaztcbiAgICBpZiAodHlwZW9mIG1ldGhvZCA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgICBjYWxsYmFjayA9IGZuO1xuICAgIH1cbiAgICBmdW5jdGlvbiBwcm9taXNpZmllZCgpIHtcbiAgICAgICAgdmFyIF9yZWNlaXZlciA9IHJlY2VpdmVyO1xuICAgICAgICBpZiAocmVjZWl2ZXIgPT09IFRISVMpIF9yZWNlaXZlciA9IHRoaXM7XG4gICAgICAgIHZhciBwcm9taXNlID0gbmV3IFByb21pc2UoSU5URVJOQUwpO1xuICAgICAgICBwcm9taXNlLl9jYXB0dXJlU3RhY2tUcmFjZSgpO1xuICAgICAgICB2YXIgY2IgPSB0eXBlb2YgbWV0aG9kID09PSBcInN0cmluZ1wiICYmIHRoaXMgIT09IGRlZmF1bHRUaGlzXG4gICAgICAgICAgICA/IHRoaXNbbWV0aG9kXSA6IGNhbGxiYWNrO1xuICAgICAgICB2YXIgZm4gPSBub2RlYmFja0ZvclByb21pc2UocHJvbWlzZSwgbXVsdGlBcmdzKTtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGNiLmFwcGx5KF9yZWNlaXZlciwgd2l0aEFwcGVuZGVkKGFyZ3VtZW50cywgZm4pKTtcbiAgICAgICAgfSBjYXRjaChlKSB7XG4gICAgICAgICAgICBwcm9taXNlLl9yZWplY3RDYWxsYmFjayhtYXliZVdyYXBBc0Vycm9yKGUpLCB0cnVlLCB0cnVlKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIXByb21pc2UuX2lzRmF0ZVNlYWxlZCgpKSBwcm9taXNlLl9zZXRBc3luY0d1YXJhbnRlZWQoKTtcbiAgICAgICAgcmV0dXJuIHByb21pc2U7XG4gICAgfVxuICAgIHV0aWwubm90RW51bWVyYWJsZVByb3AocHJvbWlzaWZpZWQsIFwiX19pc1Byb21pc2lmaWVkX19cIiwgdHJ1ZSk7XG4gICAgcmV0dXJuIHByb21pc2lmaWVkO1xufVxuXG52YXIgbWFrZU5vZGVQcm9taXNpZmllZCA9IGNhbkV2YWx1YXRlXG4gICAgPyBtYWtlTm9kZVByb21pc2lmaWVkRXZhbFxuICAgIDogbWFrZU5vZGVQcm9taXNpZmllZENsb3N1cmU7XG5cbmZ1bmN0aW9uIHByb21pc2lmeUFsbChvYmosIHN1ZmZpeCwgZmlsdGVyLCBwcm9taXNpZmllciwgbXVsdGlBcmdzKSB7XG4gICAgdmFyIHN1ZmZpeFJlZ2V4cCA9IG5ldyBSZWdFeHAoZXNjYXBlSWRlbnRSZWdleChzdWZmaXgpICsgXCIkXCIpO1xuICAgIHZhciBtZXRob2RzID1cbiAgICAgICAgcHJvbWlzaWZpYWJsZU1ldGhvZHMob2JqLCBzdWZmaXgsIHN1ZmZpeFJlZ2V4cCwgZmlsdGVyKTtcblxuICAgIGZvciAodmFyIGkgPSAwLCBsZW4gPSBtZXRob2RzLmxlbmd0aDsgaSA8IGxlbjsgaSs9IDIpIHtcbiAgICAgICAgdmFyIGtleSA9IG1ldGhvZHNbaV07XG4gICAgICAgIHZhciBmbiA9IG1ldGhvZHNbaSsxXTtcbiAgICAgICAgdmFyIHByb21pc2lmaWVkS2V5ID0ga2V5ICsgc3VmZml4O1xuICAgICAgICBpZiAocHJvbWlzaWZpZXIgPT09IG1ha2VOb2RlUHJvbWlzaWZpZWQpIHtcbiAgICAgICAgICAgIG9ialtwcm9taXNpZmllZEtleV0gPVxuICAgICAgICAgICAgICAgIG1ha2VOb2RlUHJvbWlzaWZpZWQoa2V5LCBUSElTLCBrZXksIGZuLCBzdWZmaXgsIG11bHRpQXJncyk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB2YXIgcHJvbWlzaWZpZWQgPSBwcm9taXNpZmllcihmbiwgZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG1ha2VOb2RlUHJvbWlzaWZpZWQoa2V5LCBUSElTLCBrZXksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZm4sIHN1ZmZpeCwgbXVsdGlBcmdzKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgdXRpbC5ub3RFbnVtZXJhYmxlUHJvcChwcm9taXNpZmllZCwgXCJfX2lzUHJvbWlzaWZpZWRfX1wiLCB0cnVlKTtcbiAgICAgICAgICAgIG9ialtwcm9taXNpZmllZEtleV0gPSBwcm9taXNpZmllZDtcbiAgICAgICAgfVxuICAgIH1cbiAgICB1dGlsLnRvRmFzdFByb3BlcnRpZXMob2JqKTtcbiAgICByZXR1cm4gb2JqO1xufVxuXG5mdW5jdGlvbiBwcm9taXNpZnkoY2FsbGJhY2ssIHJlY2VpdmVyLCBtdWx0aUFyZ3MpIHtcbiAgICByZXR1cm4gbWFrZU5vZGVQcm9taXNpZmllZChjYWxsYmFjaywgcmVjZWl2ZXIsIHVuZGVmaW5lZCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FsbGJhY2ssIG51bGwsIG11bHRpQXJncyk7XG59XG5cblByb21pc2UucHJvbWlzaWZ5ID0gZnVuY3Rpb24gKGZuLCBvcHRpb25zKSB7XG4gICAgaWYgKHR5cGVvZiBmbiAhPT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJleHBlY3RpbmcgYSBmdW5jdGlvbiBidXQgZ290IFwiICsgdXRpbC5jbGFzc1N0cmluZyhmbikpO1xuICAgIH1cbiAgICBpZiAoaXNQcm9taXNpZmllZChmbikpIHtcbiAgICAgICAgcmV0dXJuIGZuO1xuICAgIH1cbiAgICBvcHRpb25zID0gT2JqZWN0KG9wdGlvbnMpO1xuICAgIHZhciByZWNlaXZlciA9IG9wdGlvbnMuY29udGV4dCA9PT0gdW5kZWZpbmVkID8gVEhJUyA6IG9wdGlvbnMuY29udGV4dDtcbiAgICB2YXIgbXVsdGlBcmdzID0gISFvcHRpb25zLm11bHRpQXJncztcbiAgICB2YXIgcmV0ID0gcHJvbWlzaWZ5KGZuLCByZWNlaXZlciwgbXVsdGlBcmdzKTtcbiAgICB1dGlsLmNvcHlEZXNjcmlwdG9ycyhmbiwgcmV0LCBwcm9wc0ZpbHRlcik7XG4gICAgcmV0dXJuIHJldDtcbn07XG5cblByb21pc2UucHJvbWlzaWZ5QWxsID0gZnVuY3Rpb24gKHRhcmdldCwgb3B0aW9ucykge1xuICAgIGlmICh0eXBlb2YgdGFyZ2V0ICE9PSBcImZ1bmN0aW9uXCIgJiYgdHlwZW9mIHRhcmdldCAhPT0gXCJvYmplY3RcIikge1xuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwidGhlIHRhcmdldCBvZiBwcm9taXNpZnlBbGwgbXVzdCBiZSBhbiBvYmplY3Qgb3IgYSBmdW5jdGlvblxcdTAwMGFcXHUwMDBhICAgIFNlZSBodHRwOi8vZ29vLmdsL01xckZtWFxcdTAwMGFcIik7XG4gICAgfVxuICAgIG9wdGlvbnMgPSBPYmplY3Qob3B0aW9ucyk7XG4gICAgdmFyIG11bHRpQXJncyA9ICEhb3B0aW9ucy5tdWx0aUFyZ3M7XG4gICAgdmFyIHN1ZmZpeCA9IG9wdGlvbnMuc3VmZml4O1xuICAgIGlmICh0eXBlb2Ygc3VmZml4ICE9PSBcInN0cmluZ1wiKSBzdWZmaXggPSBkZWZhdWx0U3VmZml4O1xuICAgIHZhciBmaWx0ZXIgPSBvcHRpb25zLmZpbHRlcjtcbiAgICBpZiAodHlwZW9mIGZpbHRlciAhPT0gXCJmdW5jdGlvblwiKSBmaWx0ZXIgPSBkZWZhdWx0RmlsdGVyO1xuICAgIHZhciBwcm9taXNpZmllciA9IG9wdGlvbnMucHJvbWlzaWZpZXI7XG4gICAgaWYgKHR5cGVvZiBwcm9taXNpZmllciAhPT0gXCJmdW5jdGlvblwiKSBwcm9taXNpZmllciA9IG1ha2VOb2RlUHJvbWlzaWZpZWQ7XG5cbiAgICBpZiAoIXV0aWwuaXNJZGVudGlmaWVyKHN1ZmZpeCkpIHtcbiAgICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoXCJzdWZmaXggbXVzdCBiZSBhIHZhbGlkIGlkZW50aWZpZXJcXHUwMDBhXFx1MDAwYSAgICBTZWUgaHR0cDovL2dvby5nbC9NcXJGbVhcXHUwMDBhXCIpO1xuICAgIH1cblxuICAgIHZhciBrZXlzID0gdXRpbC5pbmhlcml0ZWREYXRhS2V5cyh0YXJnZXQpO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwga2V5cy5sZW5ndGg7ICsraSkge1xuICAgICAgICB2YXIgdmFsdWUgPSB0YXJnZXRba2V5c1tpXV07XG4gICAgICAgIGlmIChrZXlzW2ldICE9PSBcImNvbnN0cnVjdG9yXCIgJiZcbiAgICAgICAgICAgIHV0aWwuaXNDbGFzcyh2YWx1ZSkpIHtcbiAgICAgICAgICAgIHByb21pc2lmeUFsbCh2YWx1ZS5wcm90b3R5cGUsIHN1ZmZpeCwgZmlsdGVyLCBwcm9taXNpZmllcixcbiAgICAgICAgICAgICAgICBtdWx0aUFyZ3MpO1xuICAgICAgICAgICAgcHJvbWlzaWZ5QWxsKHZhbHVlLCBzdWZmaXgsIGZpbHRlciwgcHJvbWlzaWZpZXIsIG11bHRpQXJncyk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gcHJvbWlzaWZ5QWxsKHRhcmdldCwgc3VmZml4LCBmaWx0ZXIsIHByb21pc2lmaWVyLCBtdWx0aUFyZ3MpO1xufTtcbn07XG5cblxufSx7XCIuL2Vycm9yc1wiOjEyLFwiLi9ub2RlYmFja1wiOjIwLFwiLi91dGlsXCI6MzZ9XSwyNTpbZnVuY3Rpb24oX2RlcmVxXyxtb2R1bGUsZXhwb3J0cyl7XG5cInVzZSBzdHJpY3RcIjtcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oXG4gICAgUHJvbWlzZSwgUHJvbWlzZUFycmF5LCB0cnlDb252ZXJ0VG9Qcm9taXNlLCBhcGlSZWplY3Rpb24pIHtcbnZhciB1dGlsID0gX2RlcmVxXyhcIi4vdXRpbFwiKTtcbnZhciBpc09iamVjdCA9IHV0aWwuaXNPYmplY3Q7XG52YXIgZXM1ID0gX2RlcmVxXyhcIi4vZXM1XCIpO1xudmFyIEVzNk1hcDtcbmlmICh0eXBlb2YgTWFwID09PSBcImZ1bmN0aW9uXCIpIEVzNk1hcCA9IE1hcDtcblxudmFyIG1hcFRvRW50cmllcyA9IChmdW5jdGlvbigpIHtcbiAgICB2YXIgaW5kZXggPSAwO1xuICAgIHZhciBzaXplID0gMDtcblxuICAgIGZ1bmN0aW9uIGV4dHJhY3RFbnRyeSh2YWx1ZSwga2V5KSB7XG4gICAgICAgIHRoaXNbaW5kZXhdID0gdmFsdWU7XG4gICAgICAgIHRoaXNbaW5kZXggKyBzaXplXSA9IGtleTtcbiAgICAgICAgaW5kZXgrKztcbiAgICB9XG5cbiAgICByZXR1cm4gZnVuY3Rpb24gbWFwVG9FbnRyaWVzKG1hcCkge1xuICAgICAgICBzaXplID0gbWFwLnNpemU7XG4gICAgICAgIGluZGV4ID0gMDtcbiAgICAgICAgdmFyIHJldCA9IG5ldyBBcnJheShtYXAuc2l6ZSAqIDIpO1xuICAgICAgICBtYXAuZm9yRWFjaChleHRyYWN0RW50cnksIHJldCk7XG4gICAgICAgIHJldHVybiByZXQ7XG4gICAgfTtcbn0pKCk7XG5cbnZhciBlbnRyaWVzVG9NYXAgPSBmdW5jdGlvbihlbnRyaWVzKSB7XG4gICAgdmFyIHJldCA9IG5ldyBFczZNYXAoKTtcbiAgICB2YXIgbGVuZ3RoID0gZW50cmllcy5sZW5ndGggLyAyIHwgMDtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbmd0aDsgKytpKSB7XG4gICAgICAgIHZhciBrZXkgPSBlbnRyaWVzW2xlbmd0aCArIGldO1xuICAgICAgICB2YXIgdmFsdWUgPSBlbnRyaWVzW2ldO1xuICAgICAgICByZXQuc2V0KGtleSwgdmFsdWUpO1xuICAgIH1cbiAgICByZXR1cm4gcmV0O1xufTtcblxuZnVuY3Rpb24gUHJvcGVydGllc1Byb21pc2VBcnJheShvYmopIHtcbiAgICB2YXIgaXNNYXAgPSBmYWxzZTtcbiAgICB2YXIgZW50cmllcztcbiAgICBpZiAoRXM2TWFwICE9PSB1bmRlZmluZWQgJiYgb2JqIGluc3RhbmNlb2YgRXM2TWFwKSB7XG4gICAgICAgIGVudHJpZXMgPSBtYXBUb0VudHJpZXMob2JqKTtcbiAgICAgICAgaXNNYXAgPSB0cnVlO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHZhciBrZXlzID0gZXM1LmtleXMob2JqKTtcbiAgICAgICAgdmFyIGxlbiA9IGtleXMubGVuZ3RoO1xuICAgICAgICBlbnRyaWVzID0gbmV3IEFycmF5KGxlbiAqIDIpO1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbjsgKytpKSB7XG4gICAgICAgICAgICB2YXIga2V5ID0ga2V5c1tpXTtcbiAgICAgICAgICAgIGVudHJpZXNbaV0gPSBvYmpba2V5XTtcbiAgICAgICAgICAgIGVudHJpZXNbaSArIGxlbl0gPSBrZXk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgdGhpcy5jb25zdHJ1Y3RvciQoZW50cmllcyk7XG4gICAgdGhpcy5faXNNYXAgPSBpc01hcDtcbiAgICB0aGlzLl9pbml0JCh1bmRlZmluZWQsIC0zKTtcbn1cbnV0aWwuaW5oZXJpdHMoUHJvcGVydGllc1Byb21pc2VBcnJheSwgUHJvbWlzZUFycmF5KTtcblxuUHJvcGVydGllc1Byb21pc2VBcnJheS5wcm90b3R5cGUuX2luaXQgPSBmdW5jdGlvbiAoKSB7fTtcblxuUHJvcGVydGllc1Byb21pc2VBcnJheS5wcm90b3R5cGUuX3Byb21pc2VGdWxmaWxsZWQgPSBmdW5jdGlvbiAodmFsdWUsIGluZGV4KSB7XG4gICAgdGhpcy5fdmFsdWVzW2luZGV4XSA9IHZhbHVlO1xuICAgIHZhciB0b3RhbFJlc29sdmVkID0gKyt0aGlzLl90b3RhbFJlc29sdmVkO1xuICAgIGlmICh0b3RhbFJlc29sdmVkID49IHRoaXMuX2xlbmd0aCkge1xuICAgICAgICB2YXIgdmFsO1xuICAgICAgICBpZiAodGhpcy5faXNNYXApIHtcbiAgICAgICAgICAgIHZhbCA9IGVudHJpZXNUb01hcCh0aGlzLl92YWx1ZXMpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdmFsID0ge307XG4gICAgICAgICAgICB2YXIga2V5T2Zmc2V0ID0gdGhpcy5sZW5ndGgoKTtcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwLCBsZW4gPSB0aGlzLmxlbmd0aCgpOyBpIDwgbGVuOyArK2kpIHtcbiAgICAgICAgICAgICAgICB2YWxbdGhpcy5fdmFsdWVzW2kgKyBrZXlPZmZzZXRdXSA9IHRoaXMuX3ZhbHVlc1tpXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB0aGlzLl9yZXNvbHZlKHZhbCk7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICByZXR1cm4gZmFsc2U7XG59O1xuXG5Qcm9wZXJ0aWVzUHJvbWlzZUFycmF5LnByb3RvdHlwZS5zaG91bGRDb3B5VmFsdWVzID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBmYWxzZTtcbn07XG5cblByb3BlcnRpZXNQcm9taXNlQXJyYXkucHJvdG90eXBlLmdldEFjdHVhbExlbmd0aCA9IGZ1bmN0aW9uIChsZW4pIHtcbiAgICByZXR1cm4gbGVuID4+IDE7XG59O1xuXG5mdW5jdGlvbiBwcm9wcyhwcm9taXNlcykge1xuICAgIHZhciByZXQ7XG4gICAgdmFyIGNhc3RWYWx1ZSA9IHRyeUNvbnZlcnRUb1Byb21pc2UocHJvbWlzZXMpO1xuXG4gICAgaWYgKCFpc09iamVjdChjYXN0VmFsdWUpKSB7XG4gICAgICAgIHJldHVybiBhcGlSZWplY3Rpb24oXCJjYW5ub3QgYXdhaXQgcHJvcGVydGllcyBvZiBhIG5vbi1vYmplY3RcXHUwMDBhXFx1MDAwYSAgICBTZWUgaHR0cDovL2dvby5nbC9NcXJGbVhcXHUwMDBhXCIpO1xuICAgIH0gZWxzZSBpZiAoY2FzdFZhbHVlIGluc3RhbmNlb2YgUHJvbWlzZSkge1xuICAgICAgICByZXQgPSBjYXN0VmFsdWUuX3RoZW4oXG4gICAgICAgICAgICBQcm9taXNlLnByb3BzLCB1bmRlZmluZWQsIHVuZGVmaW5lZCwgdW5kZWZpbmVkLCB1bmRlZmluZWQpO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHJldCA9IG5ldyBQcm9wZXJ0aWVzUHJvbWlzZUFycmF5KGNhc3RWYWx1ZSkucHJvbWlzZSgpO1xuICAgIH1cblxuICAgIGlmIChjYXN0VmFsdWUgaW5zdGFuY2VvZiBQcm9taXNlKSB7XG4gICAgICAgIHJldC5fcHJvcGFnYXRlRnJvbShjYXN0VmFsdWUsIDIpO1xuICAgIH1cbiAgICByZXR1cm4gcmV0O1xufVxuXG5Qcm9taXNlLnByb3RvdHlwZS5wcm9wcyA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gcHJvcHModGhpcyk7XG59O1xuXG5Qcm9taXNlLnByb3BzID0gZnVuY3Rpb24gKHByb21pc2VzKSB7XG4gICAgcmV0dXJuIHByb3BzKHByb21pc2VzKTtcbn07XG59O1xuXG59LHtcIi4vZXM1XCI6MTMsXCIuL3V0aWxcIjozNn1dLDI2OltmdW5jdGlvbihfZGVyZXFfLG1vZHVsZSxleHBvcnRzKXtcblwidXNlIHN0cmljdFwiO1xuZnVuY3Rpb24gYXJyYXlNb3ZlKHNyYywgc3JjSW5kZXgsIGRzdCwgZHN0SW5kZXgsIGxlbikge1xuICAgIGZvciAodmFyIGogPSAwOyBqIDwgbGVuOyArK2opIHtcbiAgICAgICAgZHN0W2ogKyBkc3RJbmRleF0gPSBzcmNbaiArIHNyY0luZGV4XTtcbiAgICAgICAgc3JjW2ogKyBzcmNJbmRleF0gPSB2b2lkIDA7XG4gICAgfVxufVxuXG5mdW5jdGlvbiBRdWV1ZShjYXBhY2l0eSkge1xuICAgIHRoaXMuX2NhcGFjaXR5ID0gY2FwYWNpdHk7XG4gICAgdGhpcy5fbGVuZ3RoID0gMDtcbiAgICB0aGlzLl9mcm9udCA9IDA7XG59XG5cblF1ZXVlLnByb3RvdHlwZS5fd2lsbEJlT3ZlckNhcGFjaXR5ID0gZnVuY3Rpb24gKHNpemUpIHtcbiAgICByZXR1cm4gdGhpcy5fY2FwYWNpdHkgPCBzaXplO1xufTtcblxuUXVldWUucHJvdG90eXBlLl9wdXNoT25lID0gZnVuY3Rpb24gKGFyZykge1xuICAgIHZhciBsZW5ndGggPSB0aGlzLmxlbmd0aCgpO1xuICAgIHRoaXMuX2NoZWNrQ2FwYWNpdHkobGVuZ3RoICsgMSk7XG4gICAgdmFyIGkgPSAodGhpcy5fZnJvbnQgKyBsZW5ndGgpICYgKHRoaXMuX2NhcGFjaXR5IC0gMSk7XG4gICAgdGhpc1tpXSA9IGFyZztcbiAgICB0aGlzLl9sZW5ndGggPSBsZW5ndGggKyAxO1xufTtcblxuUXVldWUucHJvdG90eXBlLl91bnNoaWZ0T25lID0gZnVuY3Rpb24odmFsdWUpIHtcbiAgICB2YXIgY2FwYWNpdHkgPSB0aGlzLl9jYXBhY2l0eTtcbiAgICB0aGlzLl9jaGVja0NhcGFjaXR5KHRoaXMubGVuZ3RoKCkgKyAxKTtcbiAgICB2YXIgZnJvbnQgPSB0aGlzLl9mcm9udDtcbiAgICB2YXIgaSA9ICgoKCggZnJvbnQgLSAxICkgJlxuICAgICAgICAgICAgICAgICAgICAoIGNhcGFjaXR5IC0gMSkgKSBeIGNhcGFjaXR5ICkgLSBjYXBhY2l0eSApO1xuICAgIHRoaXNbaV0gPSB2YWx1ZTtcbiAgICB0aGlzLl9mcm9udCA9IGk7XG4gICAgdGhpcy5fbGVuZ3RoID0gdGhpcy5sZW5ndGgoKSArIDE7XG59O1xuXG5RdWV1ZS5wcm90b3R5cGUudW5zaGlmdCA9IGZ1bmN0aW9uKGZuLCByZWNlaXZlciwgYXJnKSB7XG4gICAgdGhpcy5fdW5zaGlmdE9uZShhcmcpO1xuICAgIHRoaXMuX3Vuc2hpZnRPbmUocmVjZWl2ZXIpO1xuICAgIHRoaXMuX3Vuc2hpZnRPbmUoZm4pO1xufTtcblxuUXVldWUucHJvdG90eXBlLnB1c2ggPSBmdW5jdGlvbiAoZm4sIHJlY2VpdmVyLCBhcmcpIHtcbiAgICB2YXIgbGVuZ3RoID0gdGhpcy5sZW5ndGgoKSArIDM7XG4gICAgaWYgKHRoaXMuX3dpbGxCZU92ZXJDYXBhY2l0eShsZW5ndGgpKSB7XG4gICAgICAgIHRoaXMuX3B1c2hPbmUoZm4pO1xuICAgICAgICB0aGlzLl9wdXNoT25lKHJlY2VpdmVyKTtcbiAgICAgICAgdGhpcy5fcHVzaE9uZShhcmcpO1xuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIHZhciBqID0gdGhpcy5fZnJvbnQgKyBsZW5ndGggLSAzO1xuICAgIHRoaXMuX2NoZWNrQ2FwYWNpdHkobGVuZ3RoKTtcbiAgICB2YXIgd3JhcE1hc2sgPSB0aGlzLl9jYXBhY2l0eSAtIDE7XG4gICAgdGhpc1soaiArIDApICYgd3JhcE1hc2tdID0gZm47XG4gICAgdGhpc1soaiArIDEpICYgd3JhcE1hc2tdID0gcmVjZWl2ZXI7XG4gICAgdGhpc1soaiArIDIpICYgd3JhcE1hc2tdID0gYXJnO1xuICAgIHRoaXMuX2xlbmd0aCA9IGxlbmd0aDtcbn07XG5cblF1ZXVlLnByb3RvdHlwZS5zaGlmdCA9IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgZnJvbnQgPSB0aGlzLl9mcm9udCxcbiAgICAgICAgcmV0ID0gdGhpc1tmcm9udF07XG5cbiAgICB0aGlzW2Zyb250XSA9IHVuZGVmaW5lZDtcbiAgICB0aGlzLl9mcm9udCA9IChmcm9udCArIDEpICYgKHRoaXMuX2NhcGFjaXR5IC0gMSk7XG4gICAgdGhpcy5fbGVuZ3RoLS07XG4gICAgcmV0dXJuIHJldDtcbn07XG5cblF1ZXVlLnByb3RvdHlwZS5sZW5ndGggPSBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2xlbmd0aDtcbn07XG5cblF1ZXVlLnByb3RvdHlwZS5fY2hlY2tDYXBhY2l0eSA9IGZ1bmN0aW9uIChzaXplKSB7XG4gICAgaWYgKHRoaXMuX2NhcGFjaXR5IDwgc2l6ZSkge1xuICAgICAgICB0aGlzLl9yZXNpemVUbyh0aGlzLl9jYXBhY2l0eSA8PCAxKTtcbiAgICB9XG59O1xuXG5RdWV1ZS5wcm90b3R5cGUuX3Jlc2l6ZVRvID0gZnVuY3Rpb24gKGNhcGFjaXR5KSB7XG4gICAgdmFyIG9sZENhcGFjaXR5ID0gdGhpcy5fY2FwYWNpdHk7XG4gICAgdGhpcy5fY2FwYWNpdHkgPSBjYXBhY2l0eTtcbiAgICB2YXIgZnJvbnQgPSB0aGlzLl9mcm9udDtcbiAgICB2YXIgbGVuZ3RoID0gdGhpcy5fbGVuZ3RoO1xuICAgIHZhciBtb3ZlSXRlbXNDb3VudCA9IChmcm9udCArIGxlbmd0aCkgJiAob2xkQ2FwYWNpdHkgLSAxKTtcbiAgICBhcnJheU1vdmUodGhpcywgMCwgdGhpcywgb2xkQ2FwYWNpdHksIG1vdmVJdGVtc0NvdW50KTtcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gUXVldWU7XG5cbn0se31dLDI3OltmdW5jdGlvbihfZGVyZXFfLG1vZHVsZSxleHBvcnRzKXtcblwidXNlIHN0cmljdFwiO1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihcbiAgICBQcm9taXNlLCBJTlRFUk5BTCwgdHJ5Q29udmVydFRvUHJvbWlzZSwgYXBpUmVqZWN0aW9uKSB7XG52YXIgdXRpbCA9IF9kZXJlcV8oXCIuL3V0aWxcIik7XG5cbnZhciByYWNlTGF0ZXIgPSBmdW5jdGlvbiAocHJvbWlzZSkge1xuICAgIHJldHVybiBwcm9taXNlLnRoZW4oZnVuY3Rpb24oYXJyYXkpIHtcbiAgICAgICAgcmV0dXJuIHJhY2UoYXJyYXksIHByb21pc2UpO1xuICAgIH0pO1xufTtcblxuZnVuY3Rpb24gcmFjZShwcm9taXNlcywgcGFyZW50KSB7XG4gICAgdmFyIG1heWJlUHJvbWlzZSA9IHRyeUNvbnZlcnRUb1Byb21pc2UocHJvbWlzZXMpO1xuXG4gICAgaWYgKG1heWJlUHJvbWlzZSBpbnN0YW5jZW9mIFByb21pc2UpIHtcbiAgICAgICAgcmV0dXJuIHJhY2VMYXRlcihtYXliZVByb21pc2UpO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHByb21pc2VzID0gdXRpbC5hc0FycmF5KHByb21pc2VzKTtcbiAgICAgICAgaWYgKHByb21pc2VzID09PSBudWxsKVxuICAgICAgICAgICAgcmV0dXJuIGFwaVJlamVjdGlvbihcImV4cGVjdGluZyBhbiBhcnJheSBvciBhbiBpdGVyYWJsZSBvYmplY3QgYnV0IGdvdCBcIiArIHV0aWwuY2xhc3NTdHJpbmcocHJvbWlzZXMpKTtcbiAgICB9XG5cbiAgICB2YXIgcmV0ID0gbmV3IFByb21pc2UoSU5URVJOQUwpO1xuICAgIGlmIChwYXJlbnQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICByZXQuX3Byb3BhZ2F0ZUZyb20ocGFyZW50LCAzKTtcbiAgICB9XG4gICAgdmFyIGZ1bGZpbGwgPSByZXQuX2Z1bGZpbGw7XG4gICAgdmFyIHJlamVjdCA9IHJldC5fcmVqZWN0O1xuICAgIGZvciAodmFyIGkgPSAwLCBsZW4gPSBwcm9taXNlcy5sZW5ndGg7IGkgPCBsZW47ICsraSkge1xuICAgICAgICB2YXIgdmFsID0gcHJvbWlzZXNbaV07XG5cbiAgICAgICAgaWYgKHZhbCA9PT0gdW5kZWZpbmVkICYmICEoaSBpbiBwcm9taXNlcykpIHtcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG5cbiAgICAgICAgUHJvbWlzZS5jYXN0KHZhbCkuX3RoZW4oZnVsZmlsbCwgcmVqZWN0LCB1bmRlZmluZWQsIHJldCwgbnVsbCk7XG4gICAgfVxuICAgIHJldHVybiByZXQ7XG59XG5cblByb21pc2UucmFjZSA9IGZ1bmN0aW9uIChwcm9taXNlcykge1xuICAgIHJldHVybiByYWNlKHByb21pc2VzLCB1bmRlZmluZWQpO1xufTtcblxuUHJvbWlzZS5wcm90b3R5cGUucmFjZSA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gcmFjZSh0aGlzLCB1bmRlZmluZWQpO1xufTtcblxufTtcblxufSx7XCIuL3V0aWxcIjozNn1dLDI4OltmdW5jdGlvbihfZGVyZXFfLG1vZHVsZSxleHBvcnRzKXtcblwidXNlIHN0cmljdFwiO1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihQcm9taXNlLFxuICAgICAgICAgICAgICAgICAgICAgICAgICBQcm9taXNlQXJyYXksXG4gICAgICAgICAgICAgICAgICAgICAgICAgIGFwaVJlamVjdGlvbixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgdHJ5Q29udmVydFRvUHJvbWlzZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgSU5URVJOQUwsXG4gICAgICAgICAgICAgICAgICAgICAgICAgIGRlYnVnKSB7XG52YXIgZ2V0RG9tYWluID0gUHJvbWlzZS5fZ2V0RG9tYWluO1xudmFyIHV0aWwgPSBfZGVyZXFfKFwiLi91dGlsXCIpO1xudmFyIHRyeUNhdGNoID0gdXRpbC50cnlDYXRjaDtcblxuZnVuY3Rpb24gUmVkdWN0aW9uUHJvbWlzZUFycmF5KHByb21pc2VzLCBmbiwgaW5pdGlhbFZhbHVlLCBfZWFjaCkge1xuICAgIHRoaXMuY29uc3RydWN0b3IkKHByb21pc2VzKTtcbiAgICB2YXIgZG9tYWluID0gZ2V0RG9tYWluKCk7XG4gICAgdGhpcy5fZm4gPSBkb21haW4gPT09IG51bGwgPyBmbiA6IGRvbWFpbi5iaW5kKGZuKTtcbiAgICBpZiAoaW5pdGlhbFZhbHVlICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgaW5pdGlhbFZhbHVlID0gUHJvbWlzZS5yZXNvbHZlKGluaXRpYWxWYWx1ZSk7XG4gICAgICAgIGluaXRpYWxWYWx1ZS5fYXR0YWNoQ2FuY2VsbGF0aW9uQ2FsbGJhY2sodGhpcyk7XG4gICAgfVxuICAgIHRoaXMuX2luaXRpYWxWYWx1ZSA9IGluaXRpYWxWYWx1ZTtcbiAgICB0aGlzLl9jdXJyZW50Q2FuY2VsbGFibGUgPSBudWxsO1xuICAgIHRoaXMuX2VhY2hWYWx1ZXMgPSBfZWFjaCA9PT0gSU5URVJOQUwgPyBbXSA6IHVuZGVmaW5lZDtcbiAgICB0aGlzLl9wcm9taXNlLl9jYXB0dXJlU3RhY2tUcmFjZSgpO1xuICAgIHRoaXMuX2luaXQkKHVuZGVmaW5lZCwgLTUpO1xufVxudXRpbC5pbmhlcml0cyhSZWR1Y3Rpb25Qcm9taXNlQXJyYXksIFByb21pc2VBcnJheSk7XG5cblJlZHVjdGlvblByb21pc2VBcnJheS5wcm90b3R5cGUuX2dvdEFjY3VtID0gZnVuY3Rpb24oYWNjdW0pIHtcbiAgICBpZiAodGhpcy5fZWFjaFZhbHVlcyAhPT0gdW5kZWZpbmVkICYmIGFjY3VtICE9PSBJTlRFUk5BTCkge1xuICAgICAgICB0aGlzLl9lYWNoVmFsdWVzLnB1c2goYWNjdW0pO1xuICAgIH1cbn07XG5cblJlZHVjdGlvblByb21pc2VBcnJheS5wcm90b3R5cGUuX2VhY2hDb21wbGV0ZSA9IGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgdGhpcy5fZWFjaFZhbHVlcy5wdXNoKHZhbHVlKTtcbiAgICByZXR1cm4gdGhpcy5fZWFjaFZhbHVlcztcbn07XG5cblJlZHVjdGlvblByb21pc2VBcnJheS5wcm90b3R5cGUuX2luaXQgPSBmdW5jdGlvbigpIHt9O1xuXG5SZWR1Y3Rpb25Qcm9taXNlQXJyYXkucHJvdG90eXBlLl9yZXNvbHZlRW1wdHlBcnJheSA9IGZ1bmN0aW9uKCkge1xuICAgIHRoaXMuX3Jlc29sdmUodGhpcy5fZWFjaFZhbHVlcyAhPT0gdW5kZWZpbmVkID8gdGhpcy5fZWFjaFZhbHVlc1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDogdGhpcy5faW5pdGlhbFZhbHVlKTtcbn07XG5cblJlZHVjdGlvblByb21pc2VBcnJheS5wcm90b3R5cGUuc2hvdWxkQ29weVZhbHVlcyA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gZmFsc2U7XG59O1xuXG5SZWR1Y3Rpb25Qcm9taXNlQXJyYXkucHJvdG90eXBlLl9yZXNvbHZlID0gZnVuY3Rpb24odmFsdWUpIHtcbiAgICB0aGlzLl9wcm9taXNlLl9yZXNvbHZlQ2FsbGJhY2sodmFsdWUpO1xuICAgIHRoaXMuX3ZhbHVlcyA9IG51bGw7XG59O1xuXG5SZWR1Y3Rpb25Qcm9taXNlQXJyYXkucHJvdG90eXBlLl9yZXN1bHRDYW5jZWxsZWQgPSBmdW5jdGlvbihzZW5kZXIpIHtcbiAgICBpZiAoc2VuZGVyID09PSB0aGlzLl9pbml0aWFsVmFsdWUpIHJldHVybiB0aGlzLl9jYW5jZWwoKTtcbiAgICBpZiAodGhpcy5faXNSZXNvbHZlZCgpKSByZXR1cm47XG4gICAgdGhpcy5fcmVzdWx0Q2FuY2VsbGVkJCgpO1xuICAgIGlmICh0aGlzLl9jdXJyZW50Q2FuY2VsbGFibGUgaW5zdGFuY2VvZiBQcm9taXNlKSB7XG4gICAgICAgIHRoaXMuX2N1cnJlbnRDYW5jZWxsYWJsZS5jYW5jZWwoKTtcbiAgICB9XG4gICAgaWYgKHRoaXMuX2luaXRpYWxWYWx1ZSBpbnN0YW5jZW9mIFByb21pc2UpIHtcbiAgICAgICAgdGhpcy5faW5pdGlhbFZhbHVlLmNhbmNlbCgpO1xuICAgIH1cbn07XG5cblJlZHVjdGlvblByb21pc2VBcnJheS5wcm90b3R5cGUuX2l0ZXJhdGUgPSBmdW5jdGlvbiAodmFsdWVzKSB7XG4gICAgdGhpcy5fdmFsdWVzID0gdmFsdWVzO1xuICAgIHZhciB2YWx1ZTtcbiAgICB2YXIgaTtcbiAgICB2YXIgbGVuZ3RoID0gdmFsdWVzLmxlbmd0aDtcbiAgICBpZiAodGhpcy5faW5pdGlhbFZhbHVlICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgdmFsdWUgPSB0aGlzLl9pbml0aWFsVmFsdWU7XG4gICAgICAgIGkgPSAwO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHZhbHVlID0gUHJvbWlzZS5yZXNvbHZlKHZhbHVlc1swXSk7XG4gICAgICAgIGkgPSAxO1xuICAgIH1cblxuICAgIHRoaXMuX2N1cnJlbnRDYW5jZWxsYWJsZSA9IHZhbHVlO1xuXG4gICAgaWYgKCF2YWx1ZS5pc1JlamVjdGVkKCkpIHtcbiAgICAgICAgZm9yICg7IGkgPCBsZW5ndGg7ICsraSkge1xuICAgICAgICAgICAgdmFyIGN0eCA9IHtcbiAgICAgICAgICAgICAgICBhY2N1bTogbnVsbCxcbiAgICAgICAgICAgICAgICB2YWx1ZTogdmFsdWVzW2ldLFxuICAgICAgICAgICAgICAgIGluZGV4OiBpLFxuICAgICAgICAgICAgICAgIGxlbmd0aDogbGVuZ3RoLFxuICAgICAgICAgICAgICAgIGFycmF5OiB0aGlzXG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgdmFsdWUgPSB2YWx1ZS5fdGhlbihnb3RBY2N1bSwgdW5kZWZpbmVkLCB1bmRlZmluZWQsIGN0eCwgdW5kZWZpbmVkKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGlmICh0aGlzLl9lYWNoVmFsdWVzICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgdmFsdWUgPSB2YWx1ZVxuICAgICAgICAgICAgLl90aGVuKHRoaXMuX2VhY2hDb21wbGV0ZSwgdW5kZWZpbmVkLCB1bmRlZmluZWQsIHRoaXMsIHVuZGVmaW5lZCk7XG4gICAgfVxuICAgIHZhbHVlLl90aGVuKGNvbXBsZXRlZCwgY29tcGxldGVkLCB1bmRlZmluZWQsIHZhbHVlLCB0aGlzKTtcbn07XG5cblByb21pc2UucHJvdG90eXBlLnJlZHVjZSA9IGZ1bmN0aW9uIChmbiwgaW5pdGlhbFZhbHVlKSB7XG4gICAgcmV0dXJuIHJlZHVjZSh0aGlzLCBmbiwgaW5pdGlhbFZhbHVlLCBudWxsKTtcbn07XG5cblByb21pc2UucmVkdWNlID0gZnVuY3Rpb24gKHByb21pc2VzLCBmbiwgaW5pdGlhbFZhbHVlLCBfZWFjaCkge1xuICAgIHJldHVybiByZWR1Y2UocHJvbWlzZXMsIGZuLCBpbml0aWFsVmFsdWUsIF9lYWNoKTtcbn07XG5cbmZ1bmN0aW9uIGNvbXBsZXRlZCh2YWx1ZU9yUmVhc29uLCBhcnJheSkge1xuICAgIGlmICh0aGlzLmlzRnVsZmlsbGVkKCkpIHtcbiAgICAgICAgYXJyYXkuX3Jlc29sdmUodmFsdWVPclJlYXNvbik7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgYXJyYXkuX3JlamVjdCh2YWx1ZU9yUmVhc29uKTtcbiAgICB9XG59XG5cbmZ1bmN0aW9uIHJlZHVjZShwcm9taXNlcywgZm4sIGluaXRpYWxWYWx1ZSwgX2VhY2gpIHtcbiAgICBpZiAodHlwZW9mIGZuICE9PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgcmV0dXJuIGFwaVJlamVjdGlvbihcImV4cGVjdGluZyBhIGZ1bmN0aW9uIGJ1dCBnb3QgXCIgKyB1dGlsLmNsYXNzU3RyaW5nKGZuKSk7XG4gICAgfVxuICAgIHZhciBhcnJheSA9IG5ldyBSZWR1Y3Rpb25Qcm9taXNlQXJyYXkocHJvbWlzZXMsIGZuLCBpbml0aWFsVmFsdWUsIF9lYWNoKTtcbiAgICByZXR1cm4gYXJyYXkucHJvbWlzZSgpO1xufVxuXG5mdW5jdGlvbiBnb3RBY2N1bShhY2N1bSkge1xuICAgIHRoaXMuYWNjdW0gPSBhY2N1bTtcbiAgICB0aGlzLmFycmF5Ll9nb3RBY2N1bShhY2N1bSk7XG4gICAgdmFyIHZhbHVlID0gdHJ5Q29udmVydFRvUHJvbWlzZSh0aGlzLnZhbHVlLCB0aGlzLmFycmF5Ll9wcm9taXNlKTtcbiAgICBpZiAodmFsdWUgaW5zdGFuY2VvZiBQcm9taXNlKSB7XG4gICAgICAgIHRoaXMuYXJyYXkuX2N1cnJlbnRDYW5jZWxsYWJsZSA9IHZhbHVlO1xuICAgICAgICByZXR1cm4gdmFsdWUuX3RoZW4oZ290VmFsdWUsIHVuZGVmaW5lZCwgdW5kZWZpbmVkLCB0aGlzLCB1bmRlZmluZWQpO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBnb3RWYWx1ZS5jYWxsKHRoaXMsIHZhbHVlKTtcbiAgICB9XG59XG5cbmZ1bmN0aW9uIGdvdFZhbHVlKHZhbHVlKSB7XG4gICAgdmFyIGFycmF5ID0gdGhpcy5hcnJheTtcbiAgICB2YXIgcHJvbWlzZSA9IGFycmF5Ll9wcm9taXNlO1xuICAgIHZhciBmbiA9IHRyeUNhdGNoKGFycmF5Ll9mbik7XG4gICAgcHJvbWlzZS5fcHVzaENvbnRleHQoKTtcbiAgICB2YXIgcmV0O1xuICAgIGlmIChhcnJheS5fZWFjaFZhbHVlcyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHJldCA9IGZuLmNhbGwocHJvbWlzZS5fYm91bmRWYWx1ZSgpLCB2YWx1ZSwgdGhpcy5pbmRleCwgdGhpcy5sZW5ndGgpO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHJldCA9IGZuLmNhbGwocHJvbWlzZS5fYm91bmRWYWx1ZSgpLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5hY2N1bSwgdmFsdWUsIHRoaXMuaW5kZXgsIHRoaXMubGVuZ3RoKTtcbiAgICB9XG4gICAgaWYgKHJldCBpbnN0YW5jZW9mIFByb21pc2UpIHtcbiAgICAgICAgYXJyYXkuX2N1cnJlbnRDYW5jZWxsYWJsZSA9IHJldDtcbiAgICB9XG4gICAgdmFyIHByb21pc2VDcmVhdGVkID0gcHJvbWlzZS5fcG9wQ29udGV4dCgpO1xuICAgIGRlYnVnLmNoZWNrRm9yZ290dGVuUmV0dXJucyhcbiAgICAgICAgcmV0LFxuICAgICAgICBwcm9taXNlQ3JlYXRlZCxcbiAgICAgICAgYXJyYXkuX2VhY2hWYWx1ZXMgIT09IHVuZGVmaW5lZCA/IFwiUHJvbWlzZS5lYWNoXCIgOiBcIlByb21pc2UucmVkdWNlXCIsXG4gICAgICAgIHByb21pc2VcbiAgICApO1xuICAgIHJldHVybiByZXQ7XG59XG59O1xuXG59LHtcIi4vdXRpbFwiOjM2fV0sMjk6W2Z1bmN0aW9uKF9kZXJlcV8sbW9kdWxlLGV4cG9ydHMpe1xuXCJ1c2Ugc3RyaWN0XCI7XG52YXIgdXRpbCA9IF9kZXJlcV8oXCIuL3V0aWxcIik7XG52YXIgc2NoZWR1bGU7XG52YXIgbm9Bc3luY1NjaGVkdWxlciA9IGZ1bmN0aW9uKCkge1xuICAgIHRocm93IG5ldyBFcnJvcihcIk5vIGFzeW5jIHNjaGVkdWxlciBhdmFpbGFibGVcXHUwMDBhXFx1MDAwYSAgICBTZWUgaHR0cDovL2dvby5nbC9NcXJGbVhcXHUwMDBhXCIpO1xufTtcbmlmICh1dGlsLmlzTm9kZSAmJiB0eXBlb2YgTXV0YXRpb25PYnNlcnZlciA9PT0gXCJ1bmRlZmluZWRcIikge1xuICAgIHZhciBHbG9iYWxTZXRJbW1lZGlhdGUgPSBnbG9iYWwuc2V0SW1tZWRpYXRlO1xuICAgIHZhciBQcm9jZXNzTmV4dFRpY2sgPSBwcm9jZXNzLm5leHRUaWNrO1xuICAgIHNjaGVkdWxlID0gdXRpbC5pc1JlY2VudE5vZGVcbiAgICAgICAgICAgICAgICA/IGZ1bmN0aW9uKGZuKSB7IEdsb2JhbFNldEltbWVkaWF0ZS5jYWxsKGdsb2JhbCwgZm4pOyB9XG4gICAgICAgICAgICAgICAgOiBmdW5jdGlvbihmbikgeyBQcm9jZXNzTmV4dFRpY2suY2FsbChwcm9jZXNzLCBmbik7IH07XG59IGVsc2UgaWYgKCh0eXBlb2YgTXV0YXRpb25PYnNlcnZlciAhPT0gXCJ1bmRlZmluZWRcIikgJiZcbiAgICAgICAgICAhKHR5cGVvZiB3aW5kb3cgIT09IFwidW5kZWZpbmVkXCIgJiZcbiAgICAgICAgICAgIHdpbmRvdy5uYXZpZ2F0b3IgJiZcbiAgICAgICAgICAgIHdpbmRvdy5uYXZpZ2F0b3Iuc3RhbmRhbG9uZSkpIHtcbiAgICBzY2hlZHVsZSA9IGZ1bmN0aW9uKGZuKSB7XG4gICAgICAgIHZhciBkaXYgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiZGl2XCIpO1xuICAgICAgICB2YXIgb2JzZXJ2ZXIgPSBuZXcgTXV0YXRpb25PYnNlcnZlcihmbik7XG4gICAgICAgIG9ic2VydmVyLm9ic2VydmUoZGl2LCB7YXR0cmlidXRlczogdHJ1ZX0pO1xuICAgICAgICByZXR1cm4gZnVuY3Rpb24oKSB7IGRpdi5jbGFzc0xpc3QudG9nZ2xlKFwiZm9vXCIpOyB9O1xuICAgIH07XG4gICAgc2NoZWR1bGUuaXNTdGF0aWMgPSB0cnVlO1xufSBlbHNlIGlmICh0eXBlb2Ygc2V0SW1tZWRpYXRlICE9PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgc2NoZWR1bGUgPSBmdW5jdGlvbiAoZm4pIHtcbiAgICAgICAgc2V0SW1tZWRpYXRlKGZuKTtcbiAgICB9O1xufSBlbHNlIGlmICh0eXBlb2Ygc2V0VGltZW91dCAhPT0gXCJ1bmRlZmluZWRcIikge1xuICAgIHNjaGVkdWxlID0gZnVuY3Rpb24gKGZuKSB7XG4gICAgICAgIHNldFRpbWVvdXQoZm4sIDApO1xuICAgIH07XG59IGVsc2Uge1xuICAgIHNjaGVkdWxlID0gbm9Bc3luY1NjaGVkdWxlcjtcbn1cbm1vZHVsZS5leHBvcnRzID0gc2NoZWR1bGU7XG5cbn0se1wiLi91dGlsXCI6MzZ9XSwzMDpbZnVuY3Rpb24oX2RlcmVxXyxtb2R1bGUsZXhwb3J0cyl7XG5cInVzZSBzdHJpY3RcIjtcbm1vZHVsZS5leHBvcnRzID1cbiAgICBmdW5jdGlvbihQcm9taXNlLCBQcm9taXNlQXJyYXksIGRlYnVnKSB7XG52YXIgUHJvbWlzZUluc3BlY3Rpb24gPSBQcm9taXNlLlByb21pc2VJbnNwZWN0aW9uO1xudmFyIHV0aWwgPSBfZGVyZXFfKFwiLi91dGlsXCIpO1xuXG5mdW5jdGlvbiBTZXR0bGVkUHJvbWlzZUFycmF5KHZhbHVlcykge1xuICAgIHRoaXMuY29uc3RydWN0b3IkKHZhbHVlcyk7XG59XG51dGlsLmluaGVyaXRzKFNldHRsZWRQcm9taXNlQXJyYXksIFByb21pc2VBcnJheSk7XG5cblNldHRsZWRQcm9taXNlQXJyYXkucHJvdG90eXBlLl9wcm9taXNlUmVzb2x2ZWQgPSBmdW5jdGlvbiAoaW5kZXgsIGluc3BlY3Rpb24pIHtcbiAgICB0aGlzLl92YWx1ZXNbaW5kZXhdID0gaW5zcGVjdGlvbjtcbiAgICB2YXIgdG90YWxSZXNvbHZlZCA9ICsrdGhpcy5fdG90YWxSZXNvbHZlZDtcbiAgICBpZiAodG90YWxSZXNvbHZlZCA+PSB0aGlzLl9sZW5ndGgpIHtcbiAgICAgICAgdGhpcy5fcmVzb2x2ZSh0aGlzLl92YWx1ZXMpO1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlO1xufTtcblxuU2V0dGxlZFByb21pc2VBcnJheS5wcm90b3R5cGUuX3Byb21pc2VGdWxmaWxsZWQgPSBmdW5jdGlvbiAodmFsdWUsIGluZGV4KSB7XG4gICAgdmFyIHJldCA9IG5ldyBQcm9taXNlSW5zcGVjdGlvbigpO1xuICAgIHJldC5fYml0RmllbGQgPSAzMzU1NDQzMjtcbiAgICByZXQuX3NldHRsZWRWYWx1ZUZpZWxkID0gdmFsdWU7XG4gICAgcmV0dXJuIHRoaXMuX3Byb21pc2VSZXNvbHZlZChpbmRleCwgcmV0KTtcbn07XG5TZXR0bGVkUHJvbWlzZUFycmF5LnByb3RvdHlwZS5fcHJvbWlzZVJlamVjdGVkID0gZnVuY3Rpb24gKHJlYXNvbiwgaW5kZXgpIHtcbiAgICB2YXIgcmV0ID0gbmV3IFByb21pc2VJbnNwZWN0aW9uKCk7XG4gICAgcmV0Ll9iaXRGaWVsZCA9IDE2Nzc3MjE2O1xuICAgIHJldC5fc2V0dGxlZFZhbHVlRmllbGQgPSByZWFzb247XG4gICAgcmV0dXJuIHRoaXMuX3Byb21pc2VSZXNvbHZlZChpbmRleCwgcmV0KTtcbn07XG5cblByb21pc2Uuc2V0dGxlID0gZnVuY3Rpb24gKHByb21pc2VzKSB7XG4gICAgZGVidWcuZGVwcmVjYXRlZChcIi5zZXR0bGUoKVwiLCBcIi5yZWZsZWN0KClcIik7XG4gICAgcmV0dXJuIG5ldyBTZXR0bGVkUHJvbWlzZUFycmF5KHByb21pc2VzKS5wcm9taXNlKCk7XG59O1xuXG5Qcm9taXNlLnByb3RvdHlwZS5zZXR0bGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIFByb21pc2Uuc2V0dGxlKHRoaXMpO1xufTtcbn07XG5cbn0se1wiLi91dGlsXCI6MzZ9XSwzMTpbZnVuY3Rpb24oX2RlcmVxXyxtb2R1bGUsZXhwb3J0cyl7XG5cInVzZSBzdHJpY3RcIjtcbm1vZHVsZS5leHBvcnRzID1cbmZ1bmN0aW9uKFByb21pc2UsIFByb21pc2VBcnJheSwgYXBpUmVqZWN0aW9uKSB7XG52YXIgdXRpbCA9IF9kZXJlcV8oXCIuL3V0aWxcIik7XG52YXIgUmFuZ2VFcnJvciA9IF9kZXJlcV8oXCIuL2Vycm9yc1wiKS5SYW5nZUVycm9yO1xudmFyIEFnZ3JlZ2F0ZUVycm9yID0gX2RlcmVxXyhcIi4vZXJyb3JzXCIpLkFnZ3JlZ2F0ZUVycm9yO1xudmFyIGlzQXJyYXkgPSB1dGlsLmlzQXJyYXk7XG52YXIgQ0FOQ0VMTEFUSU9OID0ge307XG5cblxuZnVuY3Rpb24gU29tZVByb21pc2VBcnJheSh2YWx1ZXMpIHtcbiAgICB0aGlzLmNvbnN0cnVjdG9yJCh2YWx1ZXMpO1xuICAgIHRoaXMuX2hvd01hbnkgPSAwO1xuICAgIHRoaXMuX3Vud3JhcCA9IGZhbHNlO1xuICAgIHRoaXMuX2luaXRpYWxpemVkID0gZmFsc2U7XG59XG51dGlsLmluaGVyaXRzKFNvbWVQcm9taXNlQXJyYXksIFByb21pc2VBcnJheSk7XG5cblNvbWVQcm9taXNlQXJyYXkucHJvdG90eXBlLl9pbml0ID0gZnVuY3Rpb24gKCkge1xuICAgIGlmICghdGhpcy5faW5pdGlhbGl6ZWQpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAodGhpcy5faG93TWFueSA9PT0gMCkge1xuICAgICAgICB0aGlzLl9yZXNvbHZlKFtdKTtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB0aGlzLl9pbml0JCh1bmRlZmluZWQsIC01KTtcbiAgICB2YXIgaXNBcnJheVJlc29sdmVkID0gaXNBcnJheSh0aGlzLl92YWx1ZXMpO1xuICAgIGlmICghdGhpcy5faXNSZXNvbHZlZCgpICYmXG4gICAgICAgIGlzQXJyYXlSZXNvbHZlZCAmJlxuICAgICAgICB0aGlzLl9ob3dNYW55ID4gdGhpcy5fY2FuUG9zc2libHlGdWxmaWxsKCkpIHtcbiAgICAgICAgdGhpcy5fcmVqZWN0KHRoaXMuX2dldFJhbmdlRXJyb3IodGhpcy5sZW5ndGgoKSkpO1xuICAgIH1cbn07XG5cblNvbWVQcm9taXNlQXJyYXkucHJvdG90eXBlLmluaXQgPSBmdW5jdGlvbiAoKSB7XG4gICAgdGhpcy5faW5pdGlhbGl6ZWQgPSB0cnVlO1xuICAgIHRoaXMuX2luaXQoKTtcbn07XG5cblNvbWVQcm9taXNlQXJyYXkucHJvdG90eXBlLnNldFVud3JhcCA9IGZ1bmN0aW9uICgpIHtcbiAgICB0aGlzLl91bndyYXAgPSB0cnVlO1xufTtcblxuU29tZVByb21pc2VBcnJheS5wcm90b3R5cGUuaG93TWFueSA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gdGhpcy5faG93TWFueTtcbn07XG5cblNvbWVQcm9taXNlQXJyYXkucHJvdG90eXBlLnNldEhvd01hbnkgPSBmdW5jdGlvbiAoY291bnQpIHtcbiAgICB0aGlzLl9ob3dNYW55ID0gY291bnQ7XG59O1xuXG5Tb21lUHJvbWlzZUFycmF5LnByb3RvdHlwZS5fcHJvbWlzZUZ1bGZpbGxlZCA9IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgIHRoaXMuX2FkZEZ1bGZpbGxlZCh2YWx1ZSk7XG4gICAgaWYgKHRoaXMuX2Z1bGZpbGxlZCgpID09PSB0aGlzLmhvd01hbnkoKSkge1xuICAgICAgICB0aGlzLl92YWx1ZXMubGVuZ3RoID0gdGhpcy5ob3dNYW55KCk7XG4gICAgICAgIGlmICh0aGlzLmhvd01hbnkoKSA9PT0gMSAmJiB0aGlzLl91bndyYXApIHtcbiAgICAgICAgICAgIHRoaXMuX3Jlc29sdmUodGhpcy5fdmFsdWVzWzBdKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuX3Jlc29sdmUodGhpcy5fdmFsdWVzKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlO1xuXG59O1xuU29tZVByb21pc2VBcnJheS5wcm90b3R5cGUuX3Byb21pc2VSZWplY3RlZCA9IGZ1bmN0aW9uIChyZWFzb24pIHtcbiAgICB0aGlzLl9hZGRSZWplY3RlZChyZWFzb24pO1xuICAgIHJldHVybiB0aGlzLl9jaGVja091dGNvbWUoKTtcbn07XG5cblNvbWVQcm9taXNlQXJyYXkucHJvdG90eXBlLl9wcm9taXNlQ2FuY2VsbGVkID0gZnVuY3Rpb24gKCkge1xuICAgIGlmICh0aGlzLl92YWx1ZXMgaW5zdGFuY2VvZiBQcm9taXNlIHx8IHRoaXMuX3ZhbHVlcyA9PSBudWxsKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9jYW5jZWwoKTtcbiAgICB9XG4gICAgdGhpcy5fYWRkUmVqZWN0ZWQoQ0FOQ0VMTEFUSU9OKTtcbiAgICByZXR1cm4gdGhpcy5fY2hlY2tPdXRjb21lKCk7XG59O1xuXG5Tb21lUHJvbWlzZUFycmF5LnByb3RvdHlwZS5fY2hlY2tPdXRjb21lID0gZnVuY3Rpb24oKSB7XG4gICAgaWYgKHRoaXMuaG93TWFueSgpID4gdGhpcy5fY2FuUG9zc2libHlGdWxmaWxsKCkpIHtcbiAgICAgICAgdmFyIGUgPSBuZXcgQWdncmVnYXRlRXJyb3IoKTtcbiAgICAgICAgZm9yICh2YXIgaSA9IHRoaXMubGVuZ3RoKCk7IGkgPCB0aGlzLl92YWx1ZXMubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLl92YWx1ZXNbaV0gIT09IENBTkNFTExBVElPTikge1xuICAgICAgICAgICAgICAgIGUucHVzaCh0aGlzLl92YWx1ZXNbaV0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChlLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgIHRoaXMuX3JlamVjdChlKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuX2NhbmNlbCgpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICByZXR1cm4gZmFsc2U7XG59O1xuXG5Tb21lUHJvbWlzZUFycmF5LnByb3RvdHlwZS5fZnVsZmlsbGVkID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiB0aGlzLl90b3RhbFJlc29sdmVkO1xufTtcblxuU29tZVByb21pc2VBcnJheS5wcm90b3R5cGUuX3JlamVjdGVkID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiB0aGlzLl92YWx1ZXMubGVuZ3RoIC0gdGhpcy5sZW5ndGgoKTtcbn07XG5cblNvbWVQcm9taXNlQXJyYXkucHJvdG90eXBlLl9hZGRSZWplY3RlZCA9IGZ1bmN0aW9uIChyZWFzb24pIHtcbiAgICB0aGlzLl92YWx1ZXMucHVzaChyZWFzb24pO1xufTtcblxuU29tZVByb21pc2VBcnJheS5wcm90b3R5cGUuX2FkZEZ1bGZpbGxlZCA9IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgIHRoaXMuX3ZhbHVlc1t0aGlzLl90b3RhbFJlc29sdmVkKytdID0gdmFsdWU7XG59O1xuXG5Tb21lUHJvbWlzZUFycmF5LnByb3RvdHlwZS5fY2FuUG9zc2libHlGdWxmaWxsID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiB0aGlzLmxlbmd0aCgpIC0gdGhpcy5fcmVqZWN0ZWQoKTtcbn07XG5cblNvbWVQcm9taXNlQXJyYXkucHJvdG90eXBlLl9nZXRSYW5nZUVycm9yID0gZnVuY3Rpb24gKGNvdW50KSB7XG4gICAgdmFyIG1lc3NhZ2UgPSBcIklucHV0IGFycmF5IG11c3QgY29udGFpbiBhdCBsZWFzdCBcIiArXG4gICAgICAgICAgICB0aGlzLl9ob3dNYW55ICsgXCIgaXRlbXMgYnV0IGNvbnRhaW5zIG9ubHkgXCIgKyBjb3VudCArIFwiIGl0ZW1zXCI7XG4gICAgcmV0dXJuIG5ldyBSYW5nZUVycm9yKG1lc3NhZ2UpO1xufTtcblxuU29tZVByb21pc2VBcnJheS5wcm90b3R5cGUuX3Jlc29sdmVFbXB0eUFycmF5ID0gZnVuY3Rpb24gKCkge1xuICAgIHRoaXMuX3JlamVjdCh0aGlzLl9nZXRSYW5nZUVycm9yKDApKTtcbn07XG5cbmZ1bmN0aW9uIHNvbWUocHJvbWlzZXMsIGhvd01hbnkpIHtcbiAgICBpZiAoKGhvd01hbnkgfCAwKSAhPT0gaG93TWFueSB8fCBob3dNYW55IDwgMCkge1xuICAgICAgICByZXR1cm4gYXBpUmVqZWN0aW9uKFwiZXhwZWN0aW5nIGEgcG9zaXRpdmUgaW50ZWdlclxcdTAwMGFcXHUwMDBhICAgIFNlZSBodHRwOi8vZ29vLmdsL01xckZtWFxcdTAwMGFcIik7XG4gICAgfVxuICAgIHZhciByZXQgPSBuZXcgU29tZVByb21pc2VBcnJheShwcm9taXNlcyk7XG4gICAgdmFyIHByb21pc2UgPSByZXQucHJvbWlzZSgpO1xuICAgIHJldC5zZXRIb3dNYW55KGhvd01hbnkpO1xuICAgIHJldC5pbml0KCk7XG4gICAgcmV0dXJuIHByb21pc2U7XG59XG5cblByb21pc2Uuc29tZSA9IGZ1bmN0aW9uIChwcm9taXNlcywgaG93TWFueSkge1xuICAgIHJldHVybiBzb21lKHByb21pc2VzLCBob3dNYW55KTtcbn07XG5cblByb21pc2UucHJvdG90eXBlLnNvbWUgPSBmdW5jdGlvbiAoaG93TWFueSkge1xuICAgIHJldHVybiBzb21lKHRoaXMsIGhvd01hbnkpO1xufTtcblxuUHJvbWlzZS5fU29tZVByb21pc2VBcnJheSA9IFNvbWVQcm9taXNlQXJyYXk7XG59O1xuXG59LHtcIi4vZXJyb3JzXCI6MTIsXCIuL3V0aWxcIjozNn1dLDMyOltmdW5jdGlvbihfZGVyZXFfLG1vZHVsZSxleHBvcnRzKXtcblwidXNlIHN0cmljdFwiO1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihQcm9taXNlKSB7XG5mdW5jdGlvbiBQcm9taXNlSW5zcGVjdGlvbihwcm9taXNlKSB7XG4gICAgaWYgKHByb21pc2UgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICBwcm9taXNlID0gcHJvbWlzZS5fdGFyZ2V0KCk7XG4gICAgICAgIHRoaXMuX2JpdEZpZWxkID0gcHJvbWlzZS5fYml0RmllbGQ7XG4gICAgICAgIHRoaXMuX3NldHRsZWRWYWx1ZUZpZWxkID0gcHJvbWlzZS5faXNGYXRlU2VhbGVkKClcbiAgICAgICAgICAgID8gcHJvbWlzZS5fc2V0dGxlZFZhbHVlKCkgOiB1bmRlZmluZWQ7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICB0aGlzLl9iaXRGaWVsZCA9IDA7XG4gICAgICAgIHRoaXMuX3NldHRsZWRWYWx1ZUZpZWxkID0gdW5kZWZpbmVkO1xuICAgIH1cbn1cblxuUHJvbWlzZUluc3BlY3Rpb24ucHJvdG90eXBlLl9zZXR0bGVkVmFsdWUgPSBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gdGhpcy5fc2V0dGxlZFZhbHVlRmllbGQ7XG59O1xuXG52YXIgdmFsdWUgPSBQcm9taXNlSW5zcGVjdGlvbi5wcm90b3R5cGUudmFsdWUgPSBmdW5jdGlvbiAoKSB7XG4gICAgaWYgKCF0aGlzLmlzRnVsZmlsbGVkKCkpIHtcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcImNhbm5vdCBnZXQgZnVsZmlsbG1lbnQgdmFsdWUgb2YgYSBub24tZnVsZmlsbGVkIHByb21pc2VcXHUwMDBhXFx1MDAwYSAgICBTZWUgaHR0cDovL2dvby5nbC9NcXJGbVhcXHUwMDBhXCIpO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5fc2V0dGxlZFZhbHVlKCk7XG59O1xuXG52YXIgcmVhc29uID0gUHJvbWlzZUluc3BlY3Rpb24ucHJvdG90eXBlLmVycm9yID1cblByb21pc2VJbnNwZWN0aW9uLnByb3RvdHlwZS5yZWFzb24gPSBmdW5jdGlvbiAoKSB7XG4gICAgaWYgKCF0aGlzLmlzUmVqZWN0ZWQoKSkge1xuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiY2Fubm90IGdldCByZWplY3Rpb24gcmVhc29uIG9mIGEgbm9uLXJlamVjdGVkIHByb21pc2VcXHUwMDBhXFx1MDAwYSAgICBTZWUgaHR0cDovL2dvby5nbC9NcXJGbVhcXHUwMDBhXCIpO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5fc2V0dGxlZFZhbHVlKCk7XG59O1xuXG52YXIgaXNGdWxmaWxsZWQgPSBQcm9taXNlSW5zcGVjdGlvbi5wcm90b3R5cGUuaXNGdWxmaWxsZWQgPSBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gKHRoaXMuX2JpdEZpZWxkICYgMzM1NTQ0MzIpICE9PSAwO1xufTtcblxudmFyIGlzUmVqZWN0ZWQgPSBQcm9taXNlSW5zcGVjdGlvbi5wcm90b3R5cGUuaXNSZWplY3RlZCA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gKHRoaXMuX2JpdEZpZWxkICYgMTY3NzcyMTYpICE9PSAwO1xufTtcblxudmFyIGlzUGVuZGluZyA9IFByb21pc2VJbnNwZWN0aW9uLnByb3RvdHlwZS5pc1BlbmRpbmcgPSBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuICh0aGlzLl9iaXRGaWVsZCAmIDUwMzk3MTg0KSA9PT0gMDtcbn07XG5cbnZhciBpc1Jlc29sdmVkID0gUHJvbWlzZUluc3BlY3Rpb24ucHJvdG90eXBlLmlzUmVzb2x2ZWQgPSBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuICh0aGlzLl9iaXRGaWVsZCAmIDUwMzMxNjQ4KSAhPT0gMDtcbn07XG5cblByb21pc2VJbnNwZWN0aW9uLnByb3RvdHlwZS5pc0NhbmNlbGxlZCA9XG5Qcm9taXNlLnByb3RvdHlwZS5faXNDYW5jZWxsZWQgPSBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gKHRoaXMuX2JpdEZpZWxkICYgNjU1MzYpID09PSA2NTUzNjtcbn07XG5cblByb21pc2UucHJvdG90eXBlLmlzQ2FuY2VsbGVkID0gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIHRoaXMuX3RhcmdldCgpLl9pc0NhbmNlbGxlZCgpO1xufTtcblxuUHJvbWlzZS5wcm90b3R5cGUuaXNQZW5kaW5nID0gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIGlzUGVuZGluZy5jYWxsKHRoaXMuX3RhcmdldCgpKTtcbn07XG5cblByb21pc2UucHJvdG90eXBlLmlzUmVqZWN0ZWQgPSBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gaXNSZWplY3RlZC5jYWxsKHRoaXMuX3RhcmdldCgpKTtcbn07XG5cblByb21pc2UucHJvdG90eXBlLmlzRnVsZmlsbGVkID0gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIGlzRnVsZmlsbGVkLmNhbGwodGhpcy5fdGFyZ2V0KCkpO1xufTtcblxuUHJvbWlzZS5wcm90b3R5cGUuaXNSZXNvbHZlZCA9IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiBpc1Jlc29sdmVkLmNhbGwodGhpcy5fdGFyZ2V0KCkpO1xufTtcblxuUHJvbWlzZS5wcm90b3R5cGUudmFsdWUgPSBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gdmFsdWUuY2FsbCh0aGlzLl90YXJnZXQoKSk7XG59O1xuXG5Qcm9taXNlLnByb3RvdHlwZS5yZWFzb24gPSBmdW5jdGlvbigpIHtcbiAgICB2YXIgdGFyZ2V0ID0gdGhpcy5fdGFyZ2V0KCk7XG4gICAgdGFyZ2V0Ll91bnNldFJlamVjdGlvbklzVW5oYW5kbGVkKCk7XG4gICAgcmV0dXJuIHJlYXNvbi5jYWxsKHRhcmdldCk7XG59O1xuXG5Qcm9taXNlLnByb3RvdHlwZS5fdmFsdWUgPSBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gdGhpcy5fc2V0dGxlZFZhbHVlKCk7XG59O1xuXG5Qcm9taXNlLnByb3RvdHlwZS5fcmVhc29uID0gZnVuY3Rpb24oKSB7XG4gICAgdGhpcy5fdW5zZXRSZWplY3Rpb25Jc1VuaGFuZGxlZCgpO1xuICAgIHJldHVybiB0aGlzLl9zZXR0bGVkVmFsdWUoKTtcbn07XG5cblByb21pc2UuUHJvbWlzZUluc3BlY3Rpb24gPSBQcm9taXNlSW5zcGVjdGlvbjtcbn07XG5cbn0se31dLDMzOltmdW5jdGlvbihfZGVyZXFfLG1vZHVsZSxleHBvcnRzKXtcblwidXNlIHN0cmljdFwiO1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihQcm9taXNlLCBJTlRFUk5BTCkge1xudmFyIHV0aWwgPSBfZGVyZXFfKFwiLi91dGlsXCIpO1xudmFyIGVycm9yT2JqID0gdXRpbC5lcnJvck9iajtcbnZhciBpc09iamVjdCA9IHV0aWwuaXNPYmplY3Q7XG5cbmZ1bmN0aW9uIHRyeUNvbnZlcnRUb1Byb21pc2Uob2JqLCBjb250ZXh0KSB7XG4gICAgaWYgKGlzT2JqZWN0KG9iaikpIHtcbiAgICAgICAgaWYgKG9iaiBpbnN0YW5jZW9mIFByb21pc2UpIHJldHVybiBvYmo7XG4gICAgICAgIHZhciB0aGVuID0gZ2V0VGhlbihvYmopO1xuICAgICAgICBpZiAodGhlbiA9PT0gZXJyb3JPYmopIHtcbiAgICAgICAgICAgIGlmIChjb250ZXh0KSBjb250ZXh0Ll9wdXNoQ29udGV4dCgpO1xuICAgICAgICAgICAgdmFyIHJldCA9IFByb21pc2UucmVqZWN0KHRoZW4uZSk7XG4gICAgICAgICAgICBpZiAoY29udGV4dCkgY29udGV4dC5fcG9wQ29udGV4dCgpO1xuICAgICAgICAgICAgcmV0dXJuIHJldDtcbiAgICAgICAgfSBlbHNlIGlmICh0eXBlb2YgdGhlbiA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgICAgICBpZiAoaXNBbnlCbHVlYmlyZFByb21pc2Uob2JqKSkge1xuICAgICAgICAgICAgICAgIHZhciByZXQgPSBuZXcgUHJvbWlzZShJTlRFUk5BTCk7XG4gICAgICAgICAgICAgICAgb2JqLl90aGVuKFxuICAgICAgICAgICAgICAgICAgICByZXQuX2Z1bGZpbGwsXG4gICAgICAgICAgICAgICAgICAgIHJldC5fcmVqZWN0LFxuICAgICAgICAgICAgICAgICAgICB1bmRlZmluZWQsXG4gICAgICAgICAgICAgICAgICAgIHJldCxcbiAgICAgICAgICAgICAgICAgICAgbnVsbFxuICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHJldDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBkb1RoZW5hYmxlKG9iaiwgdGhlbiwgY29udGV4dCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIG9iajtcbn1cblxuZnVuY3Rpb24gZG9HZXRUaGVuKG9iaikge1xuICAgIHJldHVybiBvYmoudGhlbjtcbn1cblxuZnVuY3Rpb24gZ2V0VGhlbihvYmopIHtcbiAgICB0cnkge1xuICAgICAgICByZXR1cm4gZG9HZXRUaGVuKG9iaik7XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgICBlcnJvck9iai5lID0gZTtcbiAgICAgICAgcmV0dXJuIGVycm9yT2JqO1xuICAgIH1cbn1cblxudmFyIGhhc1Byb3AgPSB7fS5oYXNPd25Qcm9wZXJ0eTtcbmZ1bmN0aW9uIGlzQW55Qmx1ZWJpcmRQcm9taXNlKG9iaikge1xuICAgIHJldHVybiBoYXNQcm9wLmNhbGwob2JqLCBcIl9wcm9taXNlMFwiKTtcbn1cblxuZnVuY3Rpb24gZG9UaGVuYWJsZSh4LCB0aGVuLCBjb250ZXh0KSB7XG4gICAgdmFyIHByb21pc2UgPSBuZXcgUHJvbWlzZShJTlRFUk5BTCk7XG4gICAgdmFyIHJldCA9IHByb21pc2U7XG4gICAgaWYgKGNvbnRleHQpIGNvbnRleHQuX3B1c2hDb250ZXh0KCk7XG4gICAgcHJvbWlzZS5fY2FwdHVyZVN0YWNrVHJhY2UoKTtcbiAgICBpZiAoY29udGV4dCkgY29udGV4dC5fcG9wQ29udGV4dCgpO1xuICAgIHZhciBzeW5jaHJvbm91cyA9IHRydWU7XG4gICAgdmFyIHJlc3VsdCA9IHV0aWwudHJ5Q2F0Y2godGhlbikuY2FsbCh4LCByZXNvbHZlLCByZWplY3QpO1xuICAgIHN5bmNocm9ub3VzID0gZmFsc2U7XG5cbiAgICBpZiAocHJvbWlzZSAmJiByZXN1bHQgPT09IGVycm9yT2JqKSB7XG4gICAgICAgIHByb21pc2UuX3JlamVjdENhbGxiYWNrKHJlc3VsdC5lLCB0cnVlLCB0cnVlKTtcbiAgICAgICAgcHJvbWlzZSA9IG51bGw7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gcmVzb2x2ZSh2YWx1ZSkge1xuICAgICAgICBpZiAoIXByb21pc2UpIHJldHVybjtcbiAgICAgICAgcHJvbWlzZS5fcmVzb2x2ZUNhbGxiYWNrKHZhbHVlKTtcbiAgICAgICAgcHJvbWlzZSA9IG51bGw7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gcmVqZWN0KHJlYXNvbikge1xuICAgICAgICBpZiAoIXByb21pc2UpIHJldHVybjtcbiAgICAgICAgcHJvbWlzZS5fcmVqZWN0Q2FsbGJhY2socmVhc29uLCBzeW5jaHJvbm91cywgdHJ1ZSk7XG4gICAgICAgIHByb21pc2UgPSBudWxsO1xuICAgIH1cbiAgICByZXR1cm4gcmV0O1xufVxuXG5yZXR1cm4gdHJ5Q29udmVydFRvUHJvbWlzZTtcbn07XG5cbn0se1wiLi91dGlsXCI6MzZ9XSwzNDpbZnVuY3Rpb24oX2RlcmVxXyxtb2R1bGUsZXhwb3J0cyl7XG5cInVzZSBzdHJpY3RcIjtcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oUHJvbWlzZSwgSU5URVJOQUwpIHtcbnZhciB1dGlsID0gX2RlcmVxXyhcIi4vdXRpbFwiKTtcbnZhciBUaW1lb3V0RXJyb3IgPSBQcm9taXNlLlRpbWVvdXRFcnJvcjtcblxudmFyIGFmdGVyVGltZW91dCA9IGZ1bmN0aW9uIChwcm9taXNlLCBtZXNzYWdlLCBwYXJlbnQpIHtcbiAgICBpZiAoIXByb21pc2UuaXNQZW5kaW5nKCkpIHJldHVybjtcbiAgICB2YXIgZXJyO1xuICAgIGlmICh0eXBlb2YgbWVzc2FnZSAhPT0gXCJzdHJpbmdcIikge1xuICAgICAgICBpZiAobWVzc2FnZSBpbnN0YW5jZW9mIEVycm9yKSB7XG4gICAgICAgICAgICBlcnIgPSBtZXNzYWdlO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgZXJyID0gbmV3IFRpbWVvdXRFcnJvcihcIm9wZXJhdGlvbiB0aW1lZCBvdXRcIik7XG4gICAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgICBlcnIgPSBuZXcgVGltZW91dEVycm9yKG1lc3NhZ2UpO1xuICAgIH1cbiAgICB1dGlsLm1hcmtBc09yaWdpbmF0aW5nRnJvbVJlamVjdGlvbihlcnIpO1xuICAgIHByb21pc2UuX2F0dGFjaEV4dHJhVHJhY2UoZXJyKTtcbiAgICBwcm9taXNlLl9yZWplY3QoZXJyKTtcbiAgICBwYXJlbnQuY2FuY2VsKCk7XG59O1xuXG52YXIgYWZ0ZXJWYWx1ZSA9IGZ1bmN0aW9uKHZhbHVlKSB7IHJldHVybiBkZWxheSgrdGhpcykudGhlblJldHVybih2YWx1ZSk7IH07XG52YXIgZGVsYXkgPSBQcm9taXNlLmRlbGF5ID0gZnVuY3Rpb24gKG1zLCB2YWx1ZSkge1xuICAgIHZhciByZXQ7XG4gICAgaWYgKHZhbHVlICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgcmV0ID0gUHJvbWlzZS5yZXNvbHZlKHZhbHVlKVxuICAgICAgICAgICAgICAgIC5fdGhlbihhZnRlclZhbHVlLCBudWxsLCBudWxsLCBtcywgdW5kZWZpbmVkKTtcbiAgICB9IGVsc2Uge1xuICAgICAgICByZXQgPSBuZXcgUHJvbWlzZShJTlRFUk5BTCk7XG4gICAgICAgIHNldFRpbWVvdXQoZnVuY3Rpb24oKSB7IHJldC5fZnVsZmlsbCgpOyB9LCArbXMpO1xuICAgIH1cbiAgICByZXQuX3NldEFzeW5jR3VhcmFudGVlZCgpO1xuICAgIHJldHVybiByZXQ7XG59O1xuXG5Qcm9taXNlLnByb3RvdHlwZS5kZWxheSA9IGZ1bmN0aW9uIChtcykge1xuICAgIHJldHVybiBkZWxheShtcywgdGhpcyk7XG59O1xuXG5mdW5jdGlvbiBzdWNjZXNzQ2xlYXIodmFsdWUpIHtcbiAgICB2YXIgaGFuZGxlID0gdGhpcztcbiAgICBpZiAoaGFuZGxlIGluc3RhbmNlb2YgTnVtYmVyKSBoYW5kbGUgPSAraGFuZGxlO1xuICAgIGNsZWFyVGltZW91dChoYW5kbGUpO1xuICAgIHJldHVybiB2YWx1ZTtcbn1cblxuZnVuY3Rpb24gZmFpbHVyZUNsZWFyKHJlYXNvbikge1xuICAgIHZhciBoYW5kbGUgPSB0aGlzO1xuICAgIGlmIChoYW5kbGUgaW5zdGFuY2VvZiBOdW1iZXIpIGhhbmRsZSA9ICtoYW5kbGU7XG4gICAgY2xlYXJUaW1lb3V0KGhhbmRsZSk7XG4gICAgdGhyb3cgcmVhc29uO1xufVxuXG5Qcm9taXNlLnByb3RvdHlwZS50aW1lb3V0ID0gZnVuY3Rpb24gKG1zLCBtZXNzYWdlKSB7XG4gICAgbXMgPSArbXM7XG4gICAgdmFyIHBhcmVudCA9IHRoaXMudGhlbigpO1xuICAgIHZhciByZXQgPSBwYXJlbnQudGhlbigpO1xuICAgIHZhciBoYW5kbGUgPSBzZXRUaW1lb3V0KGZ1bmN0aW9uIHRpbWVvdXRUaW1lb3V0KCkge1xuICAgICAgICBhZnRlclRpbWVvdXQocmV0LCBtZXNzYWdlLCBwYXJlbnQpO1xuICAgIH0sIG1zKTtcbiAgICByZXR1cm4gcmV0Ll90aGVuKHN1Y2Nlc3NDbGVhciwgZmFpbHVyZUNsZWFyLCB1bmRlZmluZWQsIGhhbmRsZSwgdW5kZWZpbmVkKTtcbn07XG5cbn07XG5cbn0se1wiLi91dGlsXCI6MzZ9XSwzNTpbZnVuY3Rpb24oX2RlcmVxXyxtb2R1bGUsZXhwb3J0cyl7XG5cInVzZSBzdHJpY3RcIjtcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKFByb21pc2UsIGFwaVJlamVjdGlvbiwgdHJ5Q29udmVydFRvUHJvbWlzZSxcbiAgICBjcmVhdGVDb250ZXh0LCBJTlRFUk5BTCwgZGVidWcpIHtcbiAgICB2YXIgdXRpbCA9IF9kZXJlcV8oXCIuL3V0aWxcIik7XG4gICAgdmFyIFR5cGVFcnJvciA9IF9kZXJlcV8oXCIuL2Vycm9yc1wiKS5UeXBlRXJyb3I7XG4gICAgdmFyIGluaGVyaXRzID0gX2RlcmVxXyhcIi4vdXRpbFwiKS5pbmhlcml0cztcbiAgICB2YXIgZXJyb3JPYmogPSB1dGlsLmVycm9yT2JqO1xuICAgIHZhciB0cnlDYXRjaCA9IHV0aWwudHJ5Q2F0Y2g7XG5cbiAgICBmdW5jdGlvbiB0aHJvd2VyKGUpIHtcbiAgICAgICAgc2V0VGltZW91dChmdW5jdGlvbigpe3Rocm93IGU7fSwgMCk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gY2FzdFByZXNlcnZpbmdEaXNwb3NhYmxlKHRoZW5hYmxlKSB7XG4gICAgICAgIHZhciBtYXliZVByb21pc2UgPSB0cnlDb252ZXJ0VG9Qcm9taXNlKHRoZW5hYmxlKTtcbiAgICAgICAgaWYgKG1heWJlUHJvbWlzZSAhPT0gdGhlbmFibGUgJiZcbiAgICAgICAgICAgIHR5cGVvZiB0aGVuYWJsZS5faXNEaXNwb3NhYmxlID09PSBcImZ1bmN0aW9uXCIgJiZcbiAgICAgICAgICAgIHR5cGVvZiB0aGVuYWJsZS5fZ2V0RGlzcG9zZXIgPT09IFwiZnVuY3Rpb25cIiAmJlxuICAgICAgICAgICAgdGhlbmFibGUuX2lzRGlzcG9zYWJsZSgpKSB7XG4gICAgICAgICAgICBtYXliZVByb21pc2UuX3NldERpc3Bvc2FibGUodGhlbmFibGUuX2dldERpc3Bvc2VyKCkpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBtYXliZVByb21pc2U7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGRpc3Bvc2UocmVzb3VyY2VzLCBpbnNwZWN0aW9uKSB7XG4gICAgICAgIHZhciBpID0gMDtcbiAgICAgICAgdmFyIGxlbiA9IHJlc291cmNlcy5sZW5ndGg7XG4gICAgICAgIHZhciByZXQgPSBuZXcgUHJvbWlzZShJTlRFUk5BTCk7XG4gICAgICAgIGZ1bmN0aW9uIGl0ZXJhdG9yKCkge1xuICAgICAgICAgICAgaWYgKGkgPj0gbGVuKSByZXR1cm4gcmV0Ll9mdWxmaWxsKCk7XG4gICAgICAgICAgICB2YXIgbWF5YmVQcm9taXNlID0gY2FzdFByZXNlcnZpbmdEaXNwb3NhYmxlKHJlc291cmNlc1tpKytdKTtcbiAgICAgICAgICAgIGlmIChtYXliZVByb21pc2UgaW5zdGFuY2VvZiBQcm9taXNlICYmXG4gICAgICAgICAgICAgICAgbWF5YmVQcm9taXNlLl9pc0Rpc3Bvc2FibGUoKSkge1xuICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgIG1heWJlUHJvbWlzZSA9IHRyeUNvbnZlcnRUb1Byb21pc2UoXG4gICAgICAgICAgICAgICAgICAgICAgICBtYXliZVByb21pc2UuX2dldERpc3Bvc2VyKCkudHJ5RGlzcG9zZShpbnNwZWN0aW9uKSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlc291cmNlcy5wcm9taXNlKTtcbiAgICAgICAgICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0aHJvd2VyKGUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAobWF5YmVQcm9taXNlIGluc3RhbmNlb2YgUHJvbWlzZSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gbWF5YmVQcm9taXNlLl90aGVuKGl0ZXJhdG9yLCB0aHJvd2VyLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG51bGwsIG51bGwsIG51bGwpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGl0ZXJhdG9yKCk7XG4gICAgICAgIH1cbiAgICAgICAgaXRlcmF0b3IoKTtcbiAgICAgICAgcmV0dXJuIHJldDtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBEaXNwb3NlcihkYXRhLCBwcm9taXNlLCBjb250ZXh0KSB7XG4gICAgICAgIHRoaXMuX2RhdGEgPSBkYXRhO1xuICAgICAgICB0aGlzLl9wcm9taXNlID0gcHJvbWlzZTtcbiAgICAgICAgdGhpcy5fY29udGV4dCA9IGNvbnRleHQ7XG4gICAgfVxuXG4gICAgRGlzcG9zZXIucHJvdG90eXBlLmRhdGEgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9kYXRhO1xuICAgIH07XG5cbiAgICBEaXNwb3Nlci5wcm90b3R5cGUucHJvbWlzZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3Byb21pc2U7XG4gICAgfTtcblxuICAgIERpc3Bvc2VyLnByb3RvdHlwZS5yZXNvdXJjZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKHRoaXMucHJvbWlzZSgpLmlzRnVsZmlsbGVkKCkpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnByb21pc2UoKS52YWx1ZSgpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH07XG5cbiAgICBEaXNwb3Nlci5wcm90b3R5cGUudHJ5RGlzcG9zZSA9IGZ1bmN0aW9uKGluc3BlY3Rpb24pIHtcbiAgICAgICAgdmFyIHJlc291cmNlID0gdGhpcy5yZXNvdXJjZSgpO1xuICAgICAgICB2YXIgY29udGV4dCA9IHRoaXMuX2NvbnRleHQ7XG4gICAgICAgIGlmIChjb250ZXh0ICE9PSB1bmRlZmluZWQpIGNvbnRleHQuX3B1c2hDb250ZXh0KCk7XG4gICAgICAgIHZhciByZXQgPSByZXNvdXJjZSAhPT0gbnVsbFxuICAgICAgICAgICAgPyB0aGlzLmRvRGlzcG9zZShyZXNvdXJjZSwgaW5zcGVjdGlvbikgOiBudWxsO1xuICAgICAgICBpZiAoY29udGV4dCAhPT0gdW5kZWZpbmVkKSBjb250ZXh0Ll9wb3BDb250ZXh0KCk7XG4gICAgICAgIHRoaXMuX3Byb21pc2UuX3Vuc2V0RGlzcG9zYWJsZSgpO1xuICAgICAgICB0aGlzLl9kYXRhID0gbnVsbDtcbiAgICAgICAgcmV0dXJuIHJldDtcbiAgICB9O1xuXG4gICAgRGlzcG9zZXIuaXNEaXNwb3NlciA9IGZ1bmN0aW9uIChkKSB7XG4gICAgICAgIHJldHVybiAoZCAhPSBudWxsICYmXG4gICAgICAgICAgICAgICAgdHlwZW9mIGQucmVzb3VyY2UgPT09IFwiZnVuY3Rpb25cIiAmJlxuICAgICAgICAgICAgICAgIHR5cGVvZiBkLnRyeURpc3Bvc2UgPT09IFwiZnVuY3Rpb25cIik7XG4gICAgfTtcblxuICAgIGZ1bmN0aW9uIEZ1bmN0aW9uRGlzcG9zZXIoZm4sIHByb21pc2UsIGNvbnRleHQpIHtcbiAgICAgICAgdGhpcy5jb25zdHJ1Y3RvciQoZm4sIHByb21pc2UsIGNvbnRleHQpO1xuICAgIH1cbiAgICBpbmhlcml0cyhGdW5jdGlvbkRpc3Bvc2VyLCBEaXNwb3Nlcik7XG5cbiAgICBGdW5jdGlvbkRpc3Bvc2VyLnByb3RvdHlwZS5kb0Rpc3Bvc2UgPSBmdW5jdGlvbiAocmVzb3VyY2UsIGluc3BlY3Rpb24pIHtcbiAgICAgICAgdmFyIGZuID0gdGhpcy5kYXRhKCk7XG4gICAgICAgIHJldHVybiBmbi5jYWxsKHJlc291cmNlLCByZXNvdXJjZSwgaW5zcGVjdGlvbik7XG4gICAgfTtcblxuICAgIGZ1bmN0aW9uIG1heWJlVW53cmFwRGlzcG9zZXIodmFsdWUpIHtcbiAgICAgICAgaWYgKERpc3Bvc2VyLmlzRGlzcG9zZXIodmFsdWUpKSB7XG4gICAgICAgICAgICB0aGlzLnJlc291cmNlc1t0aGlzLmluZGV4XS5fc2V0RGlzcG9zYWJsZSh2YWx1ZSk7XG4gICAgICAgICAgICByZXR1cm4gdmFsdWUucHJvbWlzZSgpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBSZXNvdXJjZUxpc3QobGVuZ3RoKSB7XG4gICAgICAgIHRoaXMubGVuZ3RoID0gbGVuZ3RoO1xuICAgICAgICB0aGlzLnByb21pc2UgPSBudWxsO1xuICAgICAgICB0aGlzW2xlbmd0aC0xXSA9IG51bGw7XG4gICAgfVxuXG4gICAgUmVzb3VyY2VMaXN0LnByb3RvdHlwZS5fcmVzdWx0Q2FuY2VsbGVkID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBsZW4gPSB0aGlzLmxlbmd0aDtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW47ICsraSkge1xuICAgICAgICAgICAgdmFyIGl0ZW0gPSB0aGlzW2ldO1xuICAgICAgICAgICAgaWYgKGl0ZW0gaW5zdGFuY2VvZiBQcm9taXNlKSB7XG4gICAgICAgICAgICAgICAgaXRlbS5jYW5jZWwoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH07XG5cbiAgICBQcm9taXNlLnVzaW5nID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgbGVuID0gYXJndW1lbnRzLmxlbmd0aDtcbiAgICAgICAgaWYgKGxlbiA8IDIpIHJldHVybiBhcGlSZWplY3Rpb24oXG4gICAgICAgICAgICAgICAgICAgICAgICBcInlvdSBtdXN0IHBhc3MgYXQgbGVhc3QgMiBhcmd1bWVudHMgdG8gUHJvbWlzZS51c2luZ1wiKTtcbiAgICAgICAgdmFyIGZuID0gYXJndW1lbnRzW2xlbiAtIDFdO1xuICAgICAgICBpZiAodHlwZW9mIGZuICE9PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgICAgIHJldHVybiBhcGlSZWplY3Rpb24oXCJleHBlY3RpbmcgYSBmdW5jdGlvbiBidXQgZ290IFwiICsgdXRpbC5jbGFzc1N0cmluZyhmbikpO1xuICAgICAgICB9XG4gICAgICAgIHZhciBpbnB1dDtcbiAgICAgICAgdmFyIHNwcmVhZEFyZ3MgPSB0cnVlO1xuICAgICAgICBpZiAobGVuID09PSAyICYmIEFycmF5LmlzQXJyYXkoYXJndW1lbnRzWzBdKSkge1xuICAgICAgICAgICAgaW5wdXQgPSBhcmd1bWVudHNbMF07XG4gICAgICAgICAgICBsZW4gPSBpbnB1dC5sZW5ndGg7XG4gICAgICAgICAgICBzcHJlYWRBcmdzID0gZmFsc2U7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBpbnB1dCA9IGFyZ3VtZW50cztcbiAgICAgICAgICAgIGxlbi0tO1xuICAgICAgICB9XG4gICAgICAgIHZhciByZXNvdXJjZXMgPSBuZXcgUmVzb3VyY2VMaXN0KGxlbik7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuOyArK2kpIHtcbiAgICAgICAgICAgIHZhciByZXNvdXJjZSA9IGlucHV0W2ldO1xuICAgICAgICAgICAgaWYgKERpc3Bvc2VyLmlzRGlzcG9zZXIocmVzb3VyY2UpKSB7XG4gICAgICAgICAgICAgICAgdmFyIGRpc3Bvc2VyID0gcmVzb3VyY2U7XG4gICAgICAgICAgICAgICAgcmVzb3VyY2UgPSByZXNvdXJjZS5wcm9taXNlKCk7XG4gICAgICAgICAgICAgICAgcmVzb3VyY2UuX3NldERpc3Bvc2FibGUoZGlzcG9zZXIpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICB2YXIgbWF5YmVQcm9taXNlID0gdHJ5Q29udmVydFRvUHJvbWlzZShyZXNvdXJjZSk7XG4gICAgICAgICAgICAgICAgaWYgKG1heWJlUHJvbWlzZSBpbnN0YW5jZW9mIFByb21pc2UpIHtcbiAgICAgICAgICAgICAgICAgICAgcmVzb3VyY2UgPVxuICAgICAgICAgICAgICAgICAgICAgICAgbWF5YmVQcm9taXNlLl90aGVuKG1heWJlVW53cmFwRGlzcG9zZXIsIG51bGwsIG51bGwsIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXNvdXJjZXM6IHJlc291cmNlcyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpbmRleDogaVxuICAgICAgICAgICAgICAgICAgICB9LCB1bmRlZmluZWQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJlc291cmNlc1tpXSA9IHJlc291cmNlO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIHJlZmxlY3RlZFJlc291cmNlcyA9IG5ldyBBcnJheShyZXNvdXJjZXMubGVuZ3RoKTtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCByZWZsZWN0ZWRSZXNvdXJjZXMubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgICAgIHJlZmxlY3RlZFJlc291cmNlc1tpXSA9IFByb21pc2UucmVzb2x2ZShyZXNvdXJjZXNbaV0pLnJlZmxlY3QoKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciByZXN1bHRQcm9taXNlID0gUHJvbWlzZS5hbGwocmVmbGVjdGVkUmVzb3VyY2VzKVxuICAgICAgICAgICAgLnRoZW4oZnVuY3Rpb24oaW5zcGVjdGlvbnMpIHtcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGluc3BlY3Rpb25zLmxlbmd0aDsgKytpKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBpbnNwZWN0aW9uID0gaW5zcGVjdGlvbnNbaV07XG4gICAgICAgICAgICAgICAgICAgIGlmIChpbnNwZWN0aW9uLmlzUmVqZWN0ZWQoKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgZXJyb3JPYmouZSA9IGluc3BlY3Rpb24uZXJyb3IoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBlcnJvck9iajtcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmICghaW5zcGVjdGlvbi5pc0Z1bGZpbGxlZCgpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXN1bHRQcm9taXNlLmNhbmNlbCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGluc3BlY3Rpb25zW2ldID0gaW5zcGVjdGlvbi52YWx1ZSgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBwcm9taXNlLl9wdXNoQ29udGV4dCgpO1xuXG4gICAgICAgICAgICAgICAgZm4gPSB0cnlDYXRjaChmbik7XG4gICAgICAgICAgICAgICAgdmFyIHJldCA9IHNwcmVhZEFyZ3NcbiAgICAgICAgICAgICAgICAgICAgPyBmbi5hcHBseSh1bmRlZmluZWQsIGluc3BlY3Rpb25zKSA6IGZuKGluc3BlY3Rpb25zKTtcbiAgICAgICAgICAgICAgICB2YXIgcHJvbWlzZUNyZWF0ZWQgPSBwcm9taXNlLl9wb3BDb250ZXh0KCk7XG4gICAgICAgICAgICAgICAgZGVidWcuY2hlY2tGb3Jnb3R0ZW5SZXR1cm5zKFxuICAgICAgICAgICAgICAgICAgICByZXQsIHByb21pc2VDcmVhdGVkLCBcIlByb21pc2UudXNpbmdcIiwgcHJvbWlzZSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHJldDtcbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgIHZhciBwcm9taXNlID0gcmVzdWx0UHJvbWlzZS5sYXN0bHkoZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICB2YXIgaW5zcGVjdGlvbiA9IG5ldyBQcm9taXNlLlByb21pc2VJbnNwZWN0aW9uKHJlc3VsdFByb21pc2UpO1xuICAgICAgICAgICAgcmV0dXJuIGRpc3Bvc2UocmVzb3VyY2VzLCBpbnNwZWN0aW9uKTtcbiAgICAgICAgfSk7XG4gICAgICAgIHJlc291cmNlcy5wcm9taXNlID0gcHJvbWlzZTtcbiAgICAgICAgcHJvbWlzZS5fc2V0T25DYW5jZWwocmVzb3VyY2VzKTtcbiAgICAgICAgcmV0dXJuIHByb21pc2U7XG4gICAgfTtcblxuICAgIFByb21pc2UucHJvdG90eXBlLl9zZXREaXNwb3NhYmxlID0gZnVuY3Rpb24gKGRpc3Bvc2VyKSB7XG4gICAgICAgIHRoaXMuX2JpdEZpZWxkID0gdGhpcy5fYml0RmllbGQgfCAxMzEwNzI7XG4gICAgICAgIHRoaXMuX2Rpc3Bvc2VyID0gZGlzcG9zZXI7XG4gICAgfTtcblxuICAgIFByb21pc2UucHJvdG90eXBlLl9pc0Rpc3Bvc2FibGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiAodGhpcy5fYml0RmllbGQgJiAxMzEwNzIpID4gMDtcbiAgICB9O1xuXG4gICAgUHJvbWlzZS5wcm90b3R5cGUuX2dldERpc3Bvc2VyID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fZGlzcG9zZXI7XG4gICAgfTtcblxuICAgIFByb21pc2UucHJvdG90eXBlLl91bnNldERpc3Bvc2FibGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMuX2JpdEZpZWxkID0gdGhpcy5fYml0RmllbGQgJiAofjEzMTA3Mik7XG4gICAgICAgIHRoaXMuX2Rpc3Bvc2VyID0gdW5kZWZpbmVkO1xuICAgIH07XG5cbiAgICBQcm9taXNlLnByb3RvdHlwZS5kaXNwb3NlciA9IGZ1bmN0aW9uIChmbikge1xuICAgICAgICBpZiAodHlwZW9mIGZuID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgICAgIHJldHVybiBuZXcgRnVuY3Rpb25EaXNwb3NlcihmbiwgdGhpcywgY3JlYXRlQ29udGV4dCgpKTtcbiAgICAgICAgfVxuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCk7XG4gICAgfTtcblxufTtcblxufSx7XCIuL2Vycm9yc1wiOjEyLFwiLi91dGlsXCI6MzZ9XSwzNjpbZnVuY3Rpb24oX2RlcmVxXyxtb2R1bGUsZXhwb3J0cyl7XG5cInVzZSBzdHJpY3RcIjtcbnZhciBlczUgPSBfZGVyZXFfKFwiLi9lczVcIik7XG52YXIgY2FuRXZhbHVhdGUgPSB0eXBlb2YgbmF2aWdhdG9yID09IFwidW5kZWZpbmVkXCI7XG5cbnZhciBlcnJvck9iaiA9IHtlOiB7fX07XG52YXIgdHJ5Q2F0Y2hUYXJnZXQ7XG5mdW5jdGlvbiB0cnlDYXRjaGVyKCkge1xuICAgIHRyeSB7XG4gICAgICAgIHZhciB0YXJnZXQgPSB0cnlDYXRjaFRhcmdldDtcbiAgICAgICAgdHJ5Q2F0Y2hUYXJnZXQgPSBudWxsO1xuICAgICAgICByZXR1cm4gdGFyZ2V0LmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgICBlcnJvck9iai5lID0gZTtcbiAgICAgICAgcmV0dXJuIGVycm9yT2JqO1xuICAgIH1cbn1cbmZ1bmN0aW9uIHRyeUNhdGNoKGZuKSB7XG4gICAgdHJ5Q2F0Y2hUYXJnZXQgPSBmbjtcbiAgICByZXR1cm4gdHJ5Q2F0Y2hlcjtcbn1cblxudmFyIGluaGVyaXRzID0gZnVuY3Rpb24oQ2hpbGQsIFBhcmVudCkge1xuICAgIHZhciBoYXNQcm9wID0ge30uaGFzT3duUHJvcGVydHk7XG5cbiAgICBmdW5jdGlvbiBUKCkge1xuICAgICAgICB0aGlzLmNvbnN0cnVjdG9yID0gQ2hpbGQ7XG4gICAgICAgIHRoaXMuY29uc3RydWN0b3IkID0gUGFyZW50O1xuICAgICAgICBmb3IgKHZhciBwcm9wZXJ0eU5hbWUgaW4gUGFyZW50LnByb3RvdHlwZSkge1xuICAgICAgICAgICAgaWYgKGhhc1Byb3AuY2FsbChQYXJlbnQucHJvdG90eXBlLCBwcm9wZXJ0eU5hbWUpICYmXG4gICAgICAgICAgICAgICAgcHJvcGVydHlOYW1lLmNoYXJBdChwcm9wZXJ0eU5hbWUubGVuZ3RoLTEpICE9PSBcIiRcIlxuICAgICAgICAgICApIHtcbiAgICAgICAgICAgICAgICB0aGlzW3Byb3BlcnR5TmFtZSArIFwiJFwiXSA9IFBhcmVudC5wcm90b3R5cGVbcHJvcGVydHlOYW1lXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICBULnByb3RvdHlwZSA9IFBhcmVudC5wcm90b3R5cGU7XG4gICAgQ2hpbGQucHJvdG90eXBlID0gbmV3IFQoKTtcbiAgICByZXR1cm4gQ2hpbGQucHJvdG90eXBlO1xufTtcblxuXG5mdW5jdGlvbiBpc1ByaW1pdGl2ZSh2YWwpIHtcbiAgICByZXR1cm4gdmFsID09IG51bGwgfHwgdmFsID09PSB0cnVlIHx8IHZhbCA9PT0gZmFsc2UgfHxcbiAgICAgICAgdHlwZW9mIHZhbCA9PT0gXCJzdHJpbmdcIiB8fCB0eXBlb2YgdmFsID09PSBcIm51bWJlclwiO1xuXG59XG5cbmZ1bmN0aW9uIGlzT2JqZWN0KHZhbHVlKSB7XG4gICAgcmV0dXJuIHR5cGVvZiB2YWx1ZSA9PT0gXCJmdW5jdGlvblwiIHx8XG4gICAgICAgICAgIHR5cGVvZiB2YWx1ZSA9PT0gXCJvYmplY3RcIiAmJiB2YWx1ZSAhPT0gbnVsbDtcbn1cblxuZnVuY3Rpb24gbWF5YmVXcmFwQXNFcnJvcihtYXliZUVycm9yKSB7XG4gICAgaWYgKCFpc1ByaW1pdGl2ZShtYXliZUVycm9yKSkgcmV0dXJuIG1heWJlRXJyb3I7XG5cbiAgICByZXR1cm4gbmV3IEVycm9yKHNhZmVUb1N0cmluZyhtYXliZUVycm9yKSk7XG59XG5cbmZ1bmN0aW9uIHdpdGhBcHBlbmRlZCh0YXJnZXQsIGFwcGVuZGVlKSB7XG4gICAgdmFyIGxlbiA9IHRhcmdldC5sZW5ndGg7XG4gICAgdmFyIHJldCA9IG5ldyBBcnJheShsZW4gKyAxKTtcbiAgICB2YXIgaTtcbiAgICBmb3IgKGkgPSAwOyBpIDwgbGVuOyArK2kpIHtcbiAgICAgICAgcmV0W2ldID0gdGFyZ2V0W2ldO1xuICAgIH1cbiAgICByZXRbaV0gPSBhcHBlbmRlZTtcbiAgICByZXR1cm4gcmV0O1xufVxuXG5mdW5jdGlvbiBnZXREYXRhUHJvcGVydHlPckRlZmF1bHQob2JqLCBrZXksIGRlZmF1bHRWYWx1ZSkge1xuICAgIGlmIChlczUuaXNFUzUpIHtcbiAgICAgICAgdmFyIGRlc2MgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKG9iaiwga2V5KTtcblxuICAgICAgICBpZiAoZGVzYyAhPSBudWxsKSB7XG4gICAgICAgICAgICByZXR1cm4gZGVzYy5nZXQgPT0gbnVsbCAmJiBkZXNjLnNldCA9PSBudWxsXG4gICAgICAgICAgICAgICAgICAgID8gZGVzYy52YWx1ZVxuICAgICAgICAgICAgICAgICAgICA6IGRlZmF1bHRWYWx1ZTtcbiAgICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiB7fS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG9iaiwga2V5KSA/IG9ialtrZXldIDogdW5kZWZpbmVkO1xuICAgIH1cbn1cblxuZnVuY3Rpb24gbm90RW51bWVyYWJsZVByb3Aob2JqLCBuYW1lLCB2YWx1ZSkge1xuICAgIGlmIChpc1ByaW1pdGl2ZShvYmopKSByZXR1cm4gb2JqO1xuICAgIHZhciBkZXNjcmlwdG9yID0ge1xuICAgICAgICB2YWx1ZTogdmFsdWUsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgICAgIHdyaXRhYmxlOiB0cnVlXG4gICAgfTtcbiAgICBlczUuZGVmaW5lUHJvcGVydHkob2JqLCBuYW1lLCBkZXNjcmlwdG9yKTtcbiAgICByZXR1cm4gb2JqO1xufVxuXG5mdW5jdGlvbiB0aHJvd2VyKHIpIHtcbiAgICB0aHJvdyByO1xufVxuXG52YXIgaW5oZXJpdGVkRGF0YUtleXMgPSAoZnVuY3Rpb24oKSB7XG4gICAgdmFyIGV4Y2x1ZGVkUHJvdG90eXBlcyA9IFtcbiAgICAgICAgQXJyYXkucHJvdG90eXBlLFxuICAgICAgICBPYmplY3QucHJvdG90eXBlLFxuICAgICAgICBGdW5jdGlvbi5wcm90b3R5cGVcbiAgICBdO1xuXG4gICAgdmFyIGlzRXhjbHVkZWRQcm90byA9IGZ1bmN0aW9uKHZhbCkge1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGV4Y2x1ZGVkUHJvdG90eXBlcy5sZW5ndGg7ICsraSkge1xuICAgICAgICAgICAgaWYgKGV4Y2x1ZGVkUHJvdG90eXBlc1tpXSA9PT0gdmFsKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH07XG5cbiAgICBpZiAoZXM1LmlzRVM1KSB7XG4gICAgICAgIHZhciBnZXRLZXlzID0gT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXM7XG4gICAgICAgIHJldHVybiBmdW5jdGlvbihvYmopIHtcbiAgICAgICAgICAgIHZhciByZXQgPSBbXTtcbiAgICAgICAgICAgIHZhciB2aXNpdGVkS2V5cyA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gICAgICAgICAgICB3aGlsZSAob2JqICE9IG51bGwgJiYgIWlzRXhjbHVkZWRQcm90byhvYmopKSB7XG4gICAgICAgICAgICAgICAgdmFyIGtleXM7XG4gICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAga2V5cyA9IGdldEtleXMob2JqKTtcbiAgICAgICAgICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiByZXQ7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwga2V5cy5sZW5ndGg7ICsraSkge1xuICAgICAgICAgICAgICAgICAgICB2YXIga2V5ID0ga2V5c1tpXTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHZpc2l0ZWRLZXlzW2tleV0pIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgICAgICB2aXNpdGVkS2V5c1trZXldID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGRlc2MgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKG9iaiwga2V5KTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGRlc2MgIT0gbnVsbCAmJiBkZXNjLmdldCA9PSBudWxsICYmIGRlc2Muc2V0ID09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldC5wdXNoKGtleSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgb2JqID0gZXM1LmdldFByb3RvdHlwZU9mKG9iaik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gcmV0O1xuICAgICAgICB9O1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHZhciBoYXNQcm9wID0ge30uaGFzT3duUHJvcGVydHk7XG4gICAgICAgIHJldHVybiBmdW5jdGlvbihvYmopIHtcbiAgICAgICAgICAgIGlmIChpc0V4Y2x1ZGVkUHJvdG8ob2JqKSkgcmV0dXJuIFtdO1xuICAgICAgICAgICAgdmFyIHJldCA9IFtdO1xuXG4gICAgICAgICAgICAvKmpzaGludCBmb3JpbjpmYWxzZSAqL1xuICAgICAgICAgICAgZW51bWVyYXRpb246IGZvciAodmFyIGtleSBpbiBvYmopIHtcbiAgICAgICAgICAgICAgICBpZiAoaGFzUHJvcC5jYWxsKG9iaiwga2V5KSkge1xuICAgICAgICAgICAgICAgICAgICByZXQucHVzaChrZXkpO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZXhjbHVkZWRQcm90b3R5cGVzLmxlbmd0aDsgKytpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoaGFzUHJvcC5jYWxsKGV4Y2x1ZGVkUHJvdG90eXBlc1tpXSwga2V5KSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlIGVudW1lcmF0aW9uO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHJldC5wdXNoKGtleSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHJldDtcbiAgICAgICAgfTtcbiAgICB9XG5cbn0pKCk7XG5cbnZhciB0aGlzQXNzaWdubWVudFBhdHRlcm4gPSAvdGhpc1xccypcXC5cXHMqXFxTK1xccyo9LztcbmZ1bmN0aW9uIGlzQ2xhc3MoZm4pIHtcbiAgICB0cnkge1xuICAgICAgICBpZiAodHlwZW9mIGZuID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgICAgIHZhciBrZXlzID0gZXM1Lm5hbWVzKGZuLnByb3RvdHlwZSk7XG5cbiAgICAgICAgICAgIHZhciBoYXNNZXRob2RzID0gZXM1LmlzRVM1ICYmIGtleXMubGVuZ3RoID4gMTtcbiAgICAgICAgICAgIHZhciBoYXNNZXRob2RzT3RoZXJUaGFuQ29uc3RydWN0b3IgPSBrZXlzLmxlbmd0aCA+IDAgJiZcbiAgICAgICAgICAgICAgICAhKGtleXMubGVuZ3RoID09PSAxICYmIGtleXNbMF0gPT09IFwiY29uc3RydWN0b3JcIik7XG4gICAgICAgICAgICB2YXIgaGFzVGhpc0Fzc2lnbm1lbnRBbmRTdGF0aWNNZXRob2RzID1cbiAgICAgICAgICAgICAgICB0aGlzQXNzaWdubWVudFBhdHRlcm4udGVzdChmbiArIFwiXCIpICYmIGVzNS5uYW1lcyhmbikubGVuZ3RoID4gMDtcblxuICAgICAgICAgICAgaWYgKGhhc01ldGhvZHMgfHwgaGFzTWV0aG9kc090aGVyVGhhbkNvbnN0cnVjdG9yIHx8XG4gICAgICAgICAgICAgICAgaGFzVGhpc0Fzc2lnbm1lbnRBbmRTdGF0aWNNZXRob2RzKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbn1cblxuZnVuY3Rpb24gdG9GYXN0UHJvcGVydGllcyhvYmopIHtcbiAgICAvKmpzaGludCAtVzAyNywtVzA1NSwtVzAzMSovXG4gICAgZnVuY3Rpb24gRmFrZUNvbnN0cnVjdG9yKCkge31cbiAgICBGYWtlQ29uc3RydWN0b3IucHJvdG90eXBlID0gb2JqO1xuICAgIHZhciBsID0gODtcbiAgICB3aGlsZSAobC0tKSBuZXcgRmFrZUNvbnN0cnVjdG9yKCk7XG4gICAgcmV0dXJuIG9iajtcbiAgICBldmFsKG9iaik7XG59XG5cbnZhciByaWRlbnQgPSAvXlthLXokX11bYS16JF8wLTldKiQvaTtcbmZ1bmN0aW9uIGlzSWRlbnRpZmllcihzdHIpIHtcbiAgICByZXR1cm4gcmlkZW50LnRlc3Qoc3RyKTtcbn1cblxuZnVuY3Rpb24gZmlsbGVkUmFuZ2UoY291bnQsIHByZWZpeCwgc3VmZml4KSB7XG4gICAgdmFyIHJldCA9IG5ldyBBcnJheShjb3VudCk7XG4gICAgZm9yKHZhciBpID0gMDsgaSA8IGNvdW50OyArK2kpIHtcbiAgICAgICAgcmV0W2ldID0gcHJlZml4ICsgaSArIHN1ZmZpeDtcbiAgICB9XG4gICAgcmV0dXJuIHJldDtcbn1cblxuZnVuY3Rpb24gc2FmZVRvU3RyaW5nKG9iaikge1xuICAgIHRyeSB7XG4gICAgICAgIHJldHVybiBvYmogKyBcIlwiO1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgcmV0dXJuIFwiW25vIHN0cmluZyByZXByZXNlbnRhdGlvbl1cIjtcbiAgICB9XG59XG5cbmZ1bmN0aW9uIG1hcmtBc09yaWdpbmF0aW5nRnJvbVJlamVjdGlvbihlKSB7XG4gICAgdHJ5IHtcbiAgICAgICAgbm90RW51bWVyYWJsZVByb3AoZSwgXCJpc09wZXJhdGlvbmFsXCIsIHRydWUpO1xuICAgIH1cbiAgICBjYXRjaChpZ25vcmUpIHt9XG59XG5cbmZ1bmN0aW9uIG9yaWdpbmF0ZXNGcm9tUmVqZWN0aW9uKGUpIHtcbiAgICBpZiAoZSA9PSBudWxsKSByZXR1cm4gZmFsc2U7XG4gICAgcmV0dXJuICgoZSBpbnN0YW5jZW9mIEVycm9yW1wiX19CbHVlYmlyZEVycm9yVHlwZXNfX1wiXS5PcGVyYXRpb25hbEVycm9yKSB8fFxuICAgICAgICBlW1wiaXNPcGVyYXRpb25hbFwiXSA9PT0gdHJ1ZSk7XG59XG5cbmZ1bmN0aW9uIGNhbkF0dGFjaFRyYWNlKG9iaikge1xuICAgIHJldHVybiBvYmogaW5zdGFuY2VvZiBFcnJvciAmJiBlczUucHJvcGVydHlJc1dyaXRhYmxlKG9iaiwgXCJzdGFja1wiKTtcbn1cblxudmFyIGVuc3VyZUVycm9yT2JqZWN0ID0gKGZ1bmN0aW9uKCkge1xuICAgIGlmICghKFwic3RhY2tcIiBpbiBuZXcgRXJyb3IoKSkpIHtcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgICAgICAgICBpZiAoY2FuQXR0YWNoVHJhY2UodmFsdWUpKSByZXR1cm4gdmFsdWU7XG4gICAgICAgICAgICB0cnkge3Rocm93IG5ldyBFcnJvcihzYWZlVG9TdHJpbmcodmFsdWUpKTt9XG4gICAgICAgICAgICBjYXRjaChlcnIpIHtyZXR1cm4gZXJyO31cbiAgICAgICAgfTtcbiAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gZnVuY3Rpb24odmFsdWUpIHtcbiAgICAgICAgICAgIGlmIChjYW5BdHRhY2hUcmFjZSh2YWx1ZSkpIHJldHVybiB2YWx1ZTtcbiAgICAgICAgICAgIHJldHVybiBuZXcgRXJyb3Ioc2FmZVRvU3RyaW5nKHZhbHVlKSk7XG4gICAgICAgIH07XG4gICAgfVxufSkoKTtcblxuZnVuY3Rpb24gY2xhc3NTdHJpbmcob2JqKSB7XG4gICAgcmV0dXJuIHt9LnRvU3RyaW5nLmNhbGwob2JqKTtcbn1cblxuZnVuY3Rpb24gY29weURlc2NyaXB0b3JzKGZyb20sIHRvLCBmaWx0ZXIpIHtcbiAgICB2YXIga2V5cyA9IGVzNS5uYW1lcyhmcm9tKTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGtleXMubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgdmFyIGtleSA9IGtleXNbaV07XG4gICAgICAgIGlmIChmaWx0ZXIoa2V5KSkge1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICBlczUuZGVmaW5lUHJvcGVydHkodG8sIGtleSwgZXM1LmdldERlc2NyaXB0b3IoZnJvbSwga2V5KSk7XG4gICAgICAgICAgICB9IGNhdGNoIChpZ25vcmUpIHt9XG4gICAgICAgIH1cbiAgICB9XG59XG5cbnZhciBhc0FycmF5ID0gZnVuY3Rpb24odikge1xuICAgIGlmIChlczUuaXNBcnJheSh2KSkge1xuICAgICAgICByZXR1cm4gdjtcbiAgICB9XG4gICAgcmV0dXJuIG51bGw7XG59O1xuXG5pZiAodHlwZW9mIFN5bWJvbCAhPT0gXCJ1bmRlZmluZWRcIiAmJiBTeW1ib2wuaXRlcmF0b3IpIHtcbiAgICB2YXIgQXJyYXlGcm9tID0gdHlwZW9mIEFycmF5LmZyb20gPT09IFwiZnVuY3Rpb25cIiA/IGZ1bmN0aW9uKHYpIHtcbiAgICAgICAgcmV0dXJuIEFycmF5LmZyb20odik7XG4gICAgfSA6IGZ1bmN0aW9uKHYpIHtcbiAgICAgICAgdmFyIHJldCA9IFtdO1xuICAgICAgICB2YXIgaXQgPSB2W1N5bWJvbC5pdGVyYXRvcl0oKTtcbiAgICAgICAgdmFyIGl0UmVzdWx0O1xuICAgICAgICB3aGlsZSAoISgoaXRSZXN1bHQgPSBpdC5uZXh0KCkpLmRvbmUpKSB7XG4gICAgICAgICAgICByZXQucHVzaChpdFJlc3VsdC52YWx1ZSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJldDtcbiAgICB9O1xuXG4gICAgYXNBcnJheSA9IGZ1bmN0aW9uKHYpIHtcbiAgICAgICAgaWYgKGVzNS5pc0FycmF5KHYpKSB7XG4gICAgICAgICAgICByZXR1cm4gdjtcbiAgICAgICAgfSBlbHNlIGlmICh2ICE9IG51bGwgJiYgdHlwZW9mIHZbU3ltYm9sLml0ZXJhdG9yXSA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgICAgICByZXR1cm4gQXJyYXlGcm9tKHYpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH07XG59XG5cbnZhciBpc05vZGUgPSB0eXBlb2YgcHJvY2VzcyAhPT0gXCJ1bmRlZmluZWRcIiAmJlxuICAgICAgICBjbGFzc1N0cmluZyhwcm9jZXNzKS50b0xvd2VyQ2FzZSgpID09PSBcIltvYmplY3QgcHJvY2Vzc11cIjtcblxuZnVuY3Rpb24gZW52KGtleSwgZGVmKSB7XG4gICAgcmV0dXJuIGlzTm9kZSA/IHByb2Nlc3MuZW52W2tleV0gOiBkZWY7XG59XG5cbnZhciByZXQgPSB7XG4gICAgaXNDbGFzczogaXNDbGFzcyxcbiAgICBpc0lkZW50aWZpZXI6IGlzSWRlbnRpZmllcixcbiAgICBpbmhlcml0ZWREYXRhS2V5czogaW5oZXJpdGVkRGF0YUtleXMsXG4gICAgZ2V0RGF0YVByb3BlcnR5T3JEZWZhdWx0OiBnZXREYXRhUHJvcGVydHlPckRlZmF1bHQsXG4gICAgdGhyb3dlcjogdGhyb3dlcixcbiAgICBpc0FycmF5OiBlczUuaXNBcnJheSxcbiAgICBhc0FycmF5OiBhc0FycmF5LFxuICAgIG5vdEVudW1lcmFibGVQcm9wOiBub3RFbnVtZXJhYmxlUHJvcCxcbiAgICBpc1ByaW1pdGl2ZTogaXNQcmltaXRpdmUsXG4gICAgaXNPYmplY3Q6IGlzT2JqZWN0LFxuICAgIGNhbkV2YWx1YXRlOiBjYW5FdmFsdWF0ZSxcbiAgICBlcnJvck9iajogZXJyb3JPYmosXG4gICAgdHJ5Q2F0Y2g6IHRyeUNhdGNoLFxuICAgIGluaGVyaXRzOiBpbmhlcml0cyxcbiAgICB3aXRoQXBwZW5kZWQ6IHdpdGhBcHBlbmRlZCxcbiAgICBtYXliZVdyYXBBc0Vycm9yOiBtYXliZVdyYXBBc0Vycm9yLFxuICAgIHRvRmFzdFByb3BlcnRpZXM6IHRvRmFzdFByb3BlcnRpZXMsXG4gICAgZmlsbGVkUmFuZ2U6IGZpbGxlZFJhbmdlLFxuICAgIHRvU3RyaW5nOiBzYWZlVG9TdHJpbmcsXG4gICAgY2FuQXR0YWNoVHJhY2U6IGNhbkF0dGFjaFRyYWNlLFxuICAgIGVuc3VyZUVycm9yT2JqZWN0OiBlbnN1cmVFcnJvck9iamVjdCxcbiAgICBvcmlnaW5hdGVzRnJvbVJlamVjdGlvbjogb3JpZ2luYXRlc0Zyb21SZWplY3Rpb24sXG4gICAgbWFya0FzT3JpZ2luYXRpbmdGcm9tUmVqZWN0aW9uOiBtYXJrQXNPcmlnaW5hdGluZ0Zyb21SZWplY3Rpb24sXG4gICAgY2xhc3NTdHJpbmc6IGNsYXNzU3RyaW5nLFxuICAgIGNvcHlEZXNjcmlwdG9yczogY29weURlc2NyaXB0b3JzLFxuICAgIGhhc0RldlRvb2xzOiB0eXBlb2YgY2hyb21lICE9PSBcInVuZGVmaW5lZFwiICYmIGNocm9tZSAmJlxuICAgICAgICAgICAgICAgICB0eXBlb2YgY2hyb21lLmxvYWRUaW1lcyA9PT0gXCJmdW5jdGlvblwiLFxuICAgIGlzTm9kZTogaXNOb2RlLFxuICAgIGVudjogZW52XG59O1xucmV0LmlzUmVjZW50Tm9kZSA9IHJldC5pc05vZGUgJiYgKGZ1bmN0aW9uKCkge1xuICAgIHZhciB2ZXJzaW9uID0gcHJvY2Vzcy52ZXJzaW9ucy5ub2RlLnNwbGl0KFwiLlwiKS5tYXAoTnVtYmVyKTtcbiAgICByZXR1cm4gKHZlcnNpb25bMF0gPT09IDAgJiYgdmVyc2lvblsxXSA+IDEwKSB8fCAodmVyc2lvblswXSA+IDApO1xufSkoKTtcblxuaWYgKHJldC5pc05vZGUpIHJldC50b0Zhc3RQcm9wZXJ0aWVzKHByb2Nlc3MpO1xuXG50cnkge3Rocm93IG5ldyBFcnJvcigpOyB9IGNhdGNoIChlKSB7cmV0Lmxhc3RMaW5lRXJyb3IgPSBlO31cbm1vZHVsZS5leHBvcnRzID0gcmV0O1xuXG59LHtcIi4vZXM1XCI6MTN9XX0se30sWzRdKSg0KVxufSk7ICAgICAgICAgICAgICAgICAgICA7aWYgKHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnICYmIHdpbmRvdyAhPT0gbnVsbCkgeyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB3aW5kb3cuUCA9IHdpbmRvdy5Qcm9taXNlOyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmICh0eXBlb2Ygc2VsZiAhPT0gJ3VuZGVmaW5lZCcgJiYgc2VsZiAhPT0gbnVsbCkgeyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc2VsZi5QID0gc2VsZi5Qcm9taXNlOyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0iLCIvKiFcbiAqIFRoZSBidWZmZXIgbW9kdWxlIGZyb20gbm9kZS5qcywgZm9yIHRoZSBicm93c2VyLlxuICpcbiAqIEBhdXRob3IgICBGZXJvc3MgQWJvdWtoYWRpamVoIDxmZXJvc3NAZmVyb3NzLm9yZz4gPGh0dHA6Ly9mZXJvc3Mub3JnPlxuICogQGxpY2Vuc2UgIE1JVFxuICovXG4vKiBlc2xpbnQtZGlzYWJsZSBuby1wcm90byAqL1xuXG52YXIgYmFzZTY0ID0gcmVxdWlyZSgnYmFzZTY0LWpzJylcbnZhciBpZWVlNzU0ID0gcmVxdWlyZSgnaWVlZTc1NCcpXG52YXIgaXNBcnJheSA9IHJlcXVpcmUoJ2lzYXJyYXknKVxuXG5leHBvcnRzLkJ1ZmZlciA9IEJ1ZmZlclxuZXhwb3J0cy5TbG93QnVmZmVyID0gU2xvd0J1ZmZlclxuZXhwb3J0cy5JTlNQRUNUX01BWF9CWVRFUyA9IDUwXG5CdWZmZXIucG9vbFNpemUgPSA4MTkyIC8vIG5vdCB1c2VkIGJ5IHRoaXMgaW1wbGVtZW50YXRpb25cblxudmFyIHJvb3RQYXJlbnQgPSB7fVxuXG4vKipcbiAqIElmIGBCdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVGA6XG4gKiAgID09PSB0cnVlICAgIFVzZSBVaW50OEFycmF5IGltcGxlbWVudGF0aW9uIChmYXN0ZXN0KVxuICogICA9PT0gZmFsc2UgICBVc2UgT2JqZWN0IGltcGxlbWVudGF0aW9uIChtb3N0IGNvbXBhdGlibGUsIGV2ZW4gSUU2KVxuICpcbiAqIEJyb3dzZXJzIHRoYXQgc3VwcG9ydCB0eXBlZCBhcnJheXMgYXJlIElFIDEwKywgRmlyZWZveCA0KywgQ2hyb21lIDcrLCBTYWZhcmkgNS4xKyxcbiAqIE9wZXJhIDExLjYrLCBpT1MgNC4yKy5cbiAqXG4gKiBEdWUgdG8gdmFyaW91cyBicm93c2VyIGJ1Z3MsIHNvbWV0aW1lcyB0aGUgT2JqZWN0IGltcGxlbWVudGF0aW9uIHdpbGwgYmUgdXNlZCBldmVuXG4gKiB3aGVuIHRoZSBicm93c2VyIHN1cHBvcnRzIHR5cGVkIGFycmF5cy5cbiAqXG4gKiBOb3RlOlxuICpcbiAqICAgLSBGaXJlZm94IDQtMjkgbGFja3Mgc3VwcG9ydCBmb3IgYWRkaW5nIG5ldyBwcm9wZXJ0aWVzIHRvIGBVaW50OEFycmF5YCBpbnN0YW5jZXMsXG4gKiAgICAgU2VlOiBodHRwczovL2J1Z3ppbGxhLm1vemlsbGEub3JnL3Nob3dfYnVnLmNnaT9pZD02OTU0MzguXG4gKlxuICogICAtIFNhZmFyaSA1LTcgbGFja3Mgc3VwcG9ydCBmb3IgY2hhbmdpbmcgdGhlIGBPYmplY3QucHJvdG90eXBlLmNvbnN0cnVjdG9yYCBwcm9wZXJ0eVxuICogICAgIG9uIG9iamVjdHMuXG4gKlxuICogICAtIENocm9tZSA5LTEwIGlzIG1pc3NpbmcgdGhlIGBUeXBlZEFycmF5LnByb3RvdHlwZS5zdWJhcnJheWAgZnVuY3Rpb24uXG4gKlxuICogICAtIElFMTAgaGFzIGEgYnJva2VuIGBUeXBlZEFycmF5LnByb3RvdHlwZS5zdWJhcnJheWAgZnVuY3Rpb24gd2hpY2ggcmV0dXJucyBhcnJheXMgb2ZcbiAqICAgICBpbmNvcnJlY3QgbGVuZ3RoIGluIHNvbWUgc2l0dWF0aW9ucy5cblxuICogV2UgZGV0ZWN0IHRoZXNlIGJ1Z2d5IGJyb3dzZXJzIGFuZCBzZXQgYEJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUYCB0byBgZmFsc2VgIHNvIHRoZXlcbiAqIGdldCB0aGUgT2JqZWN0IGltcGxlbWVudGF0aW9uLCB3aGljaCBpcyBzbG93ZXIgYnV0IGJlaGF2ZXMgY29ycmVjdGx5LlxuICovXG5CdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVCA9IGdsb2JhbC5UWVBFRF9BUlJBWV9TVVBQT1JUICE9PSB1bmRlZmluZWRcbiAgPyBnbG9iYWwuVFlQRURfQVJSQVlfU1VQUE9SVFxuICA6IHR5cGVkQXJyYXlTdXBwb3J0KClcblxuZnVuY3Rpb24gdHlwZWRBcnJheVN1cHBvcnQgKCkge1xuICBmdW5jdGlvbiBCYXIgKCkge31cbiAgdHJ5IHtcbiAgICB2YXIgYXJyID0gbmV3IFVpbnQ4QXJyYXkoMSlcbiAgICBhcnIuZm9vID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gNDIgfVxuICAgIGFyci5jb25zdHJ1Y3RvciA9IEJhclxuICAgIHJldHVybiBhcnIuZm9vKCkgPT09IDQyICYmIC8vIHR5cGVkIGFycmF5IGluc3RhbmNlcyBjYW4gYmUgYXVnbWVudGVkXG4gICAgICAgIGFyci5jb25zdHJ1Y3RvciA9PT0gQmFyICYmIC8vIGNvbnN0cnVjdG9yIGNhbiBiZSBzZXRcbiAgICAgICAgdHlwZW9mIGFyci5zdWJhcnJheSA9PT0gJ2Z1bmN0aW9uJyAmJiAvLyBjaHJvbWUgOS0xMCBsYWNrIGBzdWJhcnJheWBcbiAgICAgICAgYXJyLnN1YmFycmF5KDEsIDEpLmJ5dGVMZW5ndGggPT09IDAgLy8gaWUxMCBoYXMgYnJva2VuIGBzdWJhcnJheWBcbiAgfSBjYXRjaCAoZSkge1xuICAgIHJldHVybiBmYWxzZVxuICB9XG59XG5cbmZ1bmN0aW9uIGtNYXhMZW5ndGggKCkge1xuICByZXR1cm4gQnVmZmVyLlRZUEVEX0FSUkFZX1NVUFBPUlRcbiAgICA/IDB4N2ZmZmZmZmZcbiAgICA6IDB4M2ZmZmZmZmZcbn1cblxuLyoqXG4gKiBDbGFzczogQnVmZmVyXG4gKiA9PT09PT09PT09PT09XG4gKlxuICogVGhlIEJ1ZmZlciBjb25zdHJ1Y3RvciByZXR1cm5zIGluc3RhbmNlcyBvZiBgVWludDhBcnJheWAgdGhhdCBhcmUgYXVnbWVudGVkXG4gKiB3aXRoIGZ1bmN0aW9uIHByb3BlcnRpZXMgZm9yIGFsbCB0aGUgbm9kZSBgQnVmZmVyYCBBUEkgZnVuY3Rpb25zLiBXZSB1c2VcbiAqIGBVaW50OEFycmF5YCBzbyB0aGF0IHNxdWFyZSBicmFja2V0IG5vdGF0aW9uIHdvcmtzIGFzIGV4cGVjdGVkIC0tIGl0IHJldHVybnNcbiAqIGEgc2luZ2xlIG9jdGV0LlxuICpcbiAqIEJ5IGF1Z21lbnRpbmcgdGhlIGluc3RhbmNlcywgd2UgY2FuIGF2b2lkIG1vZGlmeWluZyB0aGUgYFVpbnQ4QXJyYXlgXG4gKiBwcm90b3R5cGUuXG4gKi9cbmZ1bmN0aW9uIEJ1ZmZlciAoYXJnKSB7XG4gIGlmICghKHRoaXMgaW5zdGFuY2VvZiBCdWZmZXIpKSB7XG4gICAgLy8gQXZvaWQgZ29pbmcgdGhyb3VnaCBhbiBBcmd1bWVudHNBZGFwdG9yVHJhbXBvbGluZSBpbiB0aGUgY29tbW9uIGNhc2UuXG4gICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPiAxKSByZXR1cm4gbmV3IEJ1ZmZlcihhcmcsIGFyZ3VtZW50c1sxXSlcbiAgICByZXR1cm4gbmV3IEJ1ZmZlcihhcmcpXG4gIH1cblxuICB0aGlzLmxlbmd0aCA9IDBcbiAgdGhpcy5wYXJlbnQgPSB1bmRlZmluZWRcblxuICAvLyBDb21tb24gY2FzZS5cbiAgaWYgKHR5cGVvZiBhcmcgPT09ICdudW1iZXInKSB7XG4gICAgcmV0dXJuIGZyb21OdW1iZXIodGhpcywgYXJnKVxuICB9XG5cbiAgLy8gU2xpZ2h0bHkgbGVzcyBjb21tb24gY2FzZS5cbiAgaWYgKHR5cGVvZiBhcmcgPT09ICdzdHJpbmcnKSB7XG4gICAgcmV0dXJuIGZyb21TdHJpbmcodGhpcywgYXJnLCBhcmd1bWVudHMubGVuZ3RoID4gMSA/IGFyZ3VtZW50c1sxXSA6ICd1dGY4JylcbiAgfVxuXG4gIC8vIFVudXN1YWwuXG4gIHJldHVybiBmcm9tT2JqZWN0KHRoaXMsIGFyZylcbn1cblxuZnVuY3Rpb24gZnJvbU51bWJlciAodGhhdCwgbGVuZ3RoKSB7XG4gIHRoYXQgPSBhbGxvY2F0ZSh0aGF0LCBsZW5ndGggPCAwID8gMCA6IGNoZWNrZWQobGVuZ3RoKSB8IDApXG4gIGlmICghQnVmZmVyLlRZUEVEX0FSUkFZX1NVUFBPUlQpIHtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgICB0aGF0W2ldID0gMFxuICAgIH1cbiAgfVxuICByZXR1cm4gdGhhdFxufVxuXG5mdW5jdGlvbiBmcm9tU3RyaW5nICh0aGF0LCBzdHJpbmcsIGVuY29kaW5nKSB7XG4gIGlmICh0eXBlb2YgZW5jb2RpbmcgIT09ICdzdHJpbmcnIHx8IGVuY29kaW5nID09PSAnJykgZW5jb2RpbmcgPSAndXRmOCdcblxuICAvLyBBc3N1bXB0aW9uOiBieXRlTGVuZ3RoKCkgcmV0dXJuIHZhbHVlIGlzIGFsd2F5cyA8IGtNYXhMZW5ndGguXG4gIHZhciBsZW5ndGggPSBieXRlTGVuZ3RoKHN0cmluZywgZW5jb2RpbmcpIHwgMFxuICB0aGF0ID0gYWxsb2NhdGUodGhhdCwgbGVuZ3RoKVxuXG4gIHRoYXQud3JpdGUoc3RyaW5nLCBlbmNvZGluZylcbiAgcmV0dXJuIHRoYXRcbn1cblxuZnVuY3Rpb24gZnJvbU9iamVjdCAodGhhdCwgb2JqZWN0KSB7XG4gIGlmIChCdWZmZXIuaXNCdWZmZXIob2JqZWN0KSkgcmV0dXJuIGZyb21CdWZmZXIodGhhdCwgb2JqZWN0KVxuXG4gIGlmIChpc0FycmF5KG9iamVjdCkpIHJldHVybiBmcm9tQXJyYXkodGhhdCwgb2JqZWN0KVxuXG4gIGlmIChvYmplY3QgPT0gbnVsbCkge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ211c3Qgc3RhcnQgd2l0aCBudW1iZXIsIGJ1ZmZlciwgYXJyYXkgb3Igc3RyaW5nJylcbiAgfVxuXG4gIGlmICh0eXBlb2YgQXJyYXlCdWZmZXIgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgaWYgKG9iamVjdC5idWZmZXIgaW5zdGFuY2VvZiBBcnJheUJ1ZmZlcikge1xuICAgICAgcmV0dXJuIGZyb21UeXBlZEFycmF5KHRoYXQsIG9iamVjdClcbiAgICB9XG4gICAgaWYgKG9iamVjdCBpbnN0YW5jZW9mIEFycmF5QnVmZmVyKSB7XG4gICAgICByZXR1cm4gZnJvbUFycmF5QnVmZmVyKHRoYXQsIG9iamVjdClcbiAgICB9XG4gIH1cblxuICBpZiAob2JqZWN0Lmxlbmd0aCkgcmV0dXJuIGZyb21BcnJheUxpa2UodGhhdCwgb2JqZWN0KVxuXG4gIHJldHVybiBmcm9tSnNvbk9iamVjdCh0aGF0LCBvYmplY3QpXG59XG5cbmZ1bmN0aW9uIGZyb21CdWZmZXIgKHRoYXQsIGJ1ZmZlcikge1xuICB2YXIgbGVuZ3RoID0gY2hlY2tlZChidWZmZXIubGVuZ3RoKSB8IDBcbiAgdGhhdCA9IGFsbG9jYXRlKHRoYXQsIGxlbmd0aClcbiAgYnVmZmVyLmNvcHkodGhhdCwgMCwgMCwgbGVuZ3RoKVxuICByZXR1cm4gdGhhdFxufVxuXG5mdW5jdGlvbiBmcm9tQXJyYXkgKHRoYXQsIGFycmF5KSB7XG4gIHZhciBsZW5ndGggPSBjaGVja2VkKGFycmF5Lmxlbmd0aCkgfCAwXG4gIHRoYXQgPSBhbGxvY2F0ZSh0aGF0LCBsZW5ndGgpXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuZ3RoOyBpICs9IDEpIHtcbiAgICB0aGF0W2ldID0gYXJyYXlbaV0gJiAyNTVcbiAgfVxuICByZXR1cm4gdGhhdFxufVxuXG4vLyBEdXBsaWNhdGUgb2YgZnJvbUFycmF5KCkgdG8ga2VlcCBmcm9tQXJyYXkoKSBtb25vbW9ycGhpYy5cbmZ1bmN0aW9uIGZyb21UeXBlZEFycmF5ICh0aGF0LCBhcnJheSkge1xuICB2YXIgbGVuZ3RoID0gY2hlY2tlZChhcnJheS5sZW5ndGgpIHwgMFxuICB0aGF0ID0gYWxsb2NhdGUodGhhdCwgbGVuZ3RoKVxuICAvLyBUcnVuY2F0aW5nIHRoZSBlbGVtZW50cyBpcyBwcm9iYWJseSBub3Qgd2hhdCBwZW9wbGUgZXhwZWN0IGZyb20gdHlwZWRcbiAgLy8gYXJyYXlzIHdpdGggQllURVNfUEVSX0VMRU1FTlQgPiAxIGJ1dCBpdCdzIGNvbXBhdGlibGUgd2l0aCB0aGUgYmVoYXZpb3JcbiAgLy8gb2YgdGhlIG9sZCBCdWZmZXIgY29uc3RydWN0b3IuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuZ3RoOyBpICs9IDEpIHtcbiAgICB0aGF0W2ldID0gYXJyYXlbaV0gJiAyNTVcbiAgfVxuICByZXR1cm4gdGhhdFxufVxuXG5mdW5jdGlvbiBmcm9tQXJyYXlCdWZmZXIgKHRoYXQsIGFycmF5KSB7XG4gIGlmIChCdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVCkge1xuICAgIC8vIFJldHVybiBhbiBhdWdtZW50ZWQgYFVpbnQ4QXJyYXlgIGluc3RhbmNlLCBmb3IgYmVzdCBwZXJmb3JtYW5jZVxuICAgIGFycmF5LmJ5dGVMZW5ndGhcbiAgICB0aGF0ID0gQnVmZmVyLl9hdWdtZW50KG5ldyBVaW50OEFycmF5KGFycmF5KSlcbiAgfSBlbHNlIHtcbiAgICAvLyBGYWxsYmFjazogUmV0dXJuIGFuIG9iamVjdCBpbnN0YW5jZSBvZiB0aGUgQnVmZmVyIGNsYXNzXG4gICAgdGhhdCA9IGZyb21UeXBlZEFycmF5KHRoYXQsIG5ldyBVaW50OEFycmF5KGFycmF5KSlcbiAgfVxuICByZXR1cm4gdGhhdFxufVxuXG5mdW5jdGlvbiBmcm9tQXJyYXlMaWtlICh0aGF0LCBhcnJheSkge1xuICB2YXIgbGVuZ3RoID0gY2hlY2tlZChhcnJheS5sZW5ndGgpIHwgMFxuICB0aGF0ID0gYWxsb2NhdGUodGhhdCwgbGVuZ3RoKVxuICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbmd0aDsgaSArPSAxKSB7XG4gICAgdGhhdFtpXSA9IGFycmF5W2ldICYgMjU1XG4gIH1cbiAgcmV0dXJuIHRoYXRcbn1cblxuLy8gRGVzZXJpYWxpemUgeyB0eXBlOiAnQnVmZmVyJywgZGF0YTogWzEsMiwzLC4uLl0gfSBpbnRvIGEgQnVmZmVyIG9iamVjdC5cbi8vIFJldHVybnMgYSB6ZXJvLWxlbmd0aCBidWZmZXIgZm9yIGlucHV0cyB0aGF0IGRvbid0IGNvbmZvcm0gdG8gdGhlIHNwZWMuXG5mdW5jdGlvbiBmcm9tSnNvbk9iamVjdCAodGhhdCwgb2JqZWN0KSB7XG4gIHZhciBhcnJheVxuICB2YXIgbGVuZ3RoID0gMFxuXG4gIGlmIChvYmplY3QudHlwZSA9PT0gJ0J1ZmZlcicgJiYgaXNBcnJheShvYmplY3QuZGF0YSkpIHtcbiAgICBhcnJheSA9IG9iamVjdC5kYXRhXG4gICAgbGVuZ3RoID0gY2hlY2tlZChhcnJheS5sZW5ndGgpIHwgMFxuICB9XG4gIHRoYXQgPSBhbGxvY2F0ZSh0aGF0LCBsZW5ndGgpXG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW5ndGg7IGkgKz0gMSkge1xuICAgIHRoYXRbaV0gPSBhcnJheVtpXSAmIDI1NVxuICB9XG4gIHJldHVybiB0aGF0XG59XG5cbmlmIChCdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVCkge1xuICBCdWZmZXIucHJvdG90eXBlLl9fcHJvdG9fXyA9IFVpbnQ4QXJyYXkucHJvdG90eXBlXG4gIEJ1ZmZlci5fX3Byb3RvX18gPSBVaW50OEFycmF5XG59XG5cbmZ1bmN0aW9uIGFsbG9jYXRlICh0aGF0LCBsZW5ndGgpIHtcbiAgaWYgKEJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUKSB7XG4gICAgLy8gUmV0dXJuIGFuIGF1Z21lbnRlZCBgVWludDhBcnJheWAgaW5zdGFuY2UsIGZvciBiZXN0IHBlcmZvcm1hbmNlXG4gICAgdGhhdCA9IEJ1ZmZlci5fYXVnbWVudChuZXcgVWludDhBcnJheShsZW5ndGgpKVxuICAgIHRoYXQuX19wcm90b19fID0gQnVmZmVyLnByb3RvdHlwZVxuICB9IGVsc2Uge1xuICAgIC8vIEZhbGxiYWNrOiBSZXR1cm4gYW4gb2JqZWN0IGluc3RhbmNlIG9mIHRoZSBCdWZmZXIgY2xhc3NcbiAgICB0aGF0Lmxlbmd0aCA9IGxlbmd0aFxuICAgIHRoYXQuX2lzQnVmZmVyID0gdHJ1ZVxuICB9XG5cbiAgdmFyIGZyb21Qb29sID0gbGVuZ3RoICE9PSAwICYmIGxlbmd0aCA8PSBCdWZmZXIucG9vbFNpemUgPj4+IDFcbiAgaWYgKGZyb21Qb29sKSB0aGF0LnBhcmVudCA9IHJvb3RQYXJlbnRcblxuICByZXR1cm4gdGhhdFxufVxuXG5mdW5jdGlvbiBjaGVja2VkIChsZW5ndGgpIHtcbiAgLy8gTm90ZTogY2Fubm90IHVzZSBgbGVuZ3RoIDwga01heExlbmd0aGAgaGVyZSBiZWNhdXNlIHRoYXQgZmFpbHMgd2hlblxuICAvLyBsZW5ndGggaXMgTmFOICh3aGljaCBpcyBvdGhlcndpc2UgY29lcmNlZCB0byB6ZXJvLilcbiAgaWYgKGxlbmd0aCA+PSBrTWF4TGVuZ3RoKCkpIHtcbiAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignQXR0ZW1wdCB0byBhbGxvY2F0ZSBCdWZmZXIgbGFyZ2VyIHRoYW4gbWF4aW11bSAnICtcbiAgICAgICAgICAgICAgICAgICAgICAgICAnc2l6ZTogMHgnICsga01heExlbmd0aCgpLnRvU3RyaW5nKDE2KSArICcgYnl0ZXMnKVxuICB9XG4gIHJldHVybiBsZW5ndGggfCAwXG59XG5cbmZ1bmN0aW9uIFNsb3dCdWZmZXIgKHN1YmplY3QsIGVuY29kaW5nKSB7XG4gIGlmICghKHRoaXMgaW5zdGFuY2VvZiBTbG93QnVmZmVyKSkgcmV0dXJuIG5ldyBTbG93QnVmZmVyKHN1YmplY3QsIGVuY29kaW5nKVxuXG4gIHZhciBidWYgPSBuZXcgQnVmZmVyKHN1YmplY3QsIGVuY29kaW5nKVxuICBkZWxldGUgYnVmLnBhcmVudFxuICByZXR1cm4gYnVmXG59XG5cbkJ1ZmZlci5pc0J1ZmZlciA9IGZ1bmN0aW9uIGlzQnVmZmVyIChiKSB7XG4gIHJldHVybiAhIShiICE9IG51bGwgJiYgYi5faXNCdWZmZXIpXG59XG5cbkJ1ZmZlci5jb21wYXJlID0gZnVuY3Rpb24gY29tcGFyZSAoYSwgYikge1xuICBpZiAoIUJ1ZmZlci5pc0J1ZmZlcihhKSB8fCAhQnVmZmVyLmlzQnVmZmVyKGIpKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignQXJndW1lbnRzIG11c3QgYmUgQnVmZmVycycpXG4gIH1cblxuICBpZiAoYSA9PT0gYikgcmV0dXJuIDBcblxuICB2YXIgeCA9IGEubGVuZ3RoXG4gIHZhciB5ID0gYi5sZW5ndGhcblxuICB2YXIgaSA9IDBcbiAgdmFyIGxlbiA9IE1hdGgubWluKHgsIHkpXG4gIHdoaWxlIChpIDwgbGVuKSB7XG4gICAgaWYgKGFbaV0gIT09IGJbaV0pIGJyZWFrXG5cbiAgICArK2lcbiAgfVxuXG4gIGlmIChpICE9PSBsZW4pIHtcbiAgICB4ID0gYVtpXVxuICAgIHkgPSBiW2ldXG4gIH1cblxuICBpZiAoeCA8IHkpIHJldHVybiAtMVxuICBpZiAoeSA8IHgpIHJldHVybiAxXG4gIHJldHVybiAwXG59XG5cbkJ1ZmZlci5pc0VuY29kaW5nID0gZnVuY3Rpb24gaXNFbmNvZGluZyAoZW5jb2RpbmcpIHtcbiAgc3dpdGNoIChTdHJpbmcoZW5jb2RpbmcpLnRvTG93ZXJDYXNlKCkpIHtcbiAgICBjYXNlICdoZXgnOlxuICAgIGNhc2UgJ3V0ZjgnOlxuICAgIGNhc2UgJ3V0Zi04JzpcbiAgICBjYXNlICdhc2NpaSc6XG4gICAgY2FzZSAnYmluYXJ5JzpcbiAgICBjYXNlICdiYXNlNjQnOlxuICAgIGNhc2UgJ3Jhdyc6XG4gICAgY2FzZSAndWNzMic6XG4gICAgY2FzZSAndWNzLTInOlxuICAgIGNhc2UgJ3V0ZjE2bGUnOlxuICAgIGNhc2UgJ3V0Zi0xNmxlJzpcbiAgICAgIHJldHVybiB0cnVlXG4gICAgZGVmYXVsdDpcbiAgICAgIHJldHVybiBmYWxzZVxuICB9XG59XG5cbkJ1ZmZlci5jb25jYXQgPSBmdW5jdGlvbiBjb25jYXQgKGxpc3QsIGxlbmd0aCkge1xuICBpZiAoIWlzQXJyYXkobGlzdCkpIHRocm93IG5ldyBUeXBlRXJyb3IoJ2xpc3QgYXJndW1lbnQgbXVzdCBiZSBhbiBBcnJheSBvZiBCdWZmZXJzLicpXG5cbiAgaWYgKGxpc3QubGVuZ3RoID09PSAwKSB7XG4gICAgcmV0dXJuIG5ldyBCdWZmZXIoMClcbiAgfVxuXG4gIHZhciBpXG4gIGlmIChsZW5ndGggPT09IHVuZGVmaW5lZCkge1xuICAgIGxlbmd0aCA9IDBcbiAgICBmb3IgKGkgPSAwOyBpIDwgbGlzdC5sZW5ndGg7IGkrKykge1xuICAgICAgbGVuZ3RoICs9IGxpc3RbaV0ubGVuZ3RoXG4gICAgfVxuICB9XG5cbiAgdmFyIGJ1ZiA9IG5ldyBCdWZmZXIobGVuZ3RoKVxuICB2YXIgcG9zID0gMFxuICBmb3IgKGkgPSAwOyBpIDwgbGlzdC5sZW5ndGg7IGkrKykge1xuICAgIHZhciBpdGVtID0gbGlzdFtpXVxuICAgIGl0ZW0uY29weShidWYsIHBvcylcbiAgICBwb3MgKz0gaXRlbS5sZW5ndGhcbiAgfVxuICByZXR1cm4gYnVmXG59XG5cbmZ1bmN0aW9uIGJ5dGVMZW5ndGggKHN0cmluZywgZW5jb2RpbmcpIHtcbiAgaWYgKHR5cGVvZiBzdHJpbmcgIT09ICdzdHJpbmcnKSBzdHJpbmcgPSAnJyArIHN0cmluZ1xuXG4gIHZhciBsZW4gPSBzdHJpbmcubGVuZ3RoXG4gIGlmIChsZW4gPT09IDApIHJldHVybiAwXG5cbiAgLy8gVXNlIGEgZm9yIGxvb3AgdG8gYXZvaWQgcmVjdXJzaW9uXG4gIHZhciBsb3dlcmVkQ2FzZSA9IGZhbHNlXG4gIGZvciAoOzspIHtcbiAgICBzd2l0Y2ggKGVuY29kaW5nKSB7XG4gICAgICBjYXNlICdhc2NpaSc6XG4gICAgICBjYXNlICdiaW5hcnknOlxuICAgICAgLy8gRGVwcmVjYXRlZFxuICAgICAgY2FzZSAncmF3JzpcbiAgICAgIGNhc2UgJ3Jhd3MnOlxuICAgICAgICByZXR1cm4gbGVuXG4gICAgICBjYXNlICd1dGY4JzpcbiAgICAgIGNhc2UgJ3V0Zi04JzpcbiAgICAgICAgcmV0dXJuIHV0ZjhUb0J5dGVzKHN0cmluZykubGVuZ3RoXG4gICAgICBjYXNlICd1Y3MyJzpcbiAgICAgIGNhc2UgJ3Vjcy0yJzpcbiAgICAgIGNhc2UgJ3V0ZjE2bGUnOlxuICAgICAgY2FzZSAndXRmLTE2bGUnOlxuICAgICAgICByZXR1cm4gbGVuICogMlxuICAgICAgY2FzZSAnaGV4JzpcbiAgICAgICAgcmV0dXJuIGxlbiA+Pj4gMVxuICAgICAgY2FzZSAnYmFzZTY0JzpcbiAgICAgICAgcmV0dXJuIGJhc2U2NFRvQnl0ZXMoc3RyaW5nKS5sZW5ndGhcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIGlmIChsb3dlcmVkQ2FzZSkgcmV0dXJuIHV0ZjhUb0J5dGVzKHN0cmluZykubGVuZ3RoIC8vIGFzc3VtZSB1dGY4XG4gICAgICAgIGVuY29kaW5nID0gKCcnICsgZW5jb2RpbmcpLnRvTG93ZXJDYXNlKClcbiAgICAgICAgbG93ZXJlZENhc2UgPSB0cnVlXG4gICAgfVxuICB9XG59XG5CdWZmZXIuYnl0ZUxlbmd0aCA9IGJ5dGVMZW5ndGhcblxuLy8gcHJlLXNldCBmb3IgdmFsdWVzIHRoYXQgbWF5IGV4aXN0IGluIHRoZSBmdXR1cmVcbkJ1ZmZlci5wcm90b3R5cGUubGVuZ3RoID0gdW5kZWZpbmVkXG5CdWZmZXIucHJvdG90eXBlLnBhcmVudCA9IHVuZGVmaW5lZFxuXG5mdW5jdGlvbiBzbG93VG9TdHJpbmcgKGVuY29kaW5nLCBzdGFydCwgZW5kKSB7XG4gIHZhciBsb3dlcmVkQ2FzZSA9IGZhbHNlXG5cbiAgc3RhcnQgPSBzdGFydCB8IDBcbiAgZW5kID0gZW5kID09PSB1bmRlZmluZWQgfHwgZW5kID09PSBJbmZpbml0eSA/IHRoaXMubGVuZ3RoIDogZW5kIHwgMFxuXG4gIGlmICghZW5jb2RpbmcpIGVuY29kaW5nID0gJ3V0ZjgnXG4gIGlmIChzdGFydCA8IDApIHN0YXJ0ID0gMFxuICBpZiAoZW5kID4gdGhpcy5sZW5ndGgpIGVuZCA9IHRoaXMubGVuZ3RoXG4gIGlmIChlbmQgPD0gc3RhcnQpIHJldHVybiAnJ1xuXG4gIHdoaWxlICh0cnVlKSB7XG4gICAgc3dpdGNoIChlbmNvZGluZykge1xuICAgICAgY2FzZSAnaGV4JzpcbiAgICAgICAgcmV0dXJuIGhleFNsaWNlKHRoaXMsIHN0YXJ0LCBlbmQpXG5cbiAgICAgIGNhc2UgJ3V0ZjgnOlxuICAgICAgY2FzZSAndXRmLTgnOlxuICAgICAgICByZXR1cm4gdXRmOFNsaWNlKHRoaXMsIHN0YXJ0LCBlbmQpXG5cbiAgICAgIGNhc2UgJ2FzY2lpJzpcbiAgICAgICAgcmV0dXJuIGFzY2lpU2xpY2UodGhpcywgc3RhcnQsIGVuZClcblxuICAgICAgY2FzZSAnYmluYXJ5JzpcbiAgICAgICAgcmV0dXJuIGJpbmFyeVNsaWNlKHRoaXMsIHN0YXJ0LCBlbmQpXG5cbiAgICAgIGNhc2UgJ2Jhc2U2NCc6XG4gICAgICAgIHJldHVybiBiYXNlNjRTbGljZSh0aGlzLCBzdGFydCwgZW5kKVxuXG4gICAgICBjYXNlICd1Y3MyJzpcbiAgICAgIGNhc2UgJ3Vjcy0yJzpcbiAgICAgIGNhc2UgJ3V0ZjE2bGUnOlxuICAgICAgY2FzZSAndXRmLTE2bGUnOlxuICAgICAgICByZXR1cm4gdXRmMTZsZVNsaWNlKHRoaXMsIHN0YXJ0LCBlbmQpXG5cbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIGlmIChsb3dlcmVkQ2FzZSkgdGhyb3cgbmV3IFR5cGVFcnJvcignVW5rbm93biBlbmNvZGluZzogJyArIGVuY29kaW5nKVxuICAgICAgICBlbmNvZGluZyA9IChlbmNvZGluZyArICcnKS50b0xvd2VyQ2FzZSgpXG4gICAgICAgIGxvd2VyZWRDYXNlID0gdHJ1ZVxuICAgIH1cbiAgfVxufVxuXG5CdWZmZXIucHJvdG90eXBlLnRvU3RyaW5nID0gZnVuY3Rpb24gdG9TdHJpbmcgKCkge1xuICB2YXIgbGVuZ3RoID0gdGhpcy5sZW5ndGggfCAwXG4gIGlmIChsZW5ndGggPT09IDApIHJldHVybiAnJ1xuICBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMCkgcmV0dXJuIHV0ZjhTbGljZSh0aGlzLCAwLCBsZW5ndGgpXG4gIHJldHVybiBzbG93VG9TdHJpbmcuYXBwbHkodGhpcywgYXJndW1lbnRzKVxufVxuXG5CdWZmZXIucHJvdG90eXBlLmVxdWFscyA9IGZ1bmN0aW9uIGVxdWFscyAoYikge1xuICBpZiAoIUJ1ZmZlci5pc0J1ZmZlcihiKSkgdGhyb3cgbmV3IFR5cGVFcnJvcignQXJndW1lbnQgbXVzdCBiZSBhIEJ1ZmZlcicpXG4gIGlmICh0aGlzID09PSBiKSByZXR1cm4gdHJ1ZVxuICByZXR1cm4gQnVmZmVyLmNvbXBhcmUodGhpcywgYikgPT09IDBcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5pbnNwZWN0ID0gZnVuY3Rpb24gaW5zcGVjdCAoKSB7XG4gIHZhciBzdHIgPSAnJ1xuICB2YXIgbWF4ID0gZXhwb3J0cy5JTlNQRUNUX01BWF9CWVRFU1xuICBpZiAodGhpcy5sZW5ndGggPiAwKSB7XG4gICAgc3RyID0gdGhpcy50b1N0cmluZygnaGV4JywgMCwgbWF4KS5tYXRjaCgvLnsyfS9nKS5qb2luKCcgJylcbiAgICBpZiAodGhpcy5sZW5ndGggPiBtYXgpIHN0ciArPSAnIC4uLiAnXG4gIH1cbiAgcmV0dXJuICc8QnVmZmVyICcgKyBzdHIgKyAnPidcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5jb21wYXJlID0gZnVuY3Rpb24gY29tcGFyZSAoYikge1xuICBpZiAoIUJ1ZmZlci5pc0J1ZmZlcihiKSkgdGhyb3cgbmV3IFR5cGVFcnJvcignQXJndW1lbnQgbXVzdCBiZSBhIEJ1ZmZlcicpXG4gIGlmICh0aGlzID09PSBiKSByZXR1cm4gMFxuICByZXR1cm4gQnVmZmVyLmNvbXBhcmUodGhpcywgYilcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5pbmRleE9mID0gZnVuY3Rpb24gaW5kZXhPZiAodmFsLCBieXRlT2Zmc2V0KSB7XG4gIGlmIChieXRlT2Zmc2V0ID4gMHg3ZmZmZmZmZikgYnl0ZU9mZnNldCA9IDB4N2ZmZmZmZmZcbiAgZWxzZSBpZiAoYnl0ZU9mZnNldCA8IC0weDgwMDAwMDAwKSBieXRlT2Zmc2V0ID0gLTB4ODAwMDAwMDBcbiAgYnl0ZU9mZnNldCA+Pj0gMFxuXG4gIGlmICh0aGlzLmxlbmd0aCA9PT0gMCkgcmV0dXJuIC0xXG4gIGlmIChieXRlT2Zmc2V0ID49IHRoaXMubGVuZ3RoKSByZXR1cm4gLTFcblxuICAvLyBOZWdhdGl2ZSBvZmZzZXRzIHN0YXJ0IGZyb20gdGhlIGVuZCBvZiB0aGUgYnVmZmVyXG4gIGlmIChieXRlT2Zmc2V0IDwgMCkgYnl0ZU9mZnNldCA9IE1hdGgubWF4KHRoaXMubGVuZ3RoICsgYnl0ZU9mZnNldCwgMClcblxuICBpZiAodHlwZW9mIHZhbCA9PT0gJ3N0cmluZycpIHtcbiAgICBpZiAodmFsLmxlbmd0aCA9PT0gMCkgcmV0dXJuIC0xIC8vIHNwZWNpYWwgY2FzZTogbG9va2luZyBmb3IgZW1wdHkgc3RyaW5nIGFsd2F5cyBmYWlsc1xuICAgIHJldHVybiBTdHJpbmcucHJvdG90eXBlLmluZGV4T2YuY2FsbCh0aGlzLCB2YWwsIGJ5dGVPZmZzZXQpXG4gIH1cbiAgaWYgKEJ1ZmZlci5pc0J1ZmZlcih2YWwpKSB7XG4gICAgcmV0dXJuIGFycmF5SW5kZXhPZih0aGlzLCB2YWwsIGJ5dGVPZmZzZXQpXG4gIH1cbiAgaWYgKHR5cGVvZiB2YWwgPT09ICdudW1iZXInKSB7XG4gICAgaWYgKEJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUICYmIFVpbnQ4QXJyYXkucHJvdG90eXBlLmluZGV4T2YgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIHJldHVybiBVaW50OEFycmF5LnByb3RvdHlwZS5pbmRleE9mLmNhbGwodGhpcywgdmFsLCBieXRlT2Zmc2V0KVxuICAgIH1cbiAgICByZXR1cm4gYXJyYXlJbmRleE9mKHRoaXMsIFsgdmFsIF0sIGJ5dGVPZmZzZXQpXG4gIH1cblxuICBmdW5jdGlvbiBhcnJheUluZGV4T2YgKGFyciwgdmFsLCBieXRlT2Zmc2V0KSB7XG4gICAgdmFyIGZvdW5kSW5kZXggPSAtMVxuICAgIGZvciAodmFyIGkgPSAwOyBieXRlT2Zmc2V0ICsgaSA8IGFyci5sZW5ndGg7IGkrKykge1xuICAgICAgaWYgKGFycltieXRlT2Zmc2V0ICsgaV0gPT09IHZhbFtmb3VuZEluZGV4ID09PSAtMSA/IDAgOiBpIC0gZm91bmRJbmRleF0pIHtcbiAgICAgICAgaWYgKGZvdW5kSW5kZXggPT09IC0xKSBmb3VuZEluZGV4ID0gaVxuICAgICAgICBpZiAoaSAtIGZvdW5kSW5kZXggKyAxID09PSB2YWwubGVuZ3RoKSByZXR1cm4gYnl0ZU9mZnNldCArIGZvdW5kSW5kZXhcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGZvdW5kSW5kZXggPSAtMVxuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gLTFcbiAgfVxuXG4gIHRocm93IG5ldyBUeXBlRXJyb3IoJ3ZhbCBtdXN0IGJlIHN0cmluZywgbnVtYmVyIG9yIEJ1ZmZlcicpXG59XG5cbi8vIGBnZXRgIGlzIGRlcHJlY2F0ZWRcbkJ1ZmZlci5wcm90b3R5cGUuZ2V0ID0gZnVuY3Rpb24gZ2V0IChvZmZzZXQpIHtcbiAgY29uc29sZS5sb2coJy5nZXQoKSBpcyBkZXByZWNhdGVkLiBBY2Nlc3MgdXNpbmcgYXJyYXkgaW5kZXhlcyBpbnN0ZWFkLicpXG4gIHJldHVybiB0aGlzLnJlYWRVSW50OChvZmZzZXQpXG59XG5cbi8vIGBzZXRgIGlzIGRlcHJlY2F0ZWRcbkJ1ZmZlci5wcm90b3R5cGUuc2V0ID0gZnVuY3Rpb24gc2V0ICh2LCBvZmZzZXQpIHtcbiAgY29uc29sZS5sb2coJy5zZXQoKSBpcyBkZXByZWNhdGVkLiBBY2Nlc3MgdXNpbmcgYXJyYXkgaW5kZXhlcyBpbnN0ZWFkLicpXG4gIHJldHVybiB0aGlzLndyaXRlVUludDgodiwgb2Zmc2V0KVxufVxuXG5mdW5jdGlvbiBoZXhXcml0ZSAoYnVmLCBzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKSB7XG4gIG9mZnNldCA9IE51bWJlcihvZmZzZXQpIHx8IDBcbiAgdmFyIHJlbWFpbmluZyA9IGJ1Zi5sZW5ndGggLSBvZmZzZXRcbiAgaWYgKCFsZW5ndGgpIHtcbiAgICBsZW5ndGggPSByZW1haW5pbmdcbiAgfSBlbHNlIHtcbiAgICBsZW5ndGggPSBOdW1iZXIobGVuZ3RoKVxuICAgIGlmIChsZW5ndGggPiByZW1haW5pbmcpIHtcbiAgICAgIGxlbmd0aCA9IHJlbWFpbmluZ1xuICAgIH1cbiAgfVxuXG4gIC8vIG11c3QgYmUgYW4gZXZlbiBudW1iZXIgb2YgZGlnaXRzXG4gIHZhciBzdHJMZW4gPSBzdHJpbmcubGVuZ3RoXG4gIGlmIChzdHJMZW4gJSAyICE9PSAwKSB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgaGV4IHN0cmluZycpXG5cbiAgaWYgKGxlbmd0aCA+IHN0ckxlbiAvIDIpIHtcbiAgICBsZW5ndGggPSBzdHJMZW4gLyAyXG4gIH1cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgIHZhciBwYXJzZWQgPSBwYXJzZUludChzdHJpbmcuc3Vic3RyKGkgKiAyLCAyKSwgMTYpXG4gICAgaWYgKGlzTmFOKHBhcnNlZCkpIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBoZXggc3RyaW5nJylcbiAgICBidWZbb2Zmc2V0ICsgaV0gPSBwYXJzZWRcbiAgfVxuICByZXR1cm4gaVxufVxuXG5mdW5jdGlvbiB1dGY4V3JpdGUgKGJ1Ziwgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aCkge1xuICByZXR1cm4gYmxpdEJ1ZmZlcih1dGY4VG9CeXRlcyhzdHJpbmcsIGJ1Zi5sZW5ndGggLSBvZmZzZXQpLCBidWYsIG9mZnNldCwgbGVuZ3RoKVxufVxuXG5mdW5jdGlvbiBhc2NpaVdyaXRlIChidWYsIHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpIHtcbiAgcmV0dXJuIGJsaXRCdWZmZXIoYXNjaWlUb0J5dGVzKHN0cmluZyksIGJ1Ziwgb2Zmc2V0LCBsZW5ndGgpXG59XG5cbmZ1bmN0aW9uIGJpbmFyeVdyaXRlIChidWYsIHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpIHtcbiAgcmV0dXJuIGFzY2lpV3JpdGUoYnVmLCBzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKVxufVxuXG5mdW5jdGlvbiBiYXNlNjRXcml0ZSAoYnVmLCBzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKSB7XG4gIHJldHVybiBibGl0QnVmZmVyKGJhc2U2NFRvQnl0ZXMoc3RyaW5nKSwgYnVmLCBvZmZzZXQsIGxlbmd0aClcbn1cblxuZnVuY3Rpb24gdWNzMldyaXRlIChidWYsIHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpIHtcbiAgcmV0dXJuIGJsaXRCdWZmZXIodXRmMTZsZVRvQnl0ZXMoc3RyaW5nLCBidWYubGVuZ3RoIC0gb2Zmc2V0KSwgYnVmLCBvZmZzZXQsIGxlbmd0aClcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZSA9IGZ1bmN0aW9uIHdyaXRlIChzdHJpbmcsIG9mZnNldCwgbGVuZ3RoLCBlbmNvZGluZykge1xuICAvLyBCdWZmZXIjd3JpdGUoc3RyaW5nKVxuICBpZiAob2Zmc2V0ID09PSB1bmRlZmluZWQpIHtcbiAgICBlbmNvZGluZyA9ICd1dGY4J1xuICAgIGxlbmd0aCA9IHRoaXMubGVuZ3RoXG4gICAgb2Zmc2V0ID0gMFxuICAvLyBCdWZmZXIjd3JpdGUoc3RyaW5nLCBlbmNvZGluZylcbiAgfSBlbHNlIGlmIChsZW5ndGggPT09IHVuZGVmaW5lZCAmJiB0eXBlb2Ygb2Zmc2V0ID09PSAnc3RyaW5nJykge1xuICAgIGVuY29kaW5nID0gb2Zmc2V0XG4gICAgbGVuZ3RoID0gdGhpcy5sZW5ndGhcbiAgICBvZmZzZXQgPSAwXG4gIC8vIEJ1ZmZlciN3cml0ZShzdHJpbmcsIG9mZnNldFssIGxlbmd0aF1bLCBlbmNvZGluZ10pXG4gIH0gZWxzZSBpZiAoaXNGaW5pdGUob2Zmc2V0KSkge1xuICAgIG9mZnNldCA9IG9mZnNldCB8IDBcbiAgICBpZiAoaXNGaW5pdGUobGVuZ3RoKSkge1xuICAgICAgbGVuZ3RoID0gbGVuZ3RoIHwgMFxuICAgICAgaWYgKGVuY29kaW5nID09PSB1bmRlZmluZWQpIGVuY29kaW5nID0gJ3V0ZjgnXG4gICAgfSBlbHNlIHtcbiAgICAgIGVuY29kaW5nID0gbGVuZ3RoXG4gICAgICBsZW5ndGggPSB1bmRlZmluZWRcbiAgICB9XG4gIC8vIGxlZ2FjeSB3cml0ZShzdHJpbmcsIGVuY29kaW5nLCBvZmZzZXQsIGxlbmd0aCkgLSByZW1vdmUgaW4gdjAuMTNcbiAgfSBlbHNlIHtcbiAgICB2YXIgc3dhcCA9IGVuY29kaW5nXG4gICAgZW5jb2RpbmcgPSBvZmZzZXRcbiAgICBvZmZzZXQgPSBsZW5ndGggfCAwXG4gICAgbGVuZ3RoID0gc3dhcFxuICB9XG5cbiAgdmFyIHJlbWFpbmluZyA9IHRoaXMubGVuZ3RoIC0gb2Zmc2V0XG4gIGlmIChsZW5ndGggPT09IHVuZGVmaW5lZCB8fCBsZW5ndGggPiByZW1haW5pbmcpIGxlbmd0aCA9IHJlbWFpbmluZ1xuXG4gIGlmICgoc3RyaW5nLmxlbmd0aCA+IDAgJiYgKGxlbmd0aCA8IDAgfHwgb2Zmc2V0IDwgMCkpIHx8IG9mZnNldCA+IHRoaXMubGVuZ3RoKSB7XG4gICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ2F0dGVtcHQgdG8gd3JpdGUgb3V0c2lkZSBidWZmZXIgYm91bmRzJylcbiAgfVxuXG4gIGlmICghZW5jb2RpbmcpIGVuY29kaW5nID0gJ3V0ZjgnXG5cbiAgdmFyIGxvd2VyZWRDYXNlID0gZmFsc2VcbiAgZm9yICg7Oykge1xuICAgIHN3aXRjaCAoZW5jb2RpbmcpIHtcbiAgICAgIGNhc2UgJ2hleCc6XG4gICAgICAgIHJldHVybiBoZXhXcml0ZSh0aGlzLCBzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKVxuXG4gICAgICBjYXNlICd1dGY4JzpcbiAgICAgIGNhc2UgJ3V0Zi04JzpcbiAgICAgICAgcmV0dXJuIHV0ZjhXcml0ZSh0aGlzLCBzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKVxuXG4gICAgICBjYXNlICdhc2NpaSc6XG4gICAgICAgIHJldHVybiBhc2NpaVdyaXRlKHRoaXMsIHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpXG5cbiAgICAgIGNhc2UgJ2JpbmFyeSc6XG4gICAgICAgIHJldHVybiBiaW5hcnlXcml0ZSh0aGlzLCBzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKVxuXG4gICAgICBjYXNlICdiYXNlNjQnOlxuICAgICAgICAvLyBXYXJuaW5nOiBtYXhMZW5ndGggbm90IHRha2VuIGludG8gYWNjb3VudCBpbiBiYXNlNjRXcml0ZVxuICAgICAgICByZXR1cm4gYmFzZTY0V3JpdGUodGhpcywgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aClcblxuICAgICAgY2FzZSAndWNzMic6XG4gICAgICBjYXNlICd1Y3MtMic6XG4gICAgICBjYXNlICd1dGYxNmxlJzpcbiAgICAgIGNhc2UgJ3V0Zi0xNmxlJzpcbiAgICAgICAgcmV0dXJuIHVjczJXcml0ZSh0aGlzLCBzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKVxuXG4gICAgICBkZWZhdWx0OlxuICAgICAgICBpZiAobG93ZXJlZENhc2UpIHRocm93IG5ldyBUeXBlRXJyb3IoJ1Vua25vd24gZW5jb2Rpbmc6ICcgKyBlbmNvZGluZylcbiAgICAgICAgZW5jb2RpbmcgPSAoJycgKyBlbmNvZGluZykudG9Mb3dlckNhc2UoKVxuICAgICAgICBsb3dlcmVkQ2FzZSA9IHRydWVcbiAgICB9XG4gIH1cbn1cblxuQnVmZmVyLnByb3RvdHlwZS50b0pTT04gPSBmdW5jdGlvbiB0b0pTT04gKCkge1xuICByZXR1cm4ge1xuICAgIHR5cGU6ICdCdWZmZXInLFxuICAgIGRhdGE6IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKHRoaXMuX2FyciB8fCB0aGlzLCAwKVxuICB9XG59XG5cbmZ1bmN0aW9uIGJhc2U2NFNsaWNlIChidWYsIHN0YXJ0LCBlbmQpIHtcbiAgaWYgKHN0YXJ0ID09PSAwICYmIGVuZCA9PT0gYnVmLmxlbmd0aCkge1xuICAgIHJldHVybiBiYXNlNjQuZnJvbUJ5dGVBcnJheShidWYpXG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIGJhc2U2NC5mcm9tQnl0ZUFycmF5KGJ1Zi5zbGljZShzdGFydCwgZW5kKSlcbiAgfVxufVxuXG5mdW5jdGlvbiB1dGY4U2xpY2UgKGJ1Ziwgc3RhcnQsIGVuZCkge1xuICBlbmQgPSBNYXRoLm1pbihidWYubGVuZ3RoLCBlbmQpXG4gIHZhciByZXMgPSBbXVxuXG4gIHZhciBpID0gc3RhcnRcbiAgd2hpbGUgKGkgPCBlbmQpIHtcbiAgICB2YXIgZmlyc3RCeXRlID0gYnVmW2ldXG4gICAgdmFyIGNvZGVQb2ludCA9IG51bGxcbiAgICB2YXIgYnl0ZXNQZXJTZXF1ZW5jZSA9IChmaXJzdEJ5dGUgPiAweEVGKSA/IDRcbiAgICAgIDogKGZpcnN0Qnl0ZSA+IDB4REYpID8gM1xuICAgICAgOiAoZmlyc3RCeXRlID4gMHhCRikgPyAyXG4gICAgICA6IDFcblxuICAgIGlmIChpICsgYnl0ZXNQZXJTZXF1ZW5jZSA8PSBlbmQpIHtcbiAgICAgIHZhciBzZWNvbmRCeXRlLCB0aGlyZEJ5dGUsIGZvdXJ0aEJ5dGUsIHRlbXBDb2RlUG9pbnRcblxuICAgICAgc3dpdGNoIChieXRlc1BlclNlcXVlbmNlKSB7XG4gICAgICAgIGNhc2UgMTpcbiAgICAgICAgICBpZiAoZmlyc3RCeXRlIDwgMHg4MCkge1xuICAgICAgICAgICAgY29kZVBvaW50ID0gZmlyc3RCeXRlXG4gICAgICAgICAgfVxuICAgICAgICAgIGJyZWFrXG4gICAgICAgIGNhc2UgMjpcbiAgICAgICAgICBzZWNvbmRCeXRlID0gYnVmW2kgKyAxXVxuICAgICAgICAgIGlmICgoc2Vjb25kQnl0ZSAmIDB4QzApID09PSAweDgwKSB7XG4gICAgICAgICAgICB0ZW1wQ29kZVBvaW50ID0gKGZpcnN0Qnl0ZSAmIDB4MUYpIDw8IDB4NiB8IChzZWNvbmRCeXRlICYgMHgzRilcbiAgICAgICAgICAgIGlmICh0ZW1wQ29kZVBvaW50ID4gMHg3Rikge1xuICAgICAgICAgICAgICBjb2RlUG9pbnQgPSB0ZW1wQ29kZVBvaW50XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIGJyZWFrXG4gICAgICAgIGNhc2UgMzpcbiAgICAgICAgICBzZWNvbmRCeXRlID0gYnVmW2kgKyAxXVxuICAgICAgICAgIHRoaXJkQnl0ZSA9IGJ1ZltpICsgMl1cbiAgICAgICAgICBpZiAoKHNlY29uZEJ5dGUgJiAweEMwKSA9PT0gMHg4MCAmJiAodGhpcmRCeXRlICYgMHhDMCkgPT09IDB4ODApIHtcbiAgICAgICAgICAgIHRlbXBDb2RlUG9pbnQgPSAoZmlyc3RCeXRlICYgMHhGKSA8PCAweEMgfCAoc2Vjb25kQnl0ZSAmIDB4M0YpIDw8IDB4NiB8ICh0aGlyZEJ5dGUgJiAweDNGKVxuICAgICAgICAgICAgaWYgKHRlbXBDb2RlUG9pbnQgPiAweDdGRiAmJiAodGVtcENvZGVQb2ludCA8IDB4RDgwMCB8fCB0ZW1wQ29kZVBvaW50ID4gMHhERkZGKSkge1xuICAgICAgICAgICAgICBjb2RlUG9pbnQgPSB0ZW1wQ29kZVBvaW50XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIGJyZWFrXG4gICAgICAgIGNhc2UgNDpcbiAgICAgICAgICBzZWNvbmRCeXRlID0gYnVmW2kgKyAxXVxuICAgICAgICAgIHRoaXJkQnl0ZSA9IGJ1ZltpICsgMl1cbiAgICAgICAgICBmb3VydGhCeXRlID0gYnVmW2kgKyAzXVxuICAgICAgICAgIGlmICgoc2Vjb25kQnl0ZSAmIDB4QzApID09PSAweDgwICYmICh0aGlyZEJ5dGUgJiAweEMwKSA9PT0gMHg4MCAmJiAoZm91cnRoQnl0ZSAmIDB4QzApID09PSAweDgwKSB7XG4gICAgICAgICAgICB0ZW1wQ29kZVBvaW50ID0gKGZpcnN0Qnl0ZSAmIDB4RikgPDwgMHgxMiB8IChzZWNvbmRCeXRlICYgMHgzRikgPDwgMHhDIHwgKHRoaXJkQnl0ZSAmIDB4M0YpIDw8IDB4NiB8IChmb3VydGhCeXRlICYgMHgzRilcbiAgICAgICAgICAgIGlmICh0ZW1wQ29kZVBvaW50ID4gMHhGRkZGICYmIHRlbXBDb2RlUG9pbnQgPCAweDExMDAwMCkge1xuICAgICAgICAgICAgICBjb2RlUG9pbnQgPSB0ZW1wQ29kZVBvaW50XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChjb2RlUG9pbnQgPT09IG51bGwpIHtcbiAgICAgIC8vIHdlIGRpZCBub3QgZ2VuZXJhdGUgYSB2YWxpZCBjb2RlUG9pbnQgc28gaW5zZXJ0IGFcbiAgICAgIC8vIHJlcGxhY2VtZW50IGNoYXIgKFUrRkZGRCkgYW5kIGFkdmFuY2Ugb25seSAxIGJ5dGVcbiAgICAgIGNvZGVQb2ludCA9IDB4RkZGRFxuICAgICAgYnl0ZXNQZXJTZXF1ZW5jZSA9IDFcbiAgICB9IGVsc2UgaWYgKGNvZGVQb2ludCA+IDB4RkZGRikge1xuICAgICAgLy8gZW5jb2RlIHRvIHV0ZjE2IChzdXJyb2dhdGUgcGFpciBkYW5jZSlcbiAgICAgIGNvZGVQb2ludCAtPSAweDEwMDAwXG4gICAgICByZXMucHVzaChjb2RlUG9pbnQgPj4+IDEwICYgMHgzRkYgfCAweEQ4MDApXG4gICAgICBjb2RlUG9pbnQgPSAweERDMDAgfCBjb2RlUG9pbnQgJiAweDNGRlxuICAgIH1cblxuICAgIHJlcy5wdXNoKGNvZGVQb2ludClcbiAgICBpICs9IGJ5dGVzUGVyU2VxdWVuY2VcbiAgfVxuXG4gIHJldHVybiBkZWNvZGVDb2RlUG9pbnRzQXJyYXkocmVzKVxufVxuXG4vLyBCYXNlZCBvbiBodHRwOi8vc3RhY2tvdmVyZmxvdy5jb20vYS8yMjc0NzI3Mi82ODA3NDIsIHRoZSBicm93c2VyIHdpdGhcbi8vIHRoZSBsb3dlc3QgbGltaXQgaXMgQ2hyb21lLCB3aXRoIDB4MTAwMDAgYXJncy5cbi8vIFdlIGdvIDEgbWFnbml0dWRlIGxlc3MsIGZvciBzYWZldHlcbnZhciBNQVhfQVJHVU1FTlRTX0xFTkdUSCA9IDB4MTAwMFxuXG5mdW5jdGlvbiBkZWNvZGVDb2RlUG9pbnRzQXJyYXkgKGNvZGVQb2ludHMpIHtcbiAgdmFyIGxlbiA9IGNvZGVQb2ludHMubGVuZ3RoXG4gIGlmIChsZW4gPD0gTUFYX0FSR1VNRU5UU19MRU5HVEgpIHtcbiAgICByZXR1cm4gU3RyaW5nLmZyb21DaGFyQ29kZS5hcHBseShTdHJpbmcsIGNvZGVQb2ludHMpIC8vIGF2b2lkIGV4dHJhIHNsaWNlKClcbiAgfVxuXG4gIC8vIERlY29kZSBpbiBjaHVua3MgdG8gYXZvaWQgXCJjYWxsIHN0YWNrIHNpemUgZXhjZWVkZWRcIi5cbiAgdmFyIHJlcyA9ICcnXG4gIHZhciBpID0gMFxuICB3aGlsZSAoaSA8IGxlbikge1xuICAgIHJlcyArPSBTdHJpbmcuZnJvbUNoYXJDb2RlLmFwcGx5KFxuICAgICAgU3RyaW5nLFxuICAgICAgY29kZVBvaW50cy5zbGljZShpLCBpICs9IE1BWF9BUkdVTUVOVFNfTEVOR1RIKVxuICAgIClcbiAgfVxuICByZXR1cm4gcmVzXG59XG5cbmZ1bmN0aW9uIGFzY2lpU2xpY2UgKGJ1Ziwgc3RhcnQsIGVuZCkge1xuICB2YXIgcmV0ID0gJydcbiAgZW5kID0gTWF0aC5taW4oYnVmLmxlbmd0aCwgZW5kKVxuXG4gIGZvciAodmFyIGkgPSBzdGFydDsgaSA8IGVuZDsgaSsrKSB7XG4gICAgcmV0ICs9IFN0cmluZy5mcm9tQ2hhckNvZGUoYnVmW2ldICYgMHg3RilcbiAgfVxuICByZXR1cm4gcmV0XG59XG5cbmZ1bmN0aW9uIGJpbmFyeVNsaWNlIChidWYsIHN0YXJ0LCBlbmQpIHtcbiAgdmFyIHJldCA9ICcnXG4gIGVuZCA9IE1hdGgubWluKGJ1Zi5sZW5ndGgsIGVuZClcblxuICBmb3IgKHZhciBpID0gc3RhcnQ7IGkgPCBlbmQ7IGkrKykge1xuICAgIHJldCArPSBTdHJpbmcuZnJvbUNoYXJDb2RlKGJ1ZltpXSlcbiAgfVxuICByZXR1cm4gcmV0XG59XG5cbmZ1bmN0aW9uIGhleFNsaWNlIChidWYsIHN0YXJ0LCBlbmQpIHtcbiAgdmFyIGxlbiA9IGJ1Zi5sZW5ndGhcblxuICBpZiAoIXN0YXJ0IHx8IHN0YXJ0IDwgMCkgc3RhcnQgPSAwXG4gIGlmICghZW5kIHx8IGVuZCA8IDAgfHwgZW5kID4gbGVuKSBlbmQgPSBsZW5cblxuICB2YXIgb3V0ID0gJydcbiAgZm9yICh2YXIgaSA9IHN0YXJ0OyBpIDwgZW5kOyBpKyspIHtcbiAgICBvdXQgKz0gdG9IZXgoYnVmW2ldKVxuICB9XG4gIHJldHVybiBvdXRcbn1cblxuZnVuY3Rpb24gdXRmMTZsZVNsaWNlIChidWYsIHN0YXJ0LCBlbmQpIHtcbiAgdmFyIGJ5dGVzID0gYnVmLnNsaWNlKHN0YXJ0LCBlbmQpXG4gIHZhciByZXMgPSAnJ1xuICBmb3IgKHZhciBpID0gMDsgaSA8IGJ5dGVzLmxlbmd0aDsgaSArPSAyKSB7XG4gICAgcmVzICs9IFN0cmluZy5mcm9tQ2hhckNvZGUoYnl0ZXNbaV0gKyBieXRlc1tpICsgMV0gKiAyNTYpXG4gIH1cbiAgcmV0dXJuIHJlc1xufVxuXG5CdWZmZXIucHJvdG90eXBlLnNsaWNlID0gZnVuY3Rpb24gc2xpY2UgKHN0YXJ0LCBlbmQpIHtcbiAgdmFyIGxlbiA9IHRoaXMubGVuZ3RoXG4gIHN0YXJ0ID0gfn5zdGFydFxuICBlbmQgPSBlbmQgPT09IHVuZGVmaW5lZCA/IGxlbiA6IH5+ZW5kXG5cbiAgaWYgKHN0YXJ0IDwgMCkge1xuICAgIHN0YXJ0ICs9IGxlblxuICAgIGlmIChzdGFydCA8IDApIHN0YXJ0ID0gMFxuICB9IGVsc2UgaWYgKHN0YXJ0ID4gbGVuKSB7XG4gICAgc3RhcnQgPSBsZW5cbiAgfVxuXG4gIGlmIChlbmQgPCAwKSB7XG4gICAgZW5kICs9IGxlblxuICAgIGlmIChlbmQgPCAwKSBlbmQgPSAwXG4gIH0gZWxzZSBpZiAoZW5kID4gbGVuKSB7XG4gICAgZW5kID0gbGVuXG4gIH1cblxuICBpZiAoZW5kIDwgc3RhcnQpIGVuZCA9IHN0YXJ0XG5cbiAgdmFyIG5ld0J1ZlxuICBpZiAoQnVmZmVyLlRZUEVEX0FSUkFZX1NVUFBPUlQpIHtcbiAgICBuZXdCdWYgPSBCdWZmZXIuX2F1Z21lbnQodGhpcy5zdWJhcnJheShzdGFydCwgZW5kKSlcbiAgfSBlbHNlIHtcbiAgICB2YXIgc2xpY2VMZW4gPSBlbmQgLSBzdGFydFxuICAgIG5ld0J1ZiA9IG5ldyBCdWZmZXIoc2xpY2VMZW4sIHVuZGVmaW5lZClcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHNsaWNlTGVuOyBpKyspIHtcbiAgICAgIG5ld0J1ZltpXSA9IHRoaXNbaSArIHN0YXJ0XVxuICAgIH1cbiAgfVxuXG4gIGlmIChuZXdCdWYubGVuZ3RoKSBuZXdCdWYucGFyZW50ID0gdGhpcy5wYXJlbnQgfHwgdGhpc1xuXG4gIHJldHVybiBuZXdCdWZcbn1cblxuLypcbiAqIE5lZWQgdG8gbWFrZSBzdXJlIHRoYXQgYnVmZmVyIGlzbid0IHRyeWluZyB0byB3cml0ZSBvdXQgb2YgYm91bmRzLlxuICovXG5mdW5jdGlvbiBjaGVja09mZnNldCAob2Zmc2V0LCBleHQsIGxlbmd0aCkge1xuICBpZiAoKG9mZnNldCAlIDEpICE9PSAwIHx8IG9mZnNldCA8IDApIHRocm93IG5ldyBSYW5nZUVycm9yKCdvZmZzZXQgaXMgbm90IHVpbnQnKVxuICBpZiAob2Zmc2V0ICsgZXh0ID4gbGVuZ3RoKSB0aHJvdyBuZXcgUmFuZ2VFcnJvcignVHJ5aW5nIHRvIGFjY2VzcyBiZXlvbmQgYnVmZmVyIGxlbmd0aCcpXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZFVJbnRMRSA9IGZ1bmN0aW9uIHJlYWRVSW50TEUgKG9mZnNldCwgYnl0ZUxlbmd0aCwgbm9Bc3NlcnQpIHtcbiAgb2Zmc2V0ID0gb2Zmc2V0IHwgMFxuICBieXRlTGVuZ3RoID0gYnl0ZUxlbmd0aCB8IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCBieXRlTGVuZ3RoLCB0aGlzLmxlbmd0aClcblxuICB2YXIgdmFsID0gdGhpc1tvZmZzZXRdXG4gIHZhciBtdWwgPSAxXG4gIHZhciBpID0gMFxuICB3aGlsZSAoKytpIDwgYnl0ZUxlbmd0aCAmJiAobXVsICo9IDB4MTAwKSkge1xuICAgIHZhbCArPSB0aGlzW29mZnNldCArIGldICogbXVsXG4gIH1cblxuICByZXR1cm4gdmFsXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZFVJbnRCRSA9IGZ1bmN0aW9uIHJlYWRVSW50QkUgKG9mZnNldCwgYnl0ZUxlbmd0aCwgbm9Bc3NlcnQpIHtcbiAgb2Zmc2V0ID0gb2Zmc2V0IHwgMFxuICBieXRlTGVuZ3RoID0gYnl0ZUxlbmd0aCB8IDBcbiAgaWYgKCFub0Fzc2VydCkge1xuICAgIGNoZWNrT2Zmc2V0KG9mZnNldCwgYnl0ZUxlbmd0aCwgdGhpcy5sZW5ndGgpXG4gIH1cblxuICB2YXIgdmFsID0gdGhpc1tvZmZzZXQgKyAtLWJ5dGVMZW5ndGhdXG4gIHZhciBtdWwgPSAxXG4gIHdoaWxlIChieXRlTGVuZ3RoID4gMCAmJiAobXVsICo9IDB4MTAwKSkge1xuICAgIHZhbCArPSB0aGlzW29mZnNldCArIC0tYnl0ZUxlbmd0aF0gKiBtdWxcbiAgfVxuXG4gIHJldHVybiB2YWxcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkVUludDggPSBmdW5jdGlvbiByZWFkVUludDggKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCAxLCB0aGlzLmxlbmd0aClcbiAgcmV0dXJuIHRoaXNbb2Zmc2V0XVxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRVSW50MTZMRSA9IGZ1bmN0aW9uIHJlYWRVSW50MTZMRSAob2Zmc2V0LCBub0Fzc2VydCkge1xuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIDIsIHRoaXMubGVuZ3RoKVxuICByZXR1cm4gdGhpc1tvZmZzZXRdIHwgKHRoaXNbb2Zmc2V0ICsgMV0gPDwgOClcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkVUludDE2QkUgPSBmdW5jdGlvbiByZWFkVUludDE2QkUgKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCAyLCB0aGlzLmxlbmd0aClcbiAgcmV0dXJuICh0aGlzW29mZnNldF0gPDwgOCkgfCB0aGlzW29mZnNldCArIDFdXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZFVJbnQzMkxFID0gZnVuY3Rpb24gcmVhZFVJbnQzMkxFIChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgNCwgdGhpcy5sZW5ndGgpXG5cbiAgcmV0dXJuICgodGhpc1tvZmZzZXRdKSB8XG4gICAgICAodGhpc1tvZmZzZXQgKyAxXSA8PCA4KSB8XG4gICAgICAodGhpc1tvZmZzZXQgKyAyXSA8PCAxNikpICtcbiAgICAgICh0aGlzW29mZnNldCArIDNdICogMHgxMDAwMDAwKVxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRVSW50MzJCRSA9IGZ1bmN0aW9uIHJlYWRVSW50MzJCRSAob2Zmc2V0LCBub0Fzc2VydCkge1xuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIDQsIHRoaXMubGVuZ3RoKVxuXG4gIHJldHVybiAodGhpc1tvZmZzZXRdICogMHgxMDAwMDAwKSArXG4gICAgKCh0aGlzW29mZnNldCArIDFdIDw8IDE2KSB8XG4gICAgKHRoaXNbb2Zmc2V0ICsgMl0gPDwgOCkgfFxuICAgIHRoaXNbb2Zmc2V0ICsgM10pXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZEludExFID0gZnVuY3Rpb24gcmVhZEludExFIChvZmZzZXQsIGJ5dGVMZW5ndGgsIG5vQXNzZXJ0KSB7XG4gIG9mZnNldCA9IG9mZnNldCB8IDBcbiAgYnl0ZUxlbmd0aCA9IGJ5dGVMZW5ndGggfCAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgYnl0ZUxlbmd0aCwgdGhpcy5sZW5ndGgpXG5cbiAgdmFyIHZhbCA9IHRoaXNbb2Zmc2V0XVxuICB2YXIgbXVsID0gMVxuICB2YXIgaSA9IDBcbiAgd2hpbGUgKCsraSA8IGJ5dGVMZW5ndGggJiYgKG11bCAqPSAweDEwMCkpIHtcbiAgICB2YWwgKz0gdGhpc1tvZmZzZXQgKyBpXSAqIG11bFxuICB9XG4gIG11bCAqPSAweDgwXG5cbiAgaWYgKHZhbCA+PSBtdWwpIHZhbCAtPSBNYXRoLnBvdygyLCA4ICogYnl0ZUxlbmd0aClcblxuICByZXR1cm4gdmFsXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZEludEJFID0gZnVuY3Rpb24gcmVhZEludEJFIChvZmZzZXQsIGJ5dGVMZW5ndGgsIG5vQXNzZXJ0KSB7XG4gIG9mZnNldCA9IG9mZnNldCB8IDBcbiAgYnl0ZUxlbmd0aCA9IGJ5dGVMZW5ndGggfCAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgYnl0ZUxlbmd0aCwgdGhpcy5sZW5ndGgpXG5cbiAgdmFyIGkgPSBieXRlTGVuZ3RoXG4gIHZhciBtdWwgPSAxXG4gIHZhciB2YWwgPSB0aGlzW29mZnNldCArIC0taV1cbiAgd2hpbGUgKGkgPiAwICYmIChtdWwgKj0gMHgxMDApKSB7XG4gICAgdmFsICs9IHRoaXNbb2Zmc2V0ICsgLS1pXSAqIG11bFxuICB9XG4gIG11bCAqPSAweDgwXG5cbiAgaWYgKHZhbCA+PSBtdWwpIHZhbCAtPSBNYXRoLnBvdygyLCA4ICogYnl0ZUxlbmd0aClcblxuICByZXR1cm4gdmFsXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZEludDggPSBmdW5jdGlvbiByZWFkSW50OCAob2Zmc2V0LCBub0Fzc2VydCkge1xuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIDEsIHRoaXMubGVuZ3RoKVxuICBpZiAoISh0aGlzW29mZnNldF0gJiAweDgwKSkgcmV0dXJuICh0aGlzW29mZnNldF0pXG4gIHJldHVybiAoKDB4ZmYgLSB0aGlzW29mZnNldF0gKyAxKSAqIC0xKVxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRJbnQxNkxFID0gZnVuY3Rpb24gcmVhZEludDE2TEUgKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCAyLCB0aGlzLmxlbmd0aClcbiAgdmFyIHZhbCA9IHRoaXNbb2Zmc2V0XSB8ICh0aGlzW29mZnNldCArIDFdIDw8IDgpXG4gIHJldHVybiAodmFsICYgMHg4MDAwKSA/IHZhbCB8IDB4RkZGRjAwMDAgOiB2YWxcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkSW50MTZCRSA9IGZ1bmN0aW9uIHJlYWRJbnQxNkJFIChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgMiwgdGhpcy5sZW5ndGgpXG4gIHZhciB2YWwgPSB0aGlzW29mZnNldCArIDFdIHwgKHRoaXNbb2Zmc2V0XSA8PCA4KVxuICByZXR1cm4gKHZhbCAmIDB4ODAwMCkgPyB2YWwgfCAweEZGRkYwMDAwIDogdmFsXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZEludDMyTEUgPSBmdW5jdGlvbiByZWFkSW50MzJMRSAob2Zmc2V0LCBub0Fzc2VydCkge1xuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIDQsIHRoaXMubGVuZ3RoKVxuXG4gIHJldHVybiAodGhpc1tvZmZzZXRdKSB8XG4gICAgKHRoaXNbb2Zmc2V0ICsgMV0gPDwgOCkgfFxuICAgICh0aGlzW29mZnNldCArIDJdIDw8IDE2KSB8XG4gICAgKHRoaXNbb2Zmc2V0ICsgM10gPDwgMjQpXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZEludDMyQkUgPSBmdW5jdGlvbiByZWFkSW50MzJCRSAob2Zmc2V0LCBub0Fzc2VydCkge1xuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIDQsIHRoaXMubGVuZ3RoKVxuXG4gIHJldHVybiAodGhpc1tvZmZzZXRdIDw8IDI0KSB8XG4gICAgKHRoaXNbb2Zmc2V0ICsgMV0gPDwgMTYpIHxcbiAgICAodGhpc1tvZmZzZXQgKyAyXSA8PCA4KSB8XG4gICAgKHRoaXNbb2Zmc2V0ICsgM10pXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZEZsb2F0TEUgPSBmdW5jdGlvbiByZWFkRmxvYXRMRSAob2Zmc2V0LCBub0Fzc2VydCkge1xuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIDQsIHRoaXMubGVuZ3RoKVxuICByZXR1cm4gaWVlZTc1NC5yZWFkKHRoaXMsIG9mZnNldCwgdHJ1ZSwgMjMsIDQpXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZEZsb2F0QkUgPSBmdW5jdGlvbiByZWFkRmxvYXRCRSAob2Zmc2V0LCBub0Fzc2VydCkge1xuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIDQsIHRoaXMubGVuZ3RoKVxuICByZXR1cm4gaWVlZTc1NC5yZWFkKHRoaXMsIG9mZnNldCwgZmFsc2UsIDIzLCA0KVxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWREb3VibGVMRSA9IGZ1bmN0aW9uIHJlYWREb3VibGVMRSAob2Zmc2V0LCBub0Fzc2VydCkge1xuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIDgsIHRoaXMubGVuZ3RoKVxuICByZXR1cm4gaWVlZTc1NC5yZWFkKHRoaXMsIG9mZnNldCwgdHJ1ZSwgNTIsIDgpXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZERvdWJsZUJFID0gZnVuY3Rpb24gcmVhZERvdWJsZUJFIChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgOCwgdGhpcy5sZW5ndGgpXG4gIHJldHVybiBpZWVlNzU0LnJlYWQodGhpcywgb2Zmc2V0LCBmYWxzZSwgNTIsIDgpXG59XG5cbmZ1bmN0aW9uIGNoZWNrSW50IChidWYsIHZhbHVlLCBvZmZzZXQsIGV4dCwgbWF4LCBtaW4pIHtcbiAgaWYgKCFCdWZmZXIuaXNCdWZmZXIoYnVmKSkgdGhyb3cgbmV3IFR5cGVFcnJvcignYnVmZmVyIG11c3QgYmUgYSBCdWZmZXIgaW5zdGFuY2UnKVxuICBpZiAodmFsdWUgPiBtYXggfHwgdmFsdWUgPCBtaW4pIHRocm93IG5ldyBSYW5nZUVycm9yKCd2YWx1ZSBpcyBvdXQgb2YgYm91bmRzJylcbiAgaWYgKG9mZnNldCArIGV4dCA+IGJ1Zi5sZW5ndGgpIHRocm93IG5ldyBSYW5nZUVycm9yKCdpbmRleCBvdXQgb2YgcmFuZ2UnKVxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlVUludExFID0gZnVuY3Rpb24gd3JpdGVVSW50TEUgKHZhbHVlLCBvZmZzZXQsIGJ5dGVMZW5ndGgsIG5vQXNzZXJ0KSB7XG4gIHZhbHVlID0gK3ZhbHVlXG4gIG9mZnNldCA9IG9mZnNldCB8IDBcbiAgYnl0ZUxlbmd0aCA9IGJ5dGVMZW5ndGggfCAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrSW50KHRoaXMsIHZhbHVlLCBvZmZzZXQsIGJ5dGVMZW5ndGgsIE1hdGgucG93KDIsIDggKiBieXRlTGVuZ3RoKSwgMClcblxuICB2YXIgbXVsID0gMVxuICB2YXIgaSA9IDBcbiAgdGhpc1tvZmZzZXRdID0gdmFsdWUgJiAweEZGXG4gIHdoaWxlICgrK2kgPCBieXRlTGVuZ3RoICYmIChtdWwgKj0gMHgxMDApKSB7XG4gICAgdGhpc1tvZmZzZXQgKyBpXSA9ICh2YWx1ZSAvIG11bCkgJiAweEZGXG4gIH1cblxuICByZXR1cm4gb2Zmc2V0ICsgYnl0ZUxlbmd0aFxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlVUludEJFID0gZnVuY3Rpb24gd3JpdGVVSW50QkUgKHZhbHVlLCBvZmZzZXQsIGJ5dGVMZW5ndGgsIG5vQXNzZXJ0KSB7XG4gIHZhbHVlID0gK3ZhbHVlXG4gIG9mZnNldCA9IG9mZnNldCB8IDBcbiAgYnl0ZUxlbmd0aCA9IGJ5dGVMZW5ndGggfCAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrSW50KHRoaXMsIHZhbHVlLCBvZmZzZXQsIGJ5dGVMZW5ndGgsIE1hdGgucG93KDIsIDggKiBieXRlTGVuZ3RoKSwgMClcblxuICB2YXIgaSA9IGJ5dGVMZW5ndGggLSAxXG4gIHZhciBtdWwgPSAxXG4gIHRoaXNbb2Zmc2V0ICsgaV0gPSB2YWx1ZSAmIDB4RkZcbiAgd2hpbGUgKC0taSA+PSAwICYmIChtdWwgKj0gMHgxMDApKSB7XG4gICAgdGhpc1tvZmZzZXQgKyBpXSA9ICh2YWx1ZSAvIG11bCkgJiAweEZGXG4gIH1cblxuICByZXR1cm4gb2Zmc2V0ICsgYnl0ZUxlbmd0aFxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlVUludDggPSBmdW5jdGlvbiB3cml0ZVVJbnQ4ICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICB2YWx1ZSA9ICt2YWx1ZVxuICBvZmZzZXQgPSBvZmZzZXQgfCAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrSW50KHRoaXMsIHZhbHVlLCBvZmZzZXQsIDEsIDB4ZmYsIDApXG4gIGlmICghQnVmZmVyLlRZUEVEX0FSUkFZX1NVUFBPUlQpIHZhbHVlID0gTWF0aC5mbG9vcih2YWx1ZSlcbiAgdGhpc1tvZmZzZXRdID0gKHZhbHVlICYgMHhmZilcbiAgcmV0dXJuIG9mZnNldCArIDFcbn1cblxuZnVuY3Rpb24gb2JqZWN0V3JpdGVVSW50MTYgKGJ1ZiwgdmFsdWUsIG9mZnNldCwgbGl0dGxlRW5kaWFuKSB7XG4gIGlmICh2YWx1ZSA8IDApIHZhbHVlID0gMHhmZmZmICsgdmFsdWUgKyAxXG4gIGZvciAodmFyIGkgPSAwLCBqID0gTWF0aC5taW4oYnVmLmxlbmd0aCAtIG9mZnNldCwgMik7IGkgPCBqOyBpKyspIHtcbiAgICBidWZbb2Zmc2V0ICsgaV0gPSAodmFsdWUgJiAoMHhmZiA8PCAoOCAqIChsaXR0bGVFbmRpYW4gPyBpIDogMSAtIGkpKSkpID4+PlxuICAgICAgKGxpdHRsZUVuZGlhbiA/IGkgOiAxIC0gaSkgKiA4XG4gIH1cbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZVVJbnQxNkxFID0gZnVuY3Rpb24gd3JpdGVVSW50MTZMRSAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgdmFsdWUgPSArdmFsdWVcbiAgb2Zmc2V0ID0gb2Zmc2V0IHwgMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja0ludCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCAyLCAweGZmZmYsIDApXG4gIGlmIChCdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVCkge1xuICAgIHRoaXNbb2Zmc2V0XSA9ICh2YWx1ZSAmIDB4ZmYpXG4gICAgdGhpc1tvZmZzZXQgKyAxXSA9ICh2YWx1ZSA+Pj4gOClcbiAgfSBlbHNlIHtcbiAgICBvYmplY3RXcml0ZVVJbnQxNih0aGlzLCB2YWx1ZSwgb2Zmc2V0LCB0cnVlKVxuICB9XG4gIHJldHVybiBvZmZzZXQgKyAyXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVVSW50MTZCRSA9IGZ1bmN0aW9uIHdyaXRlVUludDE2QkUgKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHZhbHVlID0gK3ZhbHVlXG4gIG9mZnNldCA9IG9mZnNldCB8IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tJbnQodGhpcywgdmFsdWUsIG9mZnNldCwgMiwgMHhmZmZmLCAwKVxuICBpZiAoQnVmZmVyLlRZUEVEX0FSUkFZX1NVUFBPUlQpIHtcbiAgICB0aGlzW29mZnNldF0gPSAodmFsdWUgPj4+IDgpXG4gICAgdGhpc1tvZmZzZXQgKyAxXSA9ICh2YWx1ZSAmIDB4ZmYpXG4gIH0gZWxzZSB7XG4gICAgb2JqZWN0V3JpdGVVSW50MTYodGhpcywgdmFsdWUsIG9mZnNldCwgZmFsc2UpXG4gIH1cbiAgcmV0dXJuIG9mZnNldCArIDJcbn1cblxuZnVuY3Rpb24gb2JqZWN0V3JpdGVVSW50MzIgKGJ1ZiwgdmFsdWUsIG9mZnNldCwgbGl0dGxlRW5kaWFuKSB7XG4gIGlmICh2YWx1ZSA8IDApIHZhbHVlID0gMHhmZmZmZmZmZiArIHZhbHVlICsgMVxuICBmb3IgKHZhciBpID0gMCwgaiA9IE1hdGgubWluKGJ1Zi5sZW5ndGggLSBvZmZzZXQsIDQpOyBpIDwgajsgaSsrKSB7XG4gICAgYnVmW29mZnNldCArIGldID0gKHZhbHVlID4+PiAobGl0dGxlRW5kaWFuID8gaSA6IDMgLSBpKSAqIDgpICYgMHhmZlxuICB9XG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVVSW50MzJMRSA9IGZ1bmN0aW9uIHdyaXRlVUludDMyTEUgKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHZhbHVlID0gK3ZhbHVlXG4gIG9mZnNldCA9IG9mZnNldCB8IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tJbnQodGhpcywgdmFsdWUsIG9mZnNldCwgNCwgMHhmZmZmZmZmZiwgMClcbiAgaWYgKEJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUKSB7XG4gICAgdGhpc1tvZmZzZXQgKyAzXSA9ICh2YWx1ZSA+Pj4gMjQpXG4gICAgdGhpc1tvZmZzZXQgKyAyXSA9ICh2YWx1ZSA+Pj4gMTYpXG4gICAgdGhpc1tvZmZzZXQgKyAxXSA9ICh2YWx1ZSA+Pj4gOClcbiAgICB0aGlzW29mZnNldF0gPSAodmFsdWUgJiAweGZmKVxuICB9IGVsc2Uge1xuICAgIG9iamVjdFdyaXRlVUludDMyKHRoaXMsIHZhbHVlLCBvZmZzZXQsIHRydWUpXG4gIH1cbiAgcmV0dXJuIG9mZnNldCArIDRcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZVVJbnQzMkJFID0gZnVuY3Rpb24gd3JpdGVVSW50MzJCRSAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgdmFsdWUgPSArdmFsdWVcbiAgb2Zmc2V0ID0gb2Zmc2V0IHwgMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja0ludCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCA0LCAweGZmZmZmZmZmLCAwKVxuICBpZiAoQnVmZmVyLlRZUEVEX0FSUkFZX1NVUFBPUlQpIHtcbiAgICB0aGlzW29mZnNldF0gPSAodmFsdWUgPj4+IDI0KVxuICAgIHRoaXNbb2Zmc2V0ICsgMV0gPSAodmFsdWUgPj4+IDE2KVxuICAgIHRoaXNbb2Zmc2V0ICsgMl0gPSAodmFsdWUgPj4+IDgpXG4gICAgdGhpc1tvZmZzZXQgKyAzXSA9ICh2YWx1ZSAmIDB4ZmYpXG4gIH0gZWxzZSB7XG4gICAgb2JqZWN0V3JpdGVVSW50MzIodGhpcywgdmFsdWUsIG9mZnNldCwgZmFsc2UpXG4gIH1cbiAgcmV0dXJuIG9mZnNldCArIDRcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZUludExFID0gZnVuY3Rpb24gd3JpdGVJbnRMRSAodmFsdWUsIG9mZnNldCwgYnl0ZUxlbmd0aCwgbm9Bc3NlcnQpIHtcbiAgdmFsdWUgPSArdmFsdWVcbiAgb2Zmc2V0ID0gb2Zmc2V0IHwgMFxuICBpZiAoIW5vQXNzZXJ0KSB7XG4gICAgdmFyIGxpbWl0ID0gTWF0aC5wb3coMiwgOCAqIGJ5dGVMZW5ndGggLSAxKVxuXG4gICAgY2hlY2tJbnQodGhpcywgdmFsdWUsIG9mZnNldCwgYnl0ZUxlbmd0aCwgbGltaXQgLSAxLCAtbGltaXQpXG4gIH1cblxuICB2YXIgaSA9IDBcbiAgdmFyIG11bCA9IDFcbiAgdmFyIHN1YiA9IHZhbHVlIDwgMCA/IDEgOiAwXG4gIHRoaXNbb2Zmc2V0XSA9IHZhbHVlICYgMHhGRlxuICB3aGlsZSAoKytpIDwgYnl0ZUxlbmd0aCAmJiAobXVsICo9IDB4MTAwKSkge1xuICAgIHRoaXNbb2Zmc2V0ICsgaV0gPSAoKHZhbHVlIC8gbXVsKSA+PiAwKSAtIHN1YiAmIDB4RkZcbiAgfVxuXG4gIHJldHVybiBvZmZzZXQgKyBieXRlTGVuZ3RoXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVJbnRCRSA9IGZ1bmN0aW9uIHdyaXRlSW50QkUgKHZhbHVlLCBvZmZzZXQsIGJ5dGVMZW5ndGgsIG5vQXNzZXJ0KSB7XG4gIHZhbHVlID0gK3ZhbHVlXG4gIG9mZnNldCA9IG9mZnNldCB8IDBcbiAgaWYgKCFub0Fzc2VydCkge1xuICAgIHZhciBsaW1pdCA9IE1hdGgucG93KDIsIDggKiBieXRlTGVuZ3RoIC0gMSlcblxuICAgIGNoZWNrSW50KHRoaXMsIHZhbHVlLCBvZmZzZXQsIGJ5dGVMZW5ndGgsIGxpbWl0IC0gMSwgLWxpbWl0KVxuICB9XG5cbiAgdmFyIGkgPSBieXRlTGVuZ3RoIC0gMVxuICB2YXIgbXVsID0gMVxuICB2YXIgc3ViID0gdmFsdWUgPCAwID8gMSA6IDBcbiAgdGhpc1tvZmZzZXQgKyBpXSA9IHZhbHVlICYgMHhGRlxuICB3aGlsZSAoLS1pID49IDAgJiYgKG11bCAqPSAweDEwMCkpIHtcbiAgICB0aGlzW29mZnNldCArIGldID0gKCh2YWx1ZSAvIG11bCkgPj4gMCkgLSBzdWIgJiAweEZGXG4gIH1cblxuICByZXR1cm4gb2Zmc2V0ICsgYnl0ZUxlbmd0aFxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlSW50OCA9IGZ1bmN0aW9uIHdyaXRlSW50OCAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgdmFsdWUgPSArdmFsdWVcbiAgb2Zmc2V0ID0gb2Zmc2V0IHwgMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja0ludCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCAxLCAweDdmLCAtMHg4MClcbiAgaWYgKCFCdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVCkgdmFsdWUgPSBNYXRoLmZsb29yKHZhbHVlKVxuICBpZiAodmFsdWUgPCAwKSB2YWx1ZSA9IDB4ZmYgKyB2YWx1ZSArIDFcbiAgdGhpc1tvZmZzZXRdID0gKHZhbHVlICYgMHhmZilcbiAgcmV0dXJuIG9mZnNldCArIDFcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZUludDE2TEUgPSBmdW5jdGlvbiB3cml0ZUludDE2TEUgKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHZhbHVlID0gK3ZhbHVlXG4gIG9mZnNldCA9IG9mZnNldCB8IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tJbnQodGhpcywgdmFsdWUsIG9mZnNldCwgMiwgMHg3ZmZmLCAtMHg4MDAwKVxuICBpZiAoQnVmZmVyLlRZUEVEX0FSUkFZX1NVUFBPUlQpIHtcbiAgICB0aGlzW29mZnNldF0gPSAodmFsdWUgJiAweGZmKVxuICAgIHRoaXNbb2Zmc2V0ICsgMV0gPSAodmFsdWUgPj4+IDgpXG4gIH0gZWxzZSB7XG4gICAgb2JqZWN0V3JpdGVVSW50MTYodGhpcywgdmFsdWUsIG9mZnNldCwgdHJ1ZSlcbiAgfVxuICByZXR1cm4gb2Zmc2V0ICsgMlxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlSW50MTZCRSA9IGZ1bmN0aW9uIHdyaXRlSW50MTZCRSAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgdmFsdWUgPSArdmFsdWVcbiAgb2Zmc2V0ID0gb2Zmc2V0IHwgMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja0ludCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCAyLCAweDdmZmYsIC0weDgwMDApXG4gIGlmIChCdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVCkge1xuICAgIHRoaXNbb2Zmc2V0XSA9ICh2YWx1ZSA+Pj4gOClcbiAgICB0aGlzW29mZnNldCArIDFdID0gKHZhbHVlICYgMHhmZilcbiAgfSBlbHNlIHtcbiAgICBvYmplY3RXcml0ZVVJbnQxNih0aGlzLCB2YWx1ZSwgb2Zmc2V0LCBmYWxzZSlcbiAgfVxuICByZXR1cm4gb2Zmc2V0ICsgMlxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlSW50MzJMRSA9IGZ1bmN0aW9uIHdyaXRlSW50MzJMRSAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgdmFsdWUgPSArdmFsdWVcbiAgb2Zmc2V0ID0gb2Zmc2V0IHwgMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja0ludCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCA0LCAweDdmZmZmZmZmLCAtMHg4MDAwMDAwMClcbiAgaWYgKEJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUKSB7XG4gICAgdGhpc1tvZmZzZXRdID0gKHZhbHVlICYgMHhmZilcbiAgICB0aGlzW29mZnNldCArIDFdID0gKHZhbHVlID4+PiA4KVxuICAgIHRoaXNbb2Zmc2V0ICsgMl0gPSAodmFsdWUgPj4+IDE2KVxuICAgIHRoaXNbb2Zmc2V0ICsgM10gPSAodmFsdWUgPj4+IDI0KVxuICB9IGVsc2Uge1xuICAgIG9iamVjdFdyaXRlVUludDMyKHRoaXMsIHZhbHVlLCBvZmZzZXQsIHRydWUpXG4gIH1cbiAgcmV0dXJuIG9mZnNldCArIDRcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZUludDMyQkUgPSBmdW5jdGlvbiB3cml0ZUludDMyQkUgKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHZhbHVlID0gK3ZhbHVlXG4gIG9mZnNldCA9IG9mZnNldCB8IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tJbnQodGhpcywgdmFsdWUsIG9mZnNldCwgNCwgMHg3ZmZmZmZmZiwgLTB4ODAwMDAwMDApXG4gIGlmICh2YWx1ZSA8IDApIHZhbHVlID0gMHhmZmZmZmZmZiArIHZhbHVlICsgMVxuICBpZiAoQnVmZmVyLlRZUEVEX0FSUkFZX1NVUFBPUlQpIHtcbiAgICB0aGlzW29mZnNldF0gPSAodmFsdWUgPj4+IDI0KVxuICAgIHRoaXNbb2Zmc2V0ICsgMV0gPSAodmFsdWUgPj4+IDE2KVxuICAgIHRoaXNbb2Zmc2V0ICsgMl0gPSAodmFsdWUgPj4+IDgpXG4gICAgdGhpc1tvZmZzZXQgKyAzXSA9ICh2YWx1ZSAmIDB4ZmYpXG4gIH0gZWxzZSB7XG4gICAgb2JqZWN0V3JpdGVVSW50MzIodGhpcywgdmFsdWUsIG9mZnNldCwgZmFsc2UpXG4gIH1cbiAgcmV0dXJuIG9mZnNldCArIDRcbn1cblxuZnVuY3Rpb24gY2hlY2tJRUVFNzU0IChidWYsIHZhbHVlLCBvZmZzZXQsIGV4dCwgbWF4LCBtaW4pIHtcbiAgaWYgKHZhbHVlID4gbWF4IHx8IHZhbHVlIDwgbWluKSB0aHJvdyBuZXcgUmFuZ2VFcnJvcigndmFsdWUgaXMgb3V0IG9mIGJvdW5kcycpXG4gIGlmIChvZmZzZXQgKyBleHQgPiBidWYubGVuZ3RoKSB0aHJvdyBuZXcgUmFuZ2VFcnJvcignaW5kZXggb3V0IG9mIHJhbmdlJylcbiAgaWYgKG9mZnNldCA8IDApIHRocm93IG5ldyBSYW5nZUVycm9yKCdpbmRleCBvdXQgb2YgcmFuZ2UnKVxufVxuXG5mdW5jdGlvbiB3cml0ZUZsb2F0IChidWYsIHZhbHVlLCBvZmZzZXQsIGxpdHRsZUVuZGlhbiwgbm9Bc3NlcnQpIHtcbiAgaWYgKCFub0Fzc2VydCkge1xuICAgIGNoZWNrSUVFRTc1NChidWYsIHZhbHVlLCBvZmZzZXQsIDQsIDMuNDAyODIzNDY2Mzg1Mjg4NmUrMzgsIC0zLjQwMjgyMzQ2NjM4NTI4ODZlKzM4KVxuICB9XG4gIGllZWU3NTQud3JpdGUoYnVmLCB2YWx1ZSwgb2Zmc2V0LCBsaXR0bGVFbmRpYW4sIDIzLCA0KVxuICByZXR1cm4gb2Zmc2V0ICsgNFxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlRmxvYXRMRSA9IGZ1bmN0aW9uIHdyaXRlRmxvYXRMRSAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgcmV0dXJuIHdyaXRlRmxvYXQodGhpcywgdmFsdWUsIG9mZnNldCwgdHJ1ZSwgbm9Bc3NlcnQpXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVGbG9hdEJFID0gZnVuY3Rpb24gd3JpdGVGbG9hdEJFICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICByZXR1cm4gd3JpdGVGbG9hdCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCBmYWxzZSwgbm9Bc3NlcnQpXG59XG5cbmZ1bmN0aW9uIHdyaXRlRG91YmxlIChidWYsIHZhbHVlLCBvZmZzZXQsIGxpdHRsZUVuZGlhbiwgbm9Bc3NlcnQpIHtcbiAgaWYgKCFub0Fzc2VydCkge1xuICAgIGNoZWNrSUVFRTc1NChidWYsIHZhbHVlLCBvZmZzZXQsIDgsIDEuNzk3NjkzMTM0ODYyMzE1N0UrMzA4LCAtMS43OTc2OTMxMzQ4NjIzMTU3RSszMDgpXG4gIH1cbiAgaWVlZTc1NC53cml0ZShidWYsIHZhbHVlLCBvZmZzZXQsIGxpdHRsZUVuZGlhbiwgNTIsIDgpXG4gIHJldHVybiBvZmZzZXQgKyA4XG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVEb3VibGVMRSA9IGZ1bmN0aW9uIHdyaXRlRG91YmxlTEUgKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHJldHVybiB3cml0ZURvdWJsZSh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCB0cnVlLCBub0Fzc2VydClcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZURvdWJsZUJFID0gZnVuY3Rpb24gd3JpdGVEb3VibGVCRSAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgcmV0dXJuIHdyaXRlRG91YmxlKHRoaXMsIHZhbHVlLCBvZmZzZXQsIGZhbHNlLCBub0Fzc2VydClcbn1cblxuLy8gY29weSh0YXJnZXRCdWZmZXIsIHRhcmdldFN0YXJ0PTAsIHNvdXJjZVN0YXJ0PTAsIHNvdXJjZUVuZD1idWZmZXIubGVuZ3RoKVxuQnVmZmVyLnByb3RvdHlwZS5jb3B5ID0gZnVuY3Rpb24gY29weSAodGFyZ2V0LCB0YXJnZXRTdGFydCwgc3RhcnQsIGVuZCkge1xuICBpZiAoIXN0YXJ0KSBzdGFydCA9IDBcbiAgaWYgKCFlbmQgJiYgZW5kICE9PSAwKSBlbmQgPSB0aGlzLmxlbmd0aFxuICBpZiAodGFyZ2V0U3RhcnQgPj0gdGFyZ2V0Lmxlbmd0aCkgdGFyZ2V0U3RhcnQgPSB0YXJnZXQubGVuZ3RoXG4gIGlmICghdGFyZ2V0U3RhcnQpIHRhcmdldFN0YXJ0ID0gMFxuICBpZiAoZW5kID4gMCAmJiBlbmQgPCBzdGFydCkgZW5kID0gc3RhcnRcblxuICAvLyBDb3B5IDAgYnl0ZXM7IHdlJ3JlIGRvbmVcbiAgaWYgKGVuZCA9PT0gc3RhcnQpIHJldHVybiAwXG4gIGlmICh0YXJnZXQubGVuZ3RoID09PSAwIHx8IHRoaXMubGVuZ3RoID09PSAwKSByZXR1cm4gMFxuXG4gIC8vIEZhdGFsIGVycm9yIGNvbmRpdGlvbnNcbiAgaWYgKHRhcmdldFN0YXJ0IDwgMCkge1xuICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCd0YXJnZXRTdGFydCBvdXQgb2YgYm91bmRzJylcbiAgfVxuICBpZiAoc3RhcnQgPCAwIHx8IHN0YXJ0ID49IHRoaXMubGVuZ3RoKSB0aHJvdyBuZXcgUmFuZ2VFcnJvcignc291cmNlU3RhcnQgb3V0IG9mIGJvdW5kcycpXG4gIGlmIChlbmQgPCAwKSB0aHJvdyBuZXcgUmFuZ2VFcnJvcignc291cmNlRW5kIG91dCBvZiBib3VuZHMnKVxuXG4gIC8vIEFyZSB3ZSBvb2I/XG4gIGlmIChlbmQgPiB0aGlzLmxlbmd0aCkgZW5kID0gdGhpcy5sZW5ndGhcbiAgaWYgKHRhcmdldC5sZW5ndGggLSB0YXJnZXRTdGFydCA8IGVuZCAtIHN0YXJ0KSB7XG4gICAgZW5kID0gdGFyZ2V0Lmxlbmd0aCAtIHRhcmdldFN0YXJ0ICsgc3RhcnRcbiAgfVxuXG4gIHZhciBsZW4gPSBlbmQgLSBzdGFydFxuICB2YXIgaVxuXG4gIGlmICh0aGlzID09PSB0YXJnZXQgJiYgc3RhcnQgPCB0YXJnZXRTdGFydCAmJiB0YXJnZXRTdGFydCA8IGVuZCkge1xuICAgIC8vIGRlc2NlbmRpbmcgY29weSBmcm9tIGVuZFxuICAgIGZvciAoaSA9IGxlbiAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAgICB0YXJnZXRbaSArIHRhcmdldFN0YXJ0XSA9IHRoaXNbaSArIHN0YXJ0XVxuICAgIH1cbiAgfSBlbHNlIGlmIChsZW4gPCAxMDAwIHx8ICFCdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVCkge1xuICAgIC8vIGFzY2VuZGluZyBjb3B5IGZyb20gc3RhcnRcbiAgICBmb3IgKGkgPSAwOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgIHRhcmdldFtpICsgdGFyZ2V0U3RhcnRdID0gdGhpc1tpICsgc3RhcnRdXG4gICAgfVxuICB9IGVsc2Uge1xuICAgIHRhcmdldC5fc2V0KHRoaXMuc3ViYXJyYXkoc3RhcnQsIHN0YXJ0ICsgbGVuKSwgdGFyZ2V0U3RhcnQpXG4gIH1cblxuICByZXR1cm4gbGVuXG59XG5cbi8vIGZpbGwodmFsdWUsIHN0YXJ0PTAsIGVuZD1idWZmZXIubGVuZ3RoKVxuQnVmZmVyLnByb3RvdHlwZS5maWxsID0gZnVuY3Rpb24gZmlsbCAodmFsdWUsIHN0YXJ0LCBlbmQpIHtcbiAgaWYgKCF2YWx1ZSkgdmFsdWUgPSAwXG4gIGlmICghc3RhcnQpIHN0YXJ0ID0gMFxuICBpZiAoIWVuZCkgZW5kID0gdGhpcy5sZW5ndGhcblxuICBpZiAoZW5kIDwgc3RhcnQpIHRocm93IG5ldyBSYW5nZUVycm9yKCdlbmQgPCBzdGFydCcpXG5cbiAgLy8gRmlsbCAwIGJ5dGVzOyB3ZSdyZSBkb25lXG4gIGlmIChlbmQgPT09IHN0YXJ0KSByZXR1cm5cbiAgaWYgKHRoaXMubGVuZ3RoID09PSAwKSByZXR1cm5cblxuICBpZiAoc3RhcnQgPCAwIHx8IHN0YXJ0ID49IHRoaXMubGVuZ3RoKSB0aHJvdyBuZXcgUmFuZ2VFcnJvcignc3RhcnQgb3V0IG9mIGJvdW5kcycpXG4gIGlmIChlbmQgPCAwIHx8IGVuZCA+IHRoaXMubGVuZ3RoKSB0aHJvdyBuZXcgUmFuZ2VFcnJvcignZW5kIG91dCBvZiBib3VuZHMnKVxuXG4gIHZhciBpXG4gIGlmICh0eXBlb2YgdmFsdWUgPT09ICdudW1iZXInKSB7XG4gICAgZm9yIChpID0gc3RhcnQ7IGkgPCBlbmQ7IGkrKykge1xuICAgICAgdGhpc1tpXSA9IHZhbHVlXG4gICAgfVxuICB9IGVsc2Uge1xuICAgIHZhciBieXRlcyA9IHV0ZjhUb0J5dGVzKHZhbHVlLnRvU3RyaW5nKCkpXG4gICAgdmFyIGxlbiA9IGJ5dGVzLmxlbmd0aFxuICAgIGZvciAoaSA9IHN0YXJ0OyBpIDwgZW5kOyBpKyspIHtcbiAgICAgIHRoaXNbaV0gPSBieXRlc1tpICUgbGVuXVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiB0aGlzXG59XG5cbi8qKlxuICogQ3JlYXRlcyBhIG5ldyBgQXJyYXlCdWZmZXJgIHdpdGggdGhlICpjb3BpZWQqIG1lbW9yeSBvZiB0aGUgYnVmZmVyIGluc3RhbmNlLlxuICogQWRkZWQgaW4gTm9kZSAwLjEyLiBPbmx5IGF2YWlsYWJsZSBpbiBicm93c2VycyB0aGF0IHN1cHBvcnQgQXJyYXlCdWZmZXIuXG4gKi9cbkJ1ZmZlci5wcm90b3R5cGUudG9BcnJheUJ1ZmZlciA9IGZ1bmN0aW9uIHRvQXJyYXlCdWZmZXIgKCkge1xuICBpZiAodHlwZW9mIFVpbnQ4QXJyYXkgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgaWYgKEJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUKSB7XG4gICAgICByZXR1cm4gKG5ldyBCdWZmZXIodGhpcykpLmJ1ZmZlclxuICAgIH0gZWxzZSB7XG4gICAgICB2YXIgYnVmID0gbmV3IFVpbnQ4QXJyYXkodGhpcy5sZW5ndGgpXG4gICAgICBmb3IgKHZhciBpID0gMCwgbGVuID0gYnVmLmxlbmd0aDsgaSA8IGxlbjsgaSArPSAxKSB7XG4gICAgICAgIGJ1ZltpXSA9IHRoaXNbaV1cbiAgICAgIH1cbiAgICAgIHJldHVybiBidWYuYnVmZmVyXG4gICAgfVxuICB9IGVsc2Uge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0J1ZmZlci50b0FycmF5QnVmZmVyIG5vdCBzdXBwb3J0ZWQgaW4gdGhpcyBicm93c2VyJylcbiAgfVxufVxuXG4vLyBIRUxQRVIgRlVOQ1RJT05TXG4vLyA9PT09PT09PT09PT09PT09XG5cbnZhciBCUCA9IEJ1ZmZlci5wcm90b3R5cGVcblxuLyoqXG4gKiBBdWdtZW50IGEgVWludDhBcnJheSAqaW5zdGFuY2UqIChub3QgdGhlIFVpbnQ4QXJyYXkgY2xhc3MhKSB3aXRoIEJ1ZmZlciBtZXRob2RzXG4gKi9cbkJ1ZmZlci5fYXVnbWVudCA9IGZ1bmN0aW9uIF9hdWdtZW50IChhcnIpIHtcbiAgYXJyLmNvbnN0cnVjdG9yID0gQnVmZmVyXG4gIGFyci5faXNCdWZmZXIgPSB0cnVlXG5cbiAgLy8gc2F2ZSByZWZlcmVuY2UgdG8gb3JpZ2luYWwgVWludDhBcnJheSBzZXQgbWV0aG9kIGJlZm9yZSBvdmVyd3JpdGluZ1xuICBhcnIuX3NldCA9IGFyci5zZXRcblxuICAvLyBkZXByZWNhdGVkXG4gIGFyci5nZXQgPSBCUC5nZXRcbiAgYXJyLnNldCA9IEJQLnNldFxuXG4gIGFyci53cml0ZSA9IEJQLndyaXRlXG4gIGFyci50b1N0cmluZyA9IEJQLnRvU3RyaW5nXG4gIGFyci50b0xvY2FsZVN0cmluZyA9IEJQLnRvU3RyaW5nXG4gIGFyci50b0pTT04gPSBCUC50b0pTT05cbiAgYXJyLmVxdWFscyA9IEJQLmVxdWFsc1xuICBhcnIuY29tcGFyZSA9IEJQLmNvbXBhcmVcbiAgYXJyLmluZGV4T2YgPSBCUC5pbmRleE9mXG4gIGFyci5jb3B5ID0gQlAuY29weVxuICBhcnIuc2xpY2UgPSBCUC5zbGljZVxuICBhcnIucmVhZFVJbnRMRSA9IEJQLnJlYWRVSW50TEVcbiAgYXJyLnJlYWRVSW50QkUgPSBCUC5yZWFkVUludEJFXG4gIGFyci5yZWFkVUludDggPSBCUC5yZWFkVUludDhcbiAgYXJyLnJlYWRVSW50MTZMRSA9IEJQLnJlYWRVSW50MTZMRVxuICBhcnIucmVhZFVJbnQxNkJFID0gQlAucmVhZFVJbnQxNkJFXG4gIGFyci5yZWFkVUludDMyTEUgPSBCUC5yZWFkVUludDMyTEVcbiAgYXJyLnJlYWRVSW50MzJCRSA9IEJQLnJlYWRVSW50MzJCRVxuICBhcnIucmVhZEludExFID0gQlAucmVhZEludExFXG4gIGFyci5yZWFkSW50QkUgPSBCUC5yZWFkSW50QkVcbiAgYXJyLnJlYWRJbnQ4ID0gQlAucmVhZEludDhcbiAgYXJyLnJlYWRJbnQxNkxFID0gQlAucmVhZEludDE2TEVcbiAgYXJyLnJlYWRJbnQxNkJFID0gQlAucmVhZEludDE2QkVcbiAgYXJyLnJlYWRJbnQzMkxFID0gQlAucmVhZEludDMyTEVcbiAgYXJyLnJlYWRJbnQzMkJFID0gQlAucmVhZEludDMyQkVcbiAgYXJyLnJlYWRGbG9hdExFID0gQlAucmVhZEZsb2F0TEVcbiAgYXJyLnJlYWRGbG9hdEJFID0gQlAucmVhZEZsb2F0QkVcbiAgYXJyLnJlYWREb3VibGVMRSA9IEJQLnJlYWREb3VibGVMRVxuICBhcnIucmVhZERvdWJsZUJFID0gQlAucmVhZERvdWJsZUJFXG4gIGFyci53cml0ZVVJbnQ4ID0gQlAud3JpdGVVSW50OFxuICBhcnIud3JpdGVVSW50TEUgPSBCUC53cml0ZVVJbnRMRVxuICBhcnIud3JpdGVVSW50QkUgPSBCUC53cml0ZVVJbnRCRVxuICBhcnIud3JpdGVVSW50MTZMRSA9IEJQLndyaXRlVUludDE2TEVcbiAgYXJyLndyaXRlVUludDE2QkUgPSBCUC53cml0ZVVJbnQxNkJFXG4gIGFyci53cml0ZVVJbnQzMkxFID0gQlAud3JpdGVVSW50MzJMRVxuICBhcnIud3JpdGVVSW50MzJCRSA9IEJQLndyaXRlVUludDMyQkVcbiAgYXJyLndyaXRlSW50TEUgPSBCUC53cml0ZUludExFXG4gIGFyci53cml0ZUludEJFID0gQlAud3JpdGVJbnRCRVxuICBhcnIud3JpdGVJbnQ4ID0gQlAud3JpdGVJbnQ4XG4gIGFyci53cml0ZUludDE2TEUgPSBCUC53cml0ZUludDE2TEVcbiAgYXJyLndyaXRlSW50MTZCRSA9IEJQLndyaXRlSW50MTZCRVxuICBhcnIud3JpdGVJbnQzMkxFID0gQlAud3JpdGVJbnQzMkxFXG4gIGFyci53cml0ZUludDMyQkUgPSBCUC53cml0ZUludDMyQkVcbiAgYXJyLndyaXRlRmxvYXRMRSA9IEJQLndyaXRlRmxvYXRMRVxuICBhcnIud3JpdGVGbG9hdEJFID0gQlAud3JpdGVGbG9hdEJFXG4gIGFyci53cml0ZURvdWJsZUxFID0gQlAud3JpdGVEb3VibGVMRVxuICBhcnIud3JpdGVEb3VibGVCRSA9IEJQLndyaXRlRG91YmxlQkVcbiAgYXJyLmZpbGwgPSBCUC5maWxsXG4gIGFyci5pbnNwZWN0ID0gQlAuaW5zcGVjdFxuICBhcnIudG9BcnJheUJ1ZmZlciA9IEJQLnRvQXJyYXlCdWZmZXJcblxuICByZXR1cm4gYXJyXG59XG5cbnZhciBJTlZBTElEX0JBU0U2NF9SRSA9IC9bXitcXC8wLTlBLVphLXotX10vZ1xuXG5mdW5jdGlvbiBiYXNlNjRjbGVhbiAoc3RyKSB7XG4gIC8vIE5vZGUgc3RyaXBzIG91dCBpbnZhbGlkIGNoYXJhY3RlcnMgbGlrZSBcXG4gYW5kIFxcdCBmcm9tIHRoZSBzdHJpbmcsIGJhc2U2NC1qcyBkb2VzIG5vdFxuICBzdHIgPSBzdHJpbmd0cmltKHN0cikucmVwbGFjZShJTlZBTElEX0JBU0U2NF9SRSwgJycpXG4gIC8vIE5vZGUgY29udmVydHMgc3RyaW5ncyB3aXRoIGxlbmd0aCA8IDIgdG8gJydcbiAgaWYgKHN0ci5sZW5ndGggPCAyKSByZXR1cm4gJydcbiAgLy8gTm9kZSBhbGxvd3MgZm9yIG5vbi1wYWRkZWQgYmFzZTY0IHN0cmluZ3MgKG1pc3NpbmcgdHJhaWxpbmcgPT09KSwgYmFzZTY0LWpzIGRvZXMgbm90XG4gIHdoaWxlIChzdHIubGVuZ3RoICUgNCAhPT0gMCkge1xuICAgIHN0ciA9IHN0ciArICc9J1xuICB9XG4gIHJldHVybiBzdHJcbn1cblxuZnVuY3Rpb24gc3RyaW5ndHJpbSAoc3RyKSB7XG4gIGlmIChzdHIudHJpbSkgcmV0dXJuIHN0ci50cmltKClcbiAgcmV0dXJuIHN0ci5yZXBsYWNlKC9eXFxzK3xcXHMrJC9nLCAnJylcbn1cblxuZnVuY3Rpb24gdG9IZXggKG4pIHtcbiAgaWYgKG4gPCAxNikgcmV0dXJuICcwJyArIG4udG9TdHJpbmcoMTYpXG4gIHJldHVybiBuLnRvU3RyaW5nKDE2KVxufVxuXG5mdW5jdGlvbiB1dGY4VG9CeXRlcyAoc3RyaW5nLCB1bml0cykge1xuICB1bml0cyA9IHVuaXRzIHx8IEluZmluaXR5XG4gIHZhciBjb2RlUG9pbnRcbiAgdmFyIGxlbmd0aCA9IHN0cmluZy5sZW5ndGhcbiAgdmFyIGxlYWRTdXJyb2dhdGUgPSBudWxsXG4gIHZhciBieXRlcyA9IFtdXG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgIGNvZGVQb2ludCA9IHN0cmluZy5jaGFyQ29kZUF0KGkpXG5cbiAgICAvLyBpcyBzdXJyb2dhdGUgY29tcG9uZW50XG4gICAgaWYgKGNvZGVQb2ludCA+IDB4RDdGRiAmJiBjb2RlUG9pbnQgPCAweEUwMDApIHtcbiAgICAgIC8vIGxhc3QgY2hhciB3YXMgYSBsZWFkXG4gICAgICBpZiAoIWxlYWRTdXJyb2dhdGUpIHtcbiAgICAgICAgLy8gbm8gbGVhZCB5ZXRcbiAgICAgICAgaWYgKGNvZGVQb2ludCA+IDB4REJGRikge1xuICAgICAgICAgIC8vIHVuZXhwZWN0ZWQgdHJhaWxcbiAgICAgICAgICBpZiAoKHVuaXRzIC09IDMpID4gLTEpIGJ5dGVzLnB1c2goMHhFRiwgMHhCRiwgMHhCRClcbiAgICAgICAgICBjb250aW51ZVxuICAgICAgICB9IGVsc2UgaWYgKGkgKyAxID09PSBsZW5ndGgpIHtcbiAgICAgICAgICAvLyB1bnBhaXJlZCBsZWFkXG4gICAgICAgICAgaWYgKCh1bml0cyAtPSAzKSA+IC0xKSBieXRlcy5wdXNoKDB4RUYsIDB4QkYsIDB4QkQpXG4gICAgICAgICAgY29udGludWVcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIHZhbGlkIGxlYWRcbiAgICAgICAgbGVhZFN1cnJvZ2F0ZSA9IGNvZGVQb2ludFxuXG4gICAgICAgIGNvbnRpbnVlXG4gICAgICB9XG5cbiAgICAgIC8vIDIgbGVhZHMgaW4gYSByb3dcbiAgICAgIGlmIChjb2RlUG9pbnQgPCAweERDMDApIHtcbiAgICAgICAgaWYgKCh1bml0cyAtPSAzKSA+IC0xKSBieXRlcy5wdXNoKDB4RUYsIDB4QkYsIDB4QkQpXG4gICAgICAgIGxlYWRTdXJyb2dhdGUgPSBjb2RlUG9pbnRcbiAgICAgICAgY29udGludWVcbiAgICAgIH1cblxuICAgICAgLy8gdmFsaWQgc3Vycm9nYXRlIHBhaXJcbiAgICAgIGNvZGVQb2ludCA9IChsZWFkU3Vycm9nYXRlIC0gMHhEODAwIDw8IDEwIHwgY29kZVBvaW50IC0gMHhEQzAwKSArIDB4MTAwMDBcbiAgICB9IGVsc2UgaWYgKGxlYWRTdXJyb2dhdGUpIHtcbiAgICAgIC8vIHZhbGlkIGJtcCBjaGFyLCBidXQgbGFzdCBjaGFyIHdhcyBhIGxlYWRcbiAgICAgIGlmICgodW5pdHMgLT0gMykgPiAtMSkgYnl0ZXMucHVzaCgweEVGLCAweEJGLCAweEJEKVxuICAgIH1cblxuICAgIGxlYWRTdXJyb2dhdGUgPSBudWxsXG5cbiAgICAvLyBlbmNvZGUgdXRmOFxuICAgIGlmIChjb2RlUG9pbnQgPCAweDgwKSB7XG4gICAgICBpZiAoKHVuaXRzIC09IDEpIDwgMCkgYnJlYWtcbiAgICAgIGJ5dGVzLnB1c2goY29kZVBvaW50KVxuICAgIH0gZWxzZSBpZiAoY29kZVBvaW50IDwgMHg4MDApIHtcbiAgICAgIGlmICgodW5pdHMgLT0gMikgPCAwKSBicmVha1xuICAgICAgYnl0ZXMucHVzaChcbiAgICAgICAgY29kZVBvaW50ID4+IDB4NiB8IDB4QzAsXG4gICAgICAgIGNvZGVQb2ludCAmIDB4M0YgfCAweDgwXG4gICAgICApXG4gICAgfSBlbHNlIGlmIChjb2RlUG9pbnQgPCAweDEwMDAwKSB7XG4gICAgICBpZiAoKHVuaXRzIC09IDMpIDwgMCkgYnJlYWtcbiAgICAgIGJ5dGVzLnB1c2goXG4gICAgICAgIGNvZGVQb2ludCA+PiAweEMgfCAweEUwLFxuICAgICAgICBjb2RlUG9pbnQgPj4gMHg2ICYgMHgzRiB8IDB4ODAsXG4gICAgICAgIGNvZGVQb2ludCAmIDB4M0YgfCAweDgwXG4gICAgICApXG4gICAgfSBlbHNlIGlmIChjb2RlUG9pbnQgPCAweDExMDAwMCkge1xuICAgICAgaWYgKCh1bml0cyAtPSA0KSA8IDApIGJyZWFrXG4gICAgICBieXRlcy5wdXNoKFxuICAgICAgICBjb2RlUG9pbnQgPj4gMHgxMiB8IDB4RjAsXG4gICAgICAgIGNvZGVQb2ludCA+PiAweEMgJiAweDNGIHwgMHg4MCxcbiAgICAgICAgY29kZVBvaW50ID4+IDB4NiAmIDB4M0YgfCAweDgwLFxuICAgICAgICBjb2RlUG9pbnQgJiAweDNGIHwgMHg4MFxuICAgICAgKVxuICAgIH0gZWxzZSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgY29kZSBwb2ludCcpXG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGJ5dGVzXG59XG5cbmZ1bmN0aW9uIGFzY2lpVG9CeXRlcyAoc3RyKSB7XG4gIHZhciBieXRlQXJyYXkgPSBbXVxuICBmb3IgKHZhciBpID0gMDsgaSA8IHN0ci5sZW5ndGg7IGkrKykge1xuICAgIC8vIE5vZGUncyBjb2RlIHNlZW1zIHRvIGJlIGRvaW5nIHRoaXMgYW5kIG5vdCAmIDB4N0YuLlxuICAgIGJ5dGVBcnJheS5wdXNoKHN0ci5jaGFyQ29kZUF0KGkpICYgMHhGRilcbiAgfVxuICByZXR1cm4gYnl0ZUFycmF5XG59XG5cbmZ1bmN0aW9uIHV0ZjE2bGVUb0J5dGVzIChzdHIsIHVuaXRzKSB7XG4gIHZhciBjLCBoaSwgbG9cbiAgdmFyIGJ5dGVBcnJheSA9IFtdXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgc3RyLmxlbmd0aDsgaSsrKSB7XG4gICAgaWYgKCh1bml0cyAtPSAyKSA8IDApIGJyZWFrXG5cbiAgICBjID0gc3RyLmNoYXJDb2RlQXQoaSlcbiAgICBoaSA9IGMgPj4gOFxuICAgIGxvID0gYyAlIDI1NlxuICAgIGJ5dGVBcnJheS5wdXNoKGxvKVxuICAgIGJ5dGVBcnJheS5wdXNoKGhpKVxuICB9XG5cbiAgcmV0dXJuIGJ5dGVBcnJheVxufVxuXG5mdW5jdGlvbiBiYXNlNjRUb0J5dGVzIChzdHIpIHtcbiAgcmV0dXJuIGJhc2U2NC50b0J5dGVBcnJheShiYXNlNjRjbGVhbihzdHIpKVxufVxuXG5mdW5jdGlvbiBibGl0QnVmZmVyIChzcmMsIGRzdCwgb2Zmc2V0LCBsZW5ndGgpIHtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgIGlmICgoaSArIG9mZnNldCA+PSBkc3QubGVuZ3RoKSB8fCAoaSA+PSBzcmMubGVuZ3RoKSkgYnJlYWtcbiAgICBkc3RbaSArIG9mZnNldF0gPSBzcmNbaV1cbiAgfVxuICByZXR1cm4gaVxufVxuIiwidmFyIGxvb2t1cCA9ICdBQkNERUZHSElKS0xNTk9QUVJTVFVWV1hZWmFiY2RlZmdoaWprbG1ub3BxcnN0dXZ3eHl6MDEyMzQ1Njc4OSsvJztcblxuOyhmdW5jdGlvbiAoZXhwb3J0cykge1xuXHQndXNlIHN0cmljdCc7XG5cbiAgdmFyIEFyciA9ICh0eXBlb2YgVWludDhBcnJheSAhPT0gJ3VuZGVmaW5lZCcpXG4gICAgPyBVaW50OEFycmF5XG4gICAgOiBBcnJheVxuXG5cdHZhciBQTFVTICAgPSAnKycuY2hhckNvZGVBdCgwKVxuXHR2YXIgU0xBU0ggID0gJy8nLmNoYXJDb2RlQXQoMClcblx0dmFyIE5VTUJFUiA9ICcwJy5jaGFyQ29kZUF0KDApXG5cdHZhciBMT1dFUiAgPSAnYScuY2hhckNvZGVBdCgwKVxuXHR2YXIgVVBQRVIgID0gJ0EnLmNoYXJDb2RlQXQoMClcblx0dmFyIFBMVVNfVVJMX1NBRkUgPSAnLScuY2hhckNvZGVBdCgwKVxuXHR2YXIgU0xBU0hfVVJMX1NBRkUgPSAnXycuY2hhckNvZGVBdCgwKVxuXG5cdGZ1bmN0aW9uIGRlY29kZSAoZWx0KSB7XG5cdFx0dmFyIGNvZGUgPSBlbHQuY2hhckNvZGVBdCgwKVxuXHRcdGlmIChjb2RlID09PSBQTFVTIHx8XG5cdFx0ICAgIGNvZGUgPT09IFBMVVNfVVJMX1NBRkUpXG5cdFx0XHRyZXR1cm4gNjIgLy8gJysnXG5cdFx0aWYgKGNvZGUgPT09IFNMQVNIIHx8XG5cdFx0ICAgIGNvZGUgPT09IFNMQVNIX1VSTF9TQUZFKVxuXHRcdFx0cmV0dXJuIDYzIC8vICcvJ1xuXHRcdGlmIChjb2RlIDwgTlVNQkVSKVxuXHRcdFx0cmV0dXJuIC0xIC8vbm8gbWF0Y2hcblx0XHRpZiAoY29kZSA8IE5VTUJFUiArIDEwKVxuXHRcdFx0cmV0dXJuIGNvZGUgLSBOVU1CRVIgKyAyNiArIDI2XG5cdFx0aWYgKGNvZGUgPCBVUFBFUiArIDI2KVxuXHRcdFx0cmV0dXJuIGNvZGUgLSBVUFBFUlxuXHRcdGlmIChjb2RlIDwgTE9XRVIgKyAyNilcblx0XHRcdHJldHVybiBjb2RlIC0gTE9XRVIgKyAyNlxuXHR9XG5cblx0ZnVuY3Rpb24gYjY0VG9CeXRlQXJyYXkgKGI2NCkge1xuXHRcdHZhciBpLCBqLCBsLCB0bXAsIHBsYWNlSG9sZGVycywgYXJyXG5cblx0XHRpZiAoYjY0Lmxlbmd0aCAlIDQgPiAwKSB7XG5cdFx0XHR0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgc3RyaW5nLiBMZW5ndGggbXVzdCBiZSBhIG11bHRpcGxlIG9mIDQnKVxuXHRcdH1cblxuXHRcdC8vIHRoZSBudW1iZXIgb2YgZXF1YWwgc2lnbnMgKHBsYWNlIGhvbGRlcnMpXG5cdFx0Ly8gaWYgdGhlcmUgYXJlIHR3byBwbGFjZWhvbGRlcnMsIHRoYW4gdGhlIHR3byBjaGFyYWN0ZXJzIGJlZm9yZSBpdFxuXHRcdC8vIHJlcHJlc2VudCBvbmUgYnl0ZVxuXHRcdC8vIGlmIHRoZXJlIGlzIG9ubHkgb25lLCB0aGVuIHRoZSB0aHJlZSBjaGFyYWN0ZXJzIGJlZm9yZSBpdCByZXByZXNlbnQgMiBieXRlc1xuXHRcdC8vIHRoaXMgaXMganVzdCBhIGNoZWFwIGhhY2sgdG8gbm90IGRvIGluZGV4T2YgdHdpY2Vcblx0XHR2YXIgbGVuID0gYjY0Lmxlbmd0aFxuXHRcdHBsYWNlSG9sZGVycyA9ICc9JyA9PT0gYjY0LmNoYXJBdChsZW4gLSAyKSA/IDIgOiAnPScgPT09IGI2NC5jaGFyQXQobGVuIC0gMSkgPyAxIDogMFxuXG5cdFx0Ly8gYmFzZTY0IGlzIDQvMyArIHVwIHRvIHR3byBjaGFyYWN0ZXJzIG9mIHRoZSBvcmlnaW5hbCBkYXRhXG5cdFx0YXJyID0gbmV3IEFycihiNjQubGVuZ3RoICogMyAvIDQgLSBwbGFjZUhvbGRlcnMpXG5cblx0XHQvLyBpZiB0aGVyZSBhcmUgcGxhY2Vob2xkZXJzLCBvbmx5IGdldCB1cCB0byB0aGUgbGFzdCBjb21wbGV0ZSA0IGNoYXJzXG5cdFx0bCA9IHBsYWNlSG9sZGVycyA+IDAgPyBiNjQubGVuZ3RoIC0gNCA6IGI2NC5sZW5ndGhcblxuXHRcdHZhciBMID0gMFxuXG5cdFx0ZnVuY3Rpb24gcHVzaCAodikge1xuXHRcdFx0YXJyW0wrK10gPSB2XG5cdFx0fVxuXG5cdFx0Zm9yIChpID0gMCwgaiA9IDA7IGkgPCBsOyBpICs9IDQsIGogKz0gMykge1xuXHRcdFx0dG1wID0gKGRlY29kZShiNjQuY2hhckF0KGkpKSA8PCAxOCkgfCAoZGVjb2RlKGI2NC5jaGFyQXQoaSArIDEpKSA8PCAxMikgfCAoZGVjb2RlKGI2NC5jaGFyQXQoaSArIDIpKSA8PCA2KSB8IGRlY29kZShiNjQuY2hhckF0KGkgKyAzKSlcblx0XHRcdHB1c2goKHRtcCAmIDB4RkYwMDAwKSA+PiAxNilcblx0XHRcdHB1c2goKHRtcCAmIDB4RkYwMCkgPj4gOClcblx0XHRcdHB1c2godG1wICYgMHhGRilcblx0XHR9XG5cblx0XHRpZiAocGxhY2VIb2xkZXJzID09PSAyKSB7XG5cdFx0XHR0bXAgPSAoZGVjb2RlKGI2NC5jaGFyQXQoaSkpIDw8IDIpIHwgKGRlY29kZShiNjQuY2hhckF0KGkgKyAxKSkgPj4gNClcblx0XHRcdHB1c2godG1wICYgMHhGRilcblx0XHR9IGVsc2UgaWYgKHBsYWNlSG9sZGVycyA9PT0gMSkge1xuXHRcdFx0dG1wID0gKGRlY29kZShiNjQuY2hhckF0KGkpKSA8PCAxMCkgfCAoZGVjb2RlKGI2NC5jaGFyQXQoaSArIDEpKSA8PCA0KSB8IChkZWNvZGUoYjY0LmNoYXJBdChpICsgMikpID4+IDIpXG5cdFx0XHRwdXNoKCh0bXAgPj4gOCkgJiAweEZGKVxuXHRcdFx0cHVzaCh0bXAgJiAweEZGKVxuXHRcdH1cblxuXHRcdHJldHVybiBhcnJcblx0fVxuXG5cdGZ1bmN0aW9uIHVpbnQ4VG9CYXNlNjQgKHVpbnQ4KSB7XG5cdFx0dmFyIGksXG5cdFx0XHRleHRyYUJ5dGVzID0gdWludDgubGVuZ3RoICUgMywgLy8gaWYgd2UgaGF2ZSAxIGJ5dGUgbGVmdCwgcGFkIDIgYnl0ZXNcblx0XHRcdG91dHB1dCA9IFwiXCIsXG5cdFx0XHR0ZW1wLCBsZW5ndGhcblxuXHRcdGZ1bmN0aW9uIGVuY29kZSAobnVtKSB7XG5cdFx0XHRyZXR1cm4gbG9va3VwLmNoYXJBdChudW0pXG5cdFx0fVxuXG5cdFx0ZnVuY3Rpb24gdHJpcGxldFRvQmFzZTY0IChudW0pIHtcblx0XHRcdHJldHVybiBlbmNvZGUobnVtID4+IDE4ICYgMHgzRikgKyBlbmNvZGUobnVtID4+IDEyICYgMHgzRikgKyBlbmNvZGUobnVtID4+IDYgJiAweDNGKSArIGVuY29kZShudW0gJiAweDNGKVxuXHRcdH1cblxuXHRcdC8vIGdvIHRocm91Z2ggdGhlIGFycmF5IGV2ZXJ5IHRocmVlIGJ5dGVzLCB3ZSdsbCBkZWFsIHdpdGggdHJhaWxpbmcgc3R1ZmYgbGF0ZXJcblx0XHRmb3IgKGkgPSAwLCBsZW5ndGggPSB1aW50OC5sZW5ndGggLSBleHRyYUJ5dGVzOyBpIDwgbGVuZ3RoOyBpICs9IDMpIHtcblx0XHRcdHRlbXAgPSAodWludDhbaV0gPDwgMTYpICsgKHVpbnQ4W2kgKyAxXSA8PCA4KSArICh1aW50OFtpICsgMl0pXG5cdFx0XHRvdXRwdXQgKz0gdHJpcGxldFRvQmFzZTY0KHRlbXApXG5cdFx0fVxuXG5cdFx0Ly8gcGFkIHRoZSBlbmQgd2l0aCB6ZXJvcywgYnV0IG1ha2Ugc3VyZSB0byBub3QgZm9yZ2V0IHRoZSBleHRyYSBieXRlc1xuXHRcdHN3aXRjaCAoZXh0cmFCeXRlcykge1xuXHRcdFx0Y2FzZSAxOlxuXHRcdFx0XHR0ZW1wID0gdWludDhbdWludDgubGVuZ3RoIC0gMV1cblx0XHRcdFx0b3V0cHV0ICs9IGVuY29kZSh0ZW1wID4+IDIpXG5cdFx0XHRcdG91dHB1dCArPSBlbmNvZGUoKHRlbXAgPDwgNCkgJiAweDNGKVxuXHRcdFx0XHRvdXRwdXQgKz0gJz09J1xuXHRcdFx0XHRicmVha1xuXHRcdFx0Y2FzZSAyOlxuXHRcdFx0XHR0ZW1wID0gKHVpbnQ4W3VpbnQ4Lmxlbmd0aCAtIDJdIDw8IDgpICsgKHVpbnQ4W3VpbnQ4Lmxlbmd0aCAtIDFdKVxuXHRcdFx0XHRvdXRwdXQgKz0gZW5jb2RlKHRlbXAgPj4gMTApXG5cdFx0XHRcdG91dHB1dCArPSBlbmNvZGUoKHRlbXAgPj4gNCkgJiAweDNGKVxuXHRcdFx0XHRvdXRwdXQgKz0gZW5jb2RlKCh0ZW1wIDw8IDIpICYgMHgzRilcblx0XHRcdFx0b3V0cHV0ICs9ICc9J1xuXHRcdFx0XHRicmVha1xuXHRcdH1cblxuXHRcdHJldHVybiBvdXRwdXRcblx0fVxuXG5cdGV4cG9ydHMudG9CeXRlQXJyYXkgPSBiNjRUb0J5dGVBcnJheVxuXHRleHBvcnRzLmZyb21CeXRlQXJyYXkgPSB1aW50OFRvQmFzZTY0XG59KHR5cGVvZiBleHBvcnRzID09PSAndW5kZWZpbmVkJyA/ICh0aGlzLmJhc2U2NGpzID0ge30pIDogZXhwb3J0cykpXG4iLCJleHBvcnRzLnJlYWQgPSBmdW5jdGlvbiAoYnVmZmVyLCBvZmZzZXQsIGlzTEUsIG1MZW4sIG5CeXRlcykge1xuICB2YXIgZSwgbVxuICB2YXIgZUxlbiA9IG5CeXRlcyAqIDggLSBtTGVuIC0gMVxuICB2YXIgZU1heCA9ICgxIDw8IGVMZW4pIC0gMVxuICB2YXIgZUJpYXMgPSBlTWF4ID4+IDFcbiAgdmFyIG5CaXRzID0gLTdcbiAgdmFyIGkgPSBpc0xFID8gKG5CeXRlcyAtIDEpIDogMFxuICB2YXIgZCA9IGlzTEUgPyAtMSA6IDFcbiAgdmFyIHMgPSBidWZmZXJbb2Zmc2V0ICsgaV1cblxuICBpICs9IGRcblxuICBlID0gcyAmICgoMSA8PCAoLW5CaXRzKSkgLSAxKVxuICBzID4+PSAoLW5CaXRzKVxuICBuQml0cyArPSBlTGVuXG4gIGZvciAoOyBuQml0cyA+IDA7IGUgPSBlICogMjU2ICsgYnVmZmVyW29mZnNldCArIGldLCBpICs9IGQsIG5CaXRzIC09IDgpIHt9XG5cbiAgbSA9IGUgJiAoKDEgPDwgKC1uQml0cykpIC0gMSlcbiAgZSA+Pj0gKC1uQml0cylcbiAgbkJpdHMgKz0gbUxlblxuICBmb3IgKDsgbkJpdHMgPiAwOyBtID0gbSAqIDI1NiArIGJ1ZmZlcltvZmZzZXQgKyBpXSwgaSArPSBkLCBuQml0cyAtPSA4KSB7fVxuXG4gIGlmIChlID09PSAwKSB7XG4gICAgZSA9IDEgLSBlQmlhc1xuICB9IGVsc2UgaWYgKGUgPT09IGVNYXgpIHtcbiAgICByZXR1cm4gbSA/IE5hTiA6ICgocyA/IC0xIDogMSkgKiBJbmZpbml0eSlcbiAgfSBlbHNlIHtcbiAgICBtID0gbSArIE1hdGgucG93KDIsIG1MZW4pXG4gICAgZSA9IGUgLSBlQmlhc1xuICB9XG4gIHJldHVybiAocyA/IC0xIDogMSkgKiBtICogTWF0aC5wb3coMiwgZSAtIG1MZW4pXG59XG5cbmV4cG9ydHMud3JpdGUgPSBmdW5jdGlvbiAoYnVmZmVyLCB2YWx1ZSwgb2Zmc2V0LCBpc0xFLCBtTGVuLCBuQnl0ZXMpIHtcbiAgdmFyIGUsIG0sIGNcbiAgdmFyIGVMZW4gPSBuQnl0ZXMgKiA4IC0gbUxlbiAtIDFcbiAgdmFyIGVNYXggPSAoMSA8PCBlTGVuKSAtIDFcbiAgdmFyIGVCaWFzID0gZU1heCA+PiAxXG4gIHZhciBydCA9IChtTGVuID09PSAyMyA/IE1hdGgucG93KDIsIC0yNCkgLSBNYXRoLnBvdygyLCAtNzcpIDogMClcbiAgdmFyIGkgPSBpc0xFID8gMCA6IChuQnl0ZXMgLSAxKVxuICB2YXIgZCA9IGlzTEUgPyAxIDogLTFcbiAgdmFyIHMgPSB2YWx1ZSA8IDAgfHwgKHZhbHVlID09PSAwICYmIDEgLyB2YWx1ZSA8IDApID8gMSA6IDBcblxuICB2YWx1ZSA9IE1hdGguYWJzKHZhbHVlKVxuXG4gIGlmIChpc05hTih2YWx1ZSkgfHwgdmFsdWUgPT09IEluZmluaXR5KSB7XG4gICAgbSA9IGlzTmFOKHZhbHVlKSA/IDEgOiAwXG4gICAgZSA9IGVNYXhcbiAgfSBlbHNlIHtcbiAgICBlID0gTWF0aC5mbG9vcihNYXRoLmxvZyh2YWx1ZSkgLyBNYXRoLkxOMilcbiAgICBpZiAodmFsdWUgKiAoYyA9IE1hdGgucG93KDIsIC1lKSkgPCAxKSB7XG4gICAgICBlLS1cbiAgICAgIGMgKj0gMlxuICAgIH1cbiAgICBpZiAoZSArIGVCaWFzID49IDEpIHtcbiAgICAgIHZhbHVlICs9IHJ0IC8gY1xuICAgIH0gZWxzZSB7XG4gICAgICB2YWx1ZSArPSBydCAqIE1hdGgucG93KDIsIDEgLSBlQmlhcylcbiAgICB9XG4gICAgaWYgKHZhbHVlICogYyA+PSAyKSB7XG4gICAgICBlKytcbiAgICAgIGMgLz0gMlxuICAgIH1cblxuICAgIGlmIChlICsgZUJpYXMgPj0gZU1heCkge1xuICAgICAgbSA9IDBcbiAgICAgIGUgPSBlTWF4XG4gICAgfSBlbHNlIGlmIChlICsgZUJpYXMgPj0gMSkge1xuICAgICAgbSA9ICh2YWx1ZSAqIGMgLSAxKSAqIE1hdGgucG93KDIsIG1MZW4pXG4gICAgICBlID0gZSArIGVCaWFzXG4gICAgfSBlbHNlIHtcbiAgICAgIG0gPSB2YWx1ZSAqIE1hdGgucG93KDIsIGVCaWFzIC0gMSkgKiBNYXRoLnBvdygyLCBtTGVuKVxuICAgICAgZSA9IDBcbiAgICB9XG4gIH1cblxuICBmb3IgKDsgbUxlbiA+PSA4OyBidWZmZXJbb2Zmc2V0ICsgaV0gPSBtICYgMHhmZiwgaSArPSBkLCBtIC89IDI1NiwgbUxlbiAtPSA4KSB7fVxuXG4gIGUgPSAoZSA8PCBtTGVuKSB8IG1cbiAgZUxlbiArPSBtTGVuXG4gIGZvciAoOyBlTGVuID4gMDsgYnVmZmVyW29mZnNldCArIGldID0gZSAmIDB4ZmYsIGkgKz0gZCwgZSAvPSAyNTYsIGVMZW4gLT0gOCkge31cblxuICBidWZmZXJbb2Zmc2V0ICsgaSAtIGRdIHw9IHMgKiAxMjhcbn1cbiIsIm1vZHVsZS5leHBvcnRzID0gQXJyYXkuaXNBcnJheSB8fCBmdW5jdGlvbiAoYXJyKSB7XG4gIHJldHVybiBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwoYXJyKSA9PSAnW29iamVjdCBBcnJheV0nO1xufTtcbiIsIi8vIHNoaW0gZm9yIHVzaW5nIHByb2Nlc3MgaW4gYnJvd3NlclxuXG52YXIgcHJvY2VzcyA9IG1vZHVsZS5leHBvcnRzID0ge307XG52YXIgcXVldWUgPSBbXTtcbnZhciBkcmFpbmluZyA9IGZhbHNlO1xudmFyIGN1cnJlbnRRdWV1ZTtcbnZhciBxdWV1ZUluZGV4ID0gLTE7XG5cbmZ1bmN0aW9uIGNsZWFuVXBOZXh0VGljaygpIHtcbiAgICBkcmFpbmluZyA9IGZhbHNlO1xuICAgIGlmIChjdXJyZW50UXVldWUubGVuZ3RoKSB7XG4gICAgICAgIHF1ZXVlID0gY3VycmVudFF1ZXVlLmNvbmNhdChxdWV1ZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgcXVldWVJbmRleCA9IC0xO1xuICAgIH1cbiAgICBpZiAocXVldWUubGVuZ3RoKSB7XG4gICAgICAgIGRyYWluUXVldWUoKTtcbiAgICB9XG59XG5cbmZ1bmN0aW9uIGRyYWluUXVldWUoKSB7XG4gICAgaWYgKGRyYWluaW5nKSB7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdmFyIHRpbWVvdXQgPSBzZXRUaW1lb3V0KGNsZWFuVXBOZXh0VGljayk7XG4gICAgZHJhaW5pbmcgPSB0cnVlO1xuXG4gICAgdmFyIGxlbiA9IHF1ZXVlLmxlbmd0aDtcbiAgICB3aGlsZShsZW4pIHtcbiAgICAgICAgY3VycmVudFF1ZXVlID0gcXVldWU7XG4gICAgICAgIHF1ZXVlID0gW107XG4gICAgICAgIHdoaWxlICgrK3F1ZXVlSW5kZXggPCBsZW4pIHtcbiAgICAgICAgICAgIGlmIChjdXJyZW50UXVldWUpIHtcbiAgICAgICAgICAgICAgICBjdXJyZW50UXVldWVbcXVldWVJbmRleF0ucnVuKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcXVldWVJbmRleCA9IC0xO1xuICAgICAgICBsZW4gPSBxdWV1ZS5sZW5ndGg7XG4gICAgfVxuICAgIGN1cnJlbnRRdWV1ZSA9IG51bGw7XG4gICAgZHJhaW5pbmcgPSBmYWxzZTtcbiAgICBjbGVhclRpbWVvdXQodGltZW91dCk7XG59XG5cbnByb2Nlc3MubmV4dFRpY2sgPSBmdW5jdGlvbiAoZnVuKSB7XG4gICAgdmFyIGFyZ3MgPSBuZXcgQXJyYXkoYXJndW1lbnRzLmxlbmd0aCAtIDEpO1xuICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID4gMSkge1xuICAgICAgICBmb3IgKHZhciBpID0gMTsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgYXJnc1tpIC0gMV0gPSBhcmd1bWVudHNbaV07XG4gICAgICAgIH1cbiAgICB9XG4gICAgcXVldWUucHVzaChuZXcgSXRlbShmdW4sIGFyZ3MpKTtcbiAgICBpZiAocXVldWUubGVuZ3RoID09PSAxICYmICFkcmFpbmluZykge1xuICAgICAgICBzZXRUaW1lb3V0KGRyYWluUXVldWUsIDApO1xuICAgIH1cbn07XG5cbi8vIHY4IGxpa2VzIHByZWRpY3RpYmxlIG9iamVjdHNcbmZ1bmN0aW9uIEl0ZW0oZnVuLCBhcnJheSkge1xuICAgIHRoaXMuZnVuID0gZnVuO1xuICAgIHRoaXMuYXJyYXkgPSBhcnJheTtcbn1cbkl0ZW0ucHJvdG90eXBlLnJ1biA9IGZ1bmN0aW9uICgpIHtcbiAgICB0aGlzLmZ1bi5hcHBseShudWxsLCB0aGlzLmFycmF5KTtcbn07XG5wcm9jZXNzLnRpdGxlID0gJ2Jyb3dzZXInO1xucHJvY2Vzcy5icm93c2VyID0gdHJ1ZTtcbnByb2Nlc3MuZW52ID0ge307XG5wcm9jZXNzLmFyZ3YgPSBbXTtcbnByb2Nlc3MudmVyc2lvbiA9ICcnOyAvLyBlbXB0eSBzdHJpbmcgdG8gYXZvaWQgcmVnZXhwIGlzc3Vlc1xucHJvY2Vzcy52ZXJzaW9ucyA9IHt9O1xuXG5mdW5jdGlvbiBub29wKCkge31cblxucHJvY2Vzcy5vbiA9IG5vb3A7XG5wcm9jZXNzLmFkZExpc3RlbmVyID0gbm9vcDtcbnByb2Nlc3Mub25jZSA9IG5vb3A7XG5wcm9jZXNzLm9mZiA9IG5vb3A7XG5wcm9jZXNzLnJlbW92ZUxpc3RlbmVyID0gbm9vcDtcbnByb2Nlc3MucmVtb3ZlQWxsTGlzdGVuZXJzID0gbm9vcDtcbnByb2Nlc3MuZW1pdCA9IG5vb3A7XG5cbnByb2Nlc3MuYmluZGluZyA9IGZ1bmN0aW9uIChuYW1lKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdwcm9jZXNzLmJpbmRpbmcgaXMgbm90IHN1cHBvcnRlZCcpO1xufTtcblxucHJvY2Vzcy5jd2QgPSBmdW5jdGlvbiAoKSB7IHJldHVybiAnLycgfTtcbnByb2Nlc3MuY2hkaXIgPSBmdW5jdGlvbiAoZGlyKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdwcm9jZXNzLmNoZGlyIGlzIG5vdCBzdXBwb3J0ZWQnKTtcbn07XG5wcm9jZXNzLnVtYXNrID0gZnVuY3Rpb24oKSB7IHJldHVybiAwOyB9O1xuIiwiLy8gQ29weXJpZ2h0IDIwMTQgVGhvbSBDaGlvdm9sb25pLCByZWxlYXNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UuXG5cbi8vLyBBIHJhbmRvbSBudW1iZXIgZ2VuZXJhdG9yIGJhc2VkIG9uIHRoZSBiYXNpYyBpbXBsZW1lbnRhdGlvbiBvZiB0aGUgUENHIGFsZ29yaXRobSxcbi8vLyBhcyBkZXNjcmliZWQgaGVyZTogaHR0cDovL3d3dy5wY2ctcmFuZG9tLm9yZy9cbnZhciBQY2dSYW5kb20gPSAoZnVuY3Rpb24oKSB7XG5cdCd1c2Ugc3RyaWN0JztcblxuXHR2YXIgZGVmYXVsdEluY0hpID0gMHgxNDA1N2I3ZTtcblx0dmFyIGRlZmF1bHRJbmNMbyA9IDB4Zjc2NzgxNGY7XG5cblx0Ly8vIENvbnN0cnVjdCBhIHJhbmRvbSBudW1iZXIgZ2VuZXJhdG9yLlxuXHRmdW5jdGlvbiBQY2dSYW5kb20oc2VlZEhpLCBzZWVkTG8sIGluY0hpLCBpbmNMbykge1xuXHRcdHRoaXMuc2V0U2VlZChzZWVkSGksIHNlZWRMbywgaW5jSGksIGluY0xvKVxuXHR9XG5cblx0Ly8vIFNldCB0aGUgc2VlZCBhbmQgaW5jcmVtZW50ZXIuXG5cdFBjZ1JhbmRvbS5wcm90b3R5cGUuc2V0U2VlZCA9IGZ1bmN0aW9uKHNlZWRIaSwgc2VlZExvLCBpbmNIaSwgaW5jTG8pIHtcblx0XHRpZiAoc2VlZExvID09IG51bGwgJiYgc2VlZEhpID09IG51bGwpIHtcblx0XHRcdHNlZWRMbyA9IChNYXRoLnJhbmRvbSgpICogMHhmZmZmZmZmZikgPj4+IDA7XG5cdFx0XHRzZWVkSGkgPSAwO1xuXHRcdH1cblx0XHRlbHNlIGlmIChzZWVkTG8gPT0gbnVsbCkge1xuXHRcdFx0c2VlZExvID0gc2VlZEhpO1xuXHRcdFx0c2VlZEhpID0gMDtcblx0XHR9XG5cdFx0aWYgKGluY0xvID09IG51bGwgJiYgaW5jSGkgPT0gbnVsbCkge1xuXHRcdFx0aW5jTG8gPSB0aGlzLnN0YXRlXyA/IHRoaXMuc3RhdGVfWzNdIDogZGVmYXVsdEluY0xvO1xuXHRcdFx0aW5jSGkgPSB0aGlzLnN0YXRlXyA/IHRoaXMuc3RhdGVfWzJdIDogZGVmYXVsdEluY0hpO1xuXHRcdH1cblx0XHRlbHNlIGlmIChpbmNMbyA9PSBudWxsKSB7XG5cdFx0XHRpbmNMbyA9IGluY0hpO1xuXHRcdFx0aW5jSGkgPSAwO1xuXHRcdH1cblxuXHRcdHRoaXMuc3RhdGVfID0gbmV3IEludDMyQXJyYXkoWyAwLCAwLCBpbmNIaSA+Pj4gMCwgKGluY0xvfDEpID4+PiAwIF0pO1xuXHRcdHRoaXMubmV4dF8oKTtcblx0XHRhZGQ2NF8odGhpcy5zdGF0ZV8sIHRoaXMuc3RhdGVfWzBdLCB0aGlzLnN0YXRlX1sxXSwgc2VlZEhpPj4+MCwgc2VlZExvPj4+MCk7XG5cdFx0dGhpcy5uZXh0XygpO1xuXHRcdHJldHVybiB0aGlzO1xuXHR9O1xuXG5cdC8vLyBSZXR1cm4gYSBjb3B5IG9mIHRoZSBpbnRlcm5hbCBzdGF0ZSBvZiB0aGlzIHJhbmRvbSBudW1iZXIgZ2VuZXJhdG9yIGFzIGEgSmF2YVNjcmlwdCBBcnJheS5cblx0UGNnUmFuZG9tLnByb3RvdHlwZS5nZXRTdGF0ZSA9IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiBbdGhpcy5zdGF0ZV9bMF0sIHRoaXMuc3RhdGVfWzFdLCB0aGlzLnN0YXRlX1syXSwgdGhpcy5zdGF0ZV9bM11dO1xuXHR9O1xuXG5cdC8vLyBTZXQgdGhlIHN0YXRlIG9mIHRoZSByYW5kb20gbnVtYmVyIGdlbmVyYXRvci5cblx0UGNnUmFuZG9tLnByb3RvdHlwZS5zZXRTdGF0ZSA9IGZ1bmN0aW9uKHN0YXRlKSB7XG5cdFx0dGhpcy5zdGF0ZV9bMF0gPSBzdGF0ZVswXTtcblx0XHR0aGlzLnN0YXRlX1sxXSA9IHN0YXRlWzFdO1xuXHRcdHRoaXMuc3RhdGVfWzJdID0gc3RhdGVbMl07XG5cdFx0dGhpcy5zdGF0ZV9bM10gPSBzdGF0ZVszXXwxO1xuXHR9O1xuXG5cdC8vIHNoaW0gZm9yIE1hdGguaW11bC5cblx0dmFyIGltdWwgPSBNYXRoLmltdWw7XG5cdGlmICghaW11bCkge1xuXHRcdGltdWwgPSBmdW5jdGlvbihhLCBiKSB7XG5cdFx0XHR2YXIgYWggPSAoYSA+Pj4gMTYpICYgMHhmZmZmLCBhbCA9IGEgJiAweGZmZmY7XG5cdFx0XHR2YXIgYmggPSAoYiA+Pj4gMTYpICYgMHhmZmZmLCBibCA9IGIgJiAweGZmZmY7XG5cdFx0XHRyZXR1cm4gKChhbCAqIGJsKSArICgoKGFoICogYmwgKyBhbCAqIGJoKSA8PCAxNikgPj4+IDApIHwgMCk7XG5cdFx0fTtcblx0fVxuXG5cdC8vIG11bHRpcGx5IHR3byA2NCBiaXQgbnVtYmVycyAoZ2l2ZW4gaW4gcGFydHMpLCBhbmQgc3RvcmUgdGhlIHJlc3VsdCBpbiBgb3V0YC5cblx0ZnVuY3Rpb24gbXVsNjRfKG91dCwgYUhpLCBhTG8sIGJIaSwgYkxvKSB7XG5cdFx0dmFyIGMxID0gKGFMbyA+Pj4gMTYpICogKGJMbyAmIDB4ZmZmZikgPj4+IDA7XG5cdFx0dmFyIGMwID0gKGFMbyAmIDB4ZmZmZikgKiAoYkxvID4+PiAxNikgPj4+IDA7XG5cblx0XHR2YXIgbG8gPSAoKGFMbyAmIDB4ZmZmZikgKiAoYkxvICYgMHhmZmZmKSkgPj4+IDA7XG5cdFx0dmFyIGhpID0gKChhTG8gPj4+IDE2KSAqIChiTG8gPj4+IDE2KSkgKyAoKGMwID4+PiAxNikgKyAoYzEgPj4+IDE2KSkgPj4+IDA7XG5cblx0XHRjMCA9IChjMCA8PCAxNikgPj4+IDA7XG5cdFx0bG8gPSAobG8gKyBjMCkgPj4+IDA7XG5cdFx0aWYgKChsbyA+Pj4gMCkgPCAoYzAgPj4+IDApKSB7XG5cdFx0XHRoaSA9IChoaSArIDEpID4+PiAwO1xuXHRcdH1cblxuXHRcdGMxID0gKGMxIDw8IDE2KSA+Pj4gMDtcblx0XHRsbyA9IChsbyArIGMxKSA+Pj4gMDtcblx0XHRpZiAoKGxvID4+PiAwKSA8IChjMSA+Pj4gMCkpIHtcblx0XHRcdGhpID0gKGhpICsgMSkgPj4+IDA7XG5cdFx0fVxuXG5cdFx0aGkgPSAoaGkgKyBpbXVsKGFMbywgYkhpKSkgPj4+IDA7XG5cdFx0aGkgPSAoaGkgKyBpbXVsKGFIaSwgYkxvKSkgPj4+IDA7XG5cblx0XHRvdXRbMF0gPSBoaTtcblx0XHRvdXRbMV0gPSBsbztcblx0fVxuXG5cdC8vIGFkZCB0d28gNjQgYml0IG51bWJlcnMgKGdpdmVuIGluIHBhcnRzKSwgYW5kIHN0b3JlIHRoZSByZXN1bHQgaW4gYG91dGAuXG5cdGZ1bmN0aW9uIGFkZDY0XyhvdXQsIGFIaSwgYUxvLCBiSGksIGJMbykge1xuXHRcdHZhciBoaSA9IChhSGkgKyBiSGkpID4+PiAwO1xuXHRcdHZhciBsbyA9IChhTG8gKyBiTG8pID4+PiAwO1xuXHRcdGlmICgobG8gPj4+IDApIDwgKGFMbyA+Pj4gMCkpIHtcblx0XHRcdGhpID0gKGhpICsgMSkgfCAwO1xuXHRcdH1cblx0XHRvdXRbMF0gPSBoaTtcblx0XHRvdXRbMV0gPSBsbztcblx0fVxuXG5cdHZhciBNVUxfSEkgPSAweDU4NTFmNDJkID4+PiAwO1xuXHR2YXIgTVVMX0xPID0gMHg0Yzk1N2YyZCA+Pj4gMDtcblxuXHQvLy8gR2VuZXJhdGUgYSByYW5kb20gMzIgYml0IGludGVnZXIuIFRoaXMgdXNlcyB0aGUgUENHIGFsZ29yaXRobSwgZGVzY3JpYmVkXG5cdC8vLyBoZXJlOiBodHRwOi8vd3d3LnBjZy1yYW5kb20ub3JnL1xuXHRQY2dSYW5kb20ucHJvdG90eXBlLm5leHRfID0gZnVuY3Rpb24oKSB7XG5cdFx0Ly8gc2F2ZSBjdXJyZW50IHN0YXRlICh3aGF0IHdlJ2xsIHVzZSBmb3IgdGhpcyBudW1iZXIpXG5cdFx0dmFyIG9sZEhpID0gdGhpcy5zdGF0ZV9bMF0gPj4+IDA7XG5cdFx0dmFyIG9sZExvID0gdGhpcy5zdGF0ZV9bMV0gPj4+IDA7XG5cblx0XHQvLyBjaHVybiBMQ0cuXG5cdFx0bXVsNjRfKHRoaXMuc3RhdGVfLCBvbGRIaSwgb2xkTG8sIE1VTF9ISSwgTVVMX0xPKTtcblx0XHRhZGQ2NF8odGhpcy5zdGF0ZV8sIHRoaXMuc3RhdGVfWzBdLCB0aGlzLnN0YXRlX1sxXSwgdGhpcy5zdGF0ZV9bMl0sIHRoaXMuc3RhdGVfWzNdKTtcblxuXHRcdC8vIGdldCBsZWFzdCBzaWcuIDMyIGJpdHMgb2YgKChvbGRzdGF0ZSA+PiAxOCkgXiBvbGRzdGF0ZSkgPj4gMjdcblx0XHR2YXIgeHNIaSA9IG9sZEhpID4+PiAxODtcblx0XHR2YXIgeHNMbyA9ICgob2xkTG8gPj4+IDE4KSB8IChvbGRIaSA8PCAxNCkpID4+PiAwO1xuXHRcdHhzSGkgPSAoeHNIaSBeIG9sZEhpKSA+Pj4gMDtcblx0XHR4c0xvID0gKHhzTG8gXiBvbGRMbykgPj4+IDA7XG5cdFx0dmFyIHhvcnNoaWZ0ZWQgPSAoKHhzTG8gPj4+IDI3KSB8ICh4c0hpIDw8IDUpKSA+Pj4gMDtcblx0XHQvLyByb3RhdGUgeG9yc2hpZnRlZCByaWdodCBhIHJhbmRvbSBhbW91bnQsIGJhc2VkIG9uIHRoZSBtb3N0IHNpZy4gNSBiaXRzXG5cdFx0Ly8gYml0cyBvZiB0aGUgb2xkIHN0YXRlLlxuXHRcdHZhciByb3QgPSBvbGRIaSA+Pj4gMjc7XG5cdFx0dmFyIHJvdDIgPSAoKC1yb3QgPj4+IDApICYgMzEpID4+PiAwO1xuXHRcdHJldHVybiAoKHhvcnNoaWZ0ZWQgPj4+IHJvdCkgfCAoeG9yc2hpZnRlZCA8PCByb3QyKSkgPj4+IDA7XG5cdH07XG5cblx0Ly8vIEdldCBhIHVuaWZvcm1seSBkaXN0cmlidXRlZCAzMiBiaXQgaW50ZWdlciBiZXR3ZWVuIFswLCBtYXgpLlxuXHRQY2dSYW5kb20ucHJvdG90eXBlLmludGVnZXIgPSBmdW5jdGlvbihtYXgpIHtcblx0XHRpZiAoIW1heCkge1xuXHRcdFx0cmV0dXJuIHRoaXMubmV4dF8oKTtcblx0XHR9XG5cdFx0bWF4ID0gbWF4ID4+PiAwO1xuXHRcdGlmICgobWF4ICYgKG1heCAtIDEpKSA9PT0gMCkge1xuXHRcdFx0cmV0dXJuIHRoaXMubmV4dF8oKSAmIChtYXggLSAxKTsgLy8gZmFzdCBwYXRoIGZvciBwb3dlciBvZiAyXG5cdFx0fVxuXG5cdFx0dmFyIG51bSA9IDA7XG5cdFx0dmFyIHNrZXcgPSAoKC1tYXggPj4+IDApICUgbWF4KSA+Pj4gMDtcblx0XHRmb3IgKG51bSA9IHRoaXMubmV4dF8oKTsgbnVtIDwgc2tldzsgbnVtID0gdGhpcy5uZXh0XygpKSB7XG5cdFx0XHQvLyB0aGlzIGxvb3Agd2lsbCByYXJlbHkgZXhlY3V0ZSBtb3JlIHRoYW4gdHdpY2UsXG5cdFx0XHQvLyBhbmQgaXMgaW50ZW50aW9uYWxseSBlbXB0eVxuXHRcdH1cblx0XHRyZXR1cm4gbnVtICUgbWF4O1xuXHR9O1xuXG5cdHZhciBCSVRfNTMgPSA5MDA3MTk5MjU0NzQwOTkyLjA7XG5cdHZhciBCSVRfMjcgPSAxMzQyMTc3MjguMDtcblxuXHQvLy8gR2V0IGEgdW5pZm9ybWx5IGRpc3RyaWJ1dGVkIElFRUUtNzU0IGRvdWJsZSBiZXR3ZWVuIDAuMCBhbmQgMS4wLCB3aXRoXG5cdC8vLyA1MyBiaXRzIG9mIHByZWNpc2lvbiAoZXZlcnkgYml0IG9mIHRoZSBtYW50aXNzYSBpcyByYW5kb21pemVkKS5cblx0UGNnUmFuZG9tLnByb3RvdHlwZS5udW1iZXIgPSBmdW5jdGlvbigpIHtcblx0XHR2YXIgaGkgPSAodGhpcy5uZXh0XygpICYgMHgwM2ZmZmZmZikgKiAxLjA7XG5cdFx0dmFyIGxvID0gKHRoaXMubmV4dF8oKSAmIDB4MDdmZmZmZmYpICogMS4wO1xuXHRcdHJldHVybiAoKGhpICogQklUXzI3KSArIGxvKSAvIEJJVF81Mztcblx0fTtcblxuXHRyZXR1cm4gUGNnUmFuZG9tO1xufSgpKTtcblxuaWYgKHR5cGVvZiBtb2R1bGUgIT09ICd1bmRlZmluZWQnICYmIG1vZHVsZS5leHBvcnRzKSB7XG5cdG1vZHVsZS5leHBvcnRzID0gUGNnUmFuZG9tO1xufVxuXG4iLCIndXNlIHN0cmljdCdcblxubW9kdWxlLmV4cG9ydHMgPSBwb2x5Qm9vbFxuXG52YXIgcHNsZzJwb2x5ID0gcmVxdWlyZSgncHNsZy10by1wb2x5JylcbnZhciBwb2x5MnBzbGcgPSByZXF1aXJlKCdwb2x5LXRvLXBzbGcnKVxudmFyIG92ZXJsYXkgICA9IHJlcXVpcmUoJ292ZXJsYXktcHNsZycpXG5cbmZ1bmN0aW9uIHBvbHlCb29sKGEsIGIsIG9wKSB7XG4gIHZhciBhcHNsID0gcG9seTJwc2xnKGEpXG4gIHZhciBicHNsID0gcG9seTJwc2xnKGIpXG4gIHZhciByZXN1bHQgPSBvdmVybGF5KFxuICAgIGFwc2wucG9pbnRzLCBhcHNsLmVkZ2VzLFxuICAgIGJwc2wucG9pbnRzLCBicHNsLmVkZ2VzLFxuICAgIG9wKVxuICByZXR1cm4gcHNsZzJwb2x5KHJlc3VsdC5wb2ludHMsIHJlc3VsdC5yZWQuY29uY2F0KHJlc3VsdC5ibHVlKSlcbn1cbiIsIlwidXNlIHN0cmljdFwiXG5cbmZ1bmN0aW9uIGNvbXBpbGVTZWFyY2goZnVuY05hbWUsIHByZWRpY2F0ZSwgcmV2ZXJzZWQsIGV4dHJhQXJncywgZWFybHlPdXQpIHtcbiAgdmFyIGNvZGUgPSBbXG4gICAgXCJmdW5jdGlvbiBcIiwgZnVuY05hbWUsIFwiKGEsbCxoLFwiLCBleHRyYUFyZ3Muam9pbihcIixcIiksICBcIil7XCIsXG5lYXJseU91dCA/IFwiXCIgOiBcInZhciBpPVwiLCAocmV2ZXJzZWQgPyBcImwtMVwiIDogXCJoKzFcIiksXG5cIjt3aGlsZShsPD1oKXtcXFxudmFyIG09KGwraCk+Pj4xLHg9YVttXVwiXVxuICBpZihlYXJseU91dCkge1xuICAgIGlmKHByZWRpY2F0ZS5pbmRleE9mKFwiY1wiKSA8IDApIHtcbiAgICAgIGNvZGUucHVzaChcIjtpZih4PT09eSl7cmV0dXJuIG19ZWxzZSBpZih4PD15KXtcIilcbiAgICB9IGVsc2Uge1xuICAgICAgY29kZS5wdXNoKFwiO3ZhciBwPWMoeCx5KTtpZihwPT09MCl7cmV0dXJuIG19ZWxzZSBpZihwPD0wKXtcIilcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgY29kZS5wdXNoKFwiO2lmKFwiLCBwcmVkaWNhdGUsIFwiKXtpPW07XCIpXG4gIH1cbiAgaWYocmV2ZXJzZWQpIHtcbiAgICBjb2RlLnB1c2goXCJsPW0rMX1lbHNle2g9bS0xfVwiKVxuICB9IGVsc2Uge1xuICAgIGNvZGUucHVzaChcImg9bS0xfWVsc2V7bD1tKzF9XCIpXG4gIH1cbiAgY29kZS5wdXNoKFwifVwiKVxuICBpZihlYXJseU91dCkge1xuICAgIGNvZGUucHVzaChcInJldHVybiAtMX07XCIpXG4gIH0gZWxzZSB7XG4gICAgY29kZS5wdXNoKFwicmV0dXJuIGl9O1wiKVxuICB9XG4gIHJldHVybiBjb2RlLmpvaW4oXCJcIilcbn1cblxuZnVuY3Rpb24gY29tcGlsZUJvdW5kc1NlYXJjaChwcmVkaWNhdGUsIHJldmVyc2VkLCBzdWZmaXgsIGVhcmx5T3V0KSB7XG4gIHZhciByZXN1bHQgPSBuZXcgRnVuY3Rpb24oW1xuICBjb21waWxlU2VhcmNoKFwiQVwiLCBcInhcIiArIHByZWRpY2F0ZSArIFwieVwiLCByZXZlcnNlZCwgW1wieVwiXSwgZWFybHlPdXQpLFxuICBjb21waWxlU2VhcmNoKFwiUFwiLCBcImMoeCx5KVwiICsgcHJlZGljYXRlICsgXCIwXCIsIHJldmVyc2VkLCBbXCJ5XCIsIFwiY1wiXSwgZWFybHlPdXQpLFxuXCJmdW5jdGlvbiBkaXNwYXRjaEJzZWFyY2hcIiwgc3VmZml4LCBcIihhLHksYyxsLGgpe1xcXG5pZih0eXBlb2YoYyk9PT0nZnVuY3Rpb24nKXtcXFxucmV0dXJuIFAoYSwobD09PXZvaWQgMCk/MDpsfDAsKGg9PT12b2lkIDApP2EubGVuZ3RoLTE6aHwwLHksYylcXFxufWVsc2V7XFxcbnJldHVybiBBKGEsKGM9PT12b2lkIDApPzA6Y3wwLChsPT09dm9pZCAwKT9hLmxlbmd0aC0xOmx8MCx5KVxcXG59fVxcXG5yZXR1cm4gZGlzcGF0Y2hCc2VhcmNoXCIsIHN1ZmZpeF0uam9pbihcIlwiKSlcbiAgcmV0dXJuIHJlc3VsdCgpXG59XG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICBnZTogY29tcGlsZUJvdW5kc1NlYXJjaChcIj49XCIsIGZhbHNlLCBcIkdFXCIpLFxuICBndDogY29tcGlsZUJvdW5kc1NlYXJjaChcIj5cIiwgZmFsc2UsIFwiR1RcIiksXG4gIGx0OiBjb21waWxlQm91bmRzU2VhcmNoKFwiPFwiLCB0cnVlLCBcIkxUXCIpLFxuICBsZTogY29tcGlsZUJvdW5kc1NlYXJjaChcIjw9XCIsIHRydWUsIFwiTEVcIiksXG4gIGVxOiBjb21waWxlQm91bmRzU2VhcmNoKFwiLVwiLCB0cnVlLCBcIkVRXCIsIHRydWUpXG59XG4iLCIndXNlIHN0cmljdCdcblxudmFyIG1vbm90b25lVHJpYW5ndWxhdGUgPSByZXF1aXJlKCcuL2xpYi9tb25vdG9uZScpXG52YXIgbWFrZUluZGV4ID0gcmVxdWlyZSgnLi9saWIvdHJpYW5ndWxhdGlvbicpXG52YXIgZGVsYXVuYXlGbGlwID0gcmVxdWlyZSgnLi9saWIvZGVsYXVuYXknKVxudmFyIGZpbHRlclRyaWFuZ3VsYXRpb24gPSByZXF1aXJlKCcuL2xpYi9maWx0ZXInKVxuXG5tb2R1bGUuZXhwb3J0cyA9IGNkdDJkXG5cbmZ1bmN0aW9uIGNhbm9uaWNhbGl6ZUVkZ2UoZSkge1xuICByZXR1cm4gW01hdGgubWluKGVbMF0sIGVbMV0pLCBNYXRoLm1heChlWzBdLCBlWzFdKV1cbn1cblxuZnVuY3Rpb24gY29tcGFyZUVkZ2UoYSwgYikge1xuICByZXR1cm4gYVswXS1iWzBdIHx8IGFbMV0tYlsxXVxufVxuXG5mdW5jdGlvbiBjYW5vbmljYWxpemVFZGdlcyhlZGdlcykge1xuICByZXR1cm4gZWRnZXMubWFwKGNhbm9uaWNhbGl6ZUVkZ2UpLnNvcnQoY29tcGFyZUVkZ2UpXG59XG5cbmZ1bmN0aW9uIGdldERlZmF1bHQob3B0aW9ucywgcHJvcGVydHksIGRmbHQpIHtcbiAgaWYocHJvcGVydHkgaW4gb3B0aW9ucykge1xuICAgIHJldHVybiBvcHRpb25zW3Byb3BlcnR5XVxuICB9XG4gIHJldHVybiBkZmx0XG59XG5cbmZ1bmN0aW9uIGNkdDJkKHBvaW50cywgZWRnZXMsIG9wdGlvbnMpIHtcblxuICBpZighQXJyYXkuaXNBcnJheShlZGdlcykpIHtcbiAgICBvcHRpb25zID0gZWRnZXMgfHwge31cbiAgICBlZGdlcyA9IFtdXG4gIH0gZWxzZSB7XG4gICAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge31cbiAgICBlZGdlcyA9IGVkZ2VzIHx8IFtdXG4gIH1cblxuICAvL1BhcnNlIG91dCBvcHRpb25zXG4gIHZhciBkZWxhdW5heSA9ICEhZ2V0RGVmYXVsdChvcHRpb25zLCAnZGVsYXVuYXknLCB0cnVlKVxuICB2YXIgaW50ZXJpb3IgPSAhIWdldERlZmF1bHQob3B0aW9ucywgJ2ludGVyaW9yJywgdHJ1ZSlcbiAgdmFyIGV4dGVyaW9yID0gISFnZXREZWZhdWx0KG9wdGlvbnMsICdleHRlcmlvcicsIHRydWUpXG4gIHZhciBpbmZpbml0eSA9ICEhZ2V0RGVmYXVsdChvcHRpb25zLCAnaW5maW5pdHknLCBmYWxzZSlcblxuICAvL0hhbmRsZSB0cml2aWFsIGNhc2VcbiAgaWYoKCFpbnRlcmlvciAmJiAhZXh0ZXJpb3IpIHx8IHBvaW50cy5sZW5ndGggPT09IDApIHtcbiAgICByZXR1cm4gW11cbiAgfVxuXG4gIC8vQ29uc3RydWN0IGluaXRpYWwgdHJpYW5ndWxhdGlvblxuICB2YXIgY2VsbHMgPSBtb25vdG9uZVRyaWFuZ3VsYXRlKHBvaW50cywgZWRnZXMpXG5cbiAgLy9JZiBkZWxhdW5heSByZWZpbmVtZW50IG5lZWRlZCwgdGhlbiBpbXByb3ZlIHF1YWxpdHkgYnkgZWRnZSBmbGlwcGluZ1xuICBpZihkZWxhdW5heSB8fCBpbnRlcmlvciAhPT0gZXh0ZXJpb3IgfHwgaW5maW5pdHkpIHtcblxuICAgIC8vSW5kZXggYWxsIG9mIHRoZSBjZWxscyB0byBzdXBwb3J0IGZhc3QgbmVpZ2hib3Job29kIHF1ZXJpZXNcbiAgICB2YXIgdHJpYW5ndWxhdGlvbiA9IG1ha2VJbmRleChwb2ludHMubGVuZ3RoLCBjYW5vbmljYWxpemVFZGdlcyhlZGdlcykpXG4gICAgZm9yKHZhciBpPTA7IGk8Y2VsbHMubGVuZ3RoOyArK2kpIHtcbiAgICAgIHZhciBmID0gY2VsbHNbaV1cbiAgICAgIHRyaWFuZ3VsYXRpb24uYWRkVHJpYW5nbGUoZlswXSwgZlsxXSwgZlsyXSlcbiAgICB9XG5cbiAgICAvL1J1biBlZGdlIGZsaXBwaW5nXG4gICAgaWYoZGVsYXVuYXkpIHtcbiAgICAgIGRlbGF1bmF5RmxpcChwb2ludHMsIHRyaWFuZ3VsYXRpb24pXG4gICAgfVxuXG4gICAgLy9GaWx0ZXIgcG9pbnRzXG4gICAgaWYoIWV4dGVyaW9yKSB7XG4gICAgICByZXR1cm4gZmlsdGVyVHJpYW5ndWxhdGlvbih0cmlhbmd1bGF0aW9uLCAtMSlcbiAgICB9IGVsc2UgaWYoIWludGVyaW9yKSB7XG4gICAgICByZXR1cm4gZmlsdGVyVHJpYW5ndWxhdGlvbih0cmlhbmd1bGF0aW9uLCAgMSwgaW5maW5pdHkpXG4gICAgfSBlbHNlIGlmKGluZmluaXR5KSB7XG4gICAgICByZXR1cm4gZmlsdGVyVHJpYW5ndWxhdGlvbih0cmlhbmd1bGF0aW9uLCAwLCBpbmZpbml0eSlcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIHRyaWFuZ3VsYXRpb24uY2VsbHMoKVxuICAgIH1cbiAgICBcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gY2VsbHNcbiAgfVxufVxuIiwiJ3VzZSBzdHJpY3QnXG5cbnZhciBpbkNpcmNsZSA9IHJlcXVpcmUoJ3JvYnVzdC1pbi1zcGhlcmUnKVs0XVxudmFyIGJzZWFyY2ggPSByZXF1aXJlKCdiaW5hcnktc2VhcmNoLWJvdW5kcycpXG5cbm1vZHVsZS5leHBvcnRzID0gZGVsYXVuYXlSZWZpbmVcblxuZnVuY3Rpb24gdGVzdEZsaXAocG9pbnRzLCB0cmlhbmd1bGF0aW9uLCBzdGFjaywgYSwgYiwgeCkge1xuICB2YXIgeSA9IHRyaWFuZ3VsYXRpb24ub3Bwb3NpdGUoYSwgYilcblxuICAvL1Rlc3QgYm91bmRhcnkgZWRnZVxuICBpZih5IDwgMCkge1xuICAgIHJldHVyblxuICB9XG5cbiAgLy9Td2FwIGVkZ2UgaWYgb3JkZXIgZmxpcHBlZFxuICBpZihiIDwgYSkge1xuICAgIHZhciB0bXAgPSBhXG4gICAgYSA9IGJcbiAgICBiID0gdG1wXG4gICAgdG1wID0geFxuICAgIHggPSB5XG4gICAgeSA9IHRtcFxuICB9XG5cbiAgLy9UZXN0IGlmIGVkZ2UgaXMgY29uc3RyYWluZWRcbiAgaWYodHJpYW5ndWxhdGlvbi5pc0NvbnN0cmFpbnQoYSwgYikpIHtcbiAgICByZXR1cm5cbiAgfVxuXG4gIC8vVGVzdCBpZiBlZGdlIGlzIGRlbGF1bmF5XG4gIGlmKGluQ2lyY2xlKHBvaW50c1thXSwgcG9pbnRzW2JdLCBwb2ludHNbeF0sIHBvaW50c1t5XSkgPCAwKSB7XG4gICAgc3RhY2sucHVzaChhLCBiKVxuICB9XG59XG5cbi8vQXNzdW1lIGVkZ2VzIGFyZSBzb3J0ZWQgbGV4aWNvZ3JhcGhpY2FsbHlcbmZ1bmN0aW9uIGRlbGF1bmF5UmVmaW5lKHBvaW50cywgdHJpYW5ndWxhdGlvbikge1xuICB2YXIgc3RhY2sgPSBbXVxuXG4gIHZhciBudW1Qb2ludHMgPSBwb2ludHMubGVuZ3RoXG4gIHZhciBzdGFycyA9IHRyaWFuZ3VsYXRpb24uc3RhcnNcbiAgZm9yKHZhciBhPTA7IGE8bnVtUG9pbnRzOyArK2EpIHtcbiAgICB2YXIgc3RhciA9IHN0YXJzW2FdXG4gICAgZm9yKHZhciBqPTE7IGo8c3Rhci5sZW5ndGg7IGorPTIpIHtcbiAgICAgIHZhciBiID0gc3RhcltqXVxuXG4gICAgICAvL0lmIG9yZGVyIGlzIG5vdCBjb25zaXN0ZW50LCB0aGVuIHNraXAgZWRnZVxuICAgICAgaWYoYiA8IGEpIHtcbiAgICAgICAgY29udGludWVcbiAgICAgIH1cblxuICAgICAgLy9DaGVjayBpZiBlZGdlIGlzIGNvbnN0cmFpbmVkXG4gICAgICBpZih0cmlhbmd1bGF0aW9uLmlzQ29uc3RyYWludChhLCBiKSkge1xuICAgICAgICBjb250aW51ZVxuICAgICAgfVxuXG4gICAgICAvL0ZpbmQgb3Bwb3NpdGUgZWRnZVxuICAgICAgdmFyIHggPSBzdGFyW2otMV0sIHkgPSAtMVxuICAgICAgZm9yKHZhciBrPTE7IGs8c3Rhci5sZW5ndGg7IGsrPTIpIHtcbiAgICAgICAgaWYoc3RhcltrLTFdID09PSBiKSB7XG4gICAgICAgICAgeSA9IHN0YXJba11cbiAgICAgICAgICBicmVha1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIC8vSWYgdGhpcyBpcyBhIGJvdW5kYXJ5IGVkZ2UsIGRvbid0IGZsaXAgaXRcbiAgICAgIGlmKHkgPCAwKSB7XG4gICAgICAgIGNvbnRpbnVlXG4gICAgICB9XG5cbiAgICAgIC8vSWYgZWRnZSBpcyBpbiBjaXJjbGUsIGZsaXAgaXRcbiAgICAgIGlmKGluQ2lyY2xlKHBvaW50c1thXSwgcG9pbnRzW2JdLCBwb2ludHNbeF0sIHBvaW50c1t5XSkgPCAwKSB7XG4gICAgICAgIHN0YWNrLnB1c2goYSwgYilcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICB3aGlsZShzdGFjay5sZW5ndGggPiAwKSB7XG4gICAgdmFyIGIgPSBzdGFjay5wb3AoKVxuICAgIHZhciBhID0gc3RhY2sucG9wKClcblxuICAgIC8vRmluZCBvcHBvc2l0ZSBwYWlyc1xuICAgIHZhciB4ID0gLTEsIHkgPSAtMVxuICAgIHZhciBzdGFyID0gc3RhcnNbYV1cbiAgICBmb3IodmFyIGk9MTsgaTxzdGFyLmxlbmd0aDsgaSs9Mikge1xuICAgICAgdmFyIHMgPSBzdGFyW2ktMV1cbiAgICAgIHZhciB0ID0gc3RhcltpXVxuICAgICAgaWYocyA9PT0gYikge1xuICAgICAgICB5ID0gdFxuICAgICAgfSBlbHNlIGlmKHQgPT09IGIpIHtcbiAgICAgICAgeCA9IHNcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvL0lmIHgveSBhcmUgYm90aCB2YWxpZCB0aGVuIHNraXAgZWRnZVxuICAgIGlmKHggPCAwIHx8IHkgPCAwKSB7XG4gICAgICBjb250aW51ZVxuICAgIH1cblxuICAgIC8vSWYgZWRnZSBpcyBub3cgZGVsYXVuYXksIHRoZW4gZG9uJ3QgZmxpcCBpdFxuICAgIGlmKGluQ2lyY2xlKHBvaW50c1thXSwgcG9pbnRzW2JdLCBwb2ludHNbeF0sIHBvaW50c1t5XSkgPj0gMCkge1xuICAgICAgY29udGludWVcbiAgICB9XG5cbiAgICAvL0ZsaXAgdGhlIGVkZ2VcbiAgICB0cmlhbmd1bGF0aW9uLmZsaXAoYSwgYilcblxuICAgIC8vVGVzdCBmbGlwcGluZyBuZWlnaGJvcmluZyBlZGdlc1xuICAgIHRlc3RGbGlwKHBvaW50cywgdHJpYW5ndWxhdGlvbiwgc3RhY2ssIHgsIGEsIHkpXG4gICAgdGVzdEZsaXAocG9pbnRzLCB0cmlhbmd1bGF0aW9uLCBzdGFjaywgYSwgeSwgeClcbiAgICB0ZXN0RmxpcChwb2ludHMsIHRyaWFuZ3VsYXRpb24sIHN0YWNrLCB5LCBiLCB4KVxuICAgIHRlc3RGbGlwKHBvaW50cywgdHJpYW5ndWxhdGlvbiwgc3RhY2ssIGIsIHgsIHkpXG4gIH1cbn1cbiIsIid1c2Ugc3RyaWN0J1xuXG52YXIgYnNlYXJjaCA9IHJlcXVpcmUoJ2JpbmFyeS1zZWFyY2gtYm91bmRzJylcblxubW9kdWxlLmV4cG9ydHMgPSBjbGFzc2lmeUZhY2VzXG5cbmZ1bmN0aW9uIEZhY2VJbmRleChjZWxscywgbmVpZ2hib3IsIGNvbnN0cmFpbnQsIGZsYWdzLCBhY3RpdmUsIG5leHQsIGJvdW5kYXJ5KSB7XG4gIHRoaXMuY2VsbHMgICAgICAgPSBjZWxsc1xuICB0aGlzLm5laWdoYm9yICAgID0gbmVpZ2hib3JcbiAgdGhpcy5mbGFncyAgICAgICA9IGZsYWdzXG4gIHRoaXMuY29uc3RyYWludCAgPSBjb25zdHJhaW50XG4gIHRoaXMuYWN0aXZlICAgICAgPSBhY3RpdmVcbiAgdGhpcy5uZXh0ICAgICAgICA9IG5leHRcbiAgdGhpcy5ib3VuZGFyeSAgICA9IGJvdW5kYXJ5XG59XG5cbnZhciBwcm90byA9IEZhY2VJbmRleC5wcm90b3R5cGVcblxuZnVuY3Rpb24gY29tcGFyZUNlbGwoYSwgYikge1xuICByZXR1cm4gYVswXSAtIGJbMF0gfHxcbiAgICAgICAgIGFbMV0gLSBiWzFdIHx8XG4gICAgICAgICBhWzJdIC0gYlsyXVxufVxuXG5wcm90by5sb2NhdGUgPSAoZnVuY3Rpb24oKSB7XG4gIHZhciBrZXkgPSBbMCwwLDBdXG4gIHJldHVybiBmdW5jdGlvbihhLCBiLCBjKSB7XG4gICAgdmFyIHggPSBhLCB5ID0gYiwgeiA9IGNcbiAgICBpZihiIDwgYykge1xuICAgICAgaWYoYiA8IGEpIHtcbiAgICAgICAgeCA9IGJcbiAgICAgICAgeSA9IGNcbiAgICAgICAgeiA9IGFcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYoYyA8IGEpIHtcbiAgICAgIHggPSBjXG4gICAgICB5ID0gYVxuICAgICAgeiA9IGJcbiAgICB9XG4gICAgaWYoeCA8IDApIHtcbiAgICAgIHJldHVybiAtMVxuICAgIH1cbiAgICBrZXlbMF0gPSB4XG4gICAga2V5WzFdID0geVxuICAgIGtleVsyXSA9IHpcbiAgICByZXR1cm4gYnNlYXJjaC5lcSh0aGlzLmNlbGxzLCBrZXksIGNvbXBhcmVDZWxsKVxuICB9XG59KSgpXG5cbmZ1bmN0aW9uIGluZGV4Q2VsbHModHJpYW5ndWxhdGlvbiwgaW5maW5pdHkpIHtcbiAgLy9GaXJzdCBnZXQgY2VsbHMgYW5kIGNhbm9uaWNhbGl6ZVxuICB2YXIgY2VsbHMgPSB0cmlhbmd1bGF0aW9uLmNlbGxzKClcbiAgdmFyIG5jID0gY2VsbHMubGVuZ3RoXG4gIGZvcih2YXIgaT0wOyBpPG5jOyArK2kpIHtcbiAgICB2YXIgYyA9IGNlbGxzW2ldXG4gICAgdmFyIHggPSBjWzBdLCB5ID0gY1sxXSwgeiA9IGNbMl1cbiAgICBpZih5IDwgeikge1xuICAgICAgaWYoeSA8IHgpIHtcbiAgICAgICAgY1swXSA9IHlcbiAgICAgICAgY1sxXSA9IHpcbiAgICAgICAgY1syXSA9IHhcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYoeiA8IHgpIHtcbiAgICAgIGNbMF0gPSB6XG4gICAgICBjWzFdID0geFxuICAgICAgY1syXSA9IHlcbiAgICB9XG4gIH1cbiAgY2VsbHMuc29ydChjb21wYXJlQ2VsbClcblxuICAvL0luaXRpYWxpemUgZmxhZyBhcnJheVxuICB2YXIgZmxhZ3MgPSBuZXcgQXJyYXkobmMpXG4gIGZvcih2YXIgaT0wOyBpPGZsYWdzLmxlbmd0aDsgKytpKSB7XG4gICAgZmxhZ3NbaV0gPSAwXG4gIH1cblxuICAvL0J1aWxkIG5laWdoYm9yIGluZGV4LCBpbml0aWFsaXplIHF1ZXVlc1xuICB2YXIgYWN0aXZlID0gW11cbiAgdmFyIG5leHQgICA9IFtdXG4gIHZhciBuZWlnaGJvciA9IG5ldyBBcnJheSgzKm5jKVxuICB2YXIgY29uc3RyYWludCA9IG5ldyBBcnJheSgzKm5jKVxuICB2YXIgYm91bmRhcnkgPSBudWxsXG4gIGlmKGluZmluaXR5KSB7XG4gICAgYm91bmRhcnkgPSBbXVxuICB9XG4gIHZhciBpbmRleCA9IG5ldyBGYWNlSW5kZXgoXG4gICAgY2VsbHMsXG4gICAgbmVpZ2hib3IsXG4gICAgY29uc3RyYWludCxcbiAgICBmbGFncyxcbiAgICBhY3RpdmUsXG4gICAgbmV4dCxcbiAgICBib3VuZGFyeSlcbiAgZm9yKHZhciBpPTA7IGk8bmM7ICsraSkge1xuICAgIHZhciBjID0gY2VsbHNbaV1cbiAgICBmb3IodmFyIGo9MDsgajwzOyArK2opIHtcbiAgICAgIHZhciB4ID0gY1tqXSwgeSA9IGNbKGorMSklM11cbiAgICAgIHZhciBhID0gbmVpZ2hib3JbMyppK2pdID0gaW5kZXgubG9jYXRlKHksIHgsIHRyaWFuZ3VsYXRpb24ub3Bwb3NpdGUoeSwgeCkpXG4gICAgICB2YXIgYiA9IGNvbnN0cmFpbnRbMyppK2pdID0gdHJpYW5ndWxhdGlvbi5pc0NvbnN0cmFpbnQoeCwgeSlcbiAgICAgIGlmKGEgPCAwKSB7XG4gICAgICAgIGlmKGIpIHtcbiAgICAgICAgICBuZXh0LnB1c2goaSlcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBhY3RpdmUucHVzaChpKVxuICAgICAgICAgIGZsYWdzW2ldID0gMVxuICAgICAgICB9XG4gICAgICAgIGlmKGluZmluaXR5KSB7XG4gICAgICAgICAgYm91bmRhcnkucHVzaChbeSwgeCwgLTFdKVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG4gIHJldHVybiBpbmRleFxufVxuXG5mdW5jdGlvbiBmaWx0ZXJDZWxscyhjZWxscywgZmxhZ3MsIHRhcmdldCkge1xuICB2YXIgcHRyID0gMFxuICBmb3IodmFyIGk9MDsgaTxjZWxscy5sZW5ndGg7ICsraSkge1xuICAgIGlmKGZsYWdzW2ldID09PSB0YXJnZXQpIHtcbiAgICAgIGNlbGxzW3B0cisrXSA9IGNlbGxzW2ldXG4gICAgfVxuICB9XG4gIGNlbGxzLmxlbmd0aCA9IHB0clxuICByZXR1cm4gY2VsbHNcbn1cblxuZnVuY3Rpb24gY2xhc3NpZnlGYWNlcyh0cmlhbmd1bGF0aW9uLCB0YXJnZXQsIGluZmluaXR5KSB7XG4gIHZhciBpbmRleCA9IGluZGV4Q2VsbHModHJpYW5ndWxhdGlvbiwgaW5maW5pdHkpXG5cbiAgaWYodGFyZ2V0ID09PSAwKSB7XG4gICAgaWYoaW5maW5pdHkpIHtcbiAgICAgIHJldHVybiBpbmRleC5jZWxscy5jb25jYXQoaW5kZXguYm91bmRhcnkpXG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBpbmRleC5jZWxsc1xuICAgIH1cbiAgfVxuXG4gIHZhciBzaWRlID0gMVxuICB2YXIgYWN0aXZlID0gaW5kZXguYWN0aXZlXG4gIHZhciBuZXh0ID0gaW5kZXgubmV4dFxuICB2YXIgZmxhZ3MgPSBpbmRleC5mbGFnc1xuICB2YXIgY2VsbHMgPSBpbmRleC5jZWxsc1xuICB2YXIgY29uc3RyYWludCA9IGluZGV4LmNvbnN0cmFpbnRcbiAgdmFyIG5laWdoYm9yID0gaW5kZXgubmVpZ2hib3JcblxuICB3aGlsZShhY3RpdmUubGVuZ3RoID4gMCB8fCBuZXh0Lmxlbmd0aCA+IDApIHtcbiAgICB3aGlsZShhY3RpdmUubGVuZ3RoID4gMCkge1xuICAgICAgdmFyIHQgPSBhY3RpdmUucG9wKClcbiAgICAgIGlmKGZsYWdzW3RdID09PSAtc2lkZSkge1xuICAgICAgICBjb250aW51ZVxuICAgICAgfVxuICAgICAgZmxhZ3NbdF0gPSBzaWRlXG4gICAgICB2YXIgYyA9IGNlbGxzW3RdXG4gICAgICBmb3IodmFyIGo9MDsgajwzOyArK2opIHtcbiAgICAgICAgdmFyIGYgPSBuZWlnaGJvclszKnQral1cbiAgICAgICAgaWYoZiA+PSAwICYmIGZsYWdzW2ZdID09PSAwKSB7XG4gICAgICAgICAgaWYoY29uc3RyYWludFszKnQral0pIHtcbiAgICAgICAgICAgIG5leHQucHVzaChmKVxuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBhY3RpdmUucHVzaChmKVxuICAgICAgICAgICAgZmxhZ3NbZl0gPSBzaWRlXG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy9Td2FwIGFycmF5cyBhbmQgbG9vcFxuICAgIHZhciB0bXAgPSBuZXh0XG4gICAgbmV4dCA9IGFjdGl2ZVxuICAgIGFjdGl2ZSA9IHRtcFxuICAgIG5leHQubGVuZ3RoID0gMFxuICAgIHNpZGUgPSAtc2lkZVxuICB9XG5cbiAgdmFyIHJlc3VsdCA9IGZpbHRlckNlbGxzKGNlbGxzLCBmbGFncywgdGFyZ2V0KVxuICBpZihpbmZpbml0eSkge1xuICAgIHJldHVybiByZXN1bHQuY29uY2F0KGluZGV4LmJvdW5kYXJ5KVxuICB9XG4gIHJldHVybiByZXN1bHRcbn1cbiIsIid1c2Ugc3RyaWN0J1xuXG52YXIgYnNlYXJjaCA9IHJlcXVpcmUoJ2JpbmFyeS1zZWFyY2gtYm91bmRzJylcbnZhciBvcmllbnQgPSByZXF1aXJlKCdyb2J1c3Qtb3JpZW50YXRpb24nKVszXVxuXG52YXIgRVZFTlRfUE9JTlQgPSAwXG52YXIgRVZFTlRfRU5EICAgPSAxXG52YXIgRVZFTlRfU1RBUlQgPSAyXG5cbm1vZHVsZS5leHBvcnRzID0gbW9ub3RvbmVUcmlhbmd1bGF0ZVxuXG4vL0EgcGFydGlhbCBjb252ZXggaHVsbCBmcmFnbWVudCwgbWFkZSBvZiB0d28gdW5pbW9ub3RvbmUgcG9seWdvbnNcbmZ1bmN0aW9uIFBhcnRpYWxIdWxsKGEsIGIsIGlkeCwgbG93ZXJJZHMsIHVwcGVySWRzKSB7XG4gIHRoaXMuYSA9IGFcbiAgdGhpcy5iID0gYlxuICB0aGlzLmlkeCA9IGlkeFxuICB0aGlzLmxvd2VySWRzID0gbG93ZXJJZHNcbiAgdGhpcy51cHBlcklkcyA9IHVwcGVySWRzXG59XG5cbi8vQW4gZXZlbnQgaW4gdGhlIHN3ZWVwIGxpbmUgcHJvY2VkdXJlXG5mdW5jdGlvbiBFdmVudChhLCBiLCB0eXBlLCBpZHgpIHtcbiAgdGhpcy5hICAgID0gYVxuICB0aGlzLmIgICAgPSBiXG4gIHRoaXMudHlwZSA9IHR5cGVcbiAgdGhpcy5pZHggID0gaWR4XG59XG5cbi8vVGhpcyBpcyB1c2VkIHRvIGNvbXBhcmUgZXZlbnRzIGZvciB0aGUgc3dlZXAgbGluZSBwcm9jZWR1cmVcbi8vIFBvaW50cyBhcmU6XG4vLyAgMS4gc29ydGVkIGxleGljb2dyYXBoaWNhbGx5XG4vLyAgMi4gc29ydGVkIGJ5IHR5cGUgIChwb2ludCA8IGVuZCA8IHN0YXJ0KVxuLy8gIDMuIHNlZ21lbnRzIHNvcnRlZCBieSB3aW5kaW5nIG9yZGVyXG4vLyAgNC4gc29ydGVkIGJ5IGluZGV4XG5mdW5jdGlvbiBjb21wYXJlRXZlbnQoYSwgYikge1xuICB2YXIgZCA9XG4gICAgKGEuYVswXSAtIGIuYVswXSkgfHxcbiAgICAoYS5hWzFdIC0gYi5hWzFdKSB8fFxuICAgIChhLnR5cGUgLSBiLnR5cGUpXG4gIGlmKGQpIHsgcmV0dXJuIGQgfVxuICBpZihhLnR5cGUgIT09IEVWRU5UX1BPSU5UKSB7XG4gICAgZCA9IG9yaWVudChhLmEsIGEuYiwgYi5iKVxuICAgIGlmKGQpIHsgcmV0dXJuIGQgfVxuICB9XG4gIHJldHVybiBhLmlkeCAtIGIuaWR4XG59XG5cbmZ1bmN0aW9uIHRlc3RQb2ludChodWxsLCBwKSB7XG4gIHJldHVybiBvcmllbnQoaHVsbC5hLCBodWxsLmIsIHApXG59XG5cbmZ1bmN0aW9uIGFkZFBvaW50KGNlbGxzLCBodWxscywgcG9pbnRzLCBwLCBpZHgpIHtcbiAgdmFyIGxvID0gYnNlYXJjaC5sdChodWxscywgcCwgdGVzdFBvaW50KVxuICB2YXIgaGkgPSBic2VhcmNoLmd0KGh1bGxzLCBwLCB0ZXN0UG9pbnQpXG4gIGZvcih2YXIgaT1sbzsgaTxoaTsgKytpKSB7XG4gICAgdmFyIGh1bGwgPSBodWxsc1tpXVxuXG4gICAgLy9JbnNlcnQgcCBpbnRvIGxvd2VyIGh1bGxcbiAgICB2YXIgbG93ZXJJZHMgPSBodWxsLmxvd2VySWRzXG4gICAgdmFyIG0gPSBsb3dlcklkcy5sZW5ndGhcbiAgICB3aGlsZShtID4gMSAmJiBvcmllbnQoXG4gICAgICAgIHBvaW50c1tsb3dlcklkc1ttLTJdXSxcbiAgICAgICAgcG9pbnRzW2xvd2VySWRzW20tMV1dLFxuICAgICAgICBwKSA+IDApIHtcbiAgICAgIGNlbGxzLnB1c2goXG4gICAgICAgIFtsb3dlcklkc1ttLTFdLFxuICAgICAgICAgbG93ZXJJZHNbbS0yXSxcbiAgICAgICAgIGlkeF0pXG4gICAgICBtIC09IDFcbiAgICB9XG4gICAgbG93ZXJJZHMubGVuZ3RoID0gbVxuICAgIGxvd2VySWRzLnB1c2goaWR4KVxuXG4gICAgLy9JbnNlcnQgcCBpbnRvIHVwcGVyIGh1bGxcbiAgICB2YXIgdXBwZXJJZHMgPSBodWxsLnVwcGVySWRzXG4gICAgdmFyIG0gPSB1cHBlcklkcy5sZW5ndGhcbiAgICB3aGlsZShtID4gMSAmJiBvcmllbnQoXG4gICAgICAgIHBvaW50c1t1cHBlcklkc1ttLTJdXSxcbiAgICAgICAgcG9pbnRzW3VwcGVySWRzW20tMV1dLFxuICAgICAgICBwKSA8IDApIHtcbiAgICAgIGNlbGxzLnB1c2goXG4gICAgICAgIFt1cHBlcklkc1ttLTJdLFxuICAgICAgICAgdXBwZXJJZHNbbS0xXSxcbiAgICAgICAgIGlkeF0pXG4gICAgICBtIC09IDFcbiAgICB9XG4gICAgdXBwZXJJZHMubGVuZ3RoID0gbVxuICAgIHVwcGVySWRzLnB1c2goaWR4KVxuICB9XG59XG5cbmZ1bmN0aW9uIGZpbmRTcGxpdChodWxsLCBlZGdlKSB7XG4gIHZhciBkXG4gIGlmKGh1bGwuYVswXSA8IGVkZ2UuYVswXSkge1xuICAgIGQgPSBvcmllbnQoaHVsbC5hLCBodWxsLmIsIGVkZ2UuYSlcbiAgfSBlbHNlIHtcbiAgICBkID0gb3JpZW50KGVkZ2UuYiwgZWRnZS5hLCBodWxsLmEpXG4gIH1cbiAgaWYoZCkgeyByZXR1cm4gZCB9XG4gIGlmKGVkZ2UuYlswXSA8IGh1bGwuYlswXSkge1xuICAgIGQgPSBvcmllbnQoaHVsbC5hLCBodWxsLmIsIGVkZ2UuYilcbiAgfSBlbHNlIHtcbiAgICBkID0gb3JpZW50KGVkZ2UuYiwgZWRnZS5hLCBodWxsLmIpXG4gIH1cbiAgcmV0dXJuIGQgfHwgaHVsbC5pZHggLSBlZGdlLmlkeFxufVxuXG5mdW5jdGlvbiBzcGxpdEh1bGxzKGh1bGxzLCBwb2ludHMsIGV2ZW50KSB7XG4gIHZhciBzcGxpdElkeCA9IGJzZWFyY2gubGUoaHVsbHMsIGV2ZW50LCBmaW5kU3BsaXQpXG4gIHZhciBodWxsID0gaHVsbHNbc3BsaXRJZHhdXG4gIHZhciB1cHBlcklkcyA9IGh1bGwudXBwZXJJZHNcbiAgdmFyIHggPSB1cHBlcklkc1t1cHBlcklkcy5sZW5ndGgtMV1cbiAgaHVsbC51cHBlcklkcyA9IFt4XVxuICBodWxscy5zcGxpY2Uoc3BsaXRJZHgrMSwgMCxcbiAgICBuZXcgUGFydGlhbEh1bGwoZXZlbnQuYSwgZXZlbnQuYiwgZXZlbnQuaWR4LCBbeF0sIHVwcGVySWRzKSlcbn1cblxuXG5mdW5jdGlvbiBtZXJnZUh1bGxzKGh1bGxzLCBwb2ludHMsIGV2ZW50KSB7XG4gIC8vU3dhcCBwb2ludGVycyBmb3IgbWVyZ2Ugc2VhcmNoXG4gIHZhciB0bXAgPSBldmVudC5hXG4gIGV2ZW50LmEgPSBldmVudC5iXG4gIGV2ZW50LmIgPSB0bXBcbiAgdmFyIG1lcmdlSWR4ID0gYnNlYXJjaC5lcShodWxscywgZXZlbnQsIGZpbmRTcGxpdClcbiAgdmFyIHVwcGVyID0gaHVsbHNbbWVyZ2VJZHhdXG4gIHZhciBsb3dlciA9IGh1bGxzW21lcmdlSWR4LTFdXG4gIGxvd2VyLnVwcGVySWRzID0gdXBwZXIudXBwZXJJZHNcbiAgaHVsbHMuc3BsaWNlKG1lcmdlSWR4LCAxKVxufVxuXG5cbmZ1bmN0aW9uIG1vbm90b25lVHJpYW5ndWxhdGUocG9pbnRzLCBlZGdlcykge1xuXG4gIHZhciBudW1Qb2ludHMgPSBwb2ludHMubGVuZ3RoXG4gIHZhciBudW1FZGdlcyA9IGVkZ2VzLmxlbmd0aFxuXG4gIHZhciBldmVudHMgPSBbXVxuXG4gIC8vQ3JlYXRlIHBvaW50IGV2ZW50c1xuICBmb3IodmFyIGk9MDsgaTxudW1Qb2ludHM7ICsraSkge1xuICAgIGV2ZW50cy5wdXNoKG5ldyBFdmVudChcbiAgICAgIHBvaW50c1tpXSxcbiAgICAgIG51bGwsXG4gICAgICBFVkVOVF9QT0lOVCxcbiAgICAgIGkpKVxuICB9XG5cbiAgLy9DcmVhdGUgZWRnZSBldmVudHNcbiAgZm9yKHZhciBpPTA7IGk8bnVtRWRnZXM7ICsraSkge1xuICAgIHZhciBlID0gZWRnZXNbaV1cbiAgICB2YXIgYSA9IHBvaW50c1tlWzBdXVxuICAgIHZhciBiID0gcG9pbnRzW2VbMV1dXG4gICAgaWYoYVswXSA8IGJbMF0pIHtcbiAgICAgIGV2ZW50cy5wdXNoKFxuICAgICAgICBuZXcgRXZlbnQoYSwgYiwgRVZFTlRfU1RBUlQsIGkpLFxuICAgICAgICBuZXcgRXZlbnQoYiwgYSwgRVZFTlRfRU5ELCBpKSlcbiAgICB9IGVsc2UgaWYoYVswXSA+IGJbMF0pIHtcbiAgICAgIGV2ZW50cy5wdXNoKFxuICAgICAgICBuZXcgRXZlbnQoYiwgYSwgRVZFTlRfU1RBUlQsIGkpLFxuICAgICAgICBuZXcgRXZlbnQoYSwgYiwgRVZFTlRfRU5ELCBpKSlcbiAgICB9XG4gIH1cblxuICAvL1NvcnQgZXZlbnRzXG4gIGV2ZW50cy5zb3J0KGNvbXBhcmVFdmVudClcblxuICAvL0luaXRpYWxpemUgaHVsbFxuICB2YXIgbWluWCA9IGV2ZW50c1swXS5hWzBdIC0gKDEgKyBNYXRoLmFicyhldmVudHNbMF0uYVswXSkpICogTWF0aC5wb3coMiwgLTUyKVxuICB2YXIgaHVsbCA9IFsgbmV3IFBhcnRpYWxIdWxsKFttaW5YLCAxXSwgW21pblgsIDBdLCAtMSwgW10sIFtdLCBbXSwgW10pIF1cblxuICAvL1Byb2Nlc3MgZXZlbnRzIGluIG9yZGVyXG4gIHZhciBjZWxscyA9IFtdXG4gIGZvcih2YXIgaT0wLCBudW1FdmVudHM9ZXZlbnRzLmxlbmd0aDsgaTxudW1FdmVudHM7ICsraSkge1xuICAgIHZhciBldmVudCA9IGV2ZW50c1tpXVxuICAgIHZhciB0eXBlID0gZXZlbnQudHlwZVxuICAgIGlmKHR5cGUgPT09IEVWRU5UX1BPSU5UKSB7XG4gICAgICBhZGRQb2ludChjZWxscywgaHVsbCwgcG9pbnRzLCBldmVudC5hLCBldmVudC5pZHgpXG4gICAgfSBlbHNlIGlmKHR5cGUgPT09IEVWRU5UX1NUQVJUKSB7XG4gICAgICBzcGxpdEh1bGxzKGh1bGwsIHBvaW50cywgZXZlbnQpXG4gICAgfSBlbHNlIHtcbiAgICAgIG1lcmdlSHVsbHMoaHVsbCwgcG9pbnRzLCBldmVudClcbiAgICB9XG4gIH1cblxuICAvL1JldHVybiB0cmlhbmd1bGF0aW9uXG4gIHJldHVybiBjZWxsc1xufVxuIiwiJ3VzZSBzdHJpY3QnXG5cbnZhciBic2VhcmNoID0gcmVxdWlyZSgnYmluYXJ5LXNlYXJjaC1ib3VuZHMnKVxuXG5tb2R1bGUuZXhwb3J0cyA9IGNyZWF0ZVRyaWFuZ3VsYXRpb25cblxuZnVuY3Rpb24gVHJpYW5ndWxhdGlvbihzdGFycywgZWRnZXMpIHtcbiAgdGhpcy5zdGFycyA9IHN0YXJzXG4gIHRoaXMuZWRnZXMgPSBlZGdlc1xufVxuXG52YXIgcHJvdG8gPSBUcmlhbmd1bGF0aW9uLnByb3RvdHlwZVxuXG5mdW5jdGlvbiByZW1vdmVQYWlyKGxpc3QsIGosIGspIHtcbiAgZm9yKHZhciBpPTEsIG49bGlzdC5sZW5ndGg7IGk8bjsgaSs9Mikge1xuICAgIGlmKGxpc3RbaS0xXSA9PT0gaiAmJiBsaXN0W2ldID09PSBrKSB7XG4gICAgICBsaXN0W2ktMV0gPSBsaXN0W24tMl1cbiAgICAgIGxpc3RbaV0gPSBsaXN0W24tMV1cbiAgICAgIGxpc3QubGVuZ3RoID0gbiAtIDJcbiAgICAgIHJldHVyblxuICAgIH1cbiAgfVxufVxuXG5wcm90by5pc0NvbnN0cmFpbnQgPSAoZnVuY3Rpb24oKSB7XG4gIHZhciBlID0gWzAsMF1cbiAgZnVuY3Rpb24gY29tcGFyZUxleChhLCBiKSB7XG4gICAgcmV0dXJuIGFbMF0gLSBiWzBdIHx8IGFbMV0gLSBiWzFdXG4gIH1cbiAgcmV0dXJuIGZ1bmN0aW9uKGksIGopIHtcbiAgICBlWzBdID0gTWF0aC5taW4oaSxqKVxuICAgIGVbMV0gPSBNYXRoLm1heChpLGopXG4gICAgcmV0dXJuIGJzZWFyY2guZXEodGhpcy5lZGdlcywgZSwgY29tcGFyZUxleCkgPj0gMFxuICB9XG59KSgpXG5cbnByb3RvLnJlbW92ZVRyaWFuZ2xlID0gZnVuY3Rpb24oaSwgaiwgaykge1xuICB2YXIgc3RhcnMgPSB0aGlzLnN0YXJzXG4gIHJlbW92ZVBhaXIoc3RhcnNbaV0sIGosIGspXG4gIHJlbW92ZVBhaXIoc3RhcnNbal0sIGssIGkpXG4gIHJlbW92ZVBhaXIoc3RhcnNba10sIGksIGopXG59XG5cbnByb3RvLmFkZFRyaWFuZ2xlID0gZnVuY3Rpb24oaSwgaiwgaykge1xuICB2YXIgc3RhcnMgPSB0aGlzLnN0YXJzXG4gIHN0YXJzW2ldLnB1c2goaiwgaylcbiAgc3RhcnNbal0ucHVzaChrLCBpKVxuICBzdGFyc1trXS5wdXNoKGksIGopXG59XG5cbnByb3RvLm9wcG9zaXRlID0gZnVuY3Rpb24oaiwgaSkge1xuICB2YXIgbGlzdCA9IHRoaXMuc3RhcnNbaV1cbiAgZm9yKHZhciBrPTEsIG49bGlzdC5sZW5ndGg7IGs8bjsgays9Mikge1xuICAgIGlmKGxpc3Rba10gPT09IGopIHtcbiAgICAgIHJldHVybiBsaXN0W2stMV1cbiAgICB9XG4gIH1cbiAgcmV0dXJuIC0xXG59XG5cbnByb3RvLmZsaXAgPSBmdW5jdGlvbihpLCBqKSB7XG4gIHZhciBhID0gdGhpcy5vcHBvc2l0ZShpLCBqKVxuICB2YXIgYiA9IHRoaXMub3Bwb3NpdGUoaiwgaSlcbiAgdGhpcy5yZW1vdmVUcmlhbmdsZShpLCBqLCBhKVxuICB0aGlzLnJlbW92ZVRyaWFuZ2xlKGosIGksIGIpXG4gIHRoaXMuYWRkVHJpYW5nbGUoaSwgYiwgYSlcbiAgdGhpcy5hZGRUcmlhbmdsZShqLCBhLCBiKVxufVxuXG5wcm90by5lZGdlcyA9IGZ1bmN0aW9uKCkge1xuICB2YXIgc3RhcnMgPSB0aGlzLnN0YXJzXG4gIHZhciByZXN1bHQgPSBbXVxuICBmb3IodmFyIGk9MCwgbj1zdGFycy5sZW5ndGg7IGk8bjsgKytpKSB7XG4gICAgdmFyIGxpc3QgPSBzdGFyc1tpXVxuICAgIGZvcih2YXIgaj0wLCBtPWxpc3QubGVuZ3RoOyBqPG07IGorPTIpIHtcbiAgICAgIHJlc3VsdC5wdXNoKFtsaXN0W2pdLCBsaXN0W2orMV1dKVxuICAgIH1cbiAgfVxuICByZXR1cm4gcmVzdWx0XG59XG5cbnByb3RvLmNlbGxzID0gZnVuY3Rpb24oKSB7XG4gIHZhciBzdGFycyA9IHRoaXMuc3RhcnNcbiAgdmFyIHJlc3VsdCA9IFtdXG4gIGZvcih2YXIgaT0wLCBuPXN0YXJzLmxlbmd0aDsgaTxuOyArK2kpIHtcbiAgICB2YXIgbGlzdCA9IHN0YXJzW2ldXG4gICAgZm9yKHZhciBqPTAsIG09bGlzdC5sZW5ndGg7IGo8bTsgais9Mikge1xuICAgICAgdmFyIHMgPSBsaXN0W2pdXG4gICAgICB2YXIgdCA9IGxpc3RbaisxXVxuICAgICAgaWYoaSA8IE1hdGgubWluKHMsIHQpKSB7XG4gICAgICAgIHJlc3VsdC5wdXNoKFtpLCBzLCB0XSlcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgcmV0dXJuIHJlc3VsdFxufVxuXG5mdW5jdGlvbiBjcmVhdGVUcmlhbmd1bGF0aW9uKG51bVZlcnRzLCBlZGdlcykge1xuICB2YXIgc3RhcnMgPSBuZXcgQXJyYXkobnVtVmVydHMpXG4gIGZvcih2YXIgaT0wOyBpPG51bVZlcnRzOyArK2kpIHtcbiAgICBzdGFyc1tpXSA9IFtdXG4gIH1cbiAgcmV0dXJuIG5ldyBUcmlhbmd1bGF0aW9uKHN0YXJzLCBlZGdlcylcbn1cbiIsIlwidXNlIHN0cmljdFwiXG5cbnZhciB0d29Qcm9kdWN0ID0gcmVxdWlyZShcInR3by1wcm9kdWN0XCIpXG52YXIgcm9idXN0U3VtID0gcmVxdWlyZShcInJvYnVzdC1zdW1cIilcbnZhciByb2J1c3REaWZmID0gcmVxdWlyZShcInJvYnVzdC1zdWJ0cmFjdFwiKVxudmFyIHJvYnVzdFNjYWxlID0gcmVxdWlyZShcInJvYnVzdC1zY2FsZVwiKVxuXG52YXIgTlVNX0VYUEFORCA9IDZcblxuZnVuY3Rpb24gY29mYWN0b3IobSwgYykge1xuICB2YXIgcmVzdWx0ID0gbmV3IEFycmF5KG0ubGVuZ3RoLTEpXG4gIGZvcih2YXIgaT0xOyBpPG0ubGVuZ3RoOyArK2kpIHtcbiAgICB2YXIgciA9IHJlc3VsdFtpLTFdID0gbmV3IEFycmF5KG0ubGVuZ3RoLTEpXG4gICAgZm9yKHZhciBqPTAsaz0wOyBqPG0ubGVuZ3RoOyArK2opIHtcbiAgICAgIGlmKGogPT09IGMpIHtcbiAgICAgICAgY29udGludWVcbiAgICAgIH1cbiAgICAgIHJbaysrXSA9IG1baV1bal1cbiAgICB9XG4gIH1cbiAgcmV0dXJuIHJlc3VsdFxufVxuXG5mdW5jdGlvbiBtYXRyaXgobikge1xuICB2YXIgcmVzdWx0ID0gbmV3IEFycmF5KG4pXG4gIGZvcih2YXIgaT0wOyBpPG47ICsraSkge1xuICAgIHJlc3VsdFtpXSA9IG5ldyBBcnJheShuKVxuICAgIGZvcih2YXIgaj0wOyBqPG47ICsraikge1xuICAgICAgcmVzdWx0W2ldW2pdID0gW1wibVwiLCBqLCBcIltcIiwgKG4taS0yKSwgXCJdXCJdLmpvaW4oXCJcIilcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHJlc3VsdFxufVxuXG5mdW5jdGlvbiBnZW5lcmF0ZVN1bShleHByKSB7XG4gIGlmKGV4cHIubGVuZ3RoID09PSAxKSB7XG4gICAgcmV0dXJuIGV4cHJbMF1cbiAgfSBlbHNlIGlmKGV4cHIubGVuZ3RoID09PSAyKSB7XG4gICAgcmV0dXJuIFtcInN1bShcIiwgZXhwclswXSwgXCIsXCIsIGV4cHJbMV0sIFwiKVwiXS5qb2luKFwiXCIpXG4gIH0gZWxzZSB7XG4gICAgdmFyIG0gPSBleHByLmxlbmd0aD4+MVxuICAgIHJldHVybiBbXCJzdW0oXCIsIGdlbmVyYXRlU3VtKGV4cHIuc2xpY2UoMCwgbSkpLCBcIixcIiwgZ2VuZXJhdGVTdW0oZXhwci5zbGljZShtKSksIFwiKVwiXS5qb2luKFwiXCIpXG4gIH1cbn1cblxuZnVuY3Rpb24gbWFrZVByb2R1Y3QoYSwgYikge1xuICBpZihhLmNoYXJBdCgwKSA9PT0gXCJtXCIpIHtcbiAgICBpZihiLmNoYXJBdCgwKSA9PT0gXCJ3XCIpIHtcbiAgICAgIHZhciB0b2tzID0gYS5zcGxpdChcIltcIilcbiAgICAgIHJldHVybiBbXCJ3XCIsIGIuc3Vic3RyKDEpLCBcIm1cIiwgdG9rc1swXS5zdWJzdHIoMSldLmpvaW4oXCJcIilcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIFtcInByb2QoXCIsIGEsIFwiLFwiLCBiLCBcIilcIl0uam9pbihcIlwiKVxuICAgIH1cbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gbWFrZVByb2R1Y3QoYiwgYSlcbiAgfVxufVxuXG5mdW5jdGlvbiBzaWduKHMpIHtcbiAgaWYocyAmIDEgIT09IDApIHtcbiAgICByZXR1cm4gXCItXCJcbiAgfVxuICByZXR1cm4gXCJcIlxufVxuXG5mdW5jdGlvbiBkZXRlcm1pbmFudChtKSB7XG4gIGlmKG0ubGVuZ3RoID09PSAyKSB7XG4gICAgcmV0dXJuIFtbXCJkaWZmKFwiLCBtYWtlUHJvZHVjdChtWzBdWzBdLCBtWzFdWzFdKSwgXCIsXCIsIG1ha2VQcm9kdWN0KG1bMV1bMF0sIG1bMF1bMV0pLCBcIilcIl0uam9pbihcIlwiKV1cbiAgfSBlbHNlIHtcbiAgICB2YXIgZXhwciA9IFtdXG4gICAgZm9yKHZhciBpPTA7IGk8bS5sZW5ndGg7ICsraSkge1xuICAgICAgZXhwci5wdXNoKFtcInNjYWxlKFwiLCBnZW5lcmF0ZVN1bShkZXRlcm1pbmFudChjb2ZhY3RvcihtLCBpKSkpLCBcIixcIiwgc2lnbihpKSwgbVswXVtpXSwgXCIpXCJdLmpvaW4oXCJcIikpXG4gICAgfVxuICAgIHJldHVybiBleHByXG4gIH1cbn1cblxuZnVuY3Rpb24gbWFrZVNxdWFyZShkLCBuKSB7XG4gIHZhciB0ZXJtcyA9IFtdXG4gIGZvcih2YXIgaT0wOyBpPG4tMjsgKytpKSB7XG4gICAgdGVybXMucHVzaChbXCJwcm9kKG1cIiwgZCwgXCJbXCIsIGksIFwiXSxtXCIsIGQsIFwiW1wiLCBpLCBcIl0pXCJdLmpvaW4oXCJcIikpXG4gIH1cbiAgcmV0dXJuIGdlbmVyYXRlU3VtKHRlcm1zKVxufVxuXG5mdW5jdGlvbiBvcmllbnRhdGlvbihuKSB7XG4gIHZhciBwb3MgPSBbXVxuICB2YXIgbmVnID0gW11cbiAgdmFyIG0gPSBtYXRyaXgobilcbiAgZm9yKHZhciBpPTA7IGk8bjsgKytpKSB7XG4gICAgbVswXVtpXSA9IFwiMVwiXG4gICAgbVtuLTFdW2ldID0gXCJ3XCIraVxuICB9IFxuICBmb3IodmFyIGk9MDsgaTxuOyArK2kpIHtcbiAgICBpZigoaSYxKT09PTApIHtcbiAgICAgIHBvcy5wdXNoLmFwcGx5KHBvcyxkZXRlcm1pbmFudChjb2ZhY3RvcihtLCBpKSkpXG4gICAgfSBlbHNlIHtcbiAgICAgIG5lZy5wdXNoLmFwcGx5KG5lZyxkZXRlcm1pbmFudChjb2ZhY3RvcihtLCBpKSkpXG4gICAgfVxuICB9XG4gIHZhciBwb3NFeHByID0gZ2VuZXJhdGVTdW0ocG9zKVxuICB2YXIgbmVnRXhwciA9IGdlbmVyYXRlU3VtKG5lZylcbiAgdmFyIGZ1bmNOYW1lID0gXCJleGFjdEluU3BoZXJlXCIgKyBuXG4gIHZhciBmdW5jQXJncyA9IFtdXG4gIGZvcih2YXIgaT0wOyBpPG47ICsraSkge1xuICAgIGZ1bmNBcmdzLnB1c2goXCJtXCIgKyBpKVxuICB9XG4gIHZhciBjb2RlID0gW1wiZnVuY3Rpb24gXCIsIGZ1bmNOYW1lLCBcIihcIiwgZnVuY0FyZ3Muam9pbigpLCBcIil7XCJdXG4gIGZvcih2YXIgaT0wOyBpPG47ICsraSkge1xuICAgIGNvZGUucHVzaChcInZhciB3XCIsaSxcIj1cIixtYWtlU3F1YXJlKGksbiksXCI7XCIpXG4gICAgZm9yKHZhciBqPTA7IGo8bjsgKytqKSB7XG4gICAgICBpZihqICE9PSBpKSB7XG4gICAgICAgIGNvZGUucHVzaChcInZhciB3XCIsaSxcIm1cIixqLFwiPXNjYWxlKHdcIixpLFwiLG1cIixqLFwiWzBdKTtcIilcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgY29kZS5wdXNoKFwidmFyIHA9XCIsIHBvc0V4cHIsIFwiLG49XCIsIG5lZ0V4cHIsIFwiLGQ9ZGlmZihwLG4pO3JldHVybiBkW2QubGVuZ3RoLTFdO31yZXR1cm4gXCIsIGZ1bmNOYW1lKVxuICB2YXIgcHJvYyA9IG5ldyBGdW5jdGlvbihcInN1bVwiLCBcImRpZmZcIiwgXCJwcm9kXCIsIFwic2NhbGVcIiwgY29kZS5qb2luKFwiXCIpKVxuICByZXR1cm4gcHJvYyhyb2J1c3RTdW0sIHJvYnVzdERpZmYsIHR3b1Byb2R1Y3QsIHJvYnVzdFNjYWxlKVxufVxuXG5mdW5jdGlvbiBpblNwaGVyZTAoKSB7IHJldHVybiAwIH1cbmZ1bmN0aW9uIGluU3BoZXJlMSgpIHsgcmV0dXJuIDAgfVxuZnVuY3Rpb24gaW5TcGhlcmUyKCkgeyByZXR1cm4gMCB9XG5cbnZhciBDQUNIRUQgPSBbXG4gIGluU3BoZXJlMCxcbiAgaW5TcGhlcmUxLFxuICBpblNwaGVyZTJcbl1cblxuZnVuY3Rpb24gc2xvd0luU3BoZXJlKGFyZ3MpIHtcbiAgdmFyIHByb2MgPSBDQUNIRURbYXJncy5sZW5ndGhdXG4gIGlmKCFwcm9jKSB7XG4gICAgcHJvYyA9IENBQ0hFRFthcmdzLmxlbmd0aF0gPSBvcmllbnRhdGlvbihhcmdzLmxlbmd0aClcbiAgfVxuICByZXR1cm4gcHJvYy5hcHBseSh1bmRlZmluZWQsIGFyZ3MpXG59XG5cbmZ1bmN0aW9uIGdlbmVyYXRlSW5TcGhlcmVUZXN0KCkge1xuICB3aGlsZShDQUNIRUQubGVuZ3RoIDw9IE5VTV9FWFBBTkQpIHtcbiAgICBDQUNIRUQucHVzaChvcmllbnRhdGlvbihDQUNIRUQubGVuZ3RoKSlcbiAgfVxuICB2YXIgYXJncyA9IFtdXG4gIHZhciBwcm9jQXJncyA9IFtcInNsb3dcIl1cbiAgZm9yKHZhciBpPTA7IGk8PU5VTV9FWFBBTkQ7ICsraSkge1xuICAgIGFyZ3MucHVzaChcImFcIiArIGkpXG4gICAgcHJvY0FyZ3MucHVzaChcIm9cIiArIGkpXG4gIH1cbiAgdmFyIGNvZGUgPSBbXG4gICAgXCJmdW5jdGlvbiB0ZXN0SW5TcGhlcmUoXCIsIGFyZ3Muam9pbigpLCBcIil7c3dpdGNoKGFyZ3VtZW50cy5sZW5ndGgpe2Nhc2UgMDpjYXNlIDE6cmV0dXJuIDA7XCJcbiAgXVxuICBmb3IodmFyIGk9MjsgaTw9TlVNX0VYUEFORDsgKytpKSB7XG4gICAgY29kZS5wdXNoKFwiY2FzZSBcIiwgaSwgXCI6cmV0dXJuIG9cIiwgaSwgXCIoXCIsIGFyZ3Muc2xpY2UoMCwgaSkuam9pbigpLCBcIik7XCIpXG4gIH1cbiAgY29kZS5wdXNoKFwifXZhciBzPW5ldyBBcnJheShhcmd1bWVudHMubGVuZ3RoKTtmb3IodmFyIGk9MDtpPGFyZ3VtZW50cy5sZW5ndGg7KytpKXtzW2ldPWFyZ3VtZW50c1tpXX07cmV0dXJuIHNsb3cocyk7fXJldHVybiB0ZXN0SW5TcGhlcmVcIilcbiAgcHJvY0FyZ3MucHVzaChjb2RlLmpvaW4oXCJcIikpXG5cbiAgdmFyIHByb2MgPSBGdW5jdGlvbi5hcHBseSh1bmRlZmluZWQsIHByb2NBcmdzKVxuXG4gIG1vZHVsZS5leHBvcnRzID0gcHJvYy5hcHBseSh1bmRlZmluZWQsIFtzbG93SW5TcGhlcmVdLmNvbmNhdChDQUNIRUQpKVxuICBmb3IodmFyIGk9MDsgaTw9TlVNX0VYUEFORDsgKytpKSB7XG4gICAgbW9kdWxlLmV4cG9ydHNbaV0gPSBDQUNIRURbaV1cbiAgfVxufVxuXG5nZW5lcmF0ZUluU3BoZXJlVGVzdCgpIiwiXCJ1c2Ugc3RyaWN0XCJcblxubW9kdWxlLmV4cG9ydHMgPSBmYXN0VHdvU3VtXG5cbmZ1bmN0aW9uIGZhc3RUd29TdW0oYSwgYiwgcmVzdWx0KSB7XG5cdHZhciB4ID0gYSArIGJcblx0dmFyIGJ2ID0geCAtIGFcblx0dmFyIGF2ID0geCAtIGJ2XG5cdHZhciBiciA9IGIgLSBidlxuXHR2YXIgYXIgPSBhIC0gYXZcblx0aWYocmVzdWx0KSB7XG5cdFx0cmVzdWx0WzBdID0gYXIgKyBiclxuXHRcdHJlc3VsdFsxXSA9IHhcblx0XHRyZXR1cm4gcmVzdWx0XG5cdH1cblx0cmV0dXJuIFthciticiwgeF1cbn0iLCJcInVzZSBzdHJpY3RcIlxuXG52YXIgdHdvUHJvZHVjdCA9IHJlcXVpcmUoXCJ0d28tcHJvZHVjdFwiKVxudmFyIHR3b1N1bSA9IHJlcXVpcmUoXCJ0d28tc3VtXCIpXG5cbm1vZHVsZS5leHBvcnRzID0gc2NhbGVMaW5lYXJFeHBhbnNpb25cblxuZnVuY3Rpb24gc2NhbGVMaW5lYXJFeHBhbnNpb24oZSwgc2NhbGUpIHtcbiAgdmFyIG4gPSBlLmxlbmd0aFxuICBpZihuID09PSAxKSB7XG4gICAgdmFyIHRzID0gdHdvUHJvZHVjdChlWzBdLCBzY2FsZSlcbiAgICBpZih0c1swXSkge1xuICAgICAgcmV0dXJuIHRzXG4gICAgfVxuICAgIHJldHVybiBbIHRzWzFdIF1cbiAgfVxuICB2YXIgZyA9IG5ldyBBcnJheSgyICogbilcbiAgdmFyIHEgPSBbMC4xLCAwLjFdXG4gIHZhciB0ID0gWzAuMSwgMC4xXVxuICB2YXIgY291bnQgPSAwXG4gIHR3b1Byb2R1Y3QoZVswXSwgc2NhbGUsIHEpXG4gIGlmKHFbMF0pIHtcbiAgICBnW2NvdW50KytdID0gcVswXVxuICB9XG4gIGZvcih2YXIgaT0xOyBpPG47ICsraSkge1xuICAgIHR3b1Byb2R1Y3QoZVtpXSwgc2NhbGUsIHQpXG4gICAgdmFyIHBxID0gcVsxXVxuICAgIHR3b1N1bShwcSwgdFswXSwgcSlcbiAgICBpZihxWzBdKSB7XG4gICAgICBnW2NvdW50KytdID0gcVswXVxuICAgIH1cbiAgICB2YXIgYSA9IHRbMV1cbiAgICB2YXIgYiA9IHFbMV1cbiAgICB2YXIgeCA9IGEgKyBiXG4gICAgdmFyIGJ2ID0geCAtIGFcbiAgICB2YXIgeSA9IGIgLSBidlxuICAgIHFbMV0gPSB4XG4gICAgaWYoeSkge1xuICAgICAgZ1tjb3VudCsrXSA9IHlcbiAgICB9XG4gIH1cbiAgaWYocVsxXSkge1xuICAgIGdbY291bnQrK10gPSBxWzFdXG4gIH1cbiAgaWYoY291bnQgPT09IDApIHtcbiAgICBnW2NvdW50KytdID0gMC4wXG4gIH1cbiAgZy5sZW5ndGggPSBjb3VudFxuICByZXR1cm4gZ1xufSIsIlwidXNlIHN0cmljdFwiXG5cbm1vZHVsZS5leHBvcnRzID0gcm9idXN0U3VidHJhY3RcblxuLy9FYXN5IGNhc2U6IEFkZCB0d28gc2NhbGFyc1xuZnVuY3Rpb24gc2NhbGFyU2NhbGFyKGEsIGIpIHtcbiAgdmFyIHggPSBhICsgYlxuICB2YXIgYnYgPSB4IC0gYVxuICB2YXIgYXYgPSB4IC0gYnZcbiAgdmFyIGJyID0gYiAtIGJ2XG4gIHZhciBhciA9IGEgLSBhdlxuICB2YXIgeSA9IGFyICsgYnJcbiAgaWYoeSkge1xuICAgIHJldHVybiBbeSwgeF1cbiAgfVxuICByZXR1cm4gW3hdXG59XG5cbmZ1bmN0aW9uIHJvYnVzdFN1YnRyYWN0KGUsIGYpIHtcbiAgdmFyIG5lID0gZS5sZW5ndGh8MFxuICB2YXIgbmYgPSBmLmxlbmd0aHwwXG4gIGlmKG5lID09PSAxICYmIG5mID09PSAxKSB7XG4gICAgcmV0dXJuIHNjYWxhclNjYWxhcihlWzBdLCAtZlswXSlcbiAgfVxuICB2YXIgbiA9IG5lICsgbmZcbiAgdmFyIGcgPSBuZXcgQXJyYXkobilcbiAgdmFyIGNvdW50ID0gMFxuICB2YXIgZXB0ciA9IDBcbiAgdmFyIGZwdHIgPSAwXG4gIHZhciBhYnMgPSBNYXRoLmFic1xuICB2YXIgZWkgPSBlW2VwdHJdXG4gIHZhciBlYSA9IGFicyhlaSlcbiAgdmFyIGZpID0gLWZbZnB0cl1cbiAgdmFyIGZhID0gYWJzKGZpKVxuICB2YXIgYSwgYlxuICBpZihlYSA8IGZhKSB7XG4gICAgYiA9IGVpXG4gICAgZXB0ciArPSAxXG4gICAgaWYoZXB0ciA8IG5lKSB7XG4gICAgICBlaSA9IGVbZXB0cl1cbiAgICAgIGVhID0gYWJzKGVpKVxuICAgIH1cbiAgfSBlbHNlIHtcbiAgICBiID0gZmlcbiAgICBmcHRyICs9IDFcbiAgICBpZihmcHRyIDwgbmYpIHtcbiAgICAgIGZpID0gLWZbZnB0cl1cbiAgICAgIGZhID0gYWJzKGZpKVxuICAgIH1cbiAgfVxuICBpZigoZXB0ciA8IG5lICYmIGVhIDwgZmEpIHx8IChmcHRyID49IG5mKSkge1xuICAgIGEgPSBlaVxuICAgIGVwdHIgKz0gMVxuICAgIGlmKGVwdHIgPCBuZSkge1xuICAgICAgZWkgPSBlW2VwdHJdXG4gICAgICBlYSA9IGFicyhlaSlcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgYSA9IGZpXG4gICAgZnB0ciArPSAxXG4gICAgaWYoZnB0ciA8IG5mKSB7XG4gICAgICBmaSA9IC1mW2ZwdHJdXG4gICAgICBmYSA9IGFicyhmaSlcbiAgICB9XG4gIH1cbiAgdmFyIHggPSBhICsgYlxuICB2YXIgYnYgPSB4IC0gYVxuICB2YXIgeSA9IGIgLSBidlxuICB2YXIgcTAgPSB5XG4gIHZhciBxMSA9IHhcbiAgdmFyIF94LCBfYnYsIF9hdiwgX2JyLCBfYXJcbiAgd2hpbGUoZXB0ciA8IG5lICYmIGZwdHIgPCBuZikge1xuICAgIGlmKGVhIDwgZmEpIHtcbiAgICAgIGEgPSBlaVxuICAgICAgZXB0ciArPSAxXG4gICAgICBpZihlcHRyIDwgbmUpIHtcbiAgICAgICAgZWkgPSBlW2VwdHJdXG4gICAgICAgIGVhID0gYWJzKGVpKVxuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBhID0gZmlcbiAgICAgIGZwdHIgKz0gMVxuICAgICAgaWYoZnB0ciA8IG5mKSB7XG4gICAgICAgIGZpID0gLWZbZnB0cl1cbiAgICAgICAgZmEgPSBhYnMoZmkpXG4gICAgICB9XG4gICAgfVxuICAgIGIgPSBxMFxuICAgIHggPSBhICsgYlxuICAgIGJ2ID0geCAtIGFcbiAgICB5ID0gYiAtIGJ2XG4gICAgaWYoeSkge1xuICAgICAgZ1tjb3VudCsrXSA9IHlcbiAgICB9XG4gICAgX3ggPSBxMSArIHhcbiAgICBfYnYgPSBfeCAtIHExXG4gICAgX2F2ID0gX3ggLSBfYnZcbiAgICBfYnIgPSB4IC0gX2J2XG4gICAgX2FyID0gcTEgLSBfYXZcbiAgICBxMCA9IF9hciArIF9iclxuICAgIHExID0gX3hcbiAgfVxuICB3aGlsZShlcHRyIDwgbmUpIHtcbiAgICBhID0gZWlcbiAgICBiID0gcTBcbiAgICB4ID0gYSArIGJcbiAgICBidiA9IHggLSBhXG4gICAgeSA9IGIgLSBidlxuICAgIGlmKHkpIHtcbiAgICAgIGdbY291bnQrK10gPSB5XG4gICAgfVxuICAgIF94ID0gcTEgKyB4XG4gICAgX2J2ID0gX3ggLSBxMVxuICAgIF9hdiA9IF94IC0gX2J2XG4gICAgX2JyID0geCAtIF9idlxuICAgIF9hciA9IHExIC0gX2F2XG4gICAgcTAgPSBfYXIgKyBfYnJcbiAgICBxMSA9IF94XG4gICAgZXB0ciArPSAxXG4gICAgaWYoZXB0ciA8IG5lKSB7XG4gICAgICBlaSA9IGVbZXB0cl1cbiAgICB9XG4gIH1cbiAgd2hpbGUoZnB0ciA8IG5mKSB7XG4gICAgYSA9IGZpXG4gICAgYiA9IHEwXG4gICAgeCA9IGEgKyBiXG4gICAgYnYgPSB4IC0gYVxuICAgIHkgPSBiIC0gYnZcbiAgICBpZih5KSB7XG4gICAgICBnW2NvdW50KytdID0geVxuICAgIH0gXG4gICAgX3ggPSBxMSArIHhcbiAgICBfYnYgPSBfeCAtIHExXG4gICAgX2F2ID0gX3ggLSBfYnZcbiAgICBfYnIgPSB4IC0gX2J2XG4gICAgX2FyID0gcTEgLSBfYXZcbiAgICBxMCA9IF9hciArIF9iclxuICAgIHExID0gX3hcbiAgICBmcHRyICs9IDFcbiAgICBpZihmcHRyIDwgbmYpIHtcbiAgICAgIGZpID0gLWZbZnB0cl1cbiAgICB9XG4gIH1cbiAgaWYocTApIHtcbiAgICBnW2NvdW50KytdID0gcTBcbiAgfVxuICBpZihxMSkge1xuICAgIGdbY291bnQrK10gPSBxMVxuICB9XG4gIGlmKCFjb3VudCkge1xuICAgIGdbY291bnQrK10gPSAwLjAgIFxuICB9XG4gIGcubGVuZ3RoID0gY291bnRcbiAgcmV0dXJuIGdcbn0iLCJcInVzZSBzdHJpY3RcIlxuXG5tb2R1bGUuZXhwb3J0cyA9IGxpbmVhckV4cGFuc2lvblN1bVxuXG4vL0Vhc3kgY2FzZTogQWRkIHR3byBzY2FsYXJzXG5mdW5jdGlvbiBzY2FsYXJTY2FsYXIoYSwgYikge1xuICB2YXIgeCA9IGEgKyBiXG4gIHZhciBidiA9IHggLSBhXG4gIHZhciBhdiA9IHggLSBidlxuICB2YXIgYnIgPSBiIC0gYnZcbiAgdmFyIGFyID0gYSAtIGF2XG4gIHZhciB5ID0gYXIgKyBiclxuICBpZih5KSB7XG4gICAgcmV0dXJuIFt5LCB4XVxuICB9XG4gIHJldHVybiBbeF1cbn1cblxuZnVuY3Rpb24gbGluZWFyRXhwYW5zaW9uU3VtKGUsIGYpIHtcbiAgdmFyIG5lID0gZS5sZW5ndGh8MFxuICB2YXIgbmYgPSBmLmxlbmd0aHwwXG4gIGlmKG5lID09PSAxICYmIG5mID09PSAxKSB7XG4gICAgcmV0dXJuIHNjYWxhclNjYWxhcihlWzBdLCBmWzBdKVxuICB9XG4gIHZhciBuID0gbmUgKyBuZlxuICB2YXIgZyA9IG5ldyBBcnJheShuKVxuICB2YXIgY291bnQgPSAwXG4gIHZhciBlcHRyID0gMFxuICB2YXIgZnB0ciA9IDBcbiAgdmFyIGFicyA9IE1hdGguYWJzXG4gIHZhciBlaSA9IGVbZXB0cl1cbiAgdmFyIGVhID0gYWJzKGVpKVxuICB2YXIgZmkgPSBmW2ZwdHJdXG4gIHZhciBmYSA9IGFicyhmaSlcbiAgdmFyIGEsIGJcbiAgaWYoZWEgPCBmYSkge1xuICAgIGIgPSBlaVxuICAgIGVwdHIgKz0gMVxuICAgIGlmKGVwdHIgPCBuZSkge1xuICAgICAgZWkgPSBlW2VwdHJdXG4gICAgICBlYSA9IGFicyhlaSlcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgYiA9IGZpXG4gICAgZnB0ciArPSAxXG4gICAgaWYoZnB0ciA8IG5mKSB7XG4gICAgICBmaSA9IGZbZnB0cl1cbiAgICAgIGZhID0gYWJzKGZpKVxuICAgIH1cbiAgfVxuICBpZigoZXB0ciA8IG5lICYmIGVhIDwgZmEpIHx8IChmcHRyID49IG5mKSkge1xuICAgIGEgPSBlaVxuICAgIGVwdHIgKz0gMVxuICAgIGlmKGVwdHIgPCBuZSkge1xuICAgICAgZWkgPSBlW2VwdHJdXG4gICAgICBlYSA9IGFicyhlaSlcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgYSA9IGZpXG4gICAgZnB0ciArPSAxXG4gICAgaWYoZnB0ciA8IG5mKSB7XG4gICAgICBmaSA9IGZbZnB0cl1cbiAgICAgIGZhID0gYWJzKGZpKVxuICAgIH1cbiAgfVxuICB2YXIgeCA9IGEgKyBiXG4gIHZhciBidiA9IHggLSBhXG4gIHZhciB5ID0gYiAtIGJ2XG4gIHZhciBxMCA9IHlcbiAgdmFyIHExID0geFxuICB2YXIgX3gsIF9idiwgX2F2LCBfYnIsIF9hclxuICB3aGlsZShlcHRyIDwgbmUgJiYgZnB0ciA8IG5mKSB7XG4gICAgaWYoZWEgPCBmYSkge1xuICAgICAgYSA9IGVpXG4gICAgICBlcHRyICs9IDFcbiAgICAgIGlmKGVwdHIgPCBuZSkge1xuICAgICAgICBlaSA9IGVbZXB0cl1cbiAgICAgICAgZWEgPSBhYnMoZWkpXG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGEgPSBmaVxuICAgICAgZnB0ciArPSAxXG4gICAgICBpZihmcHRyIDwgbmYpIHtcbiAgICAgICAgZmkgPSBmW2ZwdHJdXG4gICAgICAgIGZhID0gYWJzKGZpKVxuICAgICAgfVxuICAgIH1cbiAgICBiID0gcTBcbiAgICB4ID0gYSArIGJcbiAgICBidiA9IHggLSBhXG4gICAgeSA9IGIgLSBidlxuICAgIGlmKHkpIHtcbiAgICAgIGdbY291bnQrK10gPSB5XG4gICAgfVxuICAgIF94ID0gcTEgKyB4XG4gICAgX2J2ID0gX3ggLSBxMVxuICAgIF9hdiA9IF94IC0gX2J2XG4gICAgX2JyID0geCAtIF9idlxuICAgIF9hciA9IHExIC0gX2F2XG4gICAgcTAgPSBfYXIgKyBfYnJcbiAgICBxMSA9IF94XG4gIH1cbiAgd2hpbGUoZXB0ciA8IG5lKSB7XG4gICAgYSA9IGVpXG4gICAgYiA9IHEwXG4gICAgeCA9IGEgKyBiXG4gICAgYnYgPSB4IC0gYVxuICAgIHkgPSBiIC0gYnZcbiAgICBpZih5KSB7XG4gICAgICBnW2NvdW50KytdID0geVxuICAgIH1cbiAgICBfeCA9IHExICsgeFxuICAgIF9idiA9IF94IC0gcTFcbiAgICBfYXYgPSBfeCAtIF9idlxuICAgIF9iciA9IHggLSBfYnZcbiAgICBfYXIgPSBxMSAtIF9hdlxuICAgIHEwID0gX2FyICsgX2JyXG4gICAgcTEgPSBfeFxuICAgIGVwdHIgKz0gMVxuICAgIGlmKGVwdHIgPCBuZSkge1xuICAgICAgZWkgPSBlW2VwdHJdXG4gICAgfVxuICB9XG4gIHdoaWxlKGZwdHIgPCBuZikge1xuICAgIGEgPSBmaVxuICAgIGIgPSBxMFxuICAgIHggPSBhICsgYlxuICAgIGJ2ID0geCAtIGFcbiAgICB5ID0gYiAtIGJ2XG4gICAgaWYoeSkge1xuICAgICAgZ1tjb3VudCsrXSA9IHlcbiAgICB9IFxuICAgIF94ID0gcTEgKyB4XG4gICAgX2J2ID0gX3ggLSBxMVxuICAgIF9hdiA9IF94IC0gX2J2XG4gICAgX2JyID0geCAtIF9idlxuICAgIF9hciA9IHExIC0gX2F2XG4gICAgcTAgPSBfYXIgKyBfYnJcbiAgICBxMSA9IF94XG4gICAgZnB0ciArPSAxXG4gICAgaWYoZnB0ciA8IG5mKSB7XG4gICAgICBmaSA9IGZbZnB0cl1cbiAgICB9XG4gIH1cbiAgaWYocTApIHtcbiAgICBnW2NvdW50KytdID0gcTBcbiAgfVxuICBpZihxMSkge1xuICAgIGdbY291bnQrK10gPSBxMVxuICB9XG4gIGlmKCFjb3VudCkge1xuICAgIGdbY291bnQrK10gPSAwLjAgIFxuICB9XG4gIGcubGVuZ3RoID0gY291bnRcbiAgcmV0dXJuIGdcbn0iLCJcInVzZSBzdHJpY3RcIlxuXG5tb2R1bGUuZXhwb3J0cyA9IHR3b1Byb2R1Y3RcblxudmFyIFNQTElUVEVSID0gKyhNYXRoLnBvdygyLCAyNykgKyAxLjApXG5cbmZ1bmN0aW9uIHR3b1Byb2R1Y3QoYSwgYiwgcmVzdWx0KSB7XG4gIHZhciB4ID0gYSAqIGJcblxuICB2YXIgYyA9IFNQTElUVEVSICogYVxuICB2YXIgYWJpZyA9IGMgLSBhXG4gIHZhciBhaGkgPSBjIC0gYWJpZ1xuICB2YXIgYWxvID0gYSAtIGFoaVxuXG4gIHZhciBkID0gU1BMSVRURVIgKiBiXG4gIHZhciBiYmlnID0gZCAtIGJcbiAgdmFyIGJoaSA9IGQgLSBiYmlnXG4gIHZhciBibG8gPSBiIC0gYmhpXG5cbiAgdmFyIGVycjEgPSB4IC0gKGFoaSAqIGJoaSlcbiAgdmFyIGVycjIgPSBlcnIxIC0gKGFsbyAqIGJoaSlcbiAgdmFyIGVycjMgPSBlcnIyIC0gKGFoaSAqIGJsbylcblxuICB2YXIgeSA9IGFsbyAqIGJsbyAtIGVycjNcblxuICBpZihyZXN1bHQpIHtcbiAgICByZXN1bHRbMF0gPSB5XG4gICAgcmVzdWx0WzFdID0geFxuICAgIHJldHVybiByZXN1bHRcbiAgfVxuXG4gIHJldHVybiBbIHksIHggXVxufSIsIlwidXNlIHN0cmljdFwiXG5cbnZhciB0d29Qcm9kdWN0ID0gcmVxdWlyZShcInR3by1wcm9kdWN0XCIpXG52YXIgcm9idXN0U3VtID0gcmVxdWlyZShcInJvYnVzdC1zdW1cIilcbnZhciByb2J1c3RTY2FsZSA9IHJlcXVpcmUoXCJyb2J1c3Qtc2NhbGVcIilcbnZhciByb2J1c3RTdWJ0cmFjdCA9IHJlcXVpcmUoXCJyb2J1c3Qtc3VidHJhY3RcIilcblxudmFyIE5VTV9FWFBBTkQgPSA1XG5cbnZhciBFUFNJTE9OICAgICA9IDEuMTEwMjIzMDI0NjI1MTU2NWUtMTZcbnZhciBFUlJCT1VORDMgICA9ICgzLjAgKyAxNi4wICogRVBTSUxPTikgKiBFUFNJTE9OXG52YXIgRVJSQk9VTkQ0ICAgPSAoNy4wICsgNTYuMCAqIEVQU0lMT04pICogRVBTSUxPTlxuXG5mdW5jdGlvbiBjb2ZhY3RvcihtLCBjKSB7XG4gIHZhciByZXN1bHQgPSBuZXcgQXJyYXkobS5sZW5ndGgtMSlcbiAgZm9yKHZhciBpPTE7IGk8bS5sZW5ndGg7ICsraSkge1xuICAgIHZhciByID0gcmVzdWx0W2ktMV0gPSBuZXcgQXJyYXkobS5sZW5ndGgtMSlcbiAgICBmb3IodmFyIGo9MCxrPTA7IGo8bS5sZW5ndGg7ICsraikge1xuICAgICAgaWYoaiA9PT0gYykge1xuICAgICAgICBjb250aW51ZVxuICAgICAgfVxuICAgICAgcltrKytdID0gbVtpXVtqXVxuICAgIH1cbiAgfVxuICByZXR1cm4gcmVzdWx0XG59XG5cbmZ1bmN0aW9uIG1hdHJpeChuKSB7XG4gIHZhciByZXN1bHQgPSBuZXcgQXJyYXkobilcbiAgZm9yKHZhciBpPTA7IGk8bjsgKytpKSB7XG4gICAgcmVzdWx0W2ldID0gbmV3IEFycmF5KG4pXG4gICAgZm9yKHZhciBqPTA7IGo8bjsgKytqKSB7XG4gICAgICByZXN1bHRbaV1bal0gPSBbXCJtXCIsIGosIFwiW1wiLCAobi1pLTEpLCBcIl1cIl0uam9pbihcIlwiKVxuICAgIH1cbiAgfVxuICByZXR1cm4gcmVzdWx0XG59XG5cbmZ1bmN0aW9uIHNpZ24obikge1xuICBpZihuICYgMSkge1xuICAgIHJldHVybiBcIi1cIlxuICB9XG4gIHJldHVybiBcIlwiXG59XG5cbmZ1bmN0aW9uIGdlbmVyYXRlU3VtKGV4cHIpIHtcbiAgaWYoZXhwci5sZW5ndGggPT09IDEpIHtcbiAgICByZXR1cm4gZXhwclswXVxuICB9IGVsc2UgaWYoZXhwci5sZW5ndGggPT09IDIpIHtcbiAgICByZXR1cm4gW1wic3VtKFwiLCBleHByWzBdLCBcIixcIiwgZXhwclsxXSwgXCIpXCJdLmpvaW4oXCJcIilcbiAgfSBlbHNlIHtcbiAgICB2YXIgbSA9IGV4cHIubGVuZ3RoPj4xXG4gICAgcmV0dXJuIFtcInN1bShcIiwgZ2VuZXJhdGVTdW0oZXhwci5zbGljZSgwLCBtKSksIFwiLFwiLCBnZW5lcmF0ZVN1bShleHByLnNsaWNlKG0pKSwgXCIpXCJdLmpvaW4oXCJcIilcbiAgfVxufVxuXG5mdW5jdGlvbiBkZXRlcm1pbmFudChtKSB7XG4gIGlmKG0ubGVuZ3RoID09PSAyKSB7XG4gICAgcmV0dXJuIFtbXCJzdW0ocHJvZChcIiwgbVswXVswXSwgXCIsXCIsIG1bMV1bMV0sIFwiKSxwcm9kKC1cIiwgbVswXVsxXSwgXCIsXCIsIG1bMV1bMF0sIFwiKSlcIl0uam9pbihcIlwiKV1cbiAgfSBlbHNlIHtcbiAgICB2YXIgZXhwciA9IFtdXG4gICAgZm9yKHZhciBpPTA7IGk8bS5sZW5ndGg7ICsraSkge1xuICAgICAgZXhwci5wdXNoKFtcInNjYWxlKFwiLCBnZW5lcmF0ZVN1bShkZXRlcm1pbmFudChjb2ZhY3RvcihtLCBpKSkpLCBcIixcIiwgc2lnbihpKSwgbVswXVtpXSwgXCIpXCJdLmpvaW4oXCJcIikpXG4gICAgfVxuICAgIHJldHVybiBleHByXG4gIH1cbn1cblxuZnVuY3Rpb24gb3JpZW50YXRpb24obikge1xuICB2YXIgcG9zID0gW11cbiAgdmFyIG5lZyA9IFtdXG4gIHZhciBtID0gbWF0cml4KG4pXG4gIHZhciBhcmdzID0gW11cbiAgZm9yKHZhciBpPTA7IGk8bjsgKytpKSB7XG4gICAgaWYoKGkmMSk9PT0wKSB7XG4gICAgICBwb3MucHVzaC5hcHBseShwb3MsIGRldGVybWluYW50KGNvZmFjdG9yKG0sIGkpKSlcbiAgICB9IGVsc2Uge1xuICAgICAgbmVnLnB1c2guYXBwbHkobmVnLCBkZXRlcm1pbmFudChjb2ZhY3RvcihtLCBpKSkpXG4gICAgfVxuICAgIGFyZ3MucHVzaChcIm1cIiArIGkpXG4gIH1cbiAgdmFyIHBvc0V4cHIgPSBnZW5lcmF0ZVN1bShwb3MpXG4gIHZhciBuZWdFeHByID0gZ2VuZXJhdGVTdW0obmVnKVxuICB2YXIgZnVuY05hbWUgPSBcIm9yaWVudGF0aW9uXCIgKyBuICsgXCJFeGFjdFwiXG4gIHZhciBjb2RlID0gW1wiZnVuY3Rpb24gXCIsIGZ1bmNOYW1lLCBcIihcIiwgYXJncy5qb2luKCksIFwiKXt2YXIgcD1cIiwgcG9zRXhwciwgXCIsbj1cIiwgbmVnRXhwciwgXCIsZD1zdWIocCxuKTtcXFxucmV0dXJuIGRbZC5sZW5ndGgtMV07fTtyZXR1cm4gXCIsIGZ1bmNOYW1lXS5qb2luKFwiXCIpXG4gIHZhciBwcm9jID0gbmV3IEZ1bmN0aW9uKFwic3VtXCIsIFwicHJvZFwiLCBcInNjYWxlXCIsIFwic3ViXCIsIGNvZGUpXG4gIHJldHVybiBwcm9jKHJvYnVzdFN1bSwgdHdvUHJvZHVjdCwgcm9idXN0U2NhbGUsIHJvYnVzdFN1YnRyYWN0KVxufVxuXG52YXIgb3JpZW50YXRpb24zRXhhY3QgPSBvcmllbnRhdGlvbigzKVxudmFyIG9yaWVudGF0aW9uNEV4YWN0ID0gb3JpZW50YXRpb24oNClcblxudmFyIENBQ0hFRCA9IFtcbiAgZnVuY3Rpb24gb3JpZW50YXRpb24wKCkgeyByZXR1cm4gMCB9LFxuICBmdW5jdGlvbiBvcmllbnRhdGlvbjEoKSB7IHJldHVybiAwIH0sXG4gIGZ1bmN0aW9uIG9yaWVudGF0aW9uMihhLCBiKSB7IFxuICAgIHJldHVybiBiWzBdIC0gYVswXVxuICB9LFxuICBmdW5jdGlvbiBvcmllbnRhdGlvbjMoYSwgYiwgYykge1xuICAgIHZhciBsID0gKGFbMV0gLSBjWzFdKSAqIChiWzBdIC0gY1swXSlcbiAgICB2YXIgciA9IChhWzBdIC0gY1swXSkgKiAoYlsxXSAtIGNbMV0pXG4gICAgdmFyIGRldCA9IGwgLSByXG4gICAgdmFyIHNcbiAgICBpZihsID4gMCkge1xuICAgICAgaWYociA8PSAwKSB7XG4gICAgICAgIHJldHVybiBkZXRcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHMgPSBsICsgclxuICAgICAgfVxuICAgIH0gZWxzZSBpZihsIDwgMCkge1xuICAgICAgaWYociA+PSAwKSB7XG4gICAgICAgIHJldHVybiBkZXRcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHMgPSAtKGwgKyByKVxuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gZGV0XG4gICAgfVxuICAgIHZhciB0b2wgPSBFUlJCT1VORDMgKiBzXG4gICAgaWYoZGV0ID49IHRvbCB8fCBkZXQgPD0gLXRvbCkge1xuICAgICAgcmV0dXJuIGRldFxuICAgIH1cbiAgICByZXR1cm4gb3JpZW50YXRpb24zRXhhY3QoYSwgYiwgYylcbiAgfSxcbiAgZnVuY3Rpb24gb3JpZW50YXRpb240KGEsYixjLGQpIHtcbiAgICB2YXIgYWR4ID0gYVswXSAtIGRbMF1cbiAgICB2YXIgYmR4ID0gYlswXSAtIGRbMF1cbiAgICB2YXIgY2R4ID0gY1swXSAtIGRbMF1cbiAgICB2YXIgYWR5ID0gYVsxXSAtIGRbMV1cbiAgICB2YXIgYmR5ID0gYlsxXSAtIGRbMV1cbiAgICB2YXIgY2R5ID0gY1sxXSAtIGRbMV1cbiAgICB2YXIgYWR6ID0gYVsyXSAtIGRbMl1cbiAgICB2YXIgYmR6ID0gYlsyXSAtIGRbMl1cbiAgICB2YXIgY2R6ID0gY1syXSAtIGRbMl1cbiAgICB2YXIgYmR4Y2R5ID0gYmR4ICogY2R5XG4gICAgdmFyIGNkeGJkeSA9IGNkeCAqIGJkeVxuICAgIHZhciBjZHhhZHkgPSBjZHggKiBhZHlcbiAgICB2YXIgYWR4Y2R5ID0gYWR4ICogY2R5XG4gICAgdmFyIGFkeGJkeSA9IGFkeCAqIGJkeVxuICAgIHZhciBiZHhhZHkgPSBiZHggKiBhZHlcbiAgICB2YXIgZGV0ID0gYWR6ICogKGJkeGNkeSAtIGNkeGJkeSkgXG4gICAgICAgICAgICArIGJkeiAqIChjZHhhZHkgLSBhZHhjZHkpXG4gICAgICAgICAgICArIGNkeiAqIChhZHhiZHkgLSBiZHhhZHkpXG4gICAgdmFyIHBlcm1hbmVudCA9IChNYXRoLmFicyhiZHhjZHkpICsgTWF0aC5hYnMoY2R4YmR5KSkgKiBNYXRoLmFicyhhZHopXG4gICAgICAgICAgICAgICAgICArIChNYXRoLmFicyhjZHhhZHkpICsgTWF0aC5hYnMoYWR4Y2R5KSkgKiBNYXRoLmFicyhiZHopXG4gICAgICAgICAgICAgICAgICArIChNYXRoLmFicyhhZHhiZHkpICsgTWF0aC5hYnMoYmR4YWR5KSkgKiBNYXRoLmFicyhjZHopXG4gICAgdmFyIHRvbCA9IEVSUkJPVU5ENCAqIHBlcm1hbmVudFxuICAgIGlmICgoZGV0ID4gdG9sKSB8fCAoLWRldCA+IHRvbCkpIHtcbiAgICAgIHJldHVybiBkZXRcbiAgICB9XG4gICAgcmV0dXJuIG9yaWVudGF0aW9uNEV4YWN0KGEsYixjLGQpXG4gIH1cbl1cblxuZnVuY3Rpb24gc2xvd09yaWVudChhcmdzKSB7XG4gIHZhciBwcm9jID0gQ0FDSEVEW2FyZ3MubGVuZ3RoXVxuICBpZighcHJvYykge1xuICAgIHByb2MgPSBDQUNIRURbYXJncy5sZW5ndGhdID0gb3JpZW50YXRpb24oYXJncy5sZW5ndGgpXG4gIH1cbiAgcmV0dXJuIHByb2MuYXBwbHkodW5kZWZpbmVkLCBhcmdzKVxufVxuXG5mdW5jdGlvbiBnZW5lcmF0ZU9yaWVudGF0aW9uUHJvYygpIHtcbiAgd2hpbGUoQ0FDSEVELmxlbmd0aCA8PSBOVU1fRVhQQU5EKSB7XG4gICAgQ0FDSEVELnB1c2gob3JpZW50YXRpb24oQ0FDSEVELmxlbmd0aCkpXG4gIH1cbiAgdmFyIGFyZ3MgPSBbXVxuICB2YXIgcHJvY0FyZ3MgPSBbXCJzbG93XCJdXG4gIGZvcih2YXIgaT0wOyBpPD1OVU1fRVhQQU5EOyArK2kpIHtcbiAgICBhcmdzLnB1c2goXCJhXCIgKyBpKVxuICAgIHByb2NBcmdzLnB1c2goXCJvXCIgKyBpKVxuICB9XG4gIHZhciBjb2RlID0gW1xuICAgIFwiZnVuY3Rpb24gZ2V0T3JpZW50YXRpb24oXCIsIGFyZ3Muam9pbigpLCBcIil7c3dpdGNoKGFyZ3VtZW50cy5sZW5ndGgpe2Nhc2UgMDpjYXNlIDE6cmV0dXJuIDA7XCJcbiAgXVxuICBmb3IodmFyIGk9MjsgaTw9TlVNX0VYUEFORDsgKytpKSB7XG4gICAgY29kZS5wdXNoKFwiY2FzZSBcIiwgaSwgXCI6cmV0dXJuIG9cIiwgaSwgXCIoXCIsIGFyZ3Muc2xpY2UoMCwgaSkuam9pbigpLCBcIik7XCIpXG4gIH1cbiAgY29kZS5wdXNoKFwifXZhciBzPW5ldyBBcnJheShhcmd1bWVudHMubGVuZ3RoKTtmb3IodmFyIGk9MDtpPGFyZ3VtZW50cy5sZW5ndGg7KytpKXtzW2ldPWFyZ3VtZW50c1tpXX07cmV0dXJuIHNsb3cocyk7fXJldHVybiBnZXRPcmllbnRhdGlvblwiKVxuICBwcm9jQXJncy5wdXNoKGNvZGUuam9pbihcIlwiKSlcblxuICB2YXIgcHJvYyA9IEZ1bmN0aW9uLmFwcGx5KHVuZGVmaW5lZCwgcHJvY0FyZ3MpXG4gIG1vZHVsZS5leHBvcnRzID0gcHJvYy5hcHBseSh1bmRlZmluZWQsIFtzbG93T3JpZW50XS5jb25jYXQoQ0FDSEVEKSlcbiAgZm9yKHZhciBpPTA7IGk8PU5VTV9FWFBBTkQ7ICsraSkge1xuICAgIG1vZHVsZS5leHBvcnRzW2ldID0gQ0FDSEVEW2ldXG4gIH1cbn1cblxuZ2VuZXJhdGVPcmllbnRhdGlvblByb2MoKSIsIid1c2Ugc3RyaWN0J1xuXG5tb2R1bGUuZXhwb3J0cyA9IGNsZWFuUFNMR1xuXG52YXIgVW5pb25GaW5kID0gcmVxdWlyZSgndW5pb24tZmluZCcpXG52YXIgYm94SW50ZXJzZWN0ID0gcmVxdWlyZSgnYm94LWludGVyc2VjdCcpXG52YXIgY29tcGFyZUNlbGwgPSByZXF1aXJlKCdjb21wYXJlLWNlbGwnKVxudmFyIHNlZ3NlZyA9IHJlcXVpcmUoJ3JvYnVzdC1zZWdtZW50LWludGVyc2VjdCcpXG52YXIgcmF0ID0gcmVxdWlyZSgnYmlnLXJhdCcpXG52YXIgcmF0Q21wID0gcmVxdWlyZSgnYmlnLXJhdC9jbXAnKVxudmFyIHJhdFRvRmxvYXQgPSByZXF1aXJlKCdiaWctcmF0L3RvLWZsb2F0JylcbnZhciByYXRWZWMgPSByZXF1aXJlKCdyYXQtdmVjJylcbnZhciBuZXh0YWZ0ZXIgPSByZXF1aXJlKCduZXh0YWZ0ZXInKVxuXG52YXIgc29sdmVJbnRlcnNlY3Rpb24gPSByZXF1aXJlKCcuL2xpYi9yYXQtc2VnLWludGVyc2VjdCcpXG5cbi8vQm91bmRzIG9uIGEgcmF0aW9uYWwgbnVtYmVyIHdoZW4gcm91bmRlZCB0byBhIGZsb2F0XG5mdW5jdGlvbiBib3VuZFJhdChyKSB7XG4gIHZhciBmID0gcmF0VG9GbG9hdChyKVxuICB2YXIgY21wID0gcmF0Q21wKHJhdChmKSwgcilcbiAgaWYoY21wIDwgMCkge1xuICAgIHJldHVybiBbZiwgbmV4dGFmdGVyKGYsIEluZmluaXR5KV1cbiAgfSBlbHNlIGlmKGNtcCA+IDApIHtcbiAgICByZXR1cm4gW25leHRhZnRlcihmLCAtSW5maW5pdHkpLCBmXVxuICB9IGVsc2Uge1xuICAgIHJldHVybiBbZiwgZl1cbiAgfVxufVxuXG4vL0NvbnZlcnQgYSBsaXN0IG9mIGVkZ2VzIGluIGEgcHNsZyB0byBib3VuZGluZyBib3hlc1xuZnVuY3Rpb24gYm91bmRFZGdlcyhwb2ludHMsIGVkZ2VzKSB7XG4gIHZhciBib3VuZHMgPSBuZXcgQXJyYXkoZWRnZXMubGVuZ3RoKVxuICBmb3IodmFyIGk9MDsgaTxlZGdlcy5sZW5ndGg7ICsraSkge1xuICAgIHZhciBlID0gZWRnZXNbaV1cbiAgICB2YXIgYSA9IHBvaW50c1tlWzBdXVxuICAgIHZhciBiID0gcG9pbnRzW2VbMV1dXG4gICAgYm91bmRzW2ldID0gW1xuICAgICAgTWF0aC5taW4oYVswXSwgYlswXSksXG4gICAgICBNYXRoLm1pbihhWzFdLCBiWzFdKSxcbiAgICAgIE1hdGgubWF4KGFbMF0sIGJbMF0pLFxuICAgICAgTWF0aC5tYXgoYVsxXSwgYlsxXSkgXVxuICB9XG4gIHJldHVybiBib3VuZHNcbn1cblxuLy9Db252ZXJ0IGEgbGlzdCBvZiBwb2ludHMgaW50byBib3VuZGluZyBib3hlcyBieSBkdXBsaWNhdGluZyBjb29yZHNcbmZ1bmN0aW9uIGJvdW5kUG9pbnRzKHBvaW50cykge1xuICB2YXIgYm91bmRzID0gbmV3IEFycmF5KHBvaW50cy5sZW5ndGgpXG4gIGZvcih2YXIgaT0wOyBpPHBvaW50cy5sZW5ndGg7ICsraSkge1xuICAgIHZhciBwID0gcG9pbnRzW2ldXG4gICAgYm91bmRzW2ldID0gWyBwWzBdLCBwWzFdLCBwWzBdLCBwWzFdIF1cbiAgfVxuICByZXR1cm4gYm91bmRzXG59XG5cbi8vRmluZCBhbGwgcGFpcnMgb2YgY3Jvc3NpbmcgZWRnZXMgaW4gYSBwc2xnIChnaXZlbiBlZGdlIGJvdW5kcylcbmZ1bmN0aW9uIGdldENyb3NzaW5ncyhwb2ludHMsIGVkZ2VzLCBlZGdlQm91bmRzKSB7XG4gIHZhciByZXN1bHQgPSBbXVxuICBib3hJbnRlcnNlY3QoZWRnZUJvdW5kcywgZnVuY3Rpb24oaSwgaikge1xuICAgIHZhciBlID0gZWRnZXNbaV1cbiAgICB2YXIgZiA9IGVkZ2VzW2pdXG4gICAgaWYoZVswXSA9PT0gZlswXSB8fCBlWzBdID09PSBmWzFdIHx8XG4gICAgICAgZVsxXSA9PT0gZlswXSB8fCBlWzFdID09PSBmWzFdKSB7XG4gICAgICAgICByZXR1cm5cbiAgICB9XG4gICAgdmFyIGEgPSBwb2ludHNbZVswXV1cbiAgICB2YXIgYiA9IHBvaW50c1tlWzFdXVxuICAgIHZhciBjID0gcG9pbnRzW2ZbMF1dXG4gICAgdmFyIGQgPSBwb2ludHNbZlsxXV1cbiAgICBpZihzZWdzZWcoYSwgYiwgYywgZCkpIHtcbiAgICAgIHJlc3VsdC5wdXNoKFtpLCBqXSlcbiAgICB9XG4gIH0pXG4gIHJldHVybiByZXN1bHRcbn1cblxuLy9GaW5kIGFsbCBwYWlycyBvZiBjcm9zc2luZyB2ZXJ0aWNlcyBpbiBhIHBzbGcgKGdpdmVuIGVkZ2UvdmVydCBib3VuZHMpXG5mdW5jdGlvbiBnZXRUSnVuY3Rpb25zKHBvaW50cywgZWRnZXMsIGVkZ2VCb3VuZHMsIHZlcnRCb3VuZHMpIHtcbiAgdmFyIHJlc3VsdCA9IFtdXG4gIGJveEludGVyc2VjdChlZGdlQm91bmRzLCB2ZXJ0Qm91bmRzLCBmdW5jdGlvbihpLCB2KSB7XG4gICAgdmFyIGUgPSBlZGdlc1tpXVxuICAgIGlmKGVbMF0gPT09IHYgfHwgZVsxXSA9PT0gdikge1xuICAgICAgcmV0dXJuXG4gICAgfVxuICAgIHZhciBwID0gcG9pbnRzW3ZdXG4gICAgdmFyIGEgPSBwb2ludHNbZVswXV1cbiAgICB2YXIgYiA9IHBvaW50c1tlWzFdXVxuICAgIGlmKHNlZ3NlZyhhLCBiLCBwLCBwKSkge1xuICAgICAgcmVzdWx0LnB1c2goW2ksIHZdKVxuICAgIH1cbiAgfSlcbiAgcmV0dXJuIHJlc3VsdFxufVxuXG5cbi8vQ3V0IGVkZ2VzIGFsb25nIGNyb3NzaW5ncy90anVuY3Rpb25zXG5mdW5jdGlvbiBjdXRFZGdlcyhmbG9hdFBvaW50cywgZWRnZXMsIGNyb3NzaW5ncywganVuY3Rpb25zLCB1c2VDb2xvcikge1xuXG4gIC8vQ29udmVydCBjcm9zc2luZ3MgaW50byB0anVuY3Rpb25zIGJ5IGNvbnN0cnVjdGluZyByYXRpb25hbCBwb2ludHNcbiAgdmFyIHJhdFBvaW50cyA9IFtdXG4gIGZvcih2YXIgaT0wOyBpPGNyb3NzaW5ncy5sZW5ndGg7ICsraSkge1xuICAgIHZhciBjcm9zc2luZyA9IGNyb3NzaW5nc1tpXVxuICAgIHZhciBlID0gY3Jvc3NpbmdbMF1cbiAgICB2YXIgZiA9IGNyb3NzaW5nWzFdXG4gICAgdmFyIGVlID0gZWRnZXNbZV1cbiAgICB2YXIgZWYgPSBlZGdlc1tmXVxuICAgIHZhciB4ID0gc29sdmVJbnRlcnNlY3Rpb24oXG4gICAgICByYXRWZWMoZmxvYXRQb2ludHNbZWVbMF1dKSxcbiAgICAgIHJhdFZlYyhmbG9hdFBvaW50c1tlZVsxXV0pLFxuICAgICAgcmF0VmVjKGZsb2F0UG9pbnRzW2VmWzBdXSksXG4gICAgICByYXRWZWMoZmxvYXRQb2ludHNbZWZbMV1dKSlcbiAgICBpZigheCkge1xuICAgICAgLy9TZWdtZW50cyBhcmUgcGFyYWxsZWwsIHNob3VsZCBhbHJlYWR5IGJlIGhhbmRsZWQgYnkgdC1qdW5jdGlvbnNcbiAgICAgIGNvbnRpbnVlXG4gICAgfVxuICAgIHZhciBpZHggPSByYXRQb2ludHMubGVuZ3RoICsgZmxvYXRQb2ludHMubGVuZ3RoXG4gICAgcmF0UG9pbnRzLnB1c2goeClcbiAgICBqdW5jdGlvbnMucHVzaChbZSwgaWR4XSwgW2YsIGlkeF0pXG4gIH1cblxuICAvL1NvcnQgdGp1bmN0aW9uc1xuICBmdW5jdGlvbiBnZXRQb2ludChpZHgpIHtcbiAgICBpZihpZHggPj0gZmxvYXRQb2ludHMubGVuZ3RoKSB7XG4gICAgICByZXR1cm4gcmF0UG9pbnRzW2lkeC1mbG9hdFBvaW50cy5sZW5ndGhdXG4gICAgfVxuICAgIHZhciBwID0gZmxvYXRQb2ludHNbaWR4XVxuICAgIHJldHVybiBbIHJhdChwWzBdKSwgcmF0KHBbMV0pIF1cbiAgfVxuICBqdW5jdGlvbnMuc29ydChmdW5jdGlvbihhLCBiKSB7XG4gICAgaWYoYVswXSAhPT0gYlswXSkge1xuICAgICAgcmV0dXJuIGFbMF0gLSBiWzBdXG4gICAgfVxuICAgIHZhciB1ID0gZ2V0UG9pbnQoYVsxXSlcbiAgICB2YXIgdiA9IGdldFBvaW50KGJbMV0pXG4gICAgcmV0dXJuIHJhdENtcCh1WzBdLCB2WzBdKSB8fCByYXRDbXAodVsxXSwgdlsxXSlcbiAgfSlcblxuICAvL1NwbGl0IGVkZ2VzIGFsb25nIGp1bmN0aW9uc1xuICBmb3IodmFyIGk9anVuY3Rpb25zLmxlbmd0aC0xOyBpPj0wOyAtLWkpIHtcbiAgICB2YXIganVuY3Rpb24gPSBqdW5jdGlvbnNbaV1cbiAgICB2YXIgZSA9IGp1bmN0aW9uWzBdXG5cbiAgICB2YXIgZWRnZSA9IGVkZ2VzW2VdXG4gICAgdmFyIHMgPSBlZGdlWzBdXG4gICAgdmFyIHQgPSBlZGdlWzFdXG5cbiAgICAvL0NoZWNrIGlmIGVkZ2UgaXMgbm90IGxleGljb2dyYXBoaWNhbGx5IHNvcnRlZFxuICAgIHZhciBhID0gZmxvYXRQb2ludHNbc11cbiAgICB2YXIgYiA9IGZsb2F0UG9pbnRzW3RdXG4gICAgaWYoKChhWzBdIC0gYlswXSkgfHwgKGFbMV0gLSBiWzFdKSkgPCAwKSB7XG4gICAgICB2YXIgdG1wID0gc1xuICAgICAgcyA9IHRcbiAgICAgIHQgPSB0bXBcbiAgICB9XG5cbiAgICAvL1NwbGl0IGxlYWRpbmcgZWRnZVxuICAgIGVkZ2VbMF0gPSBzXG4gICAgdmFyIGxhc3QgPSBlZGdlWzFdID0ganVuY3Rpb25bMV1cblxuICAgIC8vSWYgd2UgYXJlIGdyb3VwaW5nIGVkZ2VzIGJ5IGNvbG9yLCByZW1lbWJlciB0byB0cmFjayBkYXRhXG4gICAgdmFyIGNvbG9yXG4gICAgaWYodXNlQ29sb3IpIHtcbiAgICAgIGNvbG9yID0gZWRnZVsyXVxuICAgIH1cblxuICAgIC8vU3BsaXQgb3RoZXIgZWRnZXNcbiAgICB3aGlsZShpID4gMCAmJiBqdW5jdGlvbnNbaS0xXVswXSA9PT0gZSkge1xuICAgICAgdmFyIGp1bmN0aW9uID0ganVuY3Rpb25zWy0taV1cbiAgICAgIHZhciBuZXh0ID0ganVuY3Rpb25bMV1cbiAgICAgIGlmKHVzZUNvbG9yKSB7XG4gICAgICAgIGVkZ2VzLnB1c2goW2xhc3QsIG5leHQsIGNvbG9yXSlcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGVkZ2VzLnB1c2goW2xhc3QsIG5leHRdKVxuICAgICAgfVxuICAgICAgbGFzdCA9IG5leHRcbiAgICB9XG5cbiAgICAvL0FkZCBmaW5hbCBlZGdlXG4gICAgaWYodXNlQ29sb3IpIHtcbiAgICAgIGVkZ2VzLnB1c2goW2xhc3QsIHQsIGNvbG9yXSlcbiAgICB9IGVsc2Uge1xuICAgICAgZWRnZXMucHVzaChbbGFzdCwgdF0pXG4gICAgfVxuICB9XG5cbiAgLy9SZXR1cm4gY29uc3RydWN0ZWQgcmF0aW9uYWwgcG9pbnRzXG4gIHJldHVybiByYXRQb2ludHNcbn1cblxuLy9NZXJnZSBvdmVybGFwcGluZyBwb2ludHNcbmZ1bmN0aW9uIGRlZHVwUG9pbnRzKGZsb2F0UG9pbnRzLCByYXRQb2ludHMsIGZsb2F0Qm91bmRzKSB7XG4gIHZhciBudW1Qb2ludHMgPSBmbG9hdFBvaW50cy5sZW5ndGggKyByYXRQb2ludHMubGVuZ3RoXG4gIHZhciB1ZiAgICAgICAgPSBuZXcgVW5pb25GaW5kKG51bVBvaW50cylcblxuICAvL0NvbXB1dGUgcmF0aW9uYWwgYm91bmRzXG4gIHZhciBib3VuZHMgPSBmbG9hdEJvdW5kc1xuICBmb3IodmFyIGk9MDsgaTxyYXRQb2ludHMubGVuZ3RoOyArK2kpIHtcbiAgICB2YXIgcCA9IHJhdFBvaW50c1tpXVxuICAgIHZhciB4YiA9IGJvdW5kUmF0KHBbMF0pXG4gICAgdmFyIHliID0gYm91bmRSYXQocFsxXSlcbiAgICBib3VuZHMucHVzaChbIHhiWzBdLCB5YlswXSwgeGJbMV0sIHliWzFdIF0pXG4gICAgZmxvYXRQb2ludHMucHVzaChbIHJhdFRvRmxvYXQocFswXSksIHJhdFRvRmxvYXQocFsxXSkgXSlcbiAgfVxuXG4gIC8vTGluayBhbGwgcG9pbnRzIHdpdGggb3ZlciBsYXBwaW5nIGJveGVzXG4gIGJveEludGVyc2VjdChib3VuZHMsIGZ1bmN0aW9uKGksIGopIHtcbiAgICB1Zi5saW5rKGksIGopXG4gIH0pXG5cbiAgLy9DYWxsIGZpbmQgb24gZWFjaCBwb2ludCB0byBnZXQgYSByZWxhYmVsaW5nXG4gIHZhciBwdHIgPSAwXG4gIHZhciBub0R1cGVzID0gdHJ1ZVxuICB2YXIgbGFiZWxzID0gbmV3IEFycmF5KG51bVBvaW50cylcbiAgZm9yKHZhciBpPTA7IGk8bnVtUG9pbnRzOyArK2kpIHtcbiAgICB2YXIgaiA9IHVmLmZpbmQoaSlcbiAgICBpZihqID09PSBpKSB7XG4gICAgICAvL0lmIG5vdCBhIGR1cGxpY2F0ZSwgdGhlbiBkb24ndCBib3RoZXJcbiAgICAgIGxhYmVsc1tpXSA9IHB0clxuICAgICAgZmxvYXRQb2ludHNbcHRyKytdID0gZmxvYXRQb2ludHNbaV1cbiAgICB9IGVsc2Uge1xuICAgICAgLy9DbGVhciBuby1kdXBlcyBmbGFnLCB6ZXJvIG91dCBsYWJlbFxuICAgICAgbm9EdXBlcyA9IGZhbHNlXG4gICAgICBsYWJlbHNbaV0gPSAtMVxuICAgIH1cbiAgfVxuICBmbG9hdFBvaW50cy5sZW5ndGggPSBwdHJcblxuICAvL0lmIG5vIGR1cGxpY2F0ZXMsIHJldHVybiBudWxsIHRvIHNpZ25hbCB0ZXJtaW5hdGlvblxuICBpZihub0R1cGVzKSB7XG4gICAgcmV0dXJuIG51bGxcbiAgfVxuXG4gIC8vRG8gYSBzZWNvbmQgcGFzcyB0byBmaXggdXAgbWlzc2luZyBsYWJlbHNcbiAgZm9yKHZhciBpPTA7IGk8bnVtUG9pbnRzOyArK2kpIHtcbiAgICBpZihsYWJlbHNbaV0gPCAwKSB7XG4gICAgICBsYWJlbHNbaV0gPSBsYWJlbHNbdWYuZmluZChpKV1cbiAgICB9XG4gIH1cblxuICAvL1JldHVybiByZXN1bHRpbmcgdW5pb24tZmluZCBkYXRhIHN0cnVjdHVyZVxuICByZXR1cm4gbGFiZWxzXG59XG5cbmZ1bmN0aW9uIGNvbXBhcmVMZXgyKGEsYikgeyByZXR1cm4gKGFbMF0tYlswXSkgfHwgKGFbMV0tYlsxXSkgfVxuZnVuY3Rpb24gY29tcGFyZUxleDMoYSxiKSB7XG4gIHZhciBkID0gKGFbMF0gLSBiWzBdKSB8fCAoYVsxXSAtIGJbMV0pXG4gIGlmKGQpIHtcbiAgICByZXR1cm4gZFxuICB9XG4gIGlmKGFbMl0gPCBiWzJdKSB7XG4gICAgcmV0dXJuIC0xXG4gIH0gZWxzZSBpZihhWzJdID4gYlsyXSkge1xuICAgIHJldHVybiAxXG4gIH1cbiAgcmV0dXJuIDBcbn1cblxuLy9SZW1vdmUgZHVwbGljYXRlIGVkZ2UgbGFiZWxzXG5mdW5jdGlvbiBkZWR1cEVkZ2VzKGVkZ2VzLCBsYWJlbHMsIHVzZUNvbG9yKSB7XG4gIGlmKGVkZ2VzLmxlbmd0aCA9PT0gMCkge1xuICAgIHJldHVyblxuICB9XG4gIGlmKGxhYmVscykge1xuICAgIGZvcih2YXIgaT0wOyBpPGVkZ2VzLmxlbmd0aDsgKytpKSB7XG4gICAgICB2YXIgZSA9IGVkZ2VzW2ldXG4gICAgICB2YXIgYSA9IGxhYmVsc1tlWzBdXVxuICAgICAgdmFyIGIgPSBsYWJlbHNbZVsxXV1cbiAgICAgIGVbMF0gPSBNYXRoLm1pbihhLCBiKVxuICAgICAgZVsxXSA9IE1hdGgubWF4KGEsIGIpXG4gICAgfVxuICB9IGVsc2Uge1xuICAgIGZvcih2YXIgaT0wOyBpPGVkZ2VzLmxlbmd0aDsgKytpKSB7XG4gICAgICB2YXIgZSA9IGVkZ2VzW2ldXG4gICAgICB2YXIgYSA9IGVbMF1cbiAgICAgIHZhciBiID0gZVsxXVxuICAgICAgZVswXSA9IE1hdGgubWluKGEsIGIpXG4gICAgICBlWzFdID0gTWF0aC5tYXgoYSwgYilcbiAgICB9XG4gIH1cbiAgaWYodXNlQ29sb3IpIHtcbiAgICBlZGdlcy5zb3J0KGNvbXBhcmVMZXgzKVxuICB9IGVsc2Uge1xuICAgIGVkZ2VzLnNvcnQoY29tcGFyZUxleDIpXG4gIH1cbiAgdmFyIHB0ciA9IDFcbiAgZm9yKHZhciBpPTE7IGk8ZWRnZXMubGVuZ3RoOyArK2kpIHtcbiAgICB2YXIgcHJldiA9IGVkZ2VzW2ktMV1cbiAgICB2YXIgbmV4dCA9IGVkZ2VzW2ldXG4gICAgaWYobmV4dFswXSA9PT0gcHJldlswXSAmJiBuZXh0WzFdID09PSBwcmV2WzFdICYmXG4gICAgICAoIXVzZUNvbG9yIHx8IG5leHRbMl0gPT09IHByZXZbMl0pKSB7XG4gICAgICBjb250aW51ZVxuICAgIH1cbiAgICBlZGdlc1twdHIrK10gPSBuZXh0XG4gIH1cbiAgZWRnZXMubGVuZ3RoID0gcHRyXG59XG5cbi8vUmVwZWF0IHVudGlsIGNvbnZlcmdlbmNlXG5mdW5jdGlvbiBzbmFwUm91bmQocG9pbnRzLCBlZGdlcywgdXNlQ29sb3IpIHtcblxuICAvLyAxLiBmaW5kIGVkZ2UgY3Jvc3NpbmdzXG4gIHZhciBlZGdlQm91bmRzID0gYm91bmRFZGdlcyhwb2ludHMsIGVkZ2VzKVxuICB2YXIgY3Jvc3NpbmdzICA9IGdldENyb3NzaW5ncyhwb2ludHMsIGVkZ2VzLCBlZGdlQm91bmRzKVxuXG4gIC8vIDIuIGZpbmQgdC1qdW5jdGlvbnNcbiAgdmFyIHZlcnRCb3VuZHMgPSBib3VuZFBvaW50cyhwb2ludHMpXG4gIHZhciB0anVuY3Rpb25zID0gZ2V0VEp1bmN0aW9ucyhwb2ludHMsIGVkZ2VzLCBlZGdlQm91bmRzLCB2ZXJ0Qm91bmRzKVxuXG4gIC8vIDMuIGN1dCBlZGdlcywgY29uc3RydWN0IHJhdGlvbmFsIHBvaW50c1xuICB2YXIgcmF0UG9pbnRzICA9IGN1dEVkZ2VzKHBvaW50cywgZWRnZXMsIGNyb3NzaW5ncywgdGp1bmN0aW9ucywgdXNlQ29sb3IpXG5cbiAgLy8gNC4gZGVkdXBlIHZlcnRzXG4gIHZhciBsYWJlbHMgICAgID0gZGVkdXBQb2ludHMocG9pbnRzLCByYXRQb2ludHMsIHZlcnRCb3VuZHMpXG5cbiAgLy8gNi4gZGVkdXBlIGVkZ2VzXG4gIGRlZHVwRWRnZXMoZWRnZXMsIGxhYmVscywgdXNlQ29sb3IpXG5cbiAgLy8gNS4gY2hlY2sgdGVybWluYXRpb25cbiAgaWYoIWxhYmVscykge1xuICAgIHJldHVybiAoY3Jvc3NpbmdzLmxlbmd0aCA+IDAgfHwgdGp1bmN0aW9ucy5sZW5ndGggPiAwKVxuICB9XG5cbiAgLy8gTW9yZSBpdGVyYXRpb25zIG5lY2Vzc2FyeVxuICByZXR1cm4gdHJ1ZVxufVxuXG4vL01haW4gbG9vcCwgcnVucyBQU0xHIGNsZWFuIHVwIHVudGlsIGNvbXBsZXRpb25cbmZ1bmN0aW9uIGNsZWFuUFNMRyhwb2ludHMsIGVkZ2VzLCBjb2xvcnMpIHtcbiAgdmFyIG1vZGlmaWVkID0gZmFsc2VcblxuICAvL0lmIHVzaW5nIGNvbG9ycywgYXVnbWVudCBlZGdlcyB3aXRoIGNvbG9yIGRhdGFcbiAgdmFyIHByZXZFZGdlc1xuICBpZihjb2xvcnMpIHtcbiAgICBwcmV2RWRnZXMgPSBlZGdlc1xuICAgIHZhciBhdWdFZGdlcyA9IG5ldyBBcnJheShlZGdlcy5sZW5ndGgpXG4gICAgZm9yKHZhciBpPTA7IGk8ZWRnZXMubGVuZ3RoOyArK2kpIHtcbiAgICAgIHZhciBlID0gZWRnZXNbaV1cbiAgICAgIGF1Z0VkZ2VzW2ldID0gW2VbMF0sIGVbMV0sIGNvbG9yc1tpXV1cbiAgICB9XG4gICAgZWRnZXMgPSBhdWdFZGdlc1xuICB9XG5cbiAgLy9SdW4gc25hcCByb3VuZGluZyB1bnRpbCBjb252ZXJnZW5jZVxuICB3aGlsZShzbmFwUm91bmQocG9pbnRzLCBlZGdlcywgISFjb2xvcnMpKSB7XG4gICAgbW9kaWZpZWQgPSB0cnVlXG4gIH1cblxuICAvL1N0cmlwIGNvbG9yIHRhZ3NcbiAgaWYoISFjb2xvcnMgJiYgbW9kaWZpZWQpIHtcbiAgICBwcmV2RWRnZXMubGVuZ3RoID0gMFxuICAgIGNvbG9ycy5sZW5ndGggPSAwXG4gICAgZm9yKHZhciBpPTA7IGk8ZWRnZXMubGVuZ3RoOyArK2kpIHtcbiAgICAgIHZhciBlID0gZWRnZXNbaV1cbiAgICAgIHByZXZFZGdlcy5wdXNoKFtlWzBdLCBlWzFdXSlcbiAgICAgIGNvbG9ycy5wdXNoKGVbMl0pXG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIG1vZGlmaWVkXG59XG4iLCIndXNlIHN0cmljdCdcblxuLy9UT0RPOiBNb3ZlIHRoaXMgdG8gYSBzZXBhcmF0ZSBtb2R1bGVcblxubW9kdWxlLmV4cG9ydHMgPSBzb2x2ZUludGVyc2VjdGlvblxuXG52YXIgcmF0TXVsID0gcmVxdWlyZSgnYmlnLXJhdC9tdWwnKVxudmFyIHJhdERpdiA9IHJlcXVpcmUoJ2JpZy1yYXQvZGl2JylcbnZhciByYXRTdWIgPSByZXF1aXJlKCdiaWctcmF0L3N1YicpXG52YXIgcmF0U2lnbiA9IHJlcXVpcmUoJ2JpZy1yYXQvc2lnbicpXG52YXIgcnZTdWIgPSByZXF1aXJlKCdyYXQtdmVjL3N1YicpXG52YXIgcnZBZGQgPSByZXF1aXJlKCdyYXQtdmVjL2FkZCcpXG52YXIgcnZNdWxzID0gcmVxdWlyZSgncmF0LXZlYy9tdWxzJylcblxudmFyIHRvRmxvYXQgPSByZXF1aXJlKCdiaWctcmF0L3RvLWZsb2F0JylcblxuZnVuY3Rpb24gcmF0UGVycChhLCBiKSB7XG4gIHJldHVybiByYXRTdWIocmF0TXVsKGFbMF0sIGJbMV0pLCByYXRNdWwoYVsxXSwgYlswXSkpXG59XG5cbi8vU29sdmUgZm9yIGludGVyc2VjdGlvblxuLy8gIHggPSBhICsgdCAoYi1hKVxuLy8gICh4IC0gYykgXiAoZC1jKSA9IDBcbi8vICAodCAqIChiLWEpICsgKGEtYykgKSBeIChkLWMpID0gMFxuLy8gIHQgKiAoYi1hKV4oZC1jKSA9IChkLWMpXihhLWMpXG4vLyAgdCA9IChkLWMpXihhLWMpIC8gKGItYSleKGQtYylcblxuZnVuY3Rpb24gc29sdmVJbnRlcnNlY3Rpb24oYSwgYiwgYywgZCkge1xuICB2YXIgYmEgPSBydlN1YihiLCBhKVxuICB2YXIgZGMgPSBydlN1YihkLCBjKVxuXG4gIHZhciBiYVhkYyA9IHJhdFBlcnAoYmEsIGRjKVxuXG4gIGlmKHJhdFNpZ24oYmFYZGMpID09PSAwKSB7XG4gICAgcmV0dXJuIG51bGxcbiAgfVxuXG4gIHZhciBhYyA9IHJ2U3ViKGEsIGMpXG4gIHZhciBkY1hhYyA9IHJhdFBlcnAoZGMsIGFjKVxuXG4gIHZhciB0ID0gcmF0RGl2KGRjWGFjLCBiYVhkYylcblxuICByZXR1cm4gcnZBZGQoYSwgcnZNdWxzKGJhLCB0KSlcbn1cbiIsIid1c2Ugc3RyaWN0J1xuXG52YXIgcmF0aW9uYWxpemUgPSByZXF1aXJlKCcuL2xpYi9yYXRpb25hbGl6ZScpXG5cbm1vZHVsZS5leHBvcnRzID0gYWRkXG5cbmZ1bmN0aW9uIGFkZChhLCBiKSB7XG4gIHJldHVybiByYXRpb25hbGl6ZShcbiAgICBhWzBdLm11bChiWzFdKS5hZGQoYlswXS5tdWwoYVsxXSkpLFxuICAgIGFbMV0ubXVsKGJbMV0pKVxufVxuIiwiJ3VzZSBzdHJpY3QnXG5cbm1vZHVsZS5leHBvcnRzID0gY21wXG5cbmZ1bmN0aW9uIGNtcChhLCBiKSB7XG4gICAgcmV0dXJuIGFbMF0ubXVsKGJbMV0pLmNtcChiWzBdLm11bChhWzFdKSlcbn1cbiIsIid1c2Ugc3RyaWN0J1xuXG52YXIgcmF0aW9uYWxpemUgPSByZXF1aXJlKCcuL2xpYi9yYXRpb25hbGl6ZScpXG5cbm1vZHVsZS5leHBvcnRzID0gZGl2XG5cbmZ1bmN0aW9uIGRpdihhLCBiKSB7XG4gIHJldHVybiByYXRpb25hbGl6ZShhWzBdLm11bChiWzFdKSwgYVsxXS5tdWwoYlswXSkpXG59XG4iLCIndXNlIHN0cmljdCdcblxudmFyIGlzUmF0ID0gcmVxdWlyZSgnLi9pcy1yYXQnKVxudmFyIGlzQk4gPSByZXF1aXJlKCcuL2xpYi9pcy1ibicpXG52YXIgbnVtMmJuID0gcmVxdWlyZSgnLi9saWIvbnVtLXRvLWJuJylcbnZhciBzdHIyYm4gPSByZXF1aXJlKCcuL2xpYi9zdHItdG8tYm4nKVxudmFyIHJhdGlvbmFsaXplID0gcmVxdWlyZSgnLi9saWIvcmF0aW9uYWxpemUnKVxudmFyIGRpdiA9IHJlcXVpcmUoJy4vZGl2JylcblxubW9kdWxlLmV4cG9ydHMgPSBtYWtlUmF0aW9uYWxcblxuZnVuY3Rpb24gbWFrZVJhdGlvbmFsKG51bWVyLCBkZW5vbSkge1xuICBpZihpc1JhdChudW1lcikpIHtcbiAgICBpZihkZW5vbSkge1xuICAgICAgcmV0dXJuIGRpdihudW1lciwgbWFrZVJhdGlvbmFsKGRlbm9tKSlcbiAgICB9XG4gICAgcmV0dXJuIFtudW1lclswXS5jbG9uZSgpLCBudW1lclsxXS5jbG9uZSgpXVxuICB9XG4gIHZhciBzaGlmdCA9IDBcbiAgdmFyIGEsIGJcbiAgaWYoaXNCTihudW1lcikpIHtcbiAgICBhID0gbnVtZXIuY2xvbmUoKVxuICB9IGVsc2UgaWYodHlwZW9mIG51bWVyID09PSAnc3RyaW5nJykge1xuICAgIGEgPSBzdHIyYm4obnVtZXIpXG4gIH0gZWxzZSBpZihudW1lciA9PT0gMCkge1xuICAgIHJldHVybiBbbnVtMmJuKDApLCBudW0yYm4oMSldXG4gIH0gZWxzZSBpZihudW1lciA9PT0gTWF0aC5mbG9vcihudW1lcikpIHtcbiAgICBhID0gbnVtMmJuKG51bWVyKVxuICB9IGVsc2Uge1xuICAgIHdoaWxlKG51bWVyICE9PSBNYXRoLmZsb29yKG51bWVyKSkge1xuICAgICAgbnVtZXIgPSBudW1lciAqIE1hdGgucG93KDIsIDI1NilcbiAgICAgIHNoaWZ0IC09IDI1NlxuICAgIH1cbiAgICBhID0gbnVtMmJuKG51bWVyKVxuICB9XG4gIGlmKGlzUmF0KGRlbm9tKSkge1xuICAgIGEubXVsKGRlbm9tWzFdKVxuICAgIGIgPSBkZW5vbVswXS5jbG9uZSgpXG4gIH0gZWxzZSBpZihpc0JOKGRlbm9tKSkge1xuICAgIGIgPSBkZW5vbS5jbG9uZSgpXG4gIH0gZWxzZSBpZih0eXBlb2YgZGVub20gPT09ICdzdHJpbmcnKSB7XG4gICAgYiA9IHN0cjJibihkZW5vbSlcbiAgfSBlbHNlIGlmKCFkZW5vbSkge1xuICAgIGIgPSBudW0yYm4oMSlcbiAgfSBlbHNlIGlmKGRlbm9tID09PSBNYXRoLmZsb29yKGRlbm9tKSkge1xuICAgIGIgPSBudW0yYm4oZGVub20pXG4gIH0gZWxzZSB7XG4gICAgd2hpbGUoZGVub20gIT09IE1hdGguZmxvb3IoZGVub20pKSB7XG4gICAgICBkZW5vbSA9IGRlbm9tICogTWF0aC5wb3coMiwgMjU2KVxuICAgICAgc2hpZnQgKz0gMjU2XG4gICAgfVxuICAgIGIgPSBudW0yYm4oZGVub20pXG4gIH1cbiAgaWYoc2hpZnQgPiAwKSB7XG4gICAgYSA9IGEuc2hsbihzaGlmdClcbiAgfSBlbHNlIGlmKHNoaWZ0IDwgMCkge1xuICAgIGIgPSBiLnNobG4oLXNoaWZ0KVxuICB9XG4gIHJldHVybiByYXRpb25hbGl6ZShhLCBiKVxufVxuIiwiJ3VzZSBzdHJpY3QnXG5cbnZhciBpc0JOID0gcmVxdWlyZSgnLi9saWIvaXMtYm4nKVxuXG5tb2R1bGUuZXhwb3J0cyA9IGlzUmF0XG5cbmZ1bmN0aW9uIGlzUmF0KHgpIHtcbiAgcmV0dXJuIEFycmF5LmlzQXJyYXkoeCkgJiYgeC5sZW5ndGggPT09IDIgJiYgaXNCTih4WzBdKSAmJiBpc0JOKHhbMV0pXG59XG4iLCIndXNlIHN0cmljdCdcblxudmFyIGJuID0gcmVxdWlyZSgnYm4uanMnKVxuXG5tb2R1bGUuZXhwb3J0cyA9IHNpZ25cblxuZnVuY3Rpb24gc2lnbih4KSB7XG4gIHJldHVybiB4LmNtcChuZXcgYm4oMCkpXG59XG4iLCIndXNlIHN0cmljdCdcblxubW9kdWxlLmV4cG9ydHMgPSBibjJudW1cblxuLy9UT0RPOiBNYWtlIHRoaXMgYmV0dGVyXG5mdW5jdGlvbiBibjJudW0oYikge1xuICB2YXIgbCA9IGIubGVuZ3RoXG4gIHZhciB3b3JkcyA9IGIud29yZHNcbiAgdmFyIG91dCA9IDBcbiAgaWYgKGwgPT09IDEpIHtcbiAgICBvdXQgPSB3b3Jkc1swXVxuICB9IGVsc2UgaWYgKGwgPT09IDIpIHtcbiAgICBvdXQgPSB3b3Jkc1swXSArICh3b3Jkc1sxXSAqIDB4NDAwMDAwMClcbiAgfSBlbHNlIHtcbiAgICB2YXIgb3V0ID0gMFxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbDsgaSsrKSB7XG4gICAgICB2YXIgdyA9IHdvcmRzW2ldXG4gICAgICBvdXQgKz0gdyAqIE1hdGgucG93KDB4NDAwMDAwMCwgaSlcbiAgICB9XG4gIH1cbiAgcmV0dXJuIGIuc2lnbiA/IC1vdXQgOiBvdXRcbn1cbiIsIid1c2Ugc3RyaWN0J1xuXG52YXIgZGIgPSByZXF1aXJlKCdkb3VibGUtYml0cycpXG52YXIgY3R6ID0gcmVxdWlyZSgnYml0LXR3aWRkbGUnKS5jb3VudFRyYWlsaW5nWmVyb3NcblxubW9kdWxlLmV4cG9ydHMgPSBjdHpOdW1iZXJcblxuLy9Db3VudHMgdGhlIG51bWJlciBvZiB0cmFpbGluZyB6ZXJvc1xuZnVuY3Rpb24gY3R6TnVtYmVyKHgpIHtcbiAgdmFyIGwgPSBjdHooZGIubG8oeCkpXG4gIGlmKGwgPCAzMikge1xuICAgIHJldHVybiBsXG4gIH1cbiAgdmFyIGggPSBjdHooZGIuaGkoeCkpXG4gIGlmKGggPiAyMCkge1xuICAgIHJldHVybiA1MlxuICB9XG4gIHJldHVybiBoICsgMzJcbn1cbiIsIid1c2Ugc3RyaWN0J1xuXG52YXIgQk4gPSByZXF1aXJlKCdibi5qcycpXG5cbm1vZHVsZS5leHBvcnRzID0gaXNCTlxuXG4vL1Rlc3QgaWYgeCBpcyBhIGJpZ251bWJlclxuLy9GSVhNRTogb2J2aW91c2x5IHRoaXMgaXMgdGhlIHdyb25nIHdheSB0byBkbyBpdFxuZnVuY3Rpb24gaXNCTih4KSB7XG4gIHJldHVybiB4ICYmIHR5cGVvZiB4ID09PSAnb2JqZWN0JyAmJiBCb29sZWFuKHgud29yZHMpXG59XG4iLCIndXNlIHN0cmljdCdcblxudmFyIEJOID0gcmVxdWlyZSgnYm4uanMnKVxudmFyIGRiID0gcmVxdWlyZSgnZG91YmxlLWJpdHMnKVxuXG5tb2R1bGUuZXhwb3J0cyA9IG51bTJiblxuXG5mdW5jdGlvbiBudW0yYm4oeCkge1xuICB2YXIgZSA9IGRiLmV4cG9uZW50KHgpXG4gIGlmKGUgPCA1Mikge1xuICAgIHJldHVybiBuZXcgQk4oeClcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gKG5ldyBCTih4ICogTWF0aC5wb3coMiwgNTItZSkpKS5zaGxuKGUtNTIpXG4gIH1cbn1cbiIsIid1c2Ugc3RyaWN0J1xuXG52YXIgbnVtMmJuID0gcmVxdWlyZSgnLi9udW0tdG8tYm4nKVxudmFyIHNpZ24gPSByZXF1aXJlKCcuL2JuLXNpZ24nKVxuXG5tb2R1bGUuZXhwb3J0cyA9IHJhdGlvbmFsaXplXG5cbmZ1bmN0aW9uIHJhdGlvbmFsaXplKG51bWVyLCBkZW5vbSkge1xuICB2YXIgc251bWVyID0gc2lnbihudW1lcilcbiAgdmFyIHNkZW5vbSA9IHNpZ24oZGVub20pXG4gIGlmKHNudW1lciA9PT0gMCkge1xuICAgIHJldHVybiBbbnVtMmJuKDApLCBudW0yYm4oMSldXG4gIH1cbiAgaWYoc2Rlbm9tID09PSAwKSB7XG4gICAgcmV0dXJuIFtudW0yYm4oMCksIG51bTJibigwKV1cbiAgfVxuICBpZihzZGVub20gPCAwKSB7XG4gICAgbnVtZXIgPSBudW1lci5uZWcoKVxuICAgIGRlbm9tID0gZGVub20ubmVnKClcbiAgfVxuICB2YXIgZCA9IG51bWVyLmdjZChkZW5vbSlcbiAgaWYoZC5jbXBuKDEpKSB7XG4gICAgcmV0dXJuIFsgbnVtZXIuZGl2KGQpLCBkZW5vbS5kaXYoZCkgXVxuICB9XG4gIHJldHVybiBbIG51bWVyLCBkZW5vbSBdXG59XG4iLCIndXNlIHN0cmljdCdcblxudmFyIEJOID0gcmVxdWlyZSgnYm4uanMnKVxuXG5tb2R1bGUuZXhwb3J0cyA9IHN0cjJCTlxuXG5mdW5jdGlvbiBzdHIyQk4oeCkge1xuICByZXR1cm4gbmV3IEJOKHgpXG59XG4iLCIndXNlIHN0cmljdCdcblxudmFyIHJhdGlvbmFsaXplID0gcmVxdWlyZSgnLi9saWIvcmF0aW9uYWxpemUnKVxuXG5tb2R1bGUuZXhwb3J0cyA9IG11bFxuXG5mdW5jdGlvbiBtdWwoYSwgYikge1xuICByZXR1cm4gcmF0aW9uYWxpemUoYVswXS5tdWwoYlswXSksIGFbMV0ubXVsKGJbMV0pKVxufVxuIiwiLyoqXG4gKiBCaXQgdHdpZGRsaW5nIGhhY2tzIGZvciBKYXZhU2NyaXB0LlxuICpcbiAqIEF1dGhvcjogTWlrb2xhIEx5c2Vua29cbiAqXG4gKiBQb3J0ZWQgZnJvbSBTdGFuZm9yZCBiaXQgdHdpZGRsaW5nIGhhY2sgbGlicmFyeTpcbiAqICAgIGh0dHA6Ly9ncmFwaGljcy5zdGFuZm9yZC5lZHUvfnNlYW5kZXIvYml0aGFja3MuaHRtbFxuICovXG5cblwidXNlIHN0cmljdFwiOyBcInVzZSByZXN0cmljdFwiO1xuXG4vL051bWJlciBvZiBiaXRzIGluIGFuIGludGVnZXJcbnZhciBJTlRfQklUUyA9IDMyO1xuXG4vL0NvbnN0YW50c1xuZXhwb3J0cy5JTlRfQklUUyAgPSBJTlRfQklUUztcbmV4cG9ydHMuSU5UX01BWCAgID0gIDB4N2ZmZmZmZmY7XG5leHBvcnRzLklOVF9NSU4gICA9IC0xPDwoSU5UX0JJVFMtMSk7XG5cbi8vUmV0dXJucyAtMSwgMCwgKzEgZGVwZW5kaW5nIG9uIHNpZ24gb2YgeFxuZXhwb3J0cy5zaWduID0gZnVuY3Rpb24odikge1xuICByZXR1cm4gKHYgPiAwKSAtICh2IDwgMCk7XG59XG5cbi8vQ29tcHV0ZXMgYWJzb2x1dGUgdmFsdWUgb2YgaW50ZWdlclxuZXhwb3J0cy5hYnMgPSBmdW5jdGlvbih2KSB7XG4gIHZhciBtYXNrID0gdiA+PiAoSU5UX0JJVFMtMSk7XG4gIHJldHVybiAodiBeIG1hc2spIC0gbWFzaztcbn1cblxuLy9Db21wdXRlcyBtaW5pbXVtIG9mIGludGVnZXJzIHggYW5kIHlcbmV4cG9ydHMubWluID0gZnVuY3Rpb24oeCwgeSkge1xuICByZXR1cm4geSBeICgoeCBeIHkpICYgLSh4IDwgeSkpO1xufVxuXG4vL0NvbXB1dGVzIG1heGltdW0gb2YgaW50ZWdlcnMgeCBhbmQgeVxuZXhwb3J0cy5tYXggPSBmdW5jdGlvbih4LCB5KSB7XG4gIHJldHVybiB4IF4gKCh4IF4geSkgJiAtKHggPCB5KSk7XG59XG5cbi8vQ2hlY2tzIGlmIGEgbnVtYmVyIGlzIGEgcG93ZXIgb2YgdHdvXG5leHBvcnRzLmlzUG93MiA9IGZ1bmN0aW9uKHYpIHtcbiAgcmV0dXJuICEodiAmICh2LTEpKSAmJiAoISF2KTtcbn1cblxuLy9Db21wdXRlcyBsb2cgYmFzZSAyIG9mIHZcbmV4cG9ydHMubG9nMiA9IGZ1bmN0aW9uKHYpIHtcbiAgdmFyIHIsIHNoaWZ0O1xuICByID0gICAgICh2ID4gMHhGRkZGKSA8PCA0OyB2ID4+Pj0gcjtcbiAgc2hpZnQgPSAodiA+IDB4RkYgICkgPDwgMzsgdiA+Pj49IHNoaWZ0OyByIHw9IHNoaWZ0O1xuICBzaGlmdCA9ICh2ID4gMHhGICAgKSA8PCAyOyB2ID4+Pj0gc2hpZnQ7IHIgfD0gc2hpZnQ7XG4gIHNoaWZ0ID0gKHYgPiAweDMgICApIDw8IDE7IHYgPj4+PSBzaGlmdDsgciB8PSBzaGlmdDtcbiAgcmV0dXJuIHIgfCAodiA+PiAxKTtcbn1cblxuLy9Db21wdXRlcyBsb2cgYmFzZSAxMCBvZiB2XG5leHBvcnRzLmxvZzEwID0gZnVuY3Rpb24odikge1xuICByZXR1cm4gICh2ID49IDEwMDAwMDAwMDApID8gOSA6ICh2ID49IDEwMDAwMDAwMCkgPyA4IDogKHYgPj0gMTAwMDAwMDApID8gNyA6XG4gICAgICAgICAgKHYgPj0gMTAwMDAwMCkgPyA2IDogKHYgPj0gMTAwMDAwKSA/IDUgOiAodiA+PSAxMDAwMCkgPyA0IDpcbiAgICAgICAgICAodiA+PSAxMDAwKSA/IDMgOiAodiA+PSAxMDApID8gMiA6ICh2ID49IDEwKSA/IDEgOiAwO1xufVxuXG4vL0NvdW50cyBudW1iZXIgb2YgYml0c1xuZXhwb3J0cy5wb3BDb3VudCA9IGZ1bmN0aW9uKHYpIHtcbiAgdiA9IHYgLSAoKHYgPj4+IDEpICYgMHg1NTU1NTU1NSk7XG4gIHYgPSAodiAmIDB4MzMzMzMzMzMpICsgKCh2ID4+PiAyKSAmIDB4MzMzMzMzMzMpO1xuICByZXR1cm4gKCh2ICsgKHYgPj4+IDQpICYgMHhGMEYwRjBGKSAqIDB4MTAxMDEwMSkgPj4+IDI0O1xufVxuXG4vL0NvdW50cyBudW1iZXIgb2YgdHJhaWxpbmcgemVyb3NcbmZ1bmN0aW9uIGNvdW50VHJhaWxpbmdaZXJvcyh2KSB7XG4gIHZhciBjID0gMzI7XG4gIHYgJj0gLXY7XG4gIGlmICh2KSBjLS07XG4gIGlmICh2ICYgMHgwMDAwRkZGRikgYyAtPSAxNjtcbiAgaWYgKHYgJiAweDAwRkYwMEZGKSBjIC09IDg7XG4gIGlmICh2ICYgMHgwRjBGMEYwRikgYyAtPSA0O1xuICBpZiAodiAmIDB4MzMzMzMzMzMpIGMgLT0gMjtcbiAgaWYgKHYgJiAweDU1NTU1NTU1KSBjIC09IDE7XG4gIHJldHVybiBjO1xufVxuZXhwb3J0cy5jb3VudFRyYWlsaW5nWmVyb3MgPSBjb3VudFRyYWlsaW5nWmVyb3M7XG5cbi8vUm91bmRzIHRvIG5leHQgcG93ZXIgb2YgMlxuZXhwb3J0cy5uZXh0UG93MiA9IGZ1bmN0aW9uKHYpIHtcbiAgdiArPSB2ID09PSAwO1xuICAtLXY7XG4gIHYgfD0gdiA+Pj4gMTtcbiAgdiB8PSB2ID4+PiAyO1xuICB2IHw9IHYgPj4+IDQ7XG4gIHYgfD0gdiA+Pj4gODtcbiAgdiB8PSB2ID4+PiAxNjtcbiAgcmV0dXJuIHYgKyAxO1xufVxuXG4vL1JvdW5kcyBkb3duIHRvIHByZXZpb3VzIHBvd2VyIG9mIDJcbmV4cG9ydHMucHJldlBvdzIgPSBmdW5jdGlvbih2KSB7XG4gIHYgfD0gdiA+Pj4gMTtcbiAgdiB8PSB2ID4+PiAyO1xuICB2IHw9IHYgPj4+IDQ7XG4gIHYgfD0gdiA+Pj4gODtcbiAgdiB8PSB2ID4+PiAxNjtcbiAgcmV0dXJuIHYgLSAodj4+PjEpO1xufVxuXG4vL0NvbXB1dGVzIHBhcml0eSBvZiB3b3JkXG5leHBvcnRzLnBhcml0eSA9IGZ1bmN0aW9uKHYpIHtcbiAgdiBePSB2ID4+PiAxNjtcbiAgdiBePSB2ID4+PiA4O1xuICB2IF49IHYgPj4+IDQ7XG4gIHYgJj0gMHhmO1xuICByZXR1cm4gKDB4Njk5NiA+Pj4gdikgJiAxO1xufVxuXG52YXIgUkVWRVJTRV9UQUJMRSA9IG5ldyBBcnJheSgyNTYpO1xuXG4oZnVuY3Rpb24odGFiKSB7XG4gIGZvcih2YXIgaT0wOyBpPDI1NjsgKytpKSB7XG4gICAgdmFyIHYgPSBpLCByID0gaSwgcyA9IDc7XG4gICAgZm9yICh2ID4+Pj0gMTsgdjsgdiA+Pj49IDEpIHtcbiAgICAgIHIgPDw9IDE7XG4gICAgICByIHw9IHYgJiAxO1xuICAgICAgLS1zO1xuICAgIH1cbiAgICB0YWJbaV0gPSAociA8PCBzKSAmIDB4ZmY7XG4gIH1cbn0pKFJFVkVSU0VfVEFCTEUpO1xuXG4vL1JldmVyc2UgYml0cyBpbiBhIDMyIGJpdCB3b3JkXG5leHBvcnRzLnJldmVyc2UgPSBmdW5jdGlvbih2KSB7XG4gIHJldHVybiAgKFJFVkVSU0VfVEFCTEVbIHYgICAgICAgICAmIDB4ZmZdIDw8IDI0KSB8XG4gICAgICAgICAgKFJFVkVSU0VfVEFCTEVbKHYgPj4+IDgpICAmIDB4ZmZdIDw8IDE2KSB8XG4gICAgICAgICAgKFJFVkVSU0VfVEFCTEVbKHYgPj4+IDE2KSAmIDB4ZmZdIDw8IDgpICB8XG4gICAgICAgICAgIFJFVkVSU0VfVEFCTEVbKHYgPj4+IDI0KSAmIDB4ZmZdO1xufVxuXG4vL0ludGVybGVhdmUgYml0cyBvZiAyIGNvb3JkaW5hdGVzIHdpdGggMTYgYml0cy4gIFVzZWZ1bCBmb3IgZmFzdCBxdWFkdHJlZSBjb2Rlc1xuZXhwb3J0cy5pbnRlcmxlYXZlMiA9IGZ1bmN0aW9uKHgsIHkpIHtcbiAgeCAmPSAweEZGRkY7XG4gIHggPSAoeCB8ICh4IDw8IDgpKSAmIDB4MDBGRjAwRkY7XG4gIHggPSAoeCB8ICh4IDw8IDQpKSAmIDB4MEYwRjBGMEY7XG4gIHggPSAoeCB8ICh4IDw8IDIpKSAmIDB4MzMzMzMzMzM7XG4gIHggPSAoeCB8ICh4IDw8IDEpKSAmIDB4NTU1NTU1NTU7XG5cbiAgeSAmPSAweEZGRkY7XG4gIHkgPSAoeSB8ICh5IDw8IDgpKSAmIDB4MDBGRjAwRkY7XG4gIHkgPSAoeSB8ICh5IDw8IDQpKSAmIDB4MEYwRjBGMEY7XG4gIHkgPSAoeSB8ICh5IDw8IDIpKSAmIDB4MzMzMzMzMzM7XG4gIHkgPSAoeSB8ICh5IDw8IDEpKSAmIDB4NTU1NTU1NTU7XG5cbiAgcmV0dXJuIHggfCAoeSA8PCAxKTtcbn1cblxuLy9FeHRyYWN0cyB0aGUgbnRoIGludGVybGVhdmVkIGNvbXBvbmVudFxuZXhwb3J0cy5kZWludGVybGVhdmUyID0gZnVuY3Rpb24odiwgbikge1xuICB2ID0gKHYgPj4+IG4pICYgMHg1NTU1NTU1NTtcbiAgdiA9ICh2IHwgKHYgPj4+IDEpKSAgJiAweDMzMzMzMzMzO1xuICB2ID0gKHYgfCAodiA+Pj4gMikpICAmIDB4MEYwRjBGMEY7XG4gIHYgPSAodiB8ICh2ID4+PiA0KSkgICYgMHgwMEZGMDBGRjtcbiAgdiA9ICh2IHwgKHYgPj4+IDE2KSkgJiAweDAwMEZGRkY7XG4gIHJldHVybiAodiA8PCAxNikgPj4gMTY7XG59XG5cblxuLy9JbnRlcmxlYXZlIGJpdHMgb2YgMyBjb29yZGluYXRlcywgZWFjaCB3aXRoIDEwIGJpdHMuICBVc2VmdWwgZm9yIGZhc3Qgb2N0cmVlIGNvZGVzXG5leHBvcnRzLmludGVybGVhdmUzID0gZnVuY3Rpb24oeCwgeSwgeikge1xuICB4ICY9IDB4M0ZGO1xuICB4ICA9ICh4IHwgKHg8PDE2KSkgJiA0Mjc4MTkwMzM1O1xuICB4ICA9ICh4IHwgKHg8PDgpKSAgJiAyNTE3MTk2OTU7XG4gIHggID0gKHggfCAoeDw8NCkpICAmIDMyNzIzNTYwMzU7XG4gIHggID0gKHggfCAoeDw8MikpICAmIDEyMjcxMzM1MTM7XG5cbiAgeSAmPSAweDNGRjtcbiAgeSAgPSAoeSB8ICh5PDwxNikpICYgNDI3ODE5MDMzNTtcbiAgeSAgPSAoeSB8ICh5PDw4KSkgICYgMjUxNzE5Njk1O1xuICB5ICA9ICh5IHwgKHk8PDQpKSAgJiAzMjcyMzU2MDM1O1xuICB5ICA9ICh5IHwgKHk8PDIpKSAgJiAxMjI3MTMzNTEzO1xuICB4IHw9ICh5IDw8IDEpO1xuICBcbiAgeiAmPSAweDNGRjtcbiAgeiAgPSAoeiB8ICh6PDwxNikpICYgNDI3ODE5MDMzNTtcbiAgeiAgPSAoeiB8ICh6PDw4KSkgICYgMjUxNzE5Njk1O1xuICB6ICA9ICh6IHwgKHo8PDQpKSAgJiAzMjcyMzU2MDM1O1xuICB6ICA9ICh6IHwgKHo8PDIpKSAgJiAxMjI3MTMzNTEzO1xuICBcbiAgcmV0dXJuIHggfCAoeiA8PCAyKTtcbn1cblxuLy9FeHRyYWN0cyBudGggaW50ZXJsZWF2ZWQgY29tcG9uZW50IG9mIGEgMy10dXBsZVxuZXhwb3J0cy5kZWludGVybGVhdmUzID0gZnVuY3Rpb24odiwgbikge1xuICB2ID0gKHYgPj4+IG4pICAgICAgICYgMTIyNzEzMzUxMztcbiAgdiA9ICh2IHwgKHY+Pj4yKSkgICAmIDMyNzIzNTYwMzU7XG4gIHYgPSAodiB8ICh2Pj4+NCkpICAgJiAyNTE3MTk2OTU7XG4gIHYgPSAodiB8ICh2Pj4+OCkpICAgJiA0Mjc4MTkwMzM1O1xuICB2ID0gKHYgfCAodj4+PjE2KSkgICYgMHgzRkY7XG4gIHJldHVybiAodjw8MjIpPj4yMjtcbn1cblxuLy9Db21wdXRlcyBuZXh0IGNvbWJpbmF0aW9uIGluIGNvbGV4aWNvZ3JhcGhpYyBvcmRlciAodGhpcyBpcyBtaXN0YWtlbmx5IGNhbGxlZCBuZXh0UGVybXV0YXRpb24gb24gdGhlIGJpdCB0d2lkZGxpbmcgaGFja3MgcGFnZSlcbmV4cG9ydHMubmV4dENvbWJpbmF0aW9uID0gZnVuY3Rpb24odikge1xuICB2YXIgdCA9IHYgfCAodiAtIDEpO1xuICByZXR1cm4gKHQgKyAxKSB8ICgoKH50ICYgLX50KSAtIDEpID4+PiAoY291bnRUcmFpbGluZ1plcm9zKHYpICsgMSkpO1xufVxuXG4iLCIoZnVuY3Rpb24gKG1vZHVsZSwgZXhwb3J0cykge1xuXG4ndXNlIHN0cmljdCc7XG5cbi8vIFV0aWxzXG5cbmZ1bmN0aW9uIGFzc2VydCh2YWwsIG1zZykge1xuICBpZiAoIXZhbClcbiAgICB0aHJvdyBuZXcgRXJyb3IobXNnIHx8ICdBc3NlcnRpb24gZmFpbGVkJyk7XG59XG5cbi8vIENvdWxkIHVzZSBgaW5oZXJpdHNgIG1vZHVsZSwgYnV0IGRvbid0IHdhbnQgdG8gbW92ZSBmcm9tIHNpbmdsZSBmaWxlXG4vLyBhcmNoaXRlY3R1cmUgeWV0LlxuZnVuY3Rpb24gaW5oZXJpdHMoY3Rvciwgc3VwZXJDdG9yKSB7XG4gIGN0b3Iuc3VwZXJfID0gc3VwZXJDdG9yO1xuICB2YXIgVGVtcEN0b3IgPSBmdW5jdGlvbiAoKSB7fTtcbiAgVGVtcEN0b3IucHJvdG90eXBlID0gc3VwZXJDdG9yLnByb3RvdHlwZTtcbiAgY3Rvci5wcm90b3R5cGUgPSBuZXcgVGVtcEN0b3IoKTtcbiAgY3Rvci5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBjdG9yO1xufVxuXG4vLyBCTlxuXG5mdW5jdGlvbiBCTihudW1iZXIsIGJhc2UsIGVuZGlhbikge1xuICAvLyBNYXkgYmUgYG5ldyBCTihibilgID9cbiAgaWYgKG51bWJlciAhPT0gbnVsbCAmJlxuICAgICAgdHlwZW9mIG51bWJlciA9PT0gJ29iamVjdCcgJiZcbiAgICAgIEFycmF5LmlzQXJyYXkobnVtYmVyLndvcmRzKSkge1xuICAgIHJldHVybiBudW1iZXI7XG4gIH1cblxuICB0aGlzLnNpZ24gPSBmYWxzZTtcbiAgdGhpcy53b3JkcyA9IG51bGw7XG4gIHRoaXMubGVuZ3RoID0gMDtcblxuICAvLyBSZWR1Y3Rpb24gY29udGV4dFxuICB0aGlzLnJlZCA9IG51bGw7XG5cbiAgaWYgKGJhc2UgPT09ICdsZScgfHwgYmFzZSA9PT0gJ2JlJykge1xuICAgIGVuZGlhbiA9IGJhc2U7XG4gICAgYmFzZSA9IDEwO1xuICB9XG5cbiAgaWYgKG51bWJlciAhPT0gbnVsbClcbiAgICB0aGlzLl9pbml0KG51bWJlciB8fCAwLCBiYXNlIHx8IDEwLCBlbmRpYW4gfHwgJ2JlJyk7XG59XG5pZiAodHlwZW9mIG1vZHVsZSA9PT0gJ29iamVjdCcpXG4gIG1vZHVsZS5leHBvcnRzID0gQk47XG5lbHNlXG4gIGV4cG9ydHMuQk4gPSBCTjtcblxuQk4uQk4gPSBCTjtcbkJOLndvcmRTaXplID0gMjY7XG5cbkJOLnByb3RvdHlwZS5faW5pdCA9IGZ1bmN0aW9uIGluaXQobnVtYmVyLCBiYXNlLCBlbmRpYW4pIHtcbiAgaWYgKHR5cGVvZiBudW1iZXIgPT09ICdudW1iZXInKSB7XG4gICAgcmV0dXJuIHRoaXMuX2luaXROdW1iZXIobnVtYmVyLCBiYXNlLCBlbmRpYW4pO1xuICB9IGVsc2UgaWYgKHR5cGVvZiBudW1iZXIgPT09ICdvYmplY3QnKSB7XG4gICAgcmV0dXJuIHRoaXMuX2luaXRBcnJheShudW1iZXIsIGJhc2UsIGVuZGlhbik7XG4gIH1cbiAgaWYgKGJhc2UgPT09ICdoZXgnKVxuICAgIGJhc2UgPSAxNjtcbiAgYXNzZXJ0KGJhc2UgPT09IChiYXNlIHwgMCkgJiYgYmFzZSA+PSAyICYmIGJhc2UgPD0gMzYpO1xuXG4gIG51bWJlciA9IG51bWJlci50b1N0cmluZygpLnJlcGxhY2UoL1xccysvZywgJycpO1xuICB2YXIgc3RhcnQgPSAwO1xuICBpZiAobnVtYmVyWzBdID09PSAnLScpXG4gICAgc3RhcnQrKztcblxuICBpZiAoYmFzZSA9PT0gMTYpXG4gICAgdGhpcy5fcGFyc2VIZXgobnVtYmVyLCBzdGFydCk7XG4gIGVsc2VcbiAgICB0aGlzLl9wYXJzZUJhc2UobnVtYmVyLCBiYXNlLCBzdGFydCk7XG5cbiAgaWYgKG51bWJlclswXSA9PT0gJy0nKVxuICAgIHRoaXMuc2lnbiA9IHRydWU7XG5cbiAgdGhpcy5zdHJpcCgpO1xuXG4gIGlmIChlbmRpYW4gIT09ICdsZScpXG4gICAgcmV0dXJuO1xuXG4gIHRoaXMuX2luaXRBcnJheSh0aGlzLnRvQXJyYXkoKSwgYmFzZSwgZW5kaWFuKTtcbn07XG5cbkJOLnByb3RvdHlwZS5faW5pdE51bWJlciA9IGZ1bmN0aW9uIF9pbml0TnVtYmVyKG51bWJlciwgYmFzZSwgZW5kaWFuKSB7XG4gIGlmIChudW1iZXIgPCAwKSB7XG4gICAgdGhpcy5zaWduID0gdHJ1ZTtcbiAgICBudW1iZXIgPSAtbnVtYmVyO1xuICB9XG4gIGlmIChudW1iZXIgPCAweDQwMDAwMDApIHtcbiAgICB0aGlzLndvcmRzID0gWyBudW1iZXIgJiAweDNmZmZmZmYgXTtcbiAgICB0aGlzLmxlbmd0aCA9IDE7XG4gIH0gZWxzZSBpZiAobnVtYmVyIDwgMHgxMDAwMDAwMDAwMDAwMCkge1xuICAgIHRoaXMud29yZHMgPSBbXG4gICAgICBudW1iZXIgJiAweDNmZmZmZmYsXG4gICAgICAobnVtYmVyIC8gMHg0MDAwMDAwKSAmIDB4M2ZmZmZmZlxuICAgIF07XG4gICAgdGhpcy5sZW5ndGggPSAyO1xuICB9IGVsc2Uge1xuICAgIGFzc2VydChudW1iZXIgPCAweDIwMDAwMDAwMDAwMDAwKTsgLy8gMiBeIDUzICh1bnNhZmUpXG4gICAgdGhpcy53b3JkcyA9IFtcbiAgICAgIG51bWJlciAmIDB4M2ZmZmZmZixcbiAgICAgIChudW1iZXIgLyAweDQwMDAwMDApICYgMHgzZmZmZmZmLFxuICAgICAgMVxuICAgIF07XG4gICAgdGhpcy5sZW5ndGggPSAzO1xuICB9XG5cbiAgaWYgKGVuZGlhbiAhPT0gJ2xlJylcbiAgICByZXR1cm47XG5cbiAgLy8gUmV2ZXJzZSB0aGUgYnl0ZXNcbiAgdGhpcy5faW5pdEFycmF5KHRoaXMudG9BcnJheSgpLCBiYXNlLCBlbmRpYW4pO1xufTtcblxuQk4ucHJvdG90eXBlLl9pbml0QXJyYXkgPSBmdW5jdGlvbiBfaW5pdEFycmF5KG51bWJlciwgYmFzZSwgZW5kaWFuKSB7XG4gIC8vIFBlcmhhcHMgYSBVaW50OEFycmF5XG4gIGFzc2VydCh0eXBlb2YgbnVtYmVyLmxlbmd0aCA9PT0gJ251bWJlcicpO1xuICBpZiAobnVtYmVyLmxlbmd0aCA8PSAwKSB7XG4gICAgdGhpcy53b3JkcyA9IFsgMCBdO1xuICAgIHRoaXMubGVuZ3RoID0gMTtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuXG4gIHRoaXMubGVuZ3RoID0gTWF0aC5jZWlsKG51bWJlci5sZW5ndGggLyAzKTtcbiAgdGhpcy53b3JkcyA9IG5ldyBBcnJheSh0aGlzLmxlbmd0aCk7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5sZW5ndGg7IGkrKylcbiAgICB0aGlzLndvcmRzW2ldID0gMDtcblxuICB2YXIgb2ZmID0gMDtcbiAgaWYgKGVuZGlhbiA9PT0gJ2JlJykge1xuICAgIGZvciAodmFyIGkgPSBudW1iZXIubGVuZ3RoIC0gMSwgaiA9IDA7IGkgPj0gMDsgaSAtPSAzKSB7XG4gICAgICB2YXIgdyA9IG51bWJlcltpXSB8IChudW1iZXJbaSAtIDFdIDw8IDgpIHwgKG51bWJlcltpIC0gMl0gPDwgMTYpO1xuICAgICAgdGhpcy53b3Jkc1tqXSB8PSAodyA8PCBvZmYpICYgMHgzZmZmZmZmO1xuICAgICAgdGhpcy53b3Jkc1tqICsgMV0gPSAodyA+Pj4gKDI2IC0gb2ZmKSkgJiAweDNmZmZmZmY7XG4gICAgICBvZmYgKz0gMjQ7XG4gICAgICBpZiAob2ZmID49IDI2KSB7XG4gICAgICAgIG9mZiAtPSAyNjtcbiAgICAgICAgaisrO1xuICAgICAgfVxuICAgIH1cbiAgfSBlbHNlIGlmIChlbmRpYW4gPT09ICdsZScpIHtcbiAgICBmb3IgKHZhciBpID0gMCwgaiA9IDA7IGkgPCBudW1iZXIubGVuZ3RoOyBpICs9IDMpIHtcbiAgICAgIHZhciB3ID0gbnVtYmVyW2ldIHwgKG51bWJlcltpICsgMV0gPDwgOCkgfCAobnVtYmVyW2kgKyAyXSA8PCAxNik7XG4gICAgICB0aGlzLndvcmRzW2pdIHw9ICh3IDw8IG9mZikgJiAweDNmZmZmZmY7XG4gICAgICB0aGlzLndvcmRzW2ogKyAxXSA9ICh3ID4+PiAoMjYgLSBvZmYpKSAmIDB4M2ZmZmZmZjtcbiAgICAgIG9mZiArPSAyNDtcbiAgICAgIGlmIChvZmYgPj0gMjYpIHtcbiAgICAgICAgb2ZmIC09IDI2O1xuICAgICAgICBqKys7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIHJldHVybiB0aGlzLnN0cmlwKCk7XG59O1xuXG5mdW5jdGlvbiBwYXJzZUhleChzdHIsIHN0YXJ0LCBlbmQpIHtcbiAgdmFyIHIgPSAwO1xuICB2YXIgbGVuID0gTWF0aC5taW4oc3RyLmxlbmd0aCwgZW5kKTtcbiAgZm9yICh2YXIgaSA9IHN0YXJ0OyBpIDwgbGVuOyBpKyspIHtcbiAgICB2YXIgYyA9IHN0ci5jaGFyQ29kZUF0KGkpIC0gNDg7XG5cbiAgICByIDw8PSA0O1xuXG4gICAgLy8gJ2EnIC0gJ2YnXG4gICAgaWYgKGMgPj0gNDkgJiYgYyA8PSA1NClcbiAgICAgIHIgfD0gYyAtIDQ5ICsgMHhhO1xuXG4gICAgLy8gJ0EnIC0gJ0YnXG4gICAgZWxzZSBpZiAoYyA+PSAxNyAmJiBjIDw9IDIyKVxuICAgICAgciB8PSBjIC0gMTcgKyAweGE7XG5cbiAgICAvLyAnMCcgLSAnOSdcbiAgICBlbHNlXG4gICAgICByIHw9IGMgJiAweGY7XG4gIH1cbiAgcmV0dXJuIHI7XG59XG5cbkJOLnByb3RvdHlwZS5fcGFyc2VIZXggPSBmdW5jdGlvbiBfcGFyc2VIZXgobnVtYmVyLCBzdGFydCkge1xuICAvLyBDcmVhdGUgcG9zc2libHkgYmlnZ2VyIGFycmF5IHRvIGVuc3VyZSB0aGF0IGl0IGZpdHMgdGhlIG51bWJlclxuICB0aGlzLmxlbmd0aCA9IE1hdGguY2VpbCgobnVtYmVyLmxlbmd0aCAtIHN0YXJ0KSAvIDYpO1xuICB0aGlzLndvcmRzID0gbmV3IEFycmF5KHRoaXMubGVuZ3RoKTtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLmxlbmd0aDsgaSsrKVxuICAgIHRoaXMud29yZHNbaV0gPSAwO1xuXG4gIC8vIFNjYW4gMjQtYml0IGNodW5rcyBhbmQgYWRkIHRoZW0gdG8gdGhlIG51bWJlclxuICB2YXIgb2ZmID0gMDtcbiAgZm9yICh2YXIgaSA9IG51bWJlci5sZW5ndGggLSA2LCBqID0gMDsgaSA+PSBzdGFydDsgaSAtPSA2KSB7XG4gICAgdmFyIHcgPSBwYXJzZUhleChudW1iZXIsIGksIGkgKyA2KTtcbiAgICB0aGlzLndvcmRzW2pdIHw9ICh3IDw8IG9mZikgJiAweDNmZmZmZmY7XG4gICAgdGhpcy53b3Jkc1tqICsgMV0gfD0gdyA+Pj4gKDI2IC0gb2ZmKSAmIDB4M2ZmZmZmO1xuICAgIG9mZiArPSAyNDtcbiAgICBpZiAob2ZmID49IDI2KSB7XG4gICAgICBvZmYgLT0gMjY7XG4gICAgICBqKys7XG4gICAgfVxuICB9XG4gIGlmIChpICsgNiAhPT0gc3RhcnQpIHtcbiAgICB2YXIgdyA9IHBhcnNlSGV4KG51bWJlciwgc3RhcnQsIGkgKyA2KTtcbiAgICB0aGlzLndvcmRzW2pdIHw9ICh3IDw8IG9mZikgJiAweDNmZmZmZmY7XG4gICAgdGhpcy53b3Jkc1tqICsgMV0gfD0gdyA+Pj4gKDI2IC0gb2ZmKSAmIDB4M2ZmZmZmO1xuICB9XG4gIHRoaXMuc3RyaXAoKTtcbn07XG5cbmZ1bmN0aW9uIHBhcnNlQmFzZShzdHIsIHN0YXJ0LCBlbmQsIG11bCkge1xuICB2YXIgciA9IDA7XG4gIHZhciBsZW4gPSBNYXRoLm1pbihzdHIubGVuZ3RoLCBlbmQpO1xuICBmb3IgKHZhciBpID0gc3RhcnQ7IGkgPCBsZW47IGkrKykge1xuICAgIHZhciBjID0gc3RyLmNoYXJDb2RlQXQoaSkgLSA0ODtcblxuICAgIHIgKj0gbXVsO1xuXG4gICAgLy8gJ2EnXG4gICAgaWYgKGMgPj0gNDkpXG4gICAgICByICs9IGMgLSA0OSArIDB4YTtcblxuICAgIC8vICdBJ1xuICAgIGVsc2UgaWYgKGMgPj0gMTcpXG4gICAgICByICs9IGMgLSAxNyArIDB4YTtcblxuICAgIC8vICcwJyAtICc5J1xuICAgIGVsc2VcbiAgICAgIHIgKz0gYztcbiAgfVxuICByZXR1cm4gcjtcbn1cblxuQk4ucHJvdG90eXBlLl9wYXJzZUJhc2UgPSBmdW5jdGlvbiBfcGFyc2VCYXNlKG51bWJlciwgYmFzZSwgc3RhcnQpIHtcbiAgLy8gSW5pdGlhbGl6ZSBhcyB6ZXJvXG4gIHRoaXMud29yZHMgPSBbIDAgXTtcbiAgdGhpcy5sZW5ndGggPSAxO1xuXG4gIC8vIEZpbmQgbGVuZ3RoIG9mIGxpbWIgaW4gYmFzZVxuICBmb3IgKHZhciBsaW1iTGVuID0gMCwgbGltYlBvdyA9IDE7IGxpbWJQb3cgPD0gMHgzZmZmZmZmOyBsaW1iUG93ICo9IGJhc2UpXG4gICAgbGltYkxlbisrO1xuICBsaW1iTGVuLS07XG4gIGxpbWJQb3cgPSAobGltYlBvdyAvIGJhc2UpIHwgMDtcblxuICB2YXIgdG90YWwgPSBudW1iZXIubGVuZ3RoIC0gc3RhcnQ7XG4gIHZhciBtb2QgPSB0b3RhbCAlIGxpbWJMZW47XG4gIHZhciBlbmQgPSBNYXRoLm1pbih0b3RhbCwgdG90YWwgLSBtb2QpICsgc3RhcnQ7XG5cbiAgdmFyIHdvcmQgPSAwO1xuICBmb3IgKHZhciBpID0gc3RhcnQ7IGkgPCBlbmQ7IGkgKz0gbGltYkxlbikge1xuICAgIHdvcmQgPSBwYXJzZUJhc2UobnVtYmVyLCBpLCBpICsgbGltYkxlbiwgYmFzZSk7XG5cbiAgICB0aGlzLmltdWxuKGxpbWJQb3cpO1xuICAgIGlmICh0aGlzLndvcmRzWzBdICsgd29yZCA8IDB4NDAwMDAwMClcbiAgICAgIHRoaXMud29yZHNbMF0gKz0gd29yZDtcbiAgICBlbHNlXG4gICAgICB0aGlzLl9pYWRkbih3b3JkKTtcbiAgfVxuXG4gIGlmIChtb2QgIT09IDApIHtcbiAgICB2YXIgcG93ID0gMTtcbiAgICB2YXIgd29yZCA9IHBhcnNlQmFzZShudW1iZXIsIGksIG51bWJlci5sZW5ndGgsIGJhc2UpO1xuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBtb2Q7IGkrKylcbiAgICAgIHBvdyAqPSBiYXNlO1xuICAgIHRoaXMuaW11bG4ocG93KTtcbiAgICBpZiAodGhpcy53b3Jkc1swXSArIHdvcmQgPCAweDQwMDAwMDApXG4gICAgICB0aGlzLndvcmRzWzBdICs9IHdvcmQ7XG4gICAgZWxzZVxuICAgICAgdGhpcy5faWFkZG4od29yZCk7XG4gIH1cbn07XG5cbkJOLnByb3RvdHlwZS5jb3B5ID0gZnVuY3Rpb24gY29weShkZXN0KSB7XG4gIGRlc3Qud29yZHMgPSBuZXcgQXJyYXkodGhpcy5sZW5ndGgpO1xuICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMubGVuZ3RoOyBpKyspXG4gICAgZGVzdC53b3Jkc1tpXSA9IHRoaXMud29yZHNbaV07XG4gIGRlc3QubGVuZ3RoID0gdGhpcy5sZW5ndGg7XG4gIGRlc3Quc2lnbiA9IHRoaXMuc2lnbjtcbiAgZGVzdC5yZWQgPSB0aGlzLnJlZDtcbn07XG5cbkJOLnByb3RvdHlwZS5jbG9uZSA9IGZ1bmN0aW9uIGNsb25lKCkge1xuICB2YXIgciA9IG5ldyBCTihudWxsKTtcbiAgdGhpcy5jb3B5KHIpO1xuICByZXR1cm4gcjtcbn07XG5cbi8vIFJlbW92ZSBsZWFkaW5nIGAwYCBmcm9tIGB0aGlzYFxuQk4ucHJvdG90eXBlLnN0cmlwID0gZnVuY3Rpb24gc3RyaXAoKSB7XG4gIHdoaWxlICh0aGlzLmxlbmd0aCA+IDEgJiYgdGhpcy53b3Jkc1t0aGlzLmxlbmd0aCAtIDFdID09PSAwKVxuICAgIHRoaXMubGVuZ3RoLS07XG4gIHJldHVybiB0aGlzLl9ub3JtU2lnbigpO1xufTtcblxuQk4ucHJvdG90eXBlLl9ub3JtU2lnbiA9IGZ1bmN0aW9uIF9ub3JtU2lnbigpIHtcbiAgLy8gLTAgPSAwXG4gIGlmICh0aGlzLmxlbmd0aCA9PT0gMSAmJiB0aGlzLndvcmRzWzBdID09PSAwKVxuICAgIHRoaXMuc2lnbiA9IGZhbHNlO1xuICByZXR1cm4gdGhpcztcbn07XG5cbkJOLnByb3RvdHlwZS5pbnNwZWN0ID0gZnVuY3Rpb24gaW5zcGVjdCgpIHtcbiAgcmV0dXJuICh0aGlzLnJlZCA/ICc8Qk4tUjogJyA6ICc8Qk46ICcpICsgdGhpcy50b1N0cmluZygxNikgKyAnPic7XG59O1xuXG4vKlxuXG52YXIgemVyb3MgPSBbXTtcbnZhciBncm91cFNpemVzID0gW107XG52YXIgZ3JvdXBCYXNlcyA9IFtdO1xuXG52YXIgcyA9ICcnO1xudmFyIGkgPSAtMTtcbndoaWxlICgrK2kgPCBCTi53b3JkU2l6ZSkge1xuICB6ZXJvc1tpXSA9IHM7XG4gIHMgKz0gJzAnO1xufVxuZ3JvdXBTaXplc1swXSA9IDA7XG5ncm91cFNpemVzWzFdID0gMDtcbmdyb3VwQmFzZXNbMF0gPSAwO1xuZ3JvdXBCYXNlc1sxXSA9IDA7XG52YXIgYmFzZSA9IDIgLSAxO1xud2hpbGUgKCsrYmFzZSA8IDM2ICsgMSkge1xuICB2YXIgZ3JvdXBTaXplID0gMDtcbiAgdmFyIGdyb3VwQmFzZSA9IDE7XG4gIHdoaWxlIChncm91cEJhc2UgPCAoMSA8PCBCTi53b3JkU2l6ZSkgLyBiYXNlKSB7XG4gICAgZ3JvdXBCYXNlICo9IGJhc2U7XG4gICAgZ3JvdXBTaXplICs9IDE7XG4gIH1cbiAgZ3JvdXBTaXplc1tiYXNlXSA9IGdyb3VwU2l6ZTtcbiAgZ3JvdXBCYXNlc1tiYXNlXSA9IGdyb3VwQmFzZTtcbn1cblxuKi9cblxudmFyIHplcm9zID0gW1xuICAnJyxcbiAgJzAnLFxuICAnMDAnLFxuICAnMDAwJyxcbiAgJzAwMDAnLFxuICAnMDAwMDAnLFxuICAnMDAwMDAwJyxcbiAgJzAwMDAwMDAnLFxuICAnMDAwMDAwMDAnLFxuICAnMDAwMDAwMDAwJyxcbiAgJzAwMDAwMDAwMDAnLFxuICAnMDAwMDAwMDAwMDAnLFxuICAnMDAwMDAwMDAwMDAwJyxcbiAgJzAwMDAwMDAwMDAwMDAnLFxuICAnMDAwMDAwMDAwMDAwMDAnLFxuICAnMDAwMDAwMDAwMDAwMDAwJyxcbiAgJzAwMDAwMDAwMDAwMDAwMDAnLFxuICAnMDAwMDAwMDAwMDAwMDAwMDAnLFxuICAnMDAwMDAwMDAwMDAwMDAwMDAwJyxcbiAgJzAwMDAwMDAwMDAwMDAwMDAwMDAnLFxuICAnMDAwMDAwMDAwMDAwMDAwMDAwMDAnLFxuICAnMDAwMDAwMDAwMDAwMDAwMDAwMDAwJyxcbiAgJzAwMDAwMDAwMDAwMDAwMDAwMDAwMDAnLFxuICAnMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAnLFxuICAnMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwJyxcbiAgJzAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAnXG5dO1xuXG52YXIgZ3JvdXBTaXplcyA9IFtcbiAgMCwgMCxcbiAgMjUsIDE2LCAxMiwgMTEsIDEwLCA5LCA4LFxuICA4LCA3LCA3LCA3LCA3LCA2LCA2LFxuICA2LCA2LCA2LCA2LCA2LCA1LCA1LFxuICA1LCA1LCA1LCA1LCA1LCA1LCA1LFxuICA1LCA1LCA1LCA1LCA1LCA1LCA1XG5dO1xuXG52YXIgZ3JvdXBCYXNlcyA9IFtcbiAgMCwgMCxcbiAgMzM1NTQ0MzIsIDQzMDQ2NzIxLCAxNjc3NzIxNiwgNDg4MjgxMjUsIDYwNDY2MTc2LCA0MDM1MzYwNywgMTY3NzcyMTYsXG4gIDQzMDQ2NzIxLCAxMDAwMDAwMCwgMTk0ODcxNzEsIDM1ODMxODA4LCA2Mjc0ODUxNywgNzUyOTUzNiwgMTEzOTA2MjUsXG4gIDE2Nzc3MjE2LCAyNDEzNzU2OSwgMzQwMTIyMjQsIDQ3MDQ1ODgxLCA2NDAwMDAwMCwgNDA4NDEwMSwgNTE1MzYzMixcbiAgNjQzNjM0MywgNzk2MjYyNCwgOTc2NTYyNSwgMTE4ODEzNzYsIDE0MzQ4OTA3LCAxNzIxMDM2OCwgMjA1MTExNDksXG4gIDI0MzAwMDAwLCAyODYyOTE1MSwgMzM1NTQ0MzIsIDM5MTM1MzkzLCA0NTQzNTQyNCwgNTI1MjE4NzUsIDYwNDY2MTc2XG5dO1xuXG5CTi5wcm90b3R5cGUudG9TdHJpbmcgPSBmdW5jdGlvbiB0b1N0cmluZyhiYXNlLCBwYWRkaW5nKSB7XG4gIGJhc2UgPSBiYXNlIHx8IDEwO1xuICBpZiAoYmFzZSA9PT0gMTYgfHwgYmFzZSA9PT0gJ2hleCcpIHtcbiAgICB2YXIgb3V0ID0gJyc7XG4gICAgdmFyIG9mZiA9IDA7XG4gICAgdmFyIHBhZGRpbmcgPSBwYWRkaW5nIHwgMCB8fCAxO1xuICAgIHZhciBjYXJyeSA9IDA7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIgdyA9IHRoaXMud29yZHNbaV07XG4gICAgICB2YXIgd29yZCA9ICgoKHcgPDwgb2ZmKSB8IGNhcnJ5KSAmIDB4ZmZmZmZmKS50b1N0cmluZygxNik7XG4gICAgICBjYXJyeSA9ICh3ID4+PiAoMjQgLSBvZmYpKSAmIDB4ZmZmZmZmO1xuICAgICAgaWYgKGNhcnJ5ICE9PSAwIHx8IGkgIT09IHRoaXMubGVuZ3RoIC0gMSlcbiAgICAgICAgb3V0ID0gemVyb3NbNiAtIHdvcmQubGVuZ3RoXSArIHdvcmQgKyBvdXQ7XG4gICAgICBlbHNlXG4gICAgICAgIG91dCA9IHdvcmQgKyBvdXQ7XG4gICAgICBvZmYgKz0gMjtcbiAgICAgIGlmIChvZmYgPj0gMjYpIHtcbiAgICAgICAgb2ZmIC09IDI2O1xuICAgICAgICBpLS07XG4gICAgICB9XG4gICAgfVxuICAgIGlmIChjYXJyeSAhPT0gMClcbiAgICAgIG91dCA9IGNhcnJ5LnRvU3RyaW5nKDE2KSArIG91dDtcbiAgICB3aGlsZSAob3V0Lmxlbmd0aCAlIHBhZGRpbmcgIT09IDApXG4gICAgICBvdXQgPSAnMCcgKyBvdXQ7XG4gICAgaWYgKHRoaXMuc2lnbilcbiAgICAgIG91dCA9ICctJyArIG91dDtcbiAgICByZXR1cm4gb3V0O1xuICB9IGVsc2UgaWYgKGJhc2UgPT09IChiYXNlIHwgMCkgJiYgYmFzZSA+PSAyICYmIGJhc2UgPD0gMzYpIHtcbiAgICAvLyB2YXIgZ3JvdXBTaXplID0gTWF0aC5mbG9vcihCTi53b3JkU2l6ZSAqIE1hdGguTE4yIC8gTWF0aC5sb2coYmFzZSkpO1xuICAgIHZhciBncm91cFNpemUgPSBncm91cFNpemVzW2Jhc2VdO1xuICAgIC8vIHZhciBncm91cEJhc2UgPSBNYXRoLnBvdyhiYXNlLCBncm91cFNpemUpO1xuICAgIHZhciBncm91cEJhc2UgPSBncm91cEJhc2VzW2Jhc2VdO1xuICAgIHZhciBvdXQgPSAnJztcbiAgICB2YXIgYyA9IHRoaXMuY2xvbmUoKTtcbiAgICBjLnNpZ24gPSBmYWxzZTtcbiAgICB3aGlsZSAoYy5jbXBuKDApICE9PSAwKSB7XG4gICAgICB2YXIgciA9IGMubW9kbihncm91cEJhc2UpLnRvU3RyaW5nKGJhc2UpO1xuICAgICAgYyA9IGMuaWRpdm4oZ3JvdXBCYXNlKTtcblxuICAgICAgaWYgKGMuY21wbigwKSAhPT0gMClcbiAgICAgICAgb3V0ID0gemVyb3NbZ3JvdXBTaXplIC0gci5sZW5ndGhdICsgciArIG91dDtcbiAgICAgIGVsc2VcbiAgICAgICAgb3V0ID0gciArIG91dDtcbiAgICB9XG4gICAgaWYgKHRoaXMuY21wbigwKSA9PT0gMClcbiAgICAgIG91dCA9ICcwJyArIG91dDtcbiAgICBpZiAodGhpcy5zaWduKVxuICAgICAgb3V0ID0gJy0nICsgb3V0O1xuICAgIHJldHVybiBvdXQ7XG4gIH0gZWxzZSB7XG4gICAgYXNzZXJ0KGZhbHNlLCAnQmFzZSBzaG91bGQgYmUgYmV0d2VlbiAyIGFuZCAzNicpO1xuICB9XG59O1xuXG5CTi5wcm90b3R5cGUudG9KU09OID0gZnVuY3Rpb24gdG9KU09OKCkge1xuICByZXR1cm4gdGhpcy50b1N0cmluZygxNik7XG59O1xuXG5CTi5wcm90b3R5cGUudG9BcnJheSA9IGZ1bmN0aW9uIHRvQXJyYXkoZW5kaWFuKSB7XG4gIHRoaXMuc3RyaXAoKTtcbiAgdmFyIHJlcyA9IG5ldyBBcnJheSh0aGlzLmJ5dGVMZW5ndGgoKSk7XG4gIHJlc1swXSA9IDA7XG5cbiAgdmFyIHEgPSB0aGlzLmNsb25lKCk7XG4gIGlmIChlbmRpYW4gIT09ICdsZScpIHtcbiAgICAvLyBBc3N1bWUgYmlnLWVuZGlhblxuICAgIGZvciAodmFyIGkgPSAwOyBxLmNtcG4oMCkgIT09IDA7IGkrKykge1xuICAgICAgdmFyIGIgPSBxLmFuZGxuKDB4ZmYpO1xuICAgICAgcS5pc2hybig4KTtcblxuICAgICAgcmVzW3Jlcy5sZW5ndGggLSBpIC0gMV0gPSBiO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICAvLyBBc3N1bWUgbGl0dGxlLWVuZGlhblxuICAgIGZvciAodmFyIGkgPSAwOyBxLmNtcG4oMCkgIT09IDA7IGkrKykge1xuICAgICAgdmFyIGIgPSBxLmFuZGxuKDB4ZmYpO1xuICAgICAgcS5pc2hybig4KTtcblxuICAgICAgcmVzW2ldID0gYjtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gcmVzO1xufTtcblxuaWYgKE1hdGguY2x6MzIpIHtcbiAgQk4ucHJvdG90eXBlLl9jb3VudEJpdHMgPSBmdW5jdGlvbiBfY291bnRCaXRzKHcpIHtcbiAgICByZXR1cm4gMzIgLSBNYXRoLmNsejMyKHcpO1xuICB9O1xufSBlbHNlIHtcbiAgQk4ucHJvdG90eXBlLl9jb3VudEJpdHMgPSBmdW5jdGlvbiBfY291bnRCaXRzKHcpIHtcbiAgICB2YXIgdCA9IHc7XG4gICAgdmFyIHIgPSAwO1xuICAgIGlmICh0ID49IDB4MTAwMCkge1xuICAgICAgciArPSAxMztcbiAgICAgIHQgPj4+PSAxMztcbiAgICB9XG4gICAgaWYgKHQgPj0gMHg0MCkge1xuICAgICAgciArPSA3O1xuICAgICAgdCA+Pj49IDc7XG4gICAgfVxuICAgIGlmICh0ID49IDB4OCkge1xuICAgICAgciArPSA0O1xuICAgICAgdCA+Pj49IDQ7XG4gICAgfVxuICAgIGlmICh0ID49IDB4MDIpIHtcbiAgICAgIHIgKz0gMjtcbiAgICAgIHQgPj4+PSAyO1xuICAgIH1cbiAgICByZXR1cm4gciArIHQ7XG4gIH07XG59XG5cbkJOLnByb3RvdHlwZS5femVyb0JpdHMgPSBmdW5jdGlvbiBfemVyb0JpdHModykge1xuICAvLyBTaG9ydC1jdXRcbiAgaWYgKHcgPT09IDApXG4gICAgcmV0dXJuIDI2O1xuXG4gIHZhciB0ID0gdztcbiAgdmFyIHIgPSAwO1xuICBpZiAoKHQgJiAweDFmZmYpID09PSAwKSB7XG4gICAgciArPSAxMztcbiAgICB0ID4+Pj0gMTM7XG4gIH1cbiAgaWYgKCh0ICYgMHg3ZikgPT09IDApIHtcbiAgICByICs9IDc7XG4gICAgdCA+Pj49IDc7XG4gIH1cbiAgaWYgKCh0ICYgMHhmKSA9PT0gMCkge1xuICAgIHIgKz0gNDtcbiAgICB0ID4+Pj0gNDtcbiAgfVxuICBpZiAoKHQgJiAweDMpID09PSAwKSB7XG4gICAgciArPSAyO1xuICAgIHQgPj4+PSAyO1xuICB9XG4gIGlmICgodCAmIDB4MSkgPT09IDApXG4gICAgcisrO1xuICByZXR1cm4gcjtcbn07XG5cbi8vIFJldHVybiBudW1iZXIgb2YgdXNlZCBiaXRzIGluIGEgQk5cbkJOLnByb3RvdHlwZS5iaXRMZW5ndGggPSBmdW5jdGlvbiBiaXRMZW5ndGgoKSB7XG4gIHZhciBoaSA9IDA7XG4gIHZhciB3ID0gdGhpcy53b3Jkc1t0aGlzLmxlbmd0aCAtIDFdO1xuICB2YXIgaGkgPSB0aGlzLl9jb3VudEJpdHModyk7XG4gIHJldHVybiAodGhpcy5sZW5ndGggLSAxKSAqIDI2ICsgaGk7XG59O1xuXG4vLyBOdW1iZXIgb2YgdHJhaWxpbmcgemVybyBiaXRzXG5CTi5wcm90b3R5cGUuemVyb0JpdHMgPSBmdW5jdGlvbiB6ZXJvQml0cygpIHtcbiAgaWYgKHRoaXMuY21wbigwKSA9PT0gMClcbiAgICByZXR1cm4gMDtcblxuICB2YXIgciA9IDA7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5sZW5ndGg7IGkrKykge1xuICAgIHZhciBiID0gdGhpcy5femVyb0JpdHModGhpcy53b3Jkc1tpXSk7XG4gICAgciArPSBiO1xuICAgIGlmIChiICE9PSAyNilcbiAgICAgIGJyZWFrO1xuICB9XG4gIHJldHVybiByO1xufTtcblxuQk4ucHJvdG90eXBlLmJ5dGVMZW5ndGggPSBmdW5jdGlvbiBieXRlTGVuZ3RoKCkge1xuICByZXR1cm4gTWF0aC5jZWlsKHRoaXMuYml0TGVuZ3RoKCkgLyA4KTtcbn07XG5cbi8vIFJldHVybiBuZWdhdGl2ZSBjbG9uZSBvZiBgdGhpc2BcbkJOLnByb3RvdHlwZS5uZWcgPSBmdW5jdGlvbiBuZWcoKSB7XG4gIGlmICh0aGlzLmNtcG4oMCkgPT09IDApXG4gICAgcmV0dXJuIHRoaXMuY2xvbmUoKTtcblxuICB2YXIgciA9IHRoaXMuY2xvbmUoKTtcbiAgci5zaWduID0gIXRoaXMuc2lnbjtcbiAgcmV0dXJuIHI7XG59O1xuXG5cbi8vIE9yIGBudW1gIHdpdGggYHRoaXNgIGluLXBsYWNlXG5CTi5wcm90b3R5cGUuaW9yID0gZnVuY3Rpb24gaW9yKG51bSkge1xuICB0aGlzLnNpZ24gPSB0aGlzLnNpZ24gfHwgbnVtLnNpZ247XG5cbiAgd2hpbGUgKHRoaXMubGVuZ3RoIDwgbnVtLmxlbmd0aClcbiAgICB0aGlzLndvcmRzW3RoaXMubGVuZ3RoKytdID0gMDtcblxuICBmb3IgKHZhciBpID0gMDsgaSA8IG51bS5sZW5ndGg7IGkrKylcbiAgICB0aGlzLndvcmRzW2ldID0gdGhpcy53b3Jkc1tpXSB8IG51bS53b3Jkc1tpXTtcblxuICByZXR1cm4gdGhpcy5zdHJpcCgpO1xufTtcblxuXG4vLyBPciBgbnVtYCB3aXRoIGB0aGlzYFxuQk4ucHJvdG90eXBlLm9yID0gZnVuY3Rpb24gb3IobnVtKSB7XG4gIGlmICh0aGlzLmxlbmd0aCA+IG51bS5sZW5ndGgpXG4gICAgcmV0dXJuIHRoaXMuY2xvbmUoKS5pb3IobnVtKTtcbiAgZWxzZVxuICAgIHJldHVybiBudW0uY2xvbmUoKS5pb3IodGhpcyk7XG59O1xuXG5cbi8vIEFuZCBgbnVtYCB3aXRoIGB0aGlzYCBpbi1wbGFjZVxuQk4ucHJvdG90eXBlLmlhbmQgPSBmdW5jdGlvbiBpYW5kKG51bSkge1xuICB0aGlzLnNpZ24gPSB0aGlzLnNpZ24gJiYgbnVtLnNpZ247XG5cbiAgLy8gYiA9IG1pbi1sZW5ndGgobnVtLCB0aGlzKVxuICB2YXIgYjtcbiAgaWYgKHRoaXMubGVuZ3RoID4gbnVtLmxlbmd0aClcbiAgICBiID0gbnVtO1xuICBlbHNlXG4gICAgYiA9IHRoaXM7XG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBiLmxlbmd0aDsgaSsrKVxuICAgIHRoaXMud29yZHNbaV0gPSB0aGlzLndvcmRzW2ldICYgbnVtLndvcmRzW2ldO1xuXG4gIHRoaXMubGVuZ3RoID0gYi5sZW5ndGg7XG5cbiAgcmV0dXJuIHRoaXMuc3RyaXAoKTtcbn07XG5cblxuLy8gQW5kIGBudW1gIHdpdGggYHRoaXNgXG5CTi5wcm90b3R5cGUuYW5kID0gZnVuY3Rpb24gYW5kKG51bSkge1xuICBpZiAodGhpcy5sZW5ndGggPiBudW0ubGVuZ3RoKVxuICAgIHJldHVybiB0aGlzLmNsb25lKCkuaWFuZChudW0pO1xuICBlbHNlXG4gICAgcmV0dXJuIG51bS5jbG9uZSgpLmlhbmQodGhpcyk7XG59O1xuXG5cbi8vIFhvciBgbnVtYCB3aXRoIGB0aGlzYCBpbi1wbGFjZVxuQk4ucHJvdG90eXBlLml4b3IgPSBmdW5jdGlvbiBpeG9yKG51bSkge1xuICB0aGlzLnNpZ24gPSB0aGlzLnNpZ24gfHwgbnVtLnNpZ247XG5cbiAgLy8gYS5sZW5ndGggPiBiLmxlbmd0aFxuICB2YXIgYTtcbiAgdmFyIGI7XG4gIGlmICh0aGlzLmxlbmd0aCA+IG51bS5sZW5ndGgpIHtcbiAgICBhID0gdGhpcztcbiAgICBiID0gbnVtO1xuICB9IGVsc2Uge1xuICAgIGEgPSBudW07XG4gICAgYiA9IHRoaXM7XG4gIH1cblxuICBmb3IgKHZhciBpID0gMDsgaSA8IGIubGVuZ3RoOyBpKyspXG4gICAgdGhpcy53b3Jkc1tpXSA9IGEud29yZHNbaV0gXiBiLndvcmRzW2ldO1xuXG4gIGlmICh0aGlzICE9PSBhKVxuICAgIGZvciAoOyBpIDwgYS5sZW5ndGg7IGkrKylcbiAgICAgIHRoaXMud29yZHNbaV0gPSBhLndvcmRzW2ldO1xuXG4gIHRoaXMubGVuZ3RoID0gYS5sZW5ndGg7XG5cbiAgcmV0dXJuIHRoaXMuc3RyaXAoKTtcbn07XG5cblxuLy8gWG9yIGBudW1gIHdpdGggYHRoaXNgXG5CTi5wcm90b3R5cGUueG9yID0gZnVuY3Rpb24geG9yKG51bSkge1xuICBpZiAodGhpcy5sZW5ndGggPiBudW0ubGVuZ3RoKVxuICAgIHJldHVybiB0aGlzLmNsb25lKCkuaXhvcihudW0pO1xuICBlbHNlXG4gICAgcmV0dXJuIG51bS5jbG9uZSgpLml4b3IodGhpcyk7XG59O1xuXG5cbi8vIFNldCBgYml0YCBvZiBgdGhpc2BcbkJOLnByb3RvdHlwZS5zZXRuID0gZnVuY3Rpb24gc2V0bihiaXQsIHZhbCkge1xuICBhc3NlcnQodHlwZW9mIGJpdCA9PT0gJ251bWJlcicgJiYgYml0ID49IDApO1xuXG4gIHZhciBvZmYgPSAoYml0IC8gMjYpIHwgMDtcbiAgdmFyIHdiaXQgPSBiaXQgJSAyNjtcblxuICB3aGlsZSAodGhpcy5sZW5ndGggPD0gb2ZmKVxuICAgIHRoaXMud29yZHNbdGhpcy5sZW5ndGgrK10gPSAwO1xuXG4gIGlmICh2YWwpXG4gICAgdGhpcy53b3Jkc1tvZmZdID0gdGhpcy53b3Jkc1tvZmZdIHwgKDEgPDwgd2JpdCk7XG4gIGVsc2VcbiAgICB0aGlzLndvcmRzW29mZl0gPSB0aGlzLndvcmRzW29mZl0gJiB+KDEgPDwgd2JpdCk7XG5cbiAgcmV0dXJuIHRoaXMuc3RyaXAoKTtcbn07XG5cblxuLy8gQWRkIGBudW1gIHRvIGB0aGlzYCBpbi1wbGFjZVxuQk4ucHJvdG90eXBlLmlhZGQgPSBmdW5jdGlvbiBpYWRkKG51bSkge1xuICAvLyBuZWdhdGl2ZSArIHBvc2l0aXZlXG4gIGlmICh0aGlzLnNpZ24gJiYgIW51bS5zaWduKSB7XG4gICAgdGhpcy5zaWduID0gZmFsc2U7XG4gICAgdmFyIHIgPSB0aGlzLmlzdWIobnVtKTtcbiAgICB0aGlzLnNpZ24gPSAhdGhpcy5zaWduO1xuICAgIHJldHVybiB0aGlzLl9ub3JtU2lnbigpO1xuXG4gIC8vIHBvc2l0aXZlICsgbmVnYXRpdmVcbiAgfSBlbHNlIGlmICghdGhpcy5zaWduICYmIG51bS5zaWduKSB7XG4gICAgbnVtLnNpZ24gPSBmYWxzZTtcbiAgICB2YXIgciA9IHRoaXMuaXN1YihudW0pO1xuICAgIG51bS5zaWduID0gdHJ1ZTtcbiAgICByZXR1cm4gci5fbm9ybVNpZ24oKTtcbiAgfVxuXG4gIC8vIGEubGVuZ3RoID4gYi5sZW5ndGhcbiAgdmFyIGE7XG4gIHZhciBiO1xuICBpZiAodGhpcy5sZW5ndGggPiBudW0ubGVuZ3RoKSB7XG4gICAgYSA9IHRoaXM7XG4gICAgYiA9IG51bTtcbiAgfSBlbHNlIHtcbiAgICBhID0gbnVtO1xuICAgIGIgPSB0aGlzO1xuICB9XG5cbiAgdmFyIGNhcnJ5ID0gMDtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBiLmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIHIgPSBhLndvcmRzW2ldICsgYi53b3Jkc1tpXSArIGNhcnJ5O1xuICAgIHRoaXMud29yZHNbaV0gPSByICYgMHgzZmZmZmZmO1xuICAgIGNhcnJ5ID0gciA+Pj4gMjY7XG4gIH1cbiAgZm9yICg7IGNhcnJ5ICE9PSAwICYmIGkgPCBhLmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIHIgPSBhLndvcmRzW2ldICsgY2Fycnk7XG4gICAgdGhpcy53b3Jkc1tpXSA9IHIgJiAweDNmZmZmZmY7XG4gICAgY2FycnkgPSByID4+PiAyNjtcbiAgfVxuXG4gIHRoaXMubGVuZ3RoID0gYS5sZW5ndGg7XG4gIGlmIChjYXJyeSAhPT0gMCkge1xuICAgIHRoaXMud29yZHNbdGhpcy5sZW5ndGhdID0gY2Fycnk7XG4gICAgdGhpcy5sZW5ndGgrKztcbiAgLy8gQ29weSB0aGUgcmVzdCBvZiB0aGUgd29yZHNcbiAgfSBlbHNlIGlmIChhICE9PSB0aGlzKSB7XG4gICAgZm9yICg7IGkgPCBhLmxlbmd0aDsgaSsrKVxuICAgICAgdGhpcy53b3Jkc1tpXSA9IGEud29yZHNbaV07XG4gIH1cblxuICByZXR1cm4gdGhpcztcbn07XG5cbi8vIEFkZCBgbnVtYCB0byBgdGhpc2BcbkJOLnByb3RvdHlwZS5hZGQgPSBmdW5jdGlvbiBhZGQobnVtKSB7XG4gIGlmIChudW0uc2lnbiAmJiAhdGhpcy5zaWduKSB7XG4gICAgbnVtLnNpZ24gPSBmYWxzZTtcbiAgICB2YXIgcmVzID0gdGhpcy5zdWIobnVtKTtcbiAgICBudW0uc2lnbiA9IHRydWU7XG4gICAgcmV0dXJuIHJlcztcbiAgfSBlbHNlIGlmICghbnVtLnNpZ24gJiYgdGhpcy5zaWduKSB7XG4gICAgdGhpcy5zaWduID0gZmFsc2U7XG4gICAgdmFyIHJlcyA9IG51bS5zdWIodGhpcyk7XG4gICAgdGhpcy5zaWduID0gdHJ1ZTtcbiAgICByZXR1cm4gcmVzO1xuICB9XG5cbiAgaWYgKHRoaXMubGVuZ3RoID4gbnVtLmxlbmd0aClcbiAgICByZXR1cm4gdGhpcy5jbG9uZSgpLmlhZGQobnVtKTtcbiAgZWxzZVxuICAgIHJldHVybiBudW0uY2xvbmUoKS5pYWRkKHRoaXMpO1xufTtcblxuLy8gU3VidHJhY3QgYG51bWAgZnJvbSBgdGhpc2AgaW4tcGxhY2VcbkJOLnByb3RvdHlwZS5pc3ViID0gZnVuY3Rpb24gaXN1YihudW0pIHtcbiAgLy8gdGhpcyAtICgtbnVtKSA9IHRoaXMgKyBudW1cbiAgaWYgKG51bS5zaWduKSB7XG4gICAgbnVtLnNpZ24gPSBmYWxzZTtcbiAgICB2YXIgciA9IHRoaXMuaWFkZChudW0pO1xuICAgIG51bS5zaWduID0gdHJ1ZTtcbiAgICByZXR1cm4gci5fbm9ybVNpZ24oKTtcblxuICAvLyAtdGhpcyAtIG51bSA9IC0odGhpcyArIG51bSlcbiAgfSBlbHNlIGlmICh0aGlzLnNpZ24pIHtcbiAgICB0aGlzLnNpZ24gPSBmYWxzZTtcbiAgICB0aGlzLmlhZGQobnVtKTtcbiAgICB0aGlzLnNpZ24gPSB0cnVlO1xuICAgIHJldHVybiB0aGlzLl9ub3JtU2lnbigpO1xuICB9XG5cbiAgLy8gQXQgdGhpcyBwb2ludCBib3RoIG51bWJlcnMgYXJlIHBvc2l0aXZlXG4gIHZhciBjbXAgPSB0aGlzLmNtcChudW0pO1xuXG4gIC8vIE9wdGltaXphdGlvbiAtIHplcm9pZnlcbiAgaWYgKGNtcCA9PT0gMCkge1xuICAgIHRoaXMuc2lnbiA9IGZhbHNlO1xuICAgIHRoaXMubGVuZ3RoID0gMTtcbiAgICB0aGlzLndvcmRzWzBdID0gMDtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuXG4gIC8vIGEgPiBiXG4gIHZhciBhO1xuICB2YXIgYjtcbiAgaWYgKGNtcCA+IDApIHtcbiAgICBhID0gdGhpcztcbiAgICBiID0gbnVtO1xuICB9IGVsc2Uge1xuICAgIGEgPSBudW07XG4gICAgYiA9IHRoaXM7XG4gIH1cblxuICB2YXIgY2FycnkgPSAwO1xuICBmb3IgKHZhciBpID0gMDsgaSA8IGIubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIgciA9IGEud29yZHNbaV0gLSBiLndvcmRzW2ldICsgY2Fycnk7XG4gICAgY2FycnkgPSByID4+IDI2O1xuICAgIHRoaXMud29yZHNbaV0gPSByICYgMHgzZmZmZmZmO1xuICB9XG4gIGZvciAoOyBjYXJyeSAhPT0gMCAmJiBpIDwgYS5sZW5ndGg7IGkrKykge1xuICAgIHZhciByID0gYS53b3Jkc1tpXSArIGNhcnJ5O1xuICAgIGNhcnJ5ID0gciA+PiAyNjtcbiAgICB0aGlzLndvcmRzW2ldID0gciAmIDB4M2ZmZmZmZjtcbiAgfVxuXG4gIC8vIENvcHkgcmVzdCBvZiB0aGUgd29yZHNcbiAgaWYgKGNhcnJ5ID09PSAwICYmIGkgPCBhLmxlbmd0aCAmJiBhICE9PSB0aGlzKVxuICAgIGZvciAoOyBpIDwgYS5sZW5ndGg7IGkrKylcbiAgICAgIHRoaXMud29yZHNbaV0gPSBhLndvcmRzW2ldO1xuICB0aGlzLmxlbmd0aCA9IE1hdGgubWF4KHRoaXMubGVuZ3RoLCBpKTtcblxuICBpZiAoYSAhPT0gdGhpcylcbiAgICB0aGlzLnNpZ24gPSB0cnVlO1xuXG4gIHJldHVybiB0aGlzLnN0cmlwKCk7XG59O1xuXG4vLyBTdWJ0cmFjdCBgbnVtYCBmcm9tIGB0aGlzYFxuQk4ucHJvdG90eXBlLnN1YiA9IGZ1bmN0aW9uIHN1YihudW0pIHtcbiAgcmV0dXJuIHRoaXMuY2xvbmUoKS5pc3ViKG51bSk7XG59O1xuXG4vKlxuLy8gTk9URTogVGhpcyBjb3VsZCBiZSBwb3RlbnRpb25hbGx5IHVzZWQgdG8gZ2VuZXJhdGUgbG9vcC1sZXNzIG11bHRpcGxpY2F0aW9uc1xuZnVuY3Rpb24gX2dlbkNvbWJNdWxUbyhhbGVuLCBibGVuKSB7XG4gIHZhciBsZW4gPSBhbGVuICsgYmxlbiAtIDE7XG4gIHZhciBzcmMgPSBbXG4gICAgJ3ZhciBhID0gdGhpcy53b3JkcywgYiA9IG51bS53b3JkcywgbyA9IG91dC53b3JkcywgYyA9IDAsIHcsICcgK1xuICAgICAgICAnbWFzayA9IDB4M2ZmZmZmZiwgc2hpZnQgPSAweDQwMDAwMDA7JyxcbiAgICAnb3V0Lmxlbmd0aCA9ICcgKyBsZW4gKyAnOydcbiAgXTtcbiAgZm9yICh2YXIgayA9IDA7IGsgPCBsZW47IGsrKykge1xuICAgIHZhciBtaW5KID0gTWF0aC5tYXgoMCwgayAtIGFsZW4gKyAxKTtcbiAgICB2YXIgbWF4SiA9IE1hdGgubWluKGssIGJsZW4gLSAxKTtcblxuICAgIGZvciAodmFyIGogPSBtaW5KOyBqIDw9IG1heEo7IGorKykge1xuICAgICAgdmFyIGkgPSBrIC0gajtcbiAgICAgIHZhciBtdWwgPSAnYVsnICsgaSArICddICogYlsnICsgaiArICddJztcblxuICAgICAgaWYgKGogPT09IG1pbkopIHtcbiAgICAgICAgc3JjLnB1c2goJ3cgPSAnICsgbXVsICsgJyArIGM7Jyk7XG4gICAgICAgIHNyYy5wdXNoKCdjID0gKHcgLyBzaGlmdCkgfCAwOycpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgc3JjLnB1c2goJ3cgKz0gJyArIG11bCArICc7Jyk7XG4gICAgICAgIHNyYy5wdXNoKCdjICs9ICh3IC8gc2hpZnQpIHwgMDsnKTtcbiAgICAgIH1cbiAgICAgIHNyYy5wdXNoKCd3ICY9IG1hc2s7Jyk7XG4gICAgfVxuICAgIHNyYy5wdXNoKCdvWycgKyBrICsgJ10gPSB3OycpO1xuICB9XG4gIHNyYy5wdXNoKCdpZiAoYyAhPT0gMCkgeycsXG4gICAgICAgICAgICcgIG9bJyArIGsgKyAnXSA9IGM7JyxcbiAgICAgICAgICAgJyAgb3V0Lmxlbmd0aCsrOycsXG4gICAgICAgICAgICd9JyxcbiAgICAgICAgICAgJ3JldHVybiBvdXQ7Jyk7XG5cbiAgcmV0dXJuIHNyYy5qb2luKCdcXG4nKTtcbn1cbiovXG5cbkJOLnByb3RvdHlwZS5fc21hbGxNdWxUbyA9IGZ1bmN0aW9uIF9zbWFsbE11bFRvKG51bSwgb3V0KSB7XG4gIG91dC5zaWduID0gbnVtLnNpZ24gIT09IHRoaXMuc2lnbjtcbiAgb3V0Lmxlbmd0aCA9IHRoaXMubGVuZ3RoICsgbnVtLmxlbmd0aDtcblxuICB2YXIgY2FycnkgPSAwO1xuICBmb3IgKHZhciBrID0gMDsgayA8IG91dC5sZW5ndGggLSAxOyBrKyspIHtcbiAgICAvLyBTdW0gYWxsIHdvcmRzIHdpdGggdGhlIHNhbWUgYGkgKyBqID0ga2AgYW5kIGFjY3VtdWxhdGUgYG5jYXJyeWAsXG4gICAgLy8gbm90ZSB0aGF0IG5jYXJyeSBjb3VsZCBiZSA+PSAweDNmZmZmZmZcbiAgICB2YXIgbmNhcnJ5ID0gY2FycnkgPj4+IDI2O1xuICAgIHZhciByd29yZCA9IGNhcnJ5ICYgMHgzZmZmZmZmO1xuICAgIHZhciBtYXhKID0gTWF0aC5taW4oaywgbnVtLmxlbmd0aCAtIDEpO1xuICAgIGZvciAodmFyIGogPSBNYXRoLm1heCgwLCBrIC0gdGhpcy5sZW5ndGggKyAxKTsgaiA8PSBtYXhKOyBqKyspIHtcbiAgICAgIHZhciBpID0gayAtIGo7XG4gICAgICB2YXIgYSA9IHRoaXMud29yZHNbaV0gfCAwO1xuICAgICAgdmFyIGIgPSBudW0ud29yZHNbal0gfCAwO1xuICAgICAgdmFyIHIgPSBhICogYjtcblxuICAgICAgdmFyIGxvID0gciAmIDB4M2ZmZmZmZjtcbiAgICAgIG5jYXJyeSA9IChuY2FycnkgKyAoKHIgLyAweDQwMDAwMDApIHwgMCkpIHwgMDtcbiAgICAgIGxvID0gKGxvICsgcndvcmQpIHwgMDtcbiAgICAgIHJ3b3JkID0gbG8gJiAweDNmZmZmZmY7XG4gICAgICBuY2FycnkgPSAobmNhcnJ5ICsgKGxvID4+PiAyNikpIHwgMDtcbiAgICB9XG4gICAgb3V0LndvcmRzW2tdID0gcndvcmQ7XG4gICAgY2FycnkgPSBuY2Fycnk7XG4gIH1cbiAgaWYgKGNhcnJ5ICE9PSAwKSB7XG4gICAgb3V0LndvcmRzW2tdID0gY2Fycnk7XG4gIH0gZWxzZSB7XG4gICAgb3V0Lmxlbmd0aC0tO1xuICB9XG5cbiAgcmV0dXJuIG91dC5zdHJpcCgpO1xufTtcblxuQk4ucHJvdG90eXBlLl9iaWdNdWxUbyA9IGZ1bmN0aW9uIF9iaWdNdWxUbyhudW0sIG91dCkge1xuICBvdXQuc2lnbiA9IG51bS5zaWduICE9PSB0aGlzLnNpZ247XG4gIG91dC5sZW5ndGggPSB0aGlzLmxlbmd0aCArIG51bS5sZW5ndGg7XG5cbiAgdmFyIGNhcnJ5ID0gMDtcbiAgdmFyIGhuY2FycnkgPSAwO1xuICBmb3IgKHZhciBrID0gMDsgayA8IG91dC5sZW5ndGggLSAxOyBrKyspIHtcbiAgICAvLyBTdW0gYWxsIHdvcmRzIHdpdGggdGhlIHNhbWUgYGkgKyBqID0ga2AgYW5kIGFjY3VtdWxhdGUgYG5jYXJyeWAsXG4gICAgLy8gbm90ZSB0aGF0IG5jYXJyeSBjb3VsZCBiZSA+PSAweDNmZmZmZmZcbiAgICB2YXIgbmNhcnJ5ID0gaG5jYXJyeTtcbiAgICBobmNhcnJ5ID0gMDtcbiAgICB2YXIgcndvcmQgPSBjYXJyeSAmIDB4M2ZmZmZmZjtcbiAgICB2YXIgbWF4SiA9IE1hdGgubWluKGssIG51bS5sZW5ndGggLSAxKTtcbiAgICBmb3IgKHZhciBqID0gTWF0aC5tYXgoMCwgayAtIHRoaXMubGVuZ3RoICsgMSk7IGogPD0gbWF4SjsgaisrKSB7XG4gICAgICB2YXIgaSA9IGsgLSBqO1xuICAgICAgdmFyIGEgPSB0aGlzLndvcmRzW2ldIHwgMDtcbiAgICAgIHZhciBiID0gbnVtLndvcmRzW2pdIHwgMDtcbiAgICAgIHZhciByID0gYSAqIGI7XG5cbiAgICAgIHZhciBsbyA9IHIgJiAweDNmZmZmZmY7XG4gICAgICBuY2FycnkgPSAobmNhcnJ5ICsgKChyIC8gMHg0MDAwMDAwKSB8IDApKSB8IDA7XG4gICAgICBsbyA9IChsbyArIHJ3b3JkKSB8IDA7XG4gICAgICByd29yZCA9IGxvICYgMHgzZmZmZmZmO1xuICAgICAgbmNhcnJ5ID0gKG5jYXJyeSArIChsbyA+Pj4gMjYpKSB8IDA7XG5cbiAgICAgIGhuY2FycnkgKz0gbmNhcnJ5ID4+PiAyNjtcbiAgICAgIG5jYXJyeSAmPSAweDNmZmZmZmY7XG4gICAgfVxuICAgIG91dC53b3Jkc1trXSA9IHJ3b3JkO1xuICAgIGNhcnJ5ID0gbmNhcnJ5O1xuICAgIG5jYXJyeSA9IGhuY2Fycnk7XG4gIH1cbiAgaWYgKGNhcnJ5ICE9PSAwKSB7XG4gICAgb3V0LndvcmRzW2tdID0gY2Fycnk7XG4gIH0gZWxzZSB7XG4gICAgb3V0Lmxlbmd0aC0tO1xuICB9XG5cbiAgcmV0dXJuIG91dC5zdHJpcCgpO1xufTtcblxuQk4ucHJvdG90eXBlLm11bFRvID0gZnVuY3Rpb24gbXVsVG8obnVtLCBvdXQpIHtcbiAgdmFyIHJlcztcbiAgaWYgKHRoaXMubGVuZ3RoICsgbnVtLmxlbmd0aCA8IDYzKVxuICAgIHJlcyA9IHRoaXMuX3NtYWxsTXVsVG8obnVtLCBvdXQpO1xuICBlbHNlXG4gICAgcmVzID0gdGhpcy5fYmlnTXVsVG8obnVtLCBvdXQpO1xuICByZXR1cm4gcmVzO1xufTtcblxuLy8gTXVsdGlwbHkgYHRoaXNgIGJ5IGBudW1gXG5CTi5wcm90b3R5cGUubXVsID0gZnVuY3Rpb24gbXVsKG51bSkge1xuICB2YXIgb3V0ID0gbmV3IEJOKG51bGwpO1xuICBvdXQud29yZHMgPSBuZXcgQXJyYXkodGhpcy5sZW5ndGggKyBudW0ubGVuZ3RoKTtcbiAgcmV0dXJuIHRoaXMubXVsVG8obnVtLCBvdXQpO1xufTtcblxuLy8gSW4tcGxhY2UgTXVsdGlwbGljYXRpb25cbkJOLnByb3RvdHlwZS5pbXVsID0gZnVuY3Rpb24gaW11bChudW0pIHtcbiAgaWYgKHRoaXMuY21wbigwKSA9PT0gMCB8fCBudW0uY21wbigwKSA9PT0gMCkge1xuICAgIHRoaXMud29yZHNbMF0gPSAwO1xuICAgIHRoaXMubGVuZ3RoID0gMTtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuXG4gIHZhciB0bGVuID0gdGhpcy5sZW5ndGg7XG4gIHZhciBubGVuID0gbnVtLmxlbmd0aDtcblxuICB0aGlzLnNpZ24gPSBudW0uc2lnbiAhPT0gdGhpcy5zaWduO1xuICB0aGlzLmxlbmd0aCA9IHRoaXMubGVuZ3RoICsgbnVtLmxlbmd0aDtcbiAgdGhpcy53b3Jkc1t0aGlzLmxlbmd0aCAtIDFdID0gMDtcblxuICBmb3IgKHZhciBrID0gdGhpcy5sZW5ndGggLSAyOyBrID49IDA7IGstLSkge1xuICAgIC8vIFN1bSBhbGwgd29yZHMgd2l0aCB0aGUgc2FtZSBgaSArIGogPSBrYCBhbmQgYWNjdW11bGF0ZSBgY2FycnlgLFxuICAgIC8vIG5vdGUgdGhhdCBjYXJyeSBjb3VsZCBiZSA+PSAweDNmZmZmZmZcbiAgICB2YXIgY2FycnkgPSAwO1xuICAgIHZhciByd29yZCA9IDA7XG4gICAgdmFyIG1heEogPSBNYXRoLm1pbihrLCBubGVuIC0gMSk7XG4gICAgZm9yICh2YXIgaiA9IE1hdGgubWF4KDAsIGsgLSB0bGVuICsgMSk7IGogPD0gbWF4SjsgaisrKSB7XG4gICAgICB2YXIgaSA9IGsgLSBqO1xuICAgICAgdmFyIGEgPSB0aGlzLndvcmRzW2ldO1xuICAgICAgdmFyIGIgPSBudW0ud29yZHNbal07XG4gICAgICB2YXIgciA9IGEgKiBiO1xuXG4gICAgICB2YXIgbG8gPSByICYgMHgzZmZmZmZmO1xuICAgICAgY2FycnkgKz0gKHIgLyAweDQwMDAwMDApIHwgMDtcbiAgICAgIGxvICs9IHJ3b3JkO1xuICAgICAgcndvcmQgPSBsbyAmIDB4M2ZmZmZmZjtcbiAgICAgIGNhcnJ5ICs9IGxvID4+PiAyNjtcbiAgICB9XG4gICAgdGhpcy53b3Jkc1trXSA9IHJ3b3JkO1xuICAgIHRoaXMud29yZHNbayArIDFdICs9IGNhcnJ5O1xuICAgIGNhcnJ5ID0gMDtcbiAgfVxuXG4gIC8vIFByb3BhZ2F0ZSBvdmVyZmxvd3NcbiAgdmFyIGNhcnJ5ID0gMDtcbiAgZm9yICh2YXIgaSA9IDE7IGkgPCB0aGlzLmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIHcgPSB0aGlzLndvcmRzW2ldICsgY2Fycnk7XG4gICAgdGhpcy53b3Jkc1tpXSA9IHcgJiAweDNmZmZmZmY7XG4gICAgY2FycnkgPSB3ID4+PiAyNjtcbiAgfVxuXG4gIHJldHVybiB0aGlzLnN0cmlwKCk7XG59O1xuXG5CTi5wcm90b3R5cGUuaW11bG4gPSBmdW5jdGlvbiBpbXVsbihudW0pIHtcbiAgYXNzZXJ0KHR5cGVvZiBudW0gPT09ICdudW1iZXInKTtcblxuICAvLyBDYXJyeVxuICB2YXIgY2FycnkgPSAwO1xuICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIgdyA9IHRoaXMud29yZHNbaV0gKiBudW07XG4gICAgdmFyIGxvID0gKHcgJiAweDNmZmZmZmYpICsgKGNhcnJ5ICYgMHgzZmZmZmZmKTtcbiAgICBjYXJyeSA+Pj0gMjY7XG4gICAgY2FycnkgKz0gKHcgLyAweDQwMDAwMDApIHwgMDtcbiAgICAvLyBOT1RFOiBsbyBpcyAyN2JpdCBtYXhpbXVtXG4gICAgY2FycnkgKz0gbG8gPj4+IDI2O1xuICAgIHRoaXMud29yZHNbaV0gPSBsbyAmIDB4M2ZmZmZmZjtcbiAgfVxuXG4gIGlmIChjYXJyeSAhPT0gMCkge1xuICAgIHRoaXMud29yZHNbaV0gPSBjYXJyeTtcbiAgICB0aGlzLmxlbmd0aCsrO1xuICB9XG5cbiAgcmV0dXJuIHRoaXM7XG59O1xuXG5CTi5wcm90b3R5cGUubXVsbiA9IGZ1bmN0aW9uIG11bG4obnVtKSB7XG4gIHJldHVybiB0aGlzLmNsb25lKCkuaW11bG4obnVtKTtcbn07XG5cbi8vIGB0aGlzYCAqIGB0aGlzYFxuQk4ucHJvdG90eXBlLnNxciA9IGZ1bmN0aW9uIHNxcigpIHtcbiAgcmV0dXJuIHRoaXMubXVsKHRoaXMpO1xufTtcblxuLy8gYHRoaXNgICogYHRoaXNgIGluLXBsYWNlXG5CTi5wcm90b3R5cGUuaXNxciA9IGZ1bmN0aW9uIGlzcXIoKSB7XG4gIHJldHVybiB0aGlzLm11bCh0aGlzKTtcbn07XG5cbi8vIFNoaWZ0LWxlZnQgaW4tcGxhY2VcbkJOLnByb3RvdHlwZS5pc2hsbiA9IGZ1bmN0aW9uIGlzaGxuKGJpdHMpIHtcbiAgYXNzZXJ0KHR5cGVvZiBiaXRzID09PSAnbnVtYmVyJyAmJiBiaXRzID49IDApO1xuICB2YXIgciA9IGJpdHMgJSAyNjtcbiAgdmFyIHMgPSAoYml0cyAtIHIpIC8gMjY7XG4gIHZhciBjYXJyeU1hc2sgPSAoMHgzZmZmZmZmID4+PiAoMjYgLSByKSkgPDwgKDI2IC0gcik7XG5cbiAgaWYgKHIgIT09IDApIHtcbiAgICB2YXIgY2FycnkgPSAwO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIG5ld0NhcnJ5ID0gdGhpcy53b3Jkc1tpXSAmIGNhcnJ5TWFzaztcbiAgICAgIHZhciBjID0gKHRoaXMud29yZHNbaV0gLSBuZXdDYXJyeSkgPDwgcjtcbiAgICAgIHRoaXMud29yZHNbaV0gPSBjIHwgY2Fycnk7XG4gICAgICBjYXJyeSA9IG5ld0NhcnJ5ID4+PiAoMjYgLSByKTtcbiAgICB9XG4gICAgaWYgKGNhcnJ5KSB7XG4gICAgICB0aGlzLndvcmRzW2ldID0gY2Fycnk7XG4gICAgICB0aGlzLmxlbmd0aCsrO1xuICAgIH1cbiAgfVxuXG4gIGlmIChzICE9PSAwKSB7XG4gICAgZm9yICh2YXIgaSA9IHRoaXMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pXG4gICAgICB0aGlzLndvcmRzW2kgKyBzXSA9IHRoaXMud29yZHNbaV07XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBzOyBpKyspXG4gICAgICB0aGlzLndvcmRzW2ldID0gMDtcbiAgICB0aGlzLmxlbmd0aCArPSBzO1xuICB9XG5cbiAgcmV0dXJuIHRoaXMuc3RyaXAoKTtcbn07XG5cbi8vIFNoaWZ0LXJpZ2h0IGluLXBsYWNlXG4vLyBOT1RFOiBgaGludGAgaXMgYSBsb3dlc3QgYml0IGJlZm9yZSB0cmFpbGluZyB6ZXJvZXNcbi8vIE5PVEU6IGlmIGBleHRlbmRlZGAgaXMgcHJlc2VudCAtIGl0IHdpbGwgYmUgZmlsbGVkIHdpdGggZGVzdHJveWVkIGJpdHNcbkJOLnByb3RvdHlwZS5pc2hybiA9IGZ1bmN0aW9uIGlzaHJuKGJpdHMsIGhpbnQsIGV4dGVuZGVkKSB7XG4gIGFzc2VydCh0eXBlb2YgYml0cyA9PT0gJ251bWJlcicgJiYgYml0cyA+PSAwKTtcbiAgdmFyIGg7XG4gIGlmIChoaW50KVxuICAgIGggPSAoaGludCAtIChoaW50ICUgMjYpKSAvIDI2O1xuICBlbHNlXG4gICAgaCA9IDA7XG5cbiAgdmFyIHIgPSBiaXRzICUgMjY7XG4gIHZhciBzID0gTWF0aC5taW4oKGJpdHMgLSByKSAvIDI2LCB0aGlzLmxlbmd0aCk7XG4gIHZhciBtYXNrID0gMHgzZmZmZmZmIF4gKCgweDNmZmZmZmYgPj4+IHIpIDw8IHIpO1xuICB2YXIgbWFza2VkV29yZHMgPSBleHRlbmRlZDtcblxuICBoIC09IHM7XG4gIGggPSBNYXRoLm1heCgwLCBoKTtcblxuICAvLyBFeHRlbmRlZCBtb2RlLCBjb3B5IG1hc2tlZCBwYXJ0XG4gIGlmIChtYXNrZWRXb3Jkcykge1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgczsgaSsrKVxuICAgICAgbWFza2VkV29yZHMud29yZHNbaV0gPSB0aGlzLndvcmRzW2ldO1xuICAgIG1hc2tlZFdvcmRzLmxlbmd0aCA9IHM7XG4gIH1cblxuICBpZiAocyA9PT0gMCkge1xuICAgIC8vIE5vLW9wLCB3ZSBzaG91bGQgbm90IG1vdmUgYW55dGhpbmcgYXQgYWxsXG4gIH0gZWxzZSBpZiAodGhpcy5sZW5ndGggPiBzKSB7XG4gICAgdGhpcy5sZW5ndGggLT0gcztcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMubGVuZ3RoOyBpKyspXG4gICAgICB0aGlzLndvcmRzW2ldID0gdGhpcy53b3Jkc1tpICsgc107XG4gIH0gZWxzZSB7XG4gICAgdGhpcy53b3Jkc1swXSA9IDA7XG4gICAgdGhpcy5sZW5ndGggPSAxO1xuICB9XG5cbiAgdmFyIGNhcnJ5ID0gMDtcbiAgZm9yICh2YXIgaSA9IHRoaXMubGVuZ3RoIC0gMTsgaSA+PSAwICYmIChjYXJyeSAhPT0gMCB8fCBpID49IGgpOyBpLS0pIHtcbiAgICB2YXIgd29yZCA9IHRoaXMud29yZHNbaV07XG4gICAgdGhpcy53b3Jkc1tpXSA9IChjYXJyeSA8PCAoMjYgLSByKSkgfCAod29yZCA+Pj4gcik7XG4gICAgY2FycnkgPSB3b3JkICYgbWFzaztcbiAgfVxuXG4gIC8vIFB1c2ggY2FycmllZCBiaXRzIGFzIGEgbWFza1xuICBpZiAobWFza2VkV29yZHMgJiYgY2FycnkgIT09IDApXG4gICAgbWFza2VkV29yZHMud29yZHNbbWFza2VkV29yZHMubGVuZ3RoKytdID0gY2Fycnk7XG5cbiAgaWYgKHRoaXMubGVuZ3RoID09PSAwKSB7XG4gICAgdGhpcy53b3Jkc1swXSA9IDA7XG4gICAgdGhpcy5sZW5ndGggPSAxO1xuICB9XG5cbiAgdGhpcy5zdHJpcCgpO1xuXG4gIHJldHVybiB0aGlzO1xufTtcblxuLy8gU2hpZnQtbGVmdFxuQk4ucHJvdG90eXBlLnNobG4gPSBmdW5jdGlvbiBzaGxuKGJpdHMpIHtcbiAgcmV0dXJuIHRoaXMuY2xvbmUoKS5pc2hsbihiaXRzKTtcbn07XG5cbi8vIFNoaWZ0LXJpZ2h0XG5CTi5wcm90b3R5cGUuc2hybiA9IGZ1bmN0aW9uIHNocm4oYml0cykge1xuICByZXR1cm4gdGhpcy5jbG9uZSgpLmlzaHJuKGJpdHMpO1xufTtcblxuLy8gVGVzdCBpZiBuIGJpdCBpcyBzZXRcbkJOLnByb3RvdHlwZS50ZXN0biA9IGZ1bmN0aW9uIHRlc3RuKGJpdCkge1xuICBhc3NlcnQodHlwZW9mIGJpdCA9PT0gJ251bWJlcicgJiYgYml0ID49IDApO1xuICB2YXIgciA9IGJpdCAlIDI2O1xuICB2YXIgcyA9IChiaXQgLSByKSAvIDI2O1xuICB2YXIgcSA9IDEgPDwgcjtcblxuICAvLyBGYXN0IGNhc2U6IGJpdCBpcyBtdWNoIGhpZ2hlciB0aGFuIGFsbCBleGlzdGluZyB3b3Jkc1xuICBpZiAodGhpcy5sZW5ndGggPD0gcykge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIC8vIENoZWNrIGJpdCBhbmQgcmV0dXJuXG4gIHZhciB3ID0gdGhpcy53b3Jkc1tzXTtcblxuICByZXR1cm4gISEodyAmIHEpO1xufTtcblxuLy8gUmV0dXJuIG9ubHkgbG93ZXJzIGJpdHMgb2YgbnVtYmVyIChpbi1wbGFjZSlcbkJOLnByb3RvdHlwZS5pbWFza24gPSBmdW5jdGlvbiBpbWFza24oYml0cykge1xuICBhc3NlcnQodHlwZW9mIGJpdHMgPT09ICdudW1iZXInICYmIGJpdHMgPj0gMCk7XG4gIHZhciByID0gYml0cyAlIDI2O1xuICB2YXIgcyA9IChiaXRzIC0gcikgLyAyNjtcblxuICBhc3NlcnQoIXRoaXMuc2lnbiwgJ2ltYXNrbiB3b3JrcyBvbmx5IHdpdGggcG9zaXRpdmUgbnVtYmVycycpO1xuXG4gIGlmIChyICE9PSAwKVxuICAgIHMrKztcbiAgdGhpcy5sZW5ndGggPSBNYXRoLm1pbihzLCB0aGlzLmxlbmd0aCk7XG5cbiAgaWYgKHIgIT09IDApIHtcbiAgICB2YXIgbWFzayA9IDB4M2ZmZmZmZiBeICgoMHgzZmZmZmZmID4+PiByKSA8PCByKTtcbiAgICB0aGlzLndvcmRzW3RoaXMubGVuZ3RoIC0gMV0gJj0gbWFzaztcbiAgfVxuXG4gIHJldHVybiB0aGlzLnN0cmlwKCk7XG59O1xuXG4vLyBSZXR1cm4gb25seSBsb3dlcnMgYml0cyBvZiBudW1iZXJcbkJOLnByb3RvdHlwZS5tYXNrbiA9IGZ1bmN0aW9uIG1hc2tuKGJpdHMpIHtcbiAgcmV0dXJuIHRoaXMuY2xvbmUoKS5pbWFza24oYml0cyk7XG59O1xuXG4vLyBBZGQgcGxhaW4gbnVtYmVyIGBudW1gIHRvIGB0aGlzYFxuQk4ucHJvdG90eXBlLmlhZGRuID0gZnVuY3Rpb24gaWFkZG4obnVtKSB7XG4gIGFzc2VydCh0eXBlb2YgbnVtID09PSAnbnVtYmVyJyk7XG4gIGlmIChudW0gPCAwKVxuICAgIHJldHVybiB0aGlzLmlzdWJuKC1udW0pO1xuXG4gIC8vIFBvc3NpYmxlIHNpZ24gY2hhbmdlXG4gIGlmICh0aGlzLnNpZ24pIHtcbiAgICBpZiAodGhpcy5sZW5ndGggPT09IDEgJiYgdGhpcy53b3Jkc1swXSA8IG51bSkge1xuICAgICAgdGhpcy53b3Jkc1swXSA9IG51bSAtIHRoaXMud29yZHNbMF07XG4gICAgICB0aGlzLnNpZ24gPSBmYWxzZTtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxuICAgIHRoaXMuc2lnbiA9IGZhbHNlO1xuICAgIHRoaXMuaXN1Ym4obnVtKTtcbiAgICB0aGlzLnNpZ24gPSB0cnVlO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG5cbiAgLy8gQWRkIHdpdGhvdXQgY2hlY2tzXG4gIHJldHVybiB0aGlzLl9pYWRkbihudW0pO1xufTtcblxuQk4ucHJvdG90eXBlLl9pYWRkbiA9IGZ1bmN0aW9uIF9pYWRkbihudW0pIHtcbiAgdGhpcy53b3Jkc1swXSArPSBudW07XG5cbiAgLy8gQ2FycnlcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLmxlbmd0aCAmJiB0aGlzLndvcmRzW2ldID49IDB4NDAwMDAwMDsgaSsrKSB7XG4gICAgdGhpcy53b3Jkc1tpXSAtPSAweDQwMDAwMDA7XG4gICAgaWYgKGkgPT09IHRoaXMubGVuZ3RoIC0gMSlcbiAgICAgIHRoaXMud29yZHNbaSArIDFdID0gMTtcbiAgICBlbHNlXG4gICAgICB0aGlzLndvcmRzW2kgKyAxXSsrO1xuICB9XG4gIHRoaXMubGVuZ3RoID0gTWF0aC5tYXgodGhpcy5sZW5ndGgsIGkgKyAxKTtcblxuICByZXR1cm4gdGhpcztcbn07XG5cbi8vIFN1YnRyYWN0IHBsYWluIG51bWJlciBgbnVtYCBmcm9tIGB0aGlzYFxuQk4ucHJvdG90eXBlLmlzdWJuID0gZnVuY3Rpb24gaXN1Ym4obnVtKSB7XG4gIGFzc2VydCh0eXBlb2YgbnVtID09PSAnbnVtYmVyJyk7XG4gIGlmIChudW0gPCAwKVxuICAgIHJldHVybiB0aGlzLmlhZGRuKC1udW0pO1xuXG4gIGlmICh0aGlzLnNpZ24pIHtcbiAgICB0aGlzLnNpZ24gPSBmYWxzZTtcbiAgICB0aGlzLmlhZGRuKG51bSk7XG4gICAgdGhpcy5zaWduID0gdHJ1ZTtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuXG4gIHRoaXMud29yZHNbMF0gLT0gbnVtO1xuXG4gIC8vIENhcnJ5XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5sZW5ndGggJiYgdGhpcy53b3Jkc1tpXSA8IDA7IGkrKykge1xuICAgIHRoaXMud29yZHNbaV0gKz0gMHg0MDAwMDAwO1xuICAgIHRoaXMud29yZHNbaSArIDFdIC09IDE7XG4gIH1cblxuICByZXR1cm4gdGhpcy5zdHJpcCgpO1xufTtcblxuQk4ucHJvdG90eXBlLmFkZG4gPSBmdW5jdGlvbiBhZGRuKG51bSkge1xuICByZXR1cm4gdGhpcy5jbG9uZSgpLmlhZGRuKG51bSk7XG59O1xuXG5CTi5wcm90b3R5cGUuc3VibiA9IGZ1bmN0aW9uIHN1Ym4obnVtKSB7XG4gIHJldHVybiB0aGlzLmNsb25lKCkuaXN1Ym4obnVtKTtcbn07XG5cbkJOLnByb3RvdHlwZS5pYWJzID0gZnVuY3Rpb24gaWFicygpIHtcbiAgdGhpcy5zaWduID0gZmFsc2U7XG5cbiAgcmV0dXJuIHRoaXM7XG59O1xuXG5CTi5wcm90b3R5cGUuYWJzID0gZnVuY3Rpb24gYWJzKCkge1xuICByZXR1cm4gdGhpcy5jbG9uZSgpLmlhYnMoKTtcbn07XG5cbkJOLnByb3RvdHlwZS5faXNobG5zdWJtdWwgPSBmdW5jdGlvbiBfaXNobG5zdWJtdWwobnVtLCBtdWwsIHNoaWZ0KSB7XG4gIC8vIEJpZ2dlciBzdG9yYWdlIGlzIG5lZWRlZFxuICB2YXIgbGVuID0gbnVtLmxlbmd0aCArIHNoaWZ0O1xuICB2YXIgaTtcbiAgaWYgKHRoaXMud29yZHMubGVuZ3RoIDwgbGVuKSB7XG4gICAgdmFyIHQgPSBuZXcgQXJyYXkobGVuKTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMubGVuZ3RoOyBpKyspXG4gICAgICB0W2ldID0gdGhpcy53b3Jkc1tpXTtcbiAgICB0aGlzLndvcmRzID0gdDtcbiAgfSBlbHNlIHtcbiAgICBpID0gdGhpcy5sZW5ndGg7XG4gIH1cblxuICAvLyBaZXJvaWZ5IHJlc3RcbiAgdGhpcy5sZW5ndGggPSBNYXRoLm1heCh0aGlzLmxlbmd0aCwgbGVuKTtcbiAgZm9yICg7IGkgPCB0aGlzLmxlbmd0aDsgaSsrKVxuICAgIHRoaXMud29yZHNbaV0gPSAwO1xuXG4gIHZhciBjYXJyeSA9IDA7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbnVtLmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIHcgPSB0aGlzLndvcmRzW2kgKyBzaGlmdF0gKyBjYXJyeTtcbiAgICB2YXIgcmlnaHQgPSBudW0ud29yZHNbaV0gKiBtdWw7XG4gICAgdyAtPSByaWdodCAmIDB4M2ZmZmZmZjtcbiAgICBjYXJyeSA9ICh3ID4+IDI2KSAtICgocmlnaHQgLyAweDQwMDAwMDApIHwgMCk7XG4gICAgdGhpcy53b3Jkc1tpICsgc2hpZnRdID0gdyAmIDB4M2ZmZmZmZjtcbiAgfVxuICBmb3IgKDsgaSA8IHRoaXMubGVuZ3RoIC0gc2hpZnQ7IGkrKykge1xuICAgIHZhciB3ID0gdGhpcy53b3Jkc1tpICsgc2hpZnRdICsgY2Fycnk7XG4gICAgY2FycnkgPSB3ID4+IDI2O1xuICAgIHRoaXMud29yZHNbaSArIHNoaWZ0XSA9IHcgJiAweDNmZmZmZmY7XG4gIH1cblxuICBpZiAoY2FycnkgPT09IDApXG4gICAgcmV0dXJuIHRoaXMuc3RyaXAoKTtcblxuICAvLyBTdWJ0cmFjdGlvbiBvdmVyZmxvd1xuICBhc3NlcnQoY2FycnkgPT09IC0xKTtcbiAgY2FycnkgPSAwO1xuICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIgdyA9IC10aGlzLndvcmRzW2ldICsgY2Fycnk7XG4gICAgY2FycnkgPSB3ID4+IDI2O1xuICAgIHRoaXMud29yZHNbaV0gPSB3ICYgMHgzZmZmZmZmO1xuICB9XG4gIHRoaXMuc2lnbiA9IHRydWU7XG5cbiAgcmV0dXJuIHRoaXMuc3RyaXAoKTtcbn07XG5cbkJOLnByb3RvdHlwZS5fd29yZERpdiA9IGZ1bmN0aW9uIF93b3JkRGl2KG51bSwgbW9kZSkge1xuICB2YXIgc2hpZnQgPSB0aGlzLmxlbmd0aCAtIG51bS5sZW5ndGg7XG5cbiAgdmFyIGEgPSB0aGlzLmNsb25lKCk7XG4gIHZhciBiID0gbnVtO1xuXG4gIC8vIE5vcm1hbGl6ZVxuICB2YXIgYmhpID0gYi53b3Jkc1tiLmxlbmd0aCAtIDFdO1xuICB2YXIgYmhpQml0cyA9IHRoaXMuX2NvdW50Qml0cyhiaGkpO1xuICBzaGlmdCA9IDI2IC0gYmhpQml0cztcbiAgaWYgKHNoaWZ0ICE9PSAwKSB7XG4gICAgYiA9IGIuc2hsbihzaGlmdCk7XG4gICAgYS5pc2hsbihzaGlmdCk7XG4gICAgYmhpID0gYi53b3Jkc1tiLmxlbmd0aCAtIDFdO1xuICB9XG5cbiAgLy8gSW5pdGlhbGl6ZSBxdW90aWVudFxuICB2YXIgbSA9IGEubGVuZ3RoIC0gYi5sZW5ndGg7XG4gIHZhciBxO1xuXG4gIGlmIChtb2RlICE9PSAnbW9kJykge1xuICAgIHEgPSBuZXcgQk4obnVsbCk7XG4gICAgcS5sZW5ndGggPSBtICsgMTtcbiAgICBxLndvcmRzID0gbmV3IEFycmF5KHEubGVuZ3RoKTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHEubGVuZ3RoOyBpKyspXG4gICAgICBxLndvcmRzW2ldID0gMDtcbiAgfVxuXG4gIHZhciBkaWZmID0gYS5jbG9uZSgpLl9pc2hsbnN1Ym11bChiLCAxLCBtKTtcbiAgaWYgKCFkaWZmLnNpZ24pIHtcbiAgICBhID0gZGlmZjtcbiAgICBpZiAocSlcbiAgICAgIHEud29yZHNbbV0gPSAxO1xuICB9XG5cbiAgZm9yICh2YXIgaiA9IG0gLSAxOyBqID49IDA7IGotLSkge1xuICAgIHZhciBxaiA9IGEud29yZHNbYi5sZW5ndGggKyBqXSAqIDB4NDAwMDAwMCArIGEud29yZHNbYi5sZW5ndGggKyBqIC0gMV07XG5cbiAgICAvLyBOT1RFOiAocWogLyBiaGkpIGlzICgweDNmZmZmZmYgKiAweDQwMDAwMDAgKyAweDNmZmZmZmYpIC8gMHgyMDAwMDAwIG1heFxuICAgIC8vICgweDdmZmZmZmYpXG4gICAgcWogPSBNYXRoLm1pbigocWogLyBiaGkpIHwgMCwgMHgzZmZmZmZmKTtcblxuICAgIGEuX2lzaGxuc3VibXVsKGIsIHFqLCBqKTtcbiAgICB3aGlsZSAoYS5zaWduKSB7XG4gICAgICBxai0tO1xuICAgICAgYS5zaWduID0gZmFsc2U7XG4gICAgICBhLl9pc2hsbnN1Ym11bChiLCAxLCBqKTtcbiAgICAgIGlmIChhLmNtcG4oMCkgIT09IDApXG4gICAgICAgIGEuc2lnbiA9ICFhLnNpZ247XG4gICAgfVxuICAgIGlmIChxKVxuICAgICAgcS53b3Jkc1tqXSA9IHFqO1xuICB9XG4gIGlmIChxKVxuICAgIHEuc3RyaXAoKTtcbiAgYS5zdHJpcCgpO1xuXG4gIC8vIERlbm9ybWFsaXplXG4gIGlmIChtb2RlICE9PSAnZGl2JyAmJiBzaGlmdCAhPT0gMClcbiAgICBhLmlzaHJuKHNoaWZ0KTtcbiAgcmV0dXJuIHsgZGl2OiBxID8gcSA6IG51bGwsIG1vZDogYSB9O1xufTtcblxuQk4ucHJvdG90eXBlLmRpdm1vZCA9IGZ1bmN0aW9uIGRpdm1vZChudW0sIG1vZGUpIHtcbiAgYXNzZXJ0KG51bS5jbXBuKDApICE9PSAwKTtcblxuICBpZiAodGhpcy5zaWduICYmICFudW0uc2lnbikge1xuICAgIHZhciByZXMgPSB0aGlzLm5lZygpLmRpdm1vZChudW0sIG1vZGUpO1xuICAgIHZhciBkaXY7XG4gICAgdmFyIG1vZDtcbiAgICBpZiAobW9kZSAhPT0gJ21vZCcpXG4gICAgICBkaXYgPSByZXMuZGl2Lm5lZygpO1xuICAgIGlmIChtb2RlICE9PSAnZGl2JylcbiAgICAgIG1vZCA9IHJlcy5tb2QuY21wbigwKSA9PT0gMCA/IHJlcy5tb2QgOiBudW0uc3ViKHJlcy5tb2QpO1xuICAgIHJldHVybiB7XG4gICAgICBkaXY6IGRpdixcbiAgICAgIG1vZDogbW9kXG4gICAgfTtcbiAgfSBlbHNlIGlmICghdGhpcy5zaWduICYmIG51bS5zaWduKSB7XG4gICAgdmFyIHJlcyA9IHRoaXMuZGl2bW9kKG51bS5uZWcoKSwgbW9kZSk7XG4gICAgdmFyIGRpdjtcbiAgICBpZiAobW9kZSAhPT0gJ21vZCcpXG4gICAgICBkaXYgPSByZXMuZGl2Lm5lZygpO1xuICAgIHJldHVybiB7IGRpdjogZGl2LCBtb2Q6IHJlcy5tb2QgfTtcbiAgfSBlbHNlIGlmICh0aGlzLnNpZ24gJiYgbnVtLnNpZ24pIHtcbiAgICByZXR1cm4gdGhpcy5uZWcoKS5kaXZtb2QobnVtLm5lZygpLCBtb2RlKTtcbiAgfVxuXG4gIC8vIEJvdGggbnVtYmVycyBhcmUgcG9zaXRpdmUgYXQgdGhpcyBwb2ludFxuXG4gIC8vIFN0cmlwIGJvdGggbnVtYmVycyB0byBhcHByb3hpbWF0ZSBzaGlmdCB2YWx1ZVxuICBpZiAobnVtLmxlbmd0aCA+IHRoaXMubGVuZ3RoIHx8IHRoaXMuY21wKG51bSkgPCAwKVxuICAgIHJldHVybiB7IGRpdjogbmV3IEJOKDApLCBtb2Q6IHRoaXMgfTtcblxuICAvLyBWZXJ5IHNob3J0IHJlZHVjdGlvblxuICBpZiAobnVtLmxlbmd0aCA9PT0gMSkge1xuICAgIGlmIChtb2RlID09PSAnZGl2JylcbiAgICAgIHJldHVybiB7IGRpdjogdGhpcy5kaXZuKG51bS53b3Jkc1swXSksIG1vZDogbnVsbCB9O1xuICAgIGVsc2UgaWYgKG1vZGUgPT09ICdtb2QnKVxuICAgICAgcmV0dXJuIHsgZGl2OiBudWxsLCBtb2Q6IG5ldyBCTih0aGlzLm1vZG4obnVtLndvcmRzWzBdKSkgfTtcbiAgICByZXR1cm4ge1xuICAgICAgZGl2OiB0aGlzLmRpdm4obnVtLndvcmRzWzBdKSxcbiAgICAgIG1vZDogbmV3IEJOKHRoaXMubW9kbihudW0ud29yZHNbMF0pKVxuICAgIH07XG4gIH1cblxuICByZXR1cm4gdGhpcy5fd29yZERpdihudW0sIG1vZGUpO1xufTtcblxuLy8gRmluZCBgdGhpc2AgLyBgbnVtYFxuQk4ucHJvdG90eXBlLmRpdiA9IGZ1bmN0aW9uIGRpdihudW0pIHtcbiAgcmV0dXJuIHRoaXMuZGl2bW9kKG51bSwgJ2RpdicpLmRpdjtcbn07XG5cbi8vIEZpbmQgYHRoaXNgICUgYG51bWBcbkJOLnByb3RvdHlwZS5tb2QgPSBmdW5jdGlvbiBtb2QobnVtKSB7XG4gIHJldHVybiB0aGlzLmRpdm1vZChudW0sICdtb2QnKS5tb2Q7XG59O1xuXG4vLyBGaW5kIFJvdW5kKGB0aGlzYCAvIGBudW1gKVxuQk4ucHJvdG90eXBlLmRpdlJvdW5kID0gZnVuY3Rpb24gZGl2Um91bmQobnVtKSB7XG4gIHZhciBkbSA9IHRoaXMuZGl2bW9kKG51bSk7XG5cbiAgLy8gRmFzdCBjYXNlIC0gZXhhY3QgZGl2aXNpb25cbiAgaWYgKGRtLm1vZC5jbXBuKDApID09PSAwKVxuICAgIHJldHVybiBkbS5kaXY7XG5cbiAgdmFyIG1vZCA9IGRtLmRpdi5zaWduID8gZG0ubW9kLmlzdWIobnVtKSA6IGRtLm1vZDtcblxuICB2YXIgaGFsZiA9IG51bS5zaHJuKDEpO1xuICB2YXIgcjIgPSBudW0uYW5kbG4oMSk7XG4gIHZhciBjbXAgPSBtb2QuY21wKGhhbGYpO1xuXG4gIC8vIFJvdW5kIGRvd25cbiAgaWYgKGNtcCA8IDAgfHwgcjIgPT09IDEgJiYgY21wID09PSAwKVxuICAgIHJldHVybiBkbS5kaXY7XG5cbiAgLy8gUm91bmQgdXBcbiAgcmV0dXJuIGRtLmRpdi5zaWduID8gZG0uZGl2LmlzdWJuKDEpIDogZG0uZGl2LmlhZGRuKDEpO1xufTtcblxuQk4ucHJvdG90eXBlLm1vZG4gPSBmdW5jdGlvbiBtb2RuKG51bSkge1xuICBhc3NlcnQobnVtIDw9IDB4M2ZmZmZmZik7XG4gIHZhciBwID0gKDEgPDwgMjYpICUgbnVtO1xuXG4gIHZhciBhY2MgPSAwO1xuICBmb3IgKHZhciBpID0gdGhpcy5sZW5ndGggLSAxOyBpID49IDA7IGktLSlcbiAgICBhY2MgPSAocCAqIGFjYyArIHRoaXMud29yZHNbaV0pICUgbnVtO1xuXG4gIHJldHVybiBhY2M7XG59O1xuXG4vLyBJbi1wbGFjZSBkaXZpc2lvbiBieSBudW1iZXJcbkJOLnByb3RvdHlwZS5pZGl2biA9IGZ1bmN0aW9uIGlkaXZuKG51bSkge1xuICBhc3NlcnQobnVtIDw9IDB4M2ZmZmZmZik7XG5cbiAgdmFyIGNhcnJ5ID0gMDtcbiAgZm9yICh2YXIgaSA9IHRoaXMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICB2YXIgdyA9IHRoaXMud29yZHNbaV0gKyBjYXJyeSAqIDB4NDAwMDAwMDtcbiAgICB0aGlzLndvcmRzW2ldID0gKHcgLyBudW0pIHwgMDtcbiAgICBjYXJyeSA9IHcgJSBudW07XG4gIH1cblxuICByZXR1cm4gdGhpcy5zdHJpcCgpO1xufTtcblxuQk4ucHJvdG90eXBlLmRpdm4gPSBmdW5jdGlvbiBkaXZuKG51bSkge1xuICByZXR1cm4gdGhpcy5jbG9uZSgpLmlkaXZuKG51bSk7XG59O1xuXG5CTi5wcm90b3R5cGUuZWdjZCA9IGZ1bmN0aW9uIGVnY2QocCkge1xuICBhc3NlcnQoIXAuc2lnbik7XG4gIGFzc2VydChwLmNtcG4oMCkgIT09IDApO1xuXG4gIHZhciB4ID0gdGhpcztcbiAgdmFyIHkgPSBwLmNsb25lKCk7XG5cbiAgaWYgKHguc2lnbilcbiAgICB4ID0geC5tb2QocCk7XG4gIGVsc2VcbiAgICB4ID0geC5jbG9uZSgpO1xuXG4gIC8vIEEgKiB4ICsgQiAqIHkgPSB4XG4gIHZhciBBID0gbmV3IEJOKDEpO1xuICB2YXIgQiA9IG5ldyBCTigwKTtcblxuICAvLyBDICogeCArIEQgKiB5ID0geVxuICB2YXIgQyA9IG5ldyBCTigwKTtcbiAgdmFyIEQgPSBuZXcgQk4oMSk7XG5cbiAgdmFyIGcgPSAwO1xuXG4gIHdoaWxlICh4LmlzRXZlbigpICYmIHkuaXNFdmVuKCkpIHtcbiAgICB4LmlzaHJuKDEpO1xuICAgIHkuaXNocm4oMSk7XG4gICAgKytnO1xuICB9XG5cbiAgdmFyIHlwID0geS5jbG9uZSgpO1xuICB2YXIgeHAgPSB4LmNsb25lKCk7XG5cbiAgd2hpbGUgKHguY21wbigwKSAhPT0gMCkge1xuICAgIHdoaWxlICh4LmlzRXZlbigpKSB7XG4gICAgICB4LmlzaHJuKDEpO1xuICAgICAgaWYgKEEuaXNFdmVuKCkgJiYgQi5pc0V2ZW4oKSkge1xuICAgICAgICBBLmlzaHJuKDEpO1xuICAgICAgICBCLmlzaHJuKDEpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgQS5pYWRkKHlwKS5pc2hybigxKTtcbiAgICAgICAgQi5pc3ViKHhwKS5pc2hybigxKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICB3aGlsZSAoeS5pc0V2ZW4oKSkge1xuICAgICAgeS5pc2hybigxKTtcbiAgICAgIGlmIChDLmlzRXZlbigpICYmIEQuaXNFdmVuKCkpIHtcbiAgICAgICAgQy5pc2hybigxKTtcbiAgICAgICAgRC5pc2hybigxKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIEMuaWFkZCh5cCkuaXNocm4oMSk7XG4gICAgICAgIEQuaXN1Yih4cCkuaXNocm4oMSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKHguY21wKHkpID49IDApIHtcbiAgICAgIHguaXN1Yih5KTtcbiAgICAgIEEuaXN1YihDKTtcbiAgICAgIEIuaXN1YihEKTtcbiAgICB9IGVsc2Uge1xuICAgICAgeS5pc3ViKHgpO1xuICAgICAgQy5pc3ViKEEpO1xuICAgICAgRC5pc3ViKEIpO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiB7XG4gICAgYTogQyxcbiAgICBiOiBELFxuICAgIGdjZDogeS5pc2hsbihnKVxuICB9O1xufTtcblxuLy8gVGhpcyBpcyByZWR1Y2VkIGluY2FybmF0aW9uIG9mIHRoZSBiaW5hcnkgRUVBXG4vLyBhYm92ZSwgZGVzaWduYXRlZCB0byBpbnZlcnQgbWVtYmVycyBvZiB0aGVcbi8vIF9wcmltZV8gZmllbGRzIEYocCkgYXQgYSBtYXhpbWFsIHNwZWVkXG5CTi5wcm90b3R5cGUuX2ludm1wID0gZnVuY3Rpb24gX2ludm1wKHApIHtcbiAgYXNzZXJ0KCFwLnNpZ24pO1xuICBhc3NlcnQocC5jbXBuKDApICE9PSAwKTtcblxuICB2YXIgYSA9IHRoaXM7XG4gIHZhciBiID0gcC5jbG9uZSgpO1xuXG4gIGlmIChhLnNpZ24pXG4gICAgYSA9IGEubW9kKHApO1xuICBlbHNlXG4gICAgYSA9IGEuY2xvbmUoKTtcblxuICB2YXIgeDEgPSBuZXcgQk4oMSk7XG4gIHZhciB4MiA9IG5ldyBCTigwKTtcblxuICB2YXIgZGVsdGEgPSBiLmNsb25lKCk7XG5cbiAgd2hpbGUgKGEuY21wbigxKSA+IDAgJiYgYi5jbXBuKDEpID4gMCkge1xuICAgIHdoaWxlIChhLmlzRXZlbigpKSB7XG4gICAgICBhLmlzaHJuKDEpO1xuICAgICAgaWYgKHgxLmlzRXZlbigpKVxuICAgICAgICB4MS5pc2hybigxKTtcbiAgICAgIGVsc2VcbiAgICAgICAgeDEuaWFkZChkZWx0YSkuaXNocm4oMSk7XG4gICAgfVxuICAgIHdoaWxlIChiLmlzRXZlbigpKSB7XG4gICAgICBiLmlzaHJuKDEpO1xuICAgICAgaWYgKHgyLmlzRXZlbigpKVxuICAgICAgICB4Mi5pc2hybigxKTtcbiAgICAgIGVsc2VcbiAgICAgICAgeDIuaWFkZChkZWx0YSkuaXNocm4oMSk7XG4gICAgfVxuICAgIGlmIChhLmNtcChiKSA+PSAwKSB7XG4gICAgICBhLmlzdWIoYik7XG4gICAgICB4MS5pc3ViKHgyKTtcbiAgICB9IGVsc2Uge1xuICAgICAgYi5pc3ViKGEpO1xuICAgICAgeDIuaXN1Yih4MSk7XG4gICAgfVxuICB9XG4gIGlmIChhLmNtcG4oMSkgPT09IDApXG4gICAgcmV0dXJuIHgxO1xuICBlbHNlXG4gICAgcmV0dXJuIHgyO1xufTtcblxuQk4ucHJvdG90eXBlLmdjZCA9IGZ1bmN0aW9uIGdjZChudW0pIHtcbiAgaWYgKHRoaXMuY21wbigwKSA9PT0gMClcbiAgICByZXR1cm4gbnVtLmNsb25lKCk7XG4gIGlmIChudW0uY21wbigwKSA9PT0gMClcbiAgICByZXR1cm4gdGhpcy5jbG9uZSgpO1xuXG4gIHZhciBhID0gdGhpcy5jbG9uZSgpO1xuICB2YXIgYiA9IG51bS5jbG9uZSgpO1xuICBhLnNpZ24gPSBmYWxzZTtcbiAgYi5zaWduID0gZmFsc2U7XG5cbiAgLy8gUmVtb3ZlIGNvbW1vbiBmYWN0b3Igb2YgdHdvXG4gIGZvciAodmFyIHNoaWZ0ID0gMDsgYS5pc0V2ZW4oKSAmJiBiLmlzRXZlbigpOyBzaGlmdCsrKSB7XG4gICAgYS5pc2hybigxKTtcbiAgICBiLmlzaHJuKDEpO1xuICB9XG5cbiAgZG8ge1xuICAgIHdoaWxlIChhLmlzRXZlbigpKVxuICAgICAgYS5pc2hybigxKTtcbiAgICB3aGlsZSAoYi5pc0V2ZW4oKSlcbiAgICAgIGIuaXNocm4oMSk7XG5cbiAgICB2YXIgciA9IGEuY21wKGIpO1xuICAgIGlmIChyIDwgMCkge1xuICAgICAgLy8gU3dhcCBgYWAgYW5kIGBiYCB0byBtYWtlIGBhYCBhbHdheXMgYmlnZ2VyIHRoYW4gYGJgXG4gICAgICB2YXIgdCA9IGE7XG4gICAgICBhID0gYjtcbiAgICAgIGIgPSB0O1xuICAgIH0gZWxzZSBpZiAociA9PT0gMCB8fCBiLmNtcG4oMSkgPT09IDApIHtcbiAgICAgIGJyZWFrO1xuICAgIH1cblxuICAgIGEuaXN1YihiKTtcbiAgfSB3aGlsZSAodHJ1ZSk7XG5cbiAgcmV0dXJuIGIuaXNobG4oc2hpZnQpO1xufTtcblxuLy8gSW52ZXJ0IG51bWJlciBpbiB0aGUgZmllbGQgRihudW0pXG5CTi5wcm90b3R5cGUuaW52bSA9IGZ1bmN0aW9uIGludm0obnVtKSB7XG4gIHJldHVybiB0aGlzLmVnY2QobnVtKS5hLm1vZChudW0pO1xufTtcblxuQk4ucHJvdG90eXBlLmlzRXZlbiA9IGZ1bmN0aW9uIGlzRXZlbigpIHtcbiAgcmV0dXJuICh0aGlzLndvcmRzWzBdICYgMSkgPT09IDA7XG59O1xuXG5CTi5wcm90b3R5cGUuaXNPZGQgPSBmdW5jdGlvbiBpc09kZCgpIHtcbiAgcmV0dXJuICh0aGlzLndvcmRzWzBdICYgMSkgPT09IDE7XG59O1xuXG4vLyBBbmQgZmlyc3Qgd29yZCBhbmQgbnVtXG5CTi5wcm90b3R5cGUuYW5kbG4gPSBmdW5jdGlvbiBhbmRsbihudW0pIHtcbiAgcmV0dXJuIHRoaXMud29yZHNbMF0gJiBudW07XG59O1xuXG4vLyBJbmNyZW1lbnQgYXQgdGhlIGJpdCBwb3NpdGlvbiBpbi1saW5lXG5CTi5wcm90b3R5cGUuYmluY24gPSBmdW5jdGlvbiBiaW5jbihiaXQpIHtcbiAgYXNzZXJ0KHR5cGVvZiBiaXQgPT09ICdudW1iZXInKTtcbiAgdmFyIHIgPSBiaXQgJSAyNjtcbiAgdmFyIHMgPSAoYml0IC0gcikgLyAyNjtcbiAgdmFyIHEgPSAxIDw8IHI7XG5cbiAgLy8gRmFzdCBjYXNlOiBiaXQgaXMgbXVjaCBoaWdoZXIgdGhhbiBhbGwgZXhpc3Rpbmcgd29yZHNcbiAgaWYgKHRoaXMubGVuZ3RoIDw9IHMpIHtcbiAgICBmb3IgKHZhciBpID0gdGhpcy5sZW5ndGg7IGkgPCBzICsgMTsgaSsrKVxuICAgICAgdGhpcy53b3Jkc1tpXSA9IDA7XG4gICAgdGhpcy53b3Jkc1tzXSB8PSBxO1xuICAgIHRoaXMubGVuZ3RoID0gcyArIDE7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cblxuICAvLyBBZGQgYml0IGFuZCBwcm9wYWdhdGUsIGlmIG5lZWRlZFxuICB2YXIgY2FycnkgPSBxO1xuICBmb3IgKHZhciBpID0gczsgY2FycnkgIT09IDAgJiYgaSA8IHRoaXMubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIgdyA9IHRoaXMud29yZHNbaV07XG4gICAgdyArPSBjYXJyeTtcbiAgICBjYXJyeSA9IHcgPj4+IDI2O1xuICAgIHcgJj0gMHgzZmZmZmZmO1xuICAgIHRoaXMud29yZHNbaV0gPSB3O1xuICB9XG4gIGlmIChjYXJyeSAhPT0gMCkge1xuICAgIHRoaXMud29yZHNbaV0gPSBjYXJyeTtcbiAgICB0aGlzLmxlbmd0aCsrO1xuICB9XG4gIHJldHVybiB0aGlzO1xufTtcblxuQk4ucHJvdG90eXBlLmNtcG4gPSBmdW5jdGlvbiBjbXBuKG51bSkge1xuICB2YXIgc2lnbiA9IG51bSA8IDA7XG4gIGlmIChzaWduKVxuICAgIG51bSA9IC1udW07XG5cbiAgaWYgKHRoaXMuc2lnbiAmJiAhc2lnbilcbiAgICByZXR1cm4gLTE7XG4gIGVsc2UgaWYgKCF0aGlzLnNpZ24gJiYgc2lnbilcbiAgICByZXR1cm4gMTtcblxuICBudW0gJj0gMHgzZmZmZmZmO1xuICB0aGlzLnN0cmlwKCk7XG5cbiAgdmFyIHJlcztcbiAgaWYgKHRoaXMubGVuZ3RoID4gMSkge1xuICAgIHJlcyA9IDE7XG4gIH0gZWxzZSB7XG4gICAgdmFyIHcgPSB0aGlzLndvcmRzWzBdO1xuICAgIHJlcyA9IHcgPT09IG51bSA/IDAgOiB3IDwgbnVtID8gLTEgOiAxO1xuICB9XG4gIGlmICh0aGlzLnNpZ24pXG4gICAgcmVzID0gLXJlcztcbiAgcmV0dXJuIHJlcztcbn07XG5cbi8vIENvbXBhcmUgdHdvIG51bWJlcnMgYW5kIHJldHVybjpcbi8vIDEgLSBpZiBgdGhpc2AgPiBgbnVtYFxuLy8gMCAtIGlmIGB0aGlzYCA9PSBgbnVtYFxuLy8gLTEgLSBpZiBgdGhpc2AgPCBgbnVtYFxuQk4ucHJvdG90eXBlLmNtcCA9IGZ1bmN0aW9uIGNtcChudW0pIHtcbiAgaWYgKHRoaXMuc2lnbiAmJiAhbnVtLnNpZ24pXG4gICAgcmV0dXJuIC0xO1xuICBlbHNlIGlmICghdGhpcy5zaWduICYmIG51bS5zaWduKVxuICAgIHJldHVybiAxO1xuXG4gIHZhciByZXMgPSB0aGlzLnVjbXAobnVtKTtcbiAgaWYgKHRoaXMuc2lnbilcbiAgICByZXR1cm4gLXJlcztcbiAgZWxzZVxuICAgIHJldHVybiByZXM7XG59O1xuXG4vLyBVbnNpZ25lZCBjb21wYXJpc29uXG5CTi5wcm90b3R5cGUudWNtcCA9IGZ1bmN0aW9uIHVjbXAobnVtKSB7XG4gIC8vIEF0IHRoaXMgcG9pbnQgYm90aCBudW1iZXJzIGhhdmUgdGhlIHNhbWUgc2lnblxuICBpZiAodGhpcy5sZW5ndGggPiBudW0ubGVuZ3RoKVxuICAgIHJldHVybiAxO1xuICBlbHNlIGlmICh0aGlzLmxlbmd0aCA8IG51bS5sZW5ndGgpXG4gICAgcmV0dXJuIC0xO1xuXG4gIHZhciByZXMgPSAwO1xuICBmb3IgKHZhciBpID0gdGhpcy5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuICAgIHZhciBhID0gdGhpcy53b3Jkc1tpXTtcbiAgICB2YXIgYiA9IG51bS53b3Jkc1tpXTtcblxuICAgIGlmIChhID09PSBiKVxuICAgICAgY29udGludWU7XG4gICAgaWYgKGEgPCBiKVxuICAgICAgcmVzID0gLTE7XG4gICAgZWxzZSBpZiAoYSA+IGIpXG4gICAgICByZXMgPSAxO1xuICAgIGJyZWFrO1xuICB9XG4gIHJldHVybiByZXM7XG59O1xuXG4vL1xuLy8gQSByZWR1Y2UgY29udGV4dCwgY291bGQgYmUgdXNpbmcgbW9udGdvbWVyeSBvciBzb21ldGhpbmcgYmV0dGVyLCBkZXBlbmRpbmdcbi8vIG9uIHRoZSBgbWAgaXRzZWxmLlxuLy9cbkJOLnJlZCA9IGZ1bmN0aW9uIHJlZChudW0pIHtcbiAgcmV0dXJuIG5ldyBSZWQobnVtKTtcbn07XG5cbkJOLnByb3RvdHlwZS50b1JlZCA9IGZ1bmN0aW9uIHRvUmVkKGN0eCkge1xuICBhc3NlcnQoIXRoaXMucmVkLCAnQWxyZWFkeSBhIG51bWJlciBpbiByZWR1Y3Rpb24gY29udGV4dCcpO1xuICBhc3NlcnQoIXRoaXMuc2lnbiwgJ3JlZCB3b3JrcyBvbmx5IHdpdGggcG9zaXRpdmVzJyk7XG4gIHJldHVybiBjdHguY29udmVydFRvKHRoaXMpLl9mb3JjZVJlZChjdHgpO1xufTtcblxuQk4ucHJvdG90eXBlLmZyb21SZWQgPSBmdW5jdGlvbiBmcm9tUmVkKCkge1xuICBhc3NlcnQodGhpcy5yZWQsICdmcm9tUmVkIHdvcmtzIG9ubHkgd2l0aCBudW1iZXJzIGluIHJlZHVjdGlvbiBjb250ZXh0Jyk7XG4gIHJldHVybiB0aGlzLnJlZC5jb252ZXJ0RnJvbSh0aGlzKTtcbn07XG5cbkJOLnByb3RvdHlwZS5fZm9yY2VSZWQgPSBmdW5jdGlvbiBfZm9yY2VSZWQoY3R4KSB7XG4gIHRoaXMucmVkID0gY3R4O1xuICByZXR1cm4gdGhpcztcbn07XG5cbkJOLnByb3RvdHlwZS5mb3JjZVJlZCA9IGZ1bmN0aW9uIGZvcmNlUmVkKGN0eCkge1xuICBhc3NlcnQoIXRoaXMucmVkLCAnQWxyZWFkeSBhIG51bWJlciBpbiByZWR1Y3Rpb24gY29udGV4dCcpO1xuICByZXR1cm4gdGhpcy5fZm9yY2VSZWQoY3R4KTtcbn07XG5cbkJOLnByb3RvdHlwZS5yZWRBZGQgPSBmdW5jdGlvbiByZWRBZGQobnVtKSB7XG4gIGFzc2VydCh0aGlzLnJlZCwgJ3JlZEFkZCB3b3JrcyBvbmx5IHdpdGggcmVkIG51bWJlcnMnKTtcbiAgcmV0dXJuIHRoaXMucmVkLmFkZCh0aGlzLCBudW0pO1xufTtcblxuQk4ucHJvdG90eXBlLnJlZElBZGQgPSBmdW5jdGlvbiByZWRJQWRkKG51bSkge1xuICBhc3NlcnQodGhpcy5yZWQsICdyZWRJQWRkIHdvcmtzIG9ubHkgd2l0aCByZWQgbnVtYmVycycpO1xuICByZXR1cm4gdGhpcy5yZWQuaWFkZCh0aGlzLCBudW0pO1xufTtcblxuQk4ucHJvdG90eXBlLnJlZFN1YiA9IGZ1bmN0aW9uIHJlZFN1YihudW0pIHtcbiAgYXNzZXJ0KHRoaXMucmVkLCAncmVkU3ViIHdvcmtzIG9ubHkgd2l0aCByZWQgbnVtYmVycycpO1xuICByZXR1cm4gdGhpcy5yZWQuc3ViKHRoaXMsIG51bSk7XG59O1xuXG5CTi5wcm90b3R5cGUucmVkSVN1YiA9IGZ1bmN0aW9uIHJlZElTdWIobnVtKSB7XG4gIGFzc2VydCh0aGlzLnJlZCwgJ3JlZElTdWIgd29ya3Mgb25seSB3aXRoIHJlZCBudW1iZXJzJyk7XG4gIHJldHVybiB0aGlzLnJlZC5pc3ViKHRoaXMsIG51bSk7XG59O1xuXG5CTi5wcm90b3R5cGUucmVkU2hsID0gZnVuY3Rpb24gcmVkU2hsKG51bSkge1xuICBhc3NlcnQodGhpcy5yZWQsICdyZWRTaGwgd29ya3Mgb25seSB3aXRoIHJlZCBudW1iZXJzJyk7XG4gIHJldHVybiB0aGlzLnJlZC5zaGwodGhpcywgbnVtKTtcbn07XG5cbkJOLnByb3RvdHlwZS5yZWRNdWwgPSBmdW5jdGlvbiByZWRNdWwobnVtKSB7XG4gIGFzc2VydCh0aGlzLnJlZCwgJ3JlZE11bCB3b3JrcyBvbmx5IHdpdGggcmVkIG51bWJlcnMnKTtcbiAgdGhpcy5yZWQuX3ZlcmlmeTIodGhpcywgbnVtKTtcbiAgcmV0dXJuIHRoaXMucmVkLm11bCh0aGlzLCBudW0pO1xufTtcblxuQk4ucHJvdG90eXBlLnJlZElNdWwgPSBmdW5jdGlvbiByZWRJTXVsKG51bSkge1xuICBhc3NlcnQodGhpcy5yZWQsICdyZWRNdWwgd29ya3Mgb25seSB3aXRoIHJlZCBudW1iZXJzJyk7XG4gIHRoaXMucmVkLl92ZXJpZnkyKHRoaXMsIG51bSk7XG4gIHJldHVybiB0aGlzLnJlZC5pbXVsKHRoaXMsIG51bSk7XG59O1xuXG5CTi5wcm90b3R5cGUucmVkU3FyID0gZnVuY3Rpb24gcmVkU3FyKCkge1xuICBhc3NlcnQodGhpcy5yZWQsICdyZWRTcXIgd29ya3Mgb25seSB3aXRoIHJlZCBudW1iZXJzJyk7XG4gIHRoaXMucmVkLl92ZXJpZnkxKHRoaXMpO1xuICByZXR1cm4gdGhpcy5yZWQuc3FyKHRoaXMpO1xufTtcblxuQk4ucHJvdG90eXBlLnJlZElTcXIgPSBmdW5jdGlvbiByZWRJU3FyKCkge1xuICBhc3NlcnQodGhpcy5yZWQsICdyZWRJU3FyIHdvcmtzIG9ubHkgd2l0aCByZWQgbnVtYmVycycpO1xuICB0aGlzLnJlZC5fdmVyaWZ5MSh0aGlzKTtcbiAgcmV0dXJuIHRoaXMucmVkLmlzcXIodGhpcyk7XG59O1xuXG4vLyBTcXVhcmUgcm9vdCBvdmVyIHBcbkJOLnByb3RvdHlwZS5yZWRTcXJ0ID0gZnVuY3Rpb24gcmVkU3FydCgpIHtcbiAgYXNzZXJ0KHRoaXMucmVkLCAncmVkU3FydCB3b3JrcyBvbmx5IHdpdGggcmVkIG51bWJlcnMnKTtcbiAgdGhpcy5yZWQuX3ZlcmlmeTEodGhpcyk7XG4gIHJldHVybiB0aGlzLnJlZC5zcXJ0KHRoaXMpO1xufTtcblxuQk4ucHJvdG90eXBlLnJlZEludm0gPSBmdW5jdGlvbiByZWRJbnZtKCkge1xuICBhc3NlcnQodGhpcy5yZWQsICdyZWRJbnZtIHdvcmtzIG9ubHkgd2l0aCByZWQgbnVtYmVycycpO1xuICB0aGlzLnJlZC5fdmVyaWZ5MSh0aGlzKTtcbiAgcmV0dXJuIHRoaXMucmVkLmludm0odGhpcyk7XG59O1xuXG4vLyBSZXR1cm4gbmVnYXRpdmUgY2xvbmUgb2YgYHRoaXNgICUgYHJlZCBtb2R1bG9gXG5CTi5wcm90b3R5cGUucmVkTmVnID0gZnVuY3Rpb24gcmVkTmVnKCkge1xuICBhc3NlcnQodGhpcy5yZWQsICdyZWROZWcgd29ya3Mgb25seSB3aXRoIHJlZCBudW1iZXJzJyk7XG4gIHRoaXMucmVkLl92ZXJpZnkxKHRoaXMpO1xuICByZXR1cm4gdGhpcy5yZWQubmVnKHRoaXMpO1xufTtcblxuQk4ucHJvdG90eXBlLnJlZFBvdyA9IGZ1bmN0aW9uIHJlZFBvdyhudW0pIHtcbiAgYXNzZXJ0KHRoaXMucmVkICYmICFudW0ucmVkLCAncmVkUG93KG5vcm1hbE51bSknKTtcbiAgdGhpcy5yZWQuX3ZlcmlmeTEodGhpcyk7XG4gIHJldHVybiB0aGlzLnJlZC5wb3codGhpcywgbnVtKTtcbn07XG5cbi8vIFByaW1lIG51bWJlcnMgd2l0aCBlZmZpY2llbnQgcmVkdWN0aW9uXG52YXIgcHJpbWVzID0ge1xuICBrMjU2OiBudWxsLFxuICBwMjI0OiBudWxsLFxuICBwMTkyOiBudWxsLFxuICBwMjU1MTk6IG51bGxcbn07XG5cbi8vIFBzZXVkby1NZXJzZW5uZSBwcmltZVxuZnVuY3Rpb24gTVByaW1lKG5hbWUsIHApIHtcbiAgLy8gUCA9IDIgXiBOIC0gS1xuICB0aGlzLm5hbWUgPSBuYW1lO1xuICB0aGlzLnAgPSBuZXcgQk4ocCwgMTYpO1xuICB0aGlzLm4gPSB0aGlzLnAuYml0TGVuZ3RoKCk7XG4gIHRoaXMuayA9IG5ldyBCTigxKS5pc2hsbih0aGlzLm4pLmlzdWIodGhpcy5wKTtcblxuICB0aGlzLnRtcCA9IHRoaXMuX3RtcCgpO1xufVxuXG5NUHJpbWUucHJvdG90eXBlLl90bXAgPSBmdW5jdGlvbiBfdG1wKCkge1xuICB2YXIgdG1wID0gbmV3IEJOKG51bGwpO1xuICB0bXAud29yZHMgPSBuZXcgQXJyYXkoTWF0aC5jZWlsKHRoaXMubiAvIDEzKSk7XG4gIHJldHVybiB0bXA7XG59O1xuXG5NUHJpbWUucHJvdG90eXBlLmlyZWR1Y2UgPSBmdW5jdGlvbiBpcmVkdWNlKG51bSkge1xuICAvLyBBc3N1bWVzIHRoYXQgYG51bWAgaXMgbGVzcyB0aGFuIGBQXjJgXG4gIC8vIG51bSA9IEhJICogKDIgXiBOIC0gSykgKyBISSAqIEsgKyBMTyA9IEhJICogSyArIExPIChtb2QgUClcbiAgdmFyIHIgPSBudW07XG4gIHZhciBybGVuO1xuXG4gIGRvIHtcbiAgICB0aGlzLnNwbGl0KHIsIHRoaXMudG1wKTtcbiAgICByID0gdGhpcy5pbXVsSyhyKTtcbiAgICByID0gci5pYWRkKHRoaXMudG1wKTtcbiAgICBybGVuID0gci5iaXRMZW5ndGgoKTtcbiAgfSB3aGlsZSAocmxlbiA+IHRoaXMubik7XG5cbiAgdmFyIGNtcCA9IHJsZW4gPCB0aGlzLm4gPyAtMSA6IHIudWNtcCh0aGlzLnApO1xuICBpZiAoY21wID09PSAwKSB7XG4gICAgci53b3Jkc1swXSA9IDA7XG4gICAgci5sZW5ndGggPSAxO1xuICB9IGVsc2UgaWYgKGNtcCA+IDApIHtcbiAgICByLmlzdWIodGhpcy5wKTtcbiAgfSBlbHNlIHtcbiAgICByLnN0cmlwKCk7XG4gIH1cblxuICByZXR1cm4gcjtcbn07XG5cbk1QcmltZS5wcm90b3R5cGUuc3BsaXQgPSBmdW5jdGlvbiBzcGxpdChpbnB1dCwgb3V0KSB7XG4gIGlucHV0LmlzaHJuKHRoaXMubiwgMCwgb3V0KTtcbn07XG5cbk1QcmltZS5wcm90b3R5cGUuaW11bEsgPSBmdW5jdGlvbiBpbXVsSyhudW0pIHtcbiAgcmV0dXJuIG51bS5pbXVsKHRoaXMuayk7XG59O1xuXG5mdW5jdGlvbiBLMjU2KCkge1xuICBNUHJpbWUuY2FsbChcbiAgICB0aGlzLFxuICAgICdrMjU2JyxcbiAgICAnZmZmZmZmZmYgZmZmZmZmZmYgZmZmZmZmZmYgZmZmZmZmZmYgZmZmZmZmZmYgZmZmZmZmZmYgZmZmZmZmZmUgZmZmZmZjMmYnKTtcbn1cbmluaGVyaXRzKEsyNTYsIE1QcmltZSk7XG5cbksyNTYucHJvdG90eXBlLnNwbGl0ID0gZnVuY3Rpb24gc3BsaXQoaW5wdXQsIG91dHB1dCkge1xuICAvLyAyNTYgPSA5ICogMjYgKyAyMlxuICB2YXIgbWFzayA9IDB4M2ZmZmZmO1xuXG4gIHZhciBvdXRMZW4gPSBNYXRoLm1pbihpbnB1dC5sZW5ndGgsIDkpO1xuICBmb3IgKHZhciBpID0gMDsgaSA8IG91dExlbjsgaSsrKVxuICAgIG91dHB1dC53b3Jkc1tpXSA9IGlucHV0LndvcmRzW2ldO1xuICBvdXRwdXQubGVuZ3RoID0gb3V0TGVuO1xuXG4gIGlmIChpbnB1dC5sZW5ndGggPD0gOSkge1xuICAgIGlucHV0LndvcmRzWzBdID0gMDtcbiAgICBpbnB1dC5sZW5ndGggPSAxO1xuICAgIHJldHVybjtcbiAgfVxuXG4gIC8vIFNoaWZ0IGJ5IDkgbGltYnNcbiAgdmFyIHByZXYgPSBpbnB1dC53b3Jkc1s5XTtcbiAgb3V0cHV0LndvcmRzW291dHB1dC5sZW5ndGgrK10gPSBwcmV2ICYgbWFzaztcblxuICBmb3IgKHZhciBpID0gMTA7IGkgPCBpbnB1dC5sZW5ndGg7IGkrKykge1xuICAgIHZhciBuZXh0ID0gaW5wdXQud29yZHNbaV07XG4gICAgaW5wdXQud29yZHNbaSAtIDEwXSA9ICgobmV4dCAmIG1hc2spIDw8IDQpIHwgKHByZXYgPj4+IDIyKTtcbiAgICBwcmV2ID0gbmV4dDtcbiAgfVxuICBpbnB1dC53b3Jkc1tpIC0gMTBdID0gcHJldiA+Pj4gMjI7XG4gIGlucHV0Lmxlbmd0aCAtPSA5O1xufTtcblxuSzI1Ni5wcm90b3R5cGUuaW11bEsgPSBmdW5jdGlvbiBpbXVsSyhudW0pIHtcbiAgLy8gSyA9IDB4MTAwMDAwM2QxID0gWyAweDQwLCAweDNkMSBdXG4gIG51bS53b3Jkc1tudW0ubGVuZ3RoXSA9IDA7XG4gIG51bS53b3Jkc1tudW0ubGVuZ3RoICsgMV0gPSAwO1xuICBudW0ubGVuZ3RoICs9IDI7XG5cbiAgLy8gYm91bmRlZCBhdDogMHg0MCAqIDB4M2ZmZmZmZiArIDB4M2QwID0gMHgxMDAwMDAzOTBcbiAgdmFyIGhpO1xuICB2YXIgbG8gPSAwO1xuICBmb3IgKHZhciBpID0gMDsgaSA8IG51bS5sZW5ndGg7IGkrKykge1xuICAgIHZhciB3ID0gbnVtLndvcmRzW2ldO1xuICAgIGhpID0gdyAqIDB4NDA7XG4gICAgbG8gKz0gdyAqIDB4M2QxO1xuICAgIGhpICs9IChsbyAvIDB4NDAwMDAwMCkgfCAwO1xuICAgIGxvICY9IDB4M2ZmZmZmZjtcblxuICAgIG51bS53b3Jkc1tpXSA9IGxvO1xuXG4gICAgbG8gPSBoaTtcbiAgfVxuXG4gIC8vIEZhc3QgbGVuZ3RoIHJlZHVjdGlvblxuICBpZiAobnVtLndvcmRzW251bS5sZW5ndGggLSAxXSA9PT0gMCkge1xuICAgIG51bS5sZW5ndGgtLTtcbiAgICBpZiAobnVtLndvcmRzW251bS5sZW5ndGggLSAxXSA9PT0gMClcbiAgICAgIG51bS5sZW5ndGgtLTtcbiAgfVxuICByZXR1cm4gbnVtO1xufTtcblxuZnVuY3Rpb24gUDIyNCgpIHtcbiAgTVByaW1lLmNhbGwoXG4gICAgdGhpcyxcbiAgICAncDIyNCcsXG4gICAgJ2ZmZmZmZmZmIGZmZmZmZmZmIGZmZmZmZmZmIGZmZmZmZmZmIDAwMDAwMDAwIDAwMDAwMDAwIDAwMDAwMDAxJyk7XG59XG5pbmhlcml0cyhQMjI0LCBNUHJpbWUpO1xuXG5mdW5jdGlvbiBQMTkyKCkge1xuICBNUHJpbWUuY2FsbChcbiAgICB0aGlzLFxuICAgICdwMTkyJyxcbiAgICAnZmZmZmZmZmYgZmZmZmZmZmYgZmZmZmZmZmYgZmZmZmZmZmUgZmZmZmZmZmYgZmZmZmZmZmYnKTtcbn1cbmluaGVyaXRzKFAxOTIsIE1QcmltZSk7XG5cbmZ1bmN0aW9uIFAyNTUxOSgpIHtcbiAgLy8gMiBeIDI1NSAtIDE5XG4gIE1QcmltZS5jYWxsKFxuICAgIHRoaXMsXG4gICAgJzI1NTE5JyxcbiAgICAnN2ZmZmZmZmZmZmZmZmZmZiBmZmZmZmZmZmZmZmZmZmZmIGZmZmZmZmZmZmZmZmZmZmYgZmZmZmZmZmZmZmZmZmZlZCcpO1xufVxuaW5oZXJpdHMoUDI1NTE5LCBNUHJpbWUpO1xuXG5QMjU1MTkucHJvdG90eXBlLmltdWxLID0gZnVuY3Rpb24gaW11bEsobnVtKSB7XG4gIC8vIEsgPSAweDEzXG4gIHZhciBjYXJyeSA9IDA7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbnVtLmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIGhpID0gbnVtLndvcmRzW2ldICogMHgxMyArIGNhcnJ5O1xuICAgIHZhciBsbyA9IGhpICYgMHgzZmZmZmZmO1xuICAgIGhpID4+Pj0gMjY7XG5cbiAgICBudW0ud29yZHNbaV0gPSBsbztcbiAgICBjYXJyeSA9IGhpO1xuICB9XG4gIGlmIChjYXJyeSAhPT0gMClcbiAgICBudW0ud29yZHNbbnVtLmxlbmd0aCsrXSA9IGNhcnJ5O1xuICByZXR1cm4gbnVtO1xufTtcblxuLy8gRXhwb3J0ZWQgbW9zdGx5IGZvciB0ZXN0aW5nIHB1cnBvc2VzLCB1c2UgcGxhaW4gbmFtZSBpbnN0ZWFkXG5CTi5fcHJpbWUgPSBmdW5jdGlvbiBwcmltZShuYW1lKSB7XG4gIC8vIENhY2hlZCB2ZXJzaW9uIG9mIHByaW1lXG4gIGlmIChwcmltZXNbbmFtZV0pXG4gICAgcmV0dXJuIHByaW1lc1tuYW1lXTtcblxuICB2YXIgcHJpbWU7XG4gIGlmIChuYW1lID09PSAnazI1NicpXG4gICAgcHJpbWUgPSBuZXcgSzI1NigpO1xuICBlbHNlIGlmIChuYW1lID09PSAncDIyNCcpXG4gICAgcHJpbWUgPSBuZXcgUDIyNCgpO1xuICBlbHNlIGlmIChuYW1lID09PSAncDE5MicpXG4gICAgcHJpbWUgPSBuZXcgUDE5MigpO1xuICBlbHNlIGlmIChuYW1lID09PSAncDI1NTE5JylcbiAgICBwcmltZSA9IG5ldyBQMjU1MTkoKTtcbiAgZWxzZVxuICAgIHRocm93IG5ldyBFcnJvcignVW5rbm93biBwcmltZSAnICsgbmFtZSk7XG4gIHByaW1lc1tuYW1lXSA9IHByaW1lO1xuXG4gIHJldHVybiBwcmltZTtcbn07XG5cbi8vXG4vLyBCYXNlIHJlZHVjdGlvbiBlbmdpbmVcbi8vXG5mdW5jdGlvbiBSZWQobSkge1xuICBpZiAodHlwZW9mIG0gPT09ICdzdHJpbmcnKSB7XG4gICAgdmFyIHByaW1lID0gQk4uX3ByaW1lKG0pO1xuICAgIHRoaXMubSA9IHByaW1lLnA7XG4gICAgdGhpcy5wcmltZSA9IHByaW1lO1xuICB9IGVsc2Uge1xuICAgIHRoaXMubSA9IG07XG4gICAgdGhpcy5wcmltZSA9IG51bGw7XG4gIH1cbn1cblxuUmVkLnByb3RvdHlwZS5fdmVyaWZ5MSA9IGZ1bmN0aW9uIF92ZXJpZnkxKGEpIHtcbiAgYXNzZXJ0KCFhLnNpZ24sICdyZWQgd29ya3Mgb25seSB3aXRoIHBvc2l0aXZlcycpO1xuICBhc3NlcnQoYS5yZWQsICdyZWQgd29ya3Mgb25seSB3aXRoIHJlZCBudW1iZXJzJyk7XG59O1xuXG5SZWQucHJvdG90eXBlLl92ZXJpZnkyID0gZnVuY3Rpb24gX3ZlcmlmeTIoYSwgYikge1xuICBhc3NlcnQoIWEuc2lnbiAmJiAhYi5zaWduLCAncmVkIHdvcmtzIG9ubHkgd2l0aCBwb3NpdGl2ZXMnKTtcbiAgYXNzZXJ0KGEucmVkICYmIGEucmVkID09PSBiLnJlZCxcbiAgICAgICAgICdyZWQgd29ya3Mgb25seSB3aXRoIHJlZCBudW1iZXJzJyk7XG59O1xuXG5SZWQucHJvdG90eXBlLmltb2QgPSBmdW5jdGlvbiBpbW9kKGEpIHtcbiAgaWYgKHRoaXMucHJpbWUpXG4gICAgcmV0dXJuIHRoaXMucHJpbWUuaXJlZHVjZShhKS5fZm9yY2VSZWQodGhpcyk7XG4gIHJldHVybiBhLm1vZCh0aGlzLm0pLl9mb3JjZVJlZCh0aGlzKTtcbn07XG5cblJlZC5wcm90b3R5cGUubmVnID0gZnVuY3Rpb24gbmVnKGEpIHtcbiAgdmFyIHIgPSBhLmNsb25lKCk7XG4gIHIuc2lnbiA9ICFyLnNpZ247XG4gIHJldHVybiByLmlhZGQodGhpcy5tKS5fZm9yY2VSZWQodGhpcyk7XG59O1xuXG5SZWQucHJvdG90eXBlLmFkZCA9IGZ1bmN0aW9uIGFkZChhLCBiKSB7XG4gIHRoaXMuX3ZlcmlmeTIoYSwgYik7XG5cbiAgdmFyIHJlcyA9IGEuYWRkKGIpO1xuICBpZiAocmVzLmNtcCh0aGlzLm0pID49IDApXG4gICAgcmVzLmlzdWIodGhpcy5tKTtcbiAgcmV0dXJuIHJlcy5fZm9yY2VSZWQodGhpcyk7XG59O1xuXG5SZWQucHJvdG90eXBlLmlhZGQgPSBmdW5jdGlvbiBpYWRkKGEsIGIpIHtcbiAgdGhpcy5fdmVyaWZ5MihhLCBiKTtcblxuICB2YXIgcmVzID0gYS5pYWRkKGIpO1xuICBpZiAocmVzLmNtcCh0aGlzLm0pID49IDApXG4gICAgcmVzLmlzdWIodGhpcy5tKTtcbiAgcmV0dXJuIHJlcztcbn07XG5cblJlZC5wcm90b3R5cGUuc3ViID0gZnVuY3Rpb24gc3ViKGEsIGIpIHtcbiAgdGhpcy5fdmVyaWZ5MihhLCBiKTtcblxuICB2YXIgcmVzID0gYS5zdWIoYik7XG4gIGlmIChyZXMuY21wbigwKSA8IDApXG4gICAgcmVzLmlhZGQodGhpcy5tKTtcbiAgcmV0dXJuIHJlcy5fZm9yY2VSZWQodGhpcyk7XG59O1xuXG5SZWQucHJvdG90eXBlLmlzdWIgPSBmdW5jdGlvbiBpc3ViKGEsIGIpIHtcbiAgdGhpcy5fdmVyaWZ5MihhLCBiKTtcblxuICB2YXIgcmVzID0gYS5pc3ViKGIpO1xuICBpZiAocmVzLmNtcG4oMCkgPCAwKVxuICAgIHJlcy5pYWRkKHRoaXMubSk7XG4gIHJldHVybiByZXM7XG59O1xuXG5SZWQucHJvdG90eXBlLnNobCA9IGZ1bmN0aW9uIHNobChhLCBudW0pIHtcbiAgdGhpcy5fdmVyaWZ5MShhKTtcbiAgcmV0dXJuIHRoaXMuaW1vZChhLnNobG4obnVtKSk7XG59O1xuXG5SZWQucHJvdG90eXBlLmltdWwgPSBmdW5jdGlvbiBpbXVsKGEsIGIpIHtcbiAgdGhpcy5fdmVyaWZ5MihhLCBiKTtcbiAgcmV0dXJuIHRoaXMuaW1vZChhLmltdWwoYikpO1xufTtcblxuUmVkLnByb3RvdHlwZS5tdWwgPSBmdW5jdGlvbiBtdWwoYSwgYikge1xuICB0aGlzLl92ZXJpZnkyKGEsIGIpO1xuICByZXR1cm4gdGhpcy5pbW9kKGEubXVsKGIpKTtcbn07XG5cblJlZC5wcm90b3R5cGUuaXNxciA9IGZ1bmN0aW9uIGlzcXIoYSkge1xuICByZXR1cm4gdGhpcy5pbXVsKGEsIGEpO1xufTtcblxuUmVkLnByb3RvdHlwZS5zcXIgPSBmdW5jdGlvbiBzcXIoYSkge1xuICByZXR1cm4gdGhpcy5tdWwoYSwgYSk7XG59O1xuXG5SZWQucHJvdG90eXBlLnNxcnQgPSBmdW5jdGlvbiBzcXJ0KGEpIHtcbiAgaWYgKGEuY21wbigwKSA9PT0gMClcbiAgICByZXR1cm4gYS5jbG9uZSgpO1xuXG4gIHZhciBtb2QzID0gdGhpcy5tLmFuZGxuKDMpO1xuICBhc3NlcnQobW9kMyAlIDIgPT09IDEpO1xuXG4gIC8vIEZhc3QgY2FzZVxuICBpZiAobW9kMyA9PT0gMykge1xuICAgIHZhciBwb3cgPSB0aGlzLm0uYWRkKG5ldyBCTigxKSkuaXNocm4oMik7XG4gICAgdmFyIHIgPSB0aGlzLnBvdyhhLCBwb3cpO1xuICAgIHJldHVybiByO1xuICB9XG5cbiAgLy8gVG9uZWxsaS1TaGFua3MgYWxnb3JpdGhtIChUb3RhbGx5IHVub3B0aW1pemVkIGFuZCBzbG93KVxuICAvL1xuICAvLyBGaW5kIFEgYW5kIFMsIHRoYXQgUSAqIDIgXiBTID0gKFAgLSAxKVxuICB2YXIgcSA9IHRoaXMubS5zdWJuKDEpO1xuICB2YXIgcyA9IDA7XG4gIHdoaWxlIChxLmNtcG4oMCkgIT09IDAgJiYgcS5hbmRsbigxKSA9PT0gMCkge1xuICAgIHMrKztcbiAgICBxLmlzaHJuKDEpO1xuICB9XG4gIGFzc2VydChxLmNtcG4oMCkgIT09IDApO1xuXG4gIHZhciBvbmUgPSBuZXcgQk4oMSkudG9SZWQodGhpcyk7XG4gIHZhciBuT25lID0gb25lLnJlZE5lZygpO1xuXG4gIC8vIEZpbmQgcXVhZHJhdGljIG5vbi1yZXNpZHVlXG4gIC8vIE5PVEU6IE1heCBpcyBzdWNoIGJlY2F1c2Ugb2YgZ2VuZXJhbGl6ZWQgUmllbWFubiBoeXBvdGhlc2lzLlxuICB2YXIgbHBvdyA9IHRoaXMubS5zdWJuKDEpLmlzaHJuKDEpO1xuICB2YXIgeiA9IHRoaXMubS5iaXRMZW5ndGgoKTtcbiAgeiA9IG5ldyBCTigyICogeiAqIHopLnRvUmVkKHRoaXMpO1xuICB3aGlsZSAodGhpcy5wb3coeiwgbHBvdykuY21wKG5PbmUpICE9PSAwKVxuICAgIHoucmVkSUFkZChuT25lKTtcblxuICB2YXIgYyA9IHRoaXMucG93KHosIHEpO1xuICB2YXIgciA9IHRoaXMucG93KGEsIHEuYWRkbigxKS5pc2hybigxKSk7XG4gIHZhciB0ID0gdGhpcy5wb3coYSwgcSk7XG4gIHZhciBtID0gcztcbiAgd2hpbGUgKHQuY21wKG9uZSkgIT09IDApIHtcbiAgICB2YXIgdG1wID0gdDtcbiAgICBmb3IgKHZhciBpID0gMDsgdG1wLmNtcChvbmUpICE9PSAwOyBpKyspXG4gICAgICB0bXAgPSB0bXAucmVkU3FyKCk7XG4gICAgYXNzZXJ0KGkgPCBtKTtcbiAgICB2YXIgYiA9IHRoaXMucG93KGMsIG5ldyBCTigxKS5pc2hsbihtIC0gaSAtIDEpKTtcblxuICAgIHIgPSByLnJlZE11bChiKTtcbiAgICBjID0gYi5yZWRTcXIoKTtcbiAgICB0ID0gdC5yZWRNdWwoYyk7XG4gICAgbSA9IGk7XG4gIH1cblxuICByZXR1cm4gcjtcbn07XG5cblJlZC5wcm90b3R5cGUuaW52bSA9IGZ1bmN0aW9uIGludm0oYSkge1xuICB2YXIgaW52ID0gYS5faW52bXAodGhpcy5tKTtcbiAgaWYgKGludi5zaWduKSB7XG4gICAgaW52LnNpZ24gPSBmYWxzZTtcbiAgICByZXR1cm4gdGhpcy5pbW9kKGludikucmVkTmVnKCk7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIHRoaXMuaW1vZChpbnYpO1xuICB9XG59O1xuXG5SZWQucHJvdG90eXBlLnBvdyA9IGZ1bmN0aW9uIHBvdyhhLCBudW0pIHtcbiAgdmFyIHcgPSBbXTtcblxuICBpZiAobnVtLmNtcG4oMCkgPT09IDApXG4gICAgcmV0dXJuIG5ldyBCTigxKTtcblxuICB2YXIgcSA9IG51bS5jbG9uZSgpO1xuXG4gIHdoaWxlIChxLmNtcG4oMCkgIT09IDApIHtcbiAgICB3LnB1c2gocS5hbmRsbigxKSk7XG4gICAgcS5pc2hybigxKTtcbiAgfVxuXG4gIC8vIFNraXAgbGVhZGluZyB6ZXJvZXNcbiAgdmFyIHJlcyA9IGE7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgdy5sZW5ndGg7IGkrKywgcmVzID0gdGhpcy5zcXIocmVzKSlcbiAgICBpZiAod1tpXSAhPT0gMClcbiAgICAgIGJyZWFrO1xuXG4gIGlmICgrK2kgPCB3Lmxlbmd0aCkge1xuICAgIGZvciAodmFyIHEgPSB0aGlzLnNxcihyZXMpOyBpIDwgdy5sZW5ndGg7IGkrKywgcSA9IHRoaXMuc3FyKHEpKSB7XG4gICAgICBpZiAod1tpXSA9PT0gMClcbiAgICAgICAgY29udGludWU7XG4gICAgICByZXMgPSB0aGlzLm11bChyZXMsIHEpO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiByZXM7XG59O1xuXG5SZWQucHJvdG90eXBlLmNvbnZlcnRUbyA9IGZ1bmN0aW9uIGNvbnZlcnRUbyhudW0pIHtcbiAgdmFyIHIgPSBudW0ubW9kKHRoaXMubSk7XG4gIGlmIChyID09PSBudW0pXG4gICAgcmV0dXJuIHIuY2xvbmUoKTtcbiAgZWxzZVxuICAgIHJldHVybiByO1xufTtcblxuUmVkLnByb3RvdHlwZS5jb252ZXJ0RnJvbSA9IGZ1bmN0aW9uIGNvbnZlcnRGcm9tKG51bSkge1xuICB2YXIgcmVzID0gbnVtLmNsb25lKCk7XG4gIHJlcy5yZWQgPSBudWxsO1xuICByZXR1cm4gcmVzO1xufTtcblxuLy9cbi8vIE1vbnRnb21lcnkgbWV0aG9kIGVuZ2luZVxuLy9cblxuQk4ubW9udCA9IGZ1bmN0aW9uIG1vbnQobnVtKSB7XG4gIHJldHVybiBuZXcgTW9udChudW0pO1xufTtcblxuZnVuY3Rpb24gTW9udChtKSB7XG4gIFJlZC5jYWxsKHRoaXMsIG0pO1xuXG4gIHRoaXMuc2hpZnQgPSB0aGlzLm0uYml0TGVuZ3RoKCk7XG4gIGlmICh0aGlzLnNoaWZ0ICUgMjYgIT09IDApXG4gICAgdGhpcy5zaGlmdCArPSAyNiAtICh0aGlzLnNoaWZ0ICUgMjYpO1xuICB0aGlzLnIgPSBuZXcgQk4oMSkuaXNobG4odGhpcy5zaGlmdCk7XG4gIHRoaXMucjIgPSB0aGlzLmltb2QodGhpcy5yLnNxcigpKTtcbiAgdGhpcy5yaW52ID0gdGhpcy5yLl9pbnZtcCh0aGlzLm0pO1xuXG4gIHRoaXMubWludiA9IHRoaXMucmludi5tdWwodGhpcy5yKS5pc3VibigxKS5kaXYodGhpcy5tKTtcbiAgdGhpcy5taW52LnNpZ24gPSB0cnVlO1xuICB0aGlzLm1pbnYgPSB0aGlzLm1pbnYubW9kKHRoaXMucik7XG59XG5pbmhlcml0cyhNb250LCBSZWQpO1xuXG5Nb250LnByb3RvdHlwZS5jb252ZXJ0VG8gPSBmdW5jdGlvbiBjb252ZXJ0VG8obnVtKSB7XG4gIHJldHVybiB0aGlzLmltb2QobnVtLnNobG4odGhpcy5zaGlmdCkpO1xufTtcblxuTW9udC5wcm90b3R5cGUuY29udmVydEZyb20gPSBmdW5jdGlvbiBjb252ZXJ0RnJvbShudW0pIHtcbiAgdmFyIHIgPSB0aGlzLmltb2QobnVtLm11bCh0aGlzLnJpbnYpKTtcbiAgci5yZWQgPSBudWxsO1xuICByZXR1cm4gcjtcbn07XG5cbk1vbnQucHJvdG90eXBlLmltdWwgPSBmdW5jdGlvbiBpbXVsKGEsIGIpIHtcbiAgaWYgKGEuY21wbigwKSA9PT0gMCB8fCBiLmNtcG4oMCkgPT09IDApIHtcbiAgICBhLndvcmRzWzBdID0gMDtcbiAgICBhLmxlbmd0aCA9IDE7XG4gICAgcmV0dXJuIGE7XG4gIH1cblxuICB2YXIgdCA9IGEuaW11bChiKTtcbiAgdmFyIGMgPSB0Lm1hc2tuKHRoaXMuc2hpZnQpLm11bCh0aGlzLm1pbnYpLmltYXNrbih0aGlzLnNoaWZ0KS5tdWwodGhpcy5tKTtcbiAgdmFyIHUgPSB0LmlzdWIoYykuaXNocm4odGhpcy5zaGlmdCk7XG4gIHZhciByZXMgPSB1O1xuICBpZiAodS5jbXAodGhpcy5tKSA+PSAwKVxuICAgIHJlcyA9IHUuaXN1Yih0aGlzLm0pO1xuICBlbHNlIGlmICh1LmNtcG4oMCkgPCAwKVxuICAgIHJlcyA9IHUuaWFkZCh0aGlzLm0pO1xuXG4gIHJldHVybiByZXMuX2ZvcmNlUmVkKHRoaXMpO1xufTtcblxuTW9udC5wcm90b3R5cGUubXVsID0gZnVuY3Rpb24gbXVsKGEsIGIpIHtcbiAgaWYgKGEuY21wbigwKSA9PT0gMCB8fCBiLmNtcG4oMCkgPT09IDApXG4gICAgcmV0dXJuIG5ldyBCTigwKS5fZm9yY2VSZWQodGhpcyk7XG5cbiAgdmFyIHQgPSBhLm11bChiKTtcbiAgdmFyIGMgPSB0Lm1hc2tuKHRoaXMuc2hpZnQpLm11bCh0aGlzLm1pbnYpLmltYXNrbih0aGlzLnNoaWZ0KS5tdWwodGhpcy5tKTtcbiAgdmFyIHUgPSB0LmlzdWIoYykuaXNocm4odGhpcy5zaGlmdCk7XG4gIHZhciByZXMgPSB1O1xuICBpZiAodS5jbXAodGhpcy5tKSA+PSAwKVxuICAgIHJlcyA9IHUuaXN1Yih0aGlzLm0pO1xuICBlbHNlIGlmICh1LmNtcG4oMCkgPCAwKVxuICAgIHJlcyA9IHUuaWFkZCh0aGlzLm0pO1xuXG4gIHJldHVybiByZXMuX2ZvcmNlUmVkKHRoaXMpO1xufTtcblxuTW9udC5wcm90b3R5cGUuaW52bSA9IGZ1bmN0aW9uIGludm0oYSkge1xuICAvLyAoQVIpXi0xICogUl4yID0gKEFeLTEgKiBSXi0xKSAqIFJeMiA9IEFeLTEgKiBSXG4gIHZhciByZXMgPSB0aGlzLmltb2QoYS5faW52bXAodGhpcy5tKS5tdWwodGhpcy5yMikpO1xuICByZXR1cm4gcmVzLl9mb3JjZVJlZCh0aGlzKTtcbn07XG5cbn0pKHR5cGVvZiBtb2R1bGUgPT09ICd1bmRlZmluZWQnIHx8IG1vZHVsZSwgdGhpcyk7XG4iLCJ2YXIgaGFzVHlwZWRBcnJheXMgPSBmYWxzZVxuaWYodHlwZW9mIEZsb2F0NjRBcnJheSAhPT0gXCJ1bmRlZmluZWRcIikge1xuICB2YXIgRE9VQkxFX1ZJRVcgPSBuZXcgRmxvYXQ2NEFycmF5KDEpXG4gICAgLCBVSU5UX1ZJRVcgICA9IG5ldyBVaW50MzJBcnJheShET1VCTEVfVklFVy5idWZmZXIpXG4gIERPVUJMRV9WSUVXWzBdID0gMS4wXG4gIGhhc1R5cGVkQXJyYXlzID0gdHJ1ZVxuICBpZihVSU5UX1ZJRVdbMV0gPT09IDB4M2ZmMDAwMDApIHtcbiAgICAvL1VzZSBsaXR0bGUgZW5kaWFuXG4gICAgbW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBkb3VibGVCaXRzTEUobikge1xuICAgICAgRE9VQkxFX1ZJRVdbMF0gPSBuXG4gICAgICByZXR1cm4gWyBVSU5UX1ZJRVdbMF0sIFVJTlRfVklFV1sxXSBdXG4gICAgfVxuICAgIGZ1bmN0aW9uIHRvRG91YmxlTEUobG8sIGhpKSB7XG4gICAgICBVSU5UX1ZJRVdbMF0gPSBsb1xuICAgICAgVUlOVF9WSUVXWzFdID0gaGlcbiAgICAgIHJldHVybiBET1VCTEVfVklFV1swXVxuICAgIH1cbiAgICBtb2R1bGUuZXhwb3J0cy5wYWNrID0gdG9Eb3VibGVMRVxuICAgIGZ1bmN0aW9uIGxvd1VpbnRMRShuKSB7XG4gICAgICBET1VCTEVfVklFV1swXSA9IG5cbiAgICAgIHJldHVybiBVSU5UX1ZJRVdbMF1cbiAgICB9XG4gICAgbW9kdWxlLmV4cG9ydHMubG8gPSBsb3dVaW50TEVcbiAgICBmdW5jdGlvbiBoaWdoVWludExFKG4pIHtcbiAgICAgIERPVUJMRV9WSUVXWzBdID0gblxuICAgICAgcmV0dXJuIFVJTlRfVklFV1sxXVxuICAgIH1cbiAgICBtb2R1bGUuZXhwb3J0cy5oaSA9IGhpZ2hVaW50TEVcbiAgfSBlbHNlIGlmKFVJTlRfVklFV1swXSA9PT0gMHgzZmYwMDAwMCkge1xuICAgIC8vVXNlIGJpZyBlbmRpYW5cbiAgICBtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGRvdWJsZUJpdHNCRShuKSB7XG4gICAgICBET1VCTEVfVklFV1swXSA9IG5cbiAgICAgIHJldHVybiBbIFVJTlRfVklFV1sxXSwgVUlOVF9WSUVXWzBdIF1cbiAgICB9XG4gICAgZnVuY3Rpb24gdG9Eb3VibGVCRShsbywgaGkpIHtcbiAgICAgIFVJTlRfVklFV1sxXSA9IGxvXG4gICAgICBVSU5UX1ZJRVdbMF0gPSBoaVxuICAgICAgcmV0dXJuIERPVUJMRV9WSUVXWzBdXG4gICAgfVxuICAgIG1vZHVsZS5leHBvcnRzLnBhY2sgPSB0b0RvdWJsZUJFXG4gICAgZnVuY3Rpb24gbG93VWludEJFKG4pIHtcbiAgICAgIERPVUJMRV9WSUVXWzBdID0gblxuICAgICAgcmV0dXJuIFVJTlRfVklFV1sxXVxuICAgIH1cbiAgICBtb2R1bGUuZXhwb3J0cy5sbyA9IGxvd1VpbnRCRVxuICAgIGZ1bmN0aW9uIGhpZ2hVaW50QkUobikge1xuICAgICAgRE9VQkxFX1ZJRVdbMF0gPSBuXG4gICAgICByZXR1cm4gVUlOVF9WSUVXWzBdXG4gICAgfVxuICAgIG1vZHVsZS5leHBvcnRzLmhpID0gaGlnaFVpbnRCRVxuICB9IGVsc2Uge1xuICAgIGhhc1R5cGVkQXJyYXlzID0gZmFsc2VcbiAgfVxufVxuaWYoIWhhc1R5cGVkQXJyYXlzKSB7XG4gIHZhciBidWZmZXIgPSBuZXcgQnVmZmVyKDgpXG4gIG1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gZG91YmxlQml0cyhuKSB7XG4gICAgYnVmZmVyLndyaXRlRG91YmxlTEUobiwgMCwgdHJ1ZSlcbiAgICByZXR1cm4gWyBidWZmZXIucmVhZFVJbnQzMkxFKDAsIHRydWUpLCBidWZmZXIucmVhZFVJbnQzMkxFKDQsIHRydWUpIF1cbiAgfVxuICBmdW5jdGlvbiB0b0RvdWJsZShsbywgaGkpIHtcbiAgICBidWZmZXIud3JpdGVVSW50MzJMRShsbywgMCwgdHJ1ZSlcbiAgICBidWZmZXIud3JpdGVVSW50MzJMRShoaSwgNCwgdHJ1ZSlcbiAgICByZXR1cm4gYnVmZmVyLnJlYWREb3VibGVMRSgwLCB0cnVlKVxuICB9XG4gIG1vZHVsZS5leHBvcnRzLnBhY2sgPSB0b0RvdWJsZSAgXG4gIGZ1bmN0aW9uIGxvd1VpbnQobikge1xuICAgIGJ1ZmZlci53cml0ZURvdWJsZUxFKG4sIDAsIHRydWUpXG4gICAgcmV0dXJuIGJ1ZmZlci5yZWFkVUludDMyTEUoMCwgdHJ1ZSlcbiAgfVxuICBtb2R1bGUuZXhwb3J0cy5sbyA9IGxvd1VpbnRcbiAgZnVuY3Rpb24gaGlnaFVpbnQobikge1xuICAgIGJ1ZmZlci53cml0ZURvdWJsZUxFKG4sIDAsIHRydWUpXG4gICAgcmV0dXJuIGJ1ZmZlci5yZWFkVUludDMyTEUoNCwgdHJ1ZSlcbiAgfVxuICBtb2R1bGUuZXhwb3J0cy5oaSA9IGhpZ2hVaW50XG59XG5cbm1vZHVsZS5leHBvcnRzLnNpZ24gPSBmdW5jdGlvbihuKSB7XG4gIHJldHVybiBtb2R1bGUuZXhwb3J0cy5oaShuKSA+Pj4gMzFcbn1cblxubW9kdWxlLmV4cG9ydHMuZXhwb25lbnQgPSBmdW5jdGlvbihuKSB7XG4gIHZhciBiID0gbW9kdWxlLmV4cG9ydHMuaGkobilcbiAgcmV0dXJuICgoYjw8MSkgPj4+IDIxKSAtIDEwMjNcbn1cblxubW9kdWxlLmV4cG9ydHMuZnJhY3Rpb24gPSBmdW5jdGlvbihuKSB7XG4gIHZhciBsbyA9IG1vZHVsZS5leHBvcnRzLmxvKG4pXG4gIHZhciBoaSA9IG1vZHVsZS5leHBvcnRzLmhpKG4pXG4gIHZhciBiID0gaGkgJiAoKDE8PDIwKSAtIDEpXG4gIGlmKGhpICYgMHg3ZmYwMDAwMCkge1xuICAgIGIgKz0gKDE8PDIwKVxuICB9XG4gIHJldHVybiBbbG8sIGJdXG59XG5cbm1vZHVsZS5leHBvcnRzLmRlbm9ybWFsaXplZCA9IGZ1bmN0aW9uKG4pIHtcbiAgdmFyIGhpID0gbW9kdWxlLmV4cG9ydHMuaGkobilcbiAgcmV0dXJuICEoaGkgJiAweDdmZjAwMDAwKVxufSIsIid1c2Ugc3RyaWN0J1xuXG52YXIgYm5zaWduID0gcmVxdWlyZSgnLi9saWIvYm4tc2lnbicpXG5cbm1vZHVsZS5leHBvcnRzID0gc2lnblxuXG5mdW5jdGlvbiBzaWduKHgpIHtcbiAgcmV0dXJuIGJuc2lnbih4WzBdKSAqIGJuc2lnbih4WzFdKVxufVxuIiwiJ3VzZSBzdHJpY3QnXG5cbnZhciByYXRpb25hbGl6ZSA9IHJlcXVpcmUoJy4vbGliL3JhdGlvbmFsaXplJylcblxubW9kdWxlLmV4cG9ydHMgPSBzdWJcblxuZnVuY3Rpb24gc3ViKGEsIGIpIHtcbiAgcmV0dXJuIHJhdGlvbmFsaXplKGFbMF0ubXVsKGJbMV0pLnN1YihhWzFdLm11bChiWzBdKSksIGFbMV0ubXVsKGJbMV0pKVxufVxuIiwiJ3VzZSBzdHJpY3QnXG5cbnZhciBibjJudW0gPSByZXF1aXJlKCcuL2xpYi9ibi10by1udW0nKVxudmFyIGN0eiA9IHJlcXVpcmUoJy4vbGliL2N0eicpXG5cbm1vZHVsZS5leHBvcnRzID0gcm91bmRSYXRcblxuLy9Sb3VuZCBhIHJhdGlvbmFsIHRvIHRoZSBjbG9zZXN0IGZsb2F0XG5mdW5jdGlvbiByb3VuZFJhdChmKSB7XG4gIHZhciBhID0gZlswXVxuICB2YXIgYiA9IGZbMV1cbiAgaWYoYS5jbXBuKDApID09PSAwKSB7XG4gICAgcmV0dXJuIDBcbiAgfVxuICB2YXIgaCA9IGEuZGl2bW9kKGIpXG4gIHZhciBpdiA9IGguZGl2XG4gIHZhciB4ID0gYm4ybnVtKGl2KVxuICB2YXIgaXIgPSBoLm1vZFxuICBpZihpci5jbXBuKDApID09PSAwKSB7XG4gICAgcmV0dXJuIHhcbiAgfVxuICBpZih4KSB7XG4gICAgdmFyIHMgPSBjdHooeCkgKyA0XG4gICAgdmFyIHkgPSBibjJudW0oaXIuc2hsbihzKS5kaXZSb3VuZChiKSlcblxuICAgIC8vIGZsaXAgdGhlIHNpZ24gb2YgeSBpZiB4IGlzIG5lZ2F0aXZlXG4gICAgaWYgKHg8MCkge1xuICAgICAgeSA9IC15O1xuICAgIH1cblxuICAgIHJldHVybiB4ICsgeSAqIE1hdGgucG93KDIsIC1zKVxuICB9IGVsc2Uge1xuICAgIHZhciB5Yml0cyA9IGIuYml0TGVuZ3RoKCkgLSBpci5iaXRMZW5ndGgoKSArIDUzXG4gICAgdmFyIHkgPSBibjJudW0oaXIuc2hsbih5Yml0cykuZGl2Um91bmQoYikpXG4gICAgaWYoeWJpdHMgPCAxMDIzKSB7XG4gICAgICByZXR1cm4geSAqIE1hdGgucG93KDIsIC15Yml0cylcbiAgICB9XG4gICAgeSAqPSBNYXRoLnBvdygyLCAtMTAyMylcbiAgICByZXR1cm4geSAqIE1hdGgucG93KDIsIDEwMjMteWJpdHMpXG4gIH1cbn1cbiIsIid1c2Ugc3RyaWN0J1xuXG5tb2R1bGUuZXhwb3J0cyA9IGJveEludGVyc2VjdFdyYXBwZXJcblxudmFyIHBvb2wgPSByZXF1aXJlKCd0eXBlZGFycmF5LXBvb2wnKVxudmFyIHN3ZWVwID0gcmVxdWlyZSgnLi9saWIvc3dlZXAnKVxudmFyIGJveEludGVyc2VjdEl0ZXIgPSByZXF1aXJlKCcuL2xpYi9pbnRlcnNlY3QnKVxuXG5mdW5jdGlvbiBib3hFbXB0eShkLCBib3gpIHtcbiAgZm9yKHZhciBqPTA7IGo8ZDsgKytqKSB7XG4gICAgaWYoIShib3hbal0gPD0gYm94W2orZF0pKSB7XG4gICAgICByZXR1cm4gdHJ1ZVxuICAgIH1cbiAgfVxuICByZXR1cm4gZmFsc2Vcbn1cblxuLy9VbnBhY2sgYm94ZXMgaW50byBhIGZsYXQgdHlwZWQgYXJyYXksIHJlbW92ZSBlbXB0eSBib3hlc1xuZnVuY3Rpb24gY29udmVydEJveGVzKGJveGVzLCBkLCBkYXRhLCBpZHMpIHtcbiAgdmFyIHB0ciA9IDBcbiAgdmFyIGNvdW50ID0gMFxuICBmb3IodmFyIGk9MCwgbj1ib3hlcy5sZW5ndGg7IGk8bjsgKytpKSB7XG4gICAgdmFyIGIgPSBib3hlc1tpXVxuICAgIGlmKGJveEVtcHR5KGQsIGIpKSB7XG4gICAgICBjb250aW51ZVxuICAgIH1cbiAgICBmb3IodmFyIGo9MDsgajwyKmQ7ICsraikge1xuICAgICAgZGF0YVtwdHIrK10gPSBiW2pdXG4gICAgfVxuICAgIGlkc1tjb3VudCsrXSA9IGlcbiAgfVxuICByZXR1cm4gY291bnRcbn1cblxuLy9QZXJmb3JtIHR5cGUgY29udmVyc2lvbnMsIGNoZWNrIGJvdW5kc1xuZnVuY3Rpb24gYm94SW50ZXJzZWN0KHJlZCwgYmx1ZSwgdmlzaXQsIGZ1bGwpIHtcbiAgdmFyIG4gPSByZWQubGVuZ3RoXG4gIHZhciBtID0gYmx1ZS5sZW5ndGhcblxuICAvL0lmIGVpdGhlciBhcnJheSBpcyBlbXB0eSwgdGhlbiB3ZSBjYW4gc2tpcCB0aGlzIHdob2xlIHRoaW5nXG4gIGlmKG4gPD0gMCB8fCBtIDw9IDApIHtcbiAgICByZXR1cm5cbiAgfVxuXG4gIC8vQ29tcHV0ZSBkaW1lbnNpb24sIGlmIGl0IGlzIDAgdGhlbiB3ZSBza2lwXG4gIHZhciBkID0gKHJlZFswXS5sZW5ndGgpPj4+MVxuICBpZihkIDw9IDApIHtcbiAgICByZXR1cm5cbiAgfVxuXG4gIHZhciByZXR2YWxcblxuICAvL0NvbnZlcnQgcmVkIGJveGVzXG4gIHZhciByZWRMaXN0ICA9IHBvb2wubWFsbG9jRG91YmxlKDIqZCpuKVxuICB2YXIgcmVkSWRzICAgPSBwb29sLm1hbGxvY0ludDMyKG4pXG4gIG4gPSBjb252ZXJ0Qm94ZXMocmVkLCBkLCByZWRMaXN0LCByZWRJZHMpXG5cbiAgaWYobiA+IDApIHtcbiAgICBpZihkID09PSAxICYmIGZ1bGwpIHtcbiAgICAgIC8vU3BlY2lhbCBjYXNlOiAxZCBjb21wbGV0ZVxuICAgICAgc3dlZXAuaW5pdChuKVxuICAgICAgcmV0dmFsID0gc3dlZXAuc3dlZXBDb21wbGV0ZShcbiAgICAgICAgZCwgdmlzaXQsIFxuICAgICAgICAwLCBuLCByZWRMaXN0LCByZWRJZHMsXG4gICAgICAgIDAsIG4sIHJlZExpc3QsIHJlZElkcylcbiAgICB9IGVsc2Uge1xuXG4gICAgICAvL0NvbnZlcnQgYmx1ZSBib3hlc1xuICAgICAgdmFyIGJsdWVMaXN0ID0gcG9vbC5tYWxsb2NEb3VibGUoMipkKm0pXG4gICAgICB2YXIgYmx1ZUlkcyAgPSBwb29sLm1hbGxvY0ludDMyKG0pXG4gICAgICBtID0gY29udmVydEJveGVzKGJsdWUsIGQsIGJsdWVMaXN0LCBibHVlSWRzKVxuXG4gICAgICBpZihtID4gMCkge1xuICAgICAgICBzd2VlcC5pbml0KG4rbSlcblxuICAgICAgICBpZihkID09PSAxKSB7XG4gICAgICAgICAgLy9TcGVjaWFsIGNhc2U6IDFkIGJpcGFydGl0ZVxuICAgICAgICAgIHJldHZhbCA9IHN3ZWVwLnN3ZWVwQmlwYXJ0aXRlKFxuICAgICAgICAgICAgZCwgdmlzaXQsIFxuICAgICAgICAgICAgMCwgbiwgcmVkTGlzdCwgIHJlZElkcyxcbiAgICAgICAgICAgIDAsIG0sIGJsdWVMaXN0LCBibHVlSWRzKVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIC8vR2VuZXJhbCBjYXNlOiAgZD4xXG4gICAgICAgICAgcmV0dmFsID0gYm94SW50ZXJzZWN0SXRlcihcbiAgICAgICAgICAgIGQsIHZpc2l0LCAgICBmdWxsLFxuICAgICAgICAgICAgbiwgcmVkTGlzdCwgIHJlZElkcyxcbiAgICAgICAgICAgIG0sIGJsdWVMaXN0LCBibHVlSWRzKVxuICAgICAgICB9XG5cbiAgICAgICAgcG9vbC5mcmVlKGJsdWVMaXN0KVxuICAgICAgICBwb29sLmZyZWUoYmx1ZUlkcylcbiAgICAgIH1cbiAgICB9XG5cbiAgICBwb29sLmZyZWUocmVkTGlzdClcbiAgICBwb29sLmZyZWUocmVkSWRzKVxuICB9XG5cbiAgcmV0dXJuIHJldHZhbFxufVxuXG5cbnZhciBSRVNVTFRcblxuZnVuY3Rpb24gYXBwZW5kSXRlbShpLGopIHtcbiAgUkVTVUxULnB1c2goW2ksal0pXG59XG5cbmZ1bmN0aW9uIGludGVyc2VjdEZ1bGxBcnJheSh4KSB7XG4gIFJFU1VMVCA9IFtdXG4gIGJveEludGVyc2VjdCh4LCB4LCBhcHBlbmRJdGVtLCB0cnVlKVxuICByZXR1cm4gUkVTVUxUXG59XG5cbmZ1bmN0aW9uIGludGVyc2VjdEJpcGFydGl0ZUFycmF5KHgsIHkpIHtcbiAgUkVTVUxUID0gW11cbiAgYm94SW50ZXJzZWN0KHgsIHksIGFwcGVuZEl0ZW0sIGZhbHNlKVxuICByZXR1cm4gUkVTVUxUXG59XG5cbi8vVXNlci1mcmllbmRseSB3cmFwcGVyLCBoYW5kbGUgZnVsbCBpbnB1dCBhbmQgbm8tdmlzaXRvciBjYXNlc1xuZnVuY3Rpb24gYm94SW50ZXJzZWN0V3JhcHBlcihhcmcwLCBhcmcxLCBhcmcyKSB7XG4gIHZhciByZXN1bHRcbiAgc3dpdGNoKGFyZ3VtZW50cy5sZW5ndGgpIHtcbiAgICBjYXNlIDE6XG4gICAgICByZXR1cm4gaW50ZXJzZWN0RnVsbEFycmF5KGFyZzApXG4gICAgY2FzZSAyOlxuICAgICAgaWYodHlwZW9mIGFyZzEgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgcmV0dXJuIGJveEludGVyc2VjdChhcmcwLCBhcmcwLCBhcmcxLCB0cnVlKVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIGludGVyc2VjdEJpcGFydGl0ZUFycmF5KGFyZzAsIGFyZzEpXG4gICAgICB9XG4gICAgY2FzZSAzOlxuICAgICAgcmV0dXJuIGJveEludGVyc2VjdChhcmcwLCBhcmcxLCBhcmcyLCBmYWxzZSlcbiAgICBkZWZhdWx0OlxuICAgICAgdGhyb3cgbmV3IEVycm9yKCdib3gtaW50ZXJzZWN0OiBJbnZhbGlkIGFyZ3VtZW50cycpXG4gIH1cbn0iLCIndXNlIHN0cmljdCdcblxudmFyIERJTUVOU0lPTiAgID0gJ2QnXG52YXIgQVhJUyAgICAgICAgPSAnYXgnXG52YXIgVklTSVQgICAgICAgPSAndnYnXG52YXIgRkxJUCAgICAgICAgPSAnZnAnXG5cbnZhciBFTEVNX1NJWkUgICA9ICdlcydcblxudmFyIFJFRF9TVEFSVCAgID0gJ3JzJ1xudmFyIFJFRF9FTkQgICAgID0gJ3JlJ1xudmFyIFJFRF9CT1hFUyAgID0gJ3JiJ1xudmFyIFJFRF9JTkRFWCAgID0gJ3JpJ1xudmFyIFJFRF9QVFIgICAgID0gJ3JwJ1xuXG52YXIgQkxVRV9TVEFSVCAgPSAnYnMnXG52YXIgQkxVRV9FTkQgICAgPSAnYmUnXG52YXIgQkxVRV9CT1hFUyAgPSAnYmInXG52YXIgQkxVRV9JTkRFWCAgPSAnYmknXG52YXIgQkxVRV9QVFIgICAgPSAnYnAnXG5cbnZhciBSRVRWQUwgICAgICA9ICdydidcblxudmFyIElOTkVSX0xBQkVMID0gJ1EnXG5cbnZhciBBUkdTID0gW1xuICBESU1FTlNJT04sXG4gIEFYSVMsXG4gIFZJU0lULFxuICBSRURfU1RBUlQsXG4gIFJFRF9FTkQsXG4gIFJFRF9CT1hFUyxcbiAgUkVEX0lOREVYLFxuICBCTFVFX1NUQVJULFxuICBCTFVFX0VORCxcbiAgQkxVRV9CT1hFUyxcbiAgQkxVRV9JTkRFWFxuXVxuXG5mdW5jdGlvbiBnZW5lcmF0ZUJydXRlRm9yY2UocmVkTWFqb3IsIGZsaXAsIGZ1bGwpIHtcbiAgdmFyIGZ1bmNOYW1lID0gJ2JydXRlRm9yY2UnICsgXG4gICAgKHJlZE1ham9yID8gJ1JlZCcgOiAnQmx1ZScpICsgXG4gICAgKGZsaXAgPyAnRmxpcCcgOiAnJykgK1xuICAgIChmdWxsID8gJ0Z1bGwnIDogJycpXG5cbiAgdmFyIGNvZGUgPSBbJ2Z1bmN0aW9uICcsIGZ1bmNOYW1lLCAnKCcsIEFSR1Muam9pbigpLCAnKXsnLFxuICAgICd2YXIgJywgRUxFTV9TSVpFLCAnPTIqJywgRElNRU5TSU9OLCAnOyddXG5cbiAgdmFyIHJlZExvb3AgPSBcbiAgICAnZm9yKHZhciBpPScgKyBSRURfU1RBUlQgKyAnLCcgKyBSRURfUFRSICsgJz0nICsgRUxFTV9TSVpFICsgJyonICsgUkVEX1NUQVJUICsgJzsnICtcbiAgICAgICAgJ2k8JyArIFJFRF9FTkQgKyc7JyArXG4gICAgICAgICcrK2ksJyArIFJFRF9QVFIgKyAnKz0nICsgRUxFTV9TSVpFICsgJyl7JyArXG4gICAgICAgICd2YXIgeDA9JyArIFJFRF9CT1hFUyArICdbJyArIEFYSVMgKyAnKycgKyBSRURfUFRSICsgJ10sJyArXG4gICAgICAgICAgICAneDE9JyArIFJFRF9CT1hFUyArICdbJyArIEFYSVMgKyAnKycgKyBSRURfUFRSICsgJysnICsgRElNRU5TSU9OICsgJ10sJyArXG4gICAgICAgICAgICAneGk9JyArIFJFRF9JTkRFWCArICdbaV07J1xuXG4gIHZhciBibHVlTG9vcCA9IFxuICAgICdmb3IodmFyIGo9JyArIEJMVUVfU1RBUlQgKyAnLCcgKyBCTFVFX1BUUiArICc9JyArIEVMRU1fU0laRSArICcqJyArIEJMVUVfU1RBUlQgKyAnOycgK1xuICAgICAgICAnajwnICsgQkxVRV9FTkQgKyAnOycgK1xuICAgICAgICAnKytqLCcgKyBCTFVFX1BUUiArICcrPScgKyBFTEVNX1NJWkUgKyAnKXsnICtcbiAgICAgICAgJ3ZhciB5MD0nICsgQkxVRV9CT1hFUyArICdbJyArIEFYSVMgKyAnKycgKyBCTFVFX1BUUiArICddLCcgK1xuICAgICAgICAgICAgKGZ1bGwgPyAneTE9JyArIEJMVUVfQk9YRVMgKyAnWycgKyBBWElTICsgJysnICsgQkxVRV9QVFIgKyAnKycgKyBESU1FTlNJT04gKyAnXSwnIDogJycpICtcbiAgICAgICAgICAgICd5aT0nICsgQkxVRV9JTkRFWCArICdbal07J1xuXG4gIGlmKHJlZE1ham9yKSB7XG4gICAgY29kZS5wdXNoKHJlZExvb3AsIElOTkVSX0xBQkVMLCAnOicsIGJsdWVMb29wKVxuICB9IGVsc2Uge1xuICAgIGNvZGUucHVzaChibHVlTG9vcCwgSU5ORVJfTEFCRUwsICc6JywgcmVkTG9vcClcbiAgfVxuXG4gIGlmKGZ1bGwpIHtcbiAgICBjb2RlLnB1c2goJ2lmKHkxPHgwfHx4MTx5MCljb250aW51ZTsnKVxuICB9IGVsc2UgaWYoZmxpcCkge1xuICAgIGNvZGUucHVzaCgnaWYoeTA8PXgwfHx4MTx5MCljb250aW51ZTsnKVxuICB9IGVsc2Uge1xuICAgIGNvZGUucHVzaCgnaWYoeTA8eDB8fHgxPHkwKWNvbnRpbnVlOycpXG4gIH1cblxuICBjb2RlLnB1c2goJ2Zvcih2YXIgaz0nK0FYSVMrJysxO2s8JytESU1FTlNJT04rJzsrK2speycrXG4gICAgJ3ZhciByMD0nK1JFRF9CT1hFUysnW2srJytSRURfUFRSKyddLCcrXG4gICAgICAgICdyMT0nK1JFRF9CT1hFUysnW2srJytESU1FTlNJT04rJysnK1JFRF9QVFIrJ10sJytcbiAgICAgICAgJ2IwPScrQkxVRV9CT1hFUysnW2srJytCTFVFX1BUUisnXSwnK1xuICAgICAgICAnYjE9JytCTFVFX0JPWEVTKydbaysnK0RJTUVOU0lPTisnKycrQkxVRV9QVFIrJ107JytcbiAgICAgICdpZihyMTxiMHx8YjE8cjApY29udGludWUgJyArIElOTkVSX0xBQkVMICsgJzt9JyArXG4gICAgICAndmFyICcgKyBSRVRWQUwgKyAnPScgKyBWSVNJVCArICcoJylcblxuICBpZihmbGlwKSB7XG4gICAgY29kZS5wdXNoKCd5aSx4aScpXG4gIH0gZWxzZSB7XG4gICAgY29kZS5wdXNoKCd4aSx5aScpXG4gIH1cblxuICBjb2RlLnB1c2goJyk7aWYoJyArIFJFVFZBTCArICchPT12b2lkIDApcmV0dXJuICcgKyBSRVRWQUwgKyAnO319fScpXG5cbiAgcmV0dXJuIHtcbiAgICBuYW1lOiBmdW5jTmFtZSwgXG4gICAgY29kZTogY29kZS5qb2luKCcnKVxuICB9XG59XG5cbmZ1bmN0aW9uIGJydXRlRm9yY2VQbGFubmVyKGZ1bGwpIHtcbiAgdmFyIGZ1bmNOYW1lID0gJ2JydXRlRm9yY2UnICsgKGZ1bGwgPyAnRnVsbCcgOiAnUGFydGlhbCcpXG4gIHZhciBwcmVmaXggPSBbXVxuICB2YXIgZmFyZ3MgPSBBUkdTLnNsaWNlKClcbiAgaWYoIWZ1bGwpIHtcbiAgICBmYXJncy5zcGxpY2UoMywgMCwgRkxJUClcbiAgfVxuXG4gIHZhciBjb2RlID0gWydmdW5jdGlvbiAnICsgZnVuY05hbWUgKyAnKCcgKyBmYXJncy5qb2luKCkgKyAnKXsnXVxuXG4gIGZ1bmN0aW9uIGludm9rZShyZWRNYWpvciwgZmxpcCkge1xuICAgIHZhciByZXMgPSBnZW5lcmF0ZUJydXRlRm9yY2UocmVkTWFqb3IsIGZsaXAsIGZ1bGwpXG4gICAgcHJlZml4LnB1c2gocmVzLmNvZGUpXG4gICAgY29kZS5wdXNoKCdyZXR1cm4gJyArIHJlcy5uYW1lICsgJygnICsgQVJHUy5qb2luKCkgKyAnKTsnKVxuICB9XG5cbiAgY29kZS5wdXNoKCdpZignICsgUkVEX0VORCArICctJyArIFJFRF9TVEFSVCArICc+JyArXG4gICAgICAgICAgICAgICAgICAgIEJMVUVfRU5EICsgJy0nICsgQkxVRV9TVEFSVCArICcpeycpXG5cbiAgaWYoZnVsbCkge1xuICAgIGludm9rZSh0cnVlLCBmYWxzZSlcbiAgICBjb2RlLnB1c2goJ31lbHNleycpXG4gICAgaW52b2tlKGZhbHNlLCBmYWxzZSlcbiAgfSBlbHNlIHtcbiAgICBjb2RlLnB1c2goJ2lmKCcgKyBGTElQICsgJyl7JylcbiAgICBpbnZva2UodHJ1ZSwgdHJ1ZSlcbiAgICBjb2RlLnB1c2goJ31lbHNleycpXG4gICAgaW52b2tlKHRydWUsIGZhbHNlKVxuICAgIGNvZGUucHVzaCgnfX1lbHNle2lmKCcgKyBGTElQICsgJyl7JylcbiAgICBpbnZva2UoZmFsc2UsIHRydWUpXG4gICAgY29kZS5wdXNoKCd9ZWxzZXsnKVxuICAgIGludm9rZShmYWxzZSwgZmFsc2UpXG4gICAgY29kZS5wdXNoKCd9JylcbiAgfVxuICBjb2RlLnB1c2goJ319cmV0dXJuICcgKyBmdW5jTmFtZSlcblxuICB2YXIgY29kZVN0ciA9IHByZWZpeC5qb2luKCcnKSArIGNvZGUuam9pbignJylcbiAgdmFyIHByb2MgPSBuZXcgRnVuY3Rpb24oY29kZVN0cilcbiAgcmV0dXJuIHByb2MoKVxufVxuXG5cbmV4cG9ydHMucGFydGlhbCA9IGJydXRlRm9yY2VQbGFubmVyKGZhbHNlKVxuZXhwb3J0cy5mdWxsICAgID0gYnJ1dGVGb3JjZVBsYW5uZXIodHJ1ZSkiLCIndXNlIHN0cmljdCdcblxubW9kdWxlLmV4cG9ydHMgPSBib3hJbnRlcnNlY3RJdGVyXG5cbnZhciBwb29sID0gcmVxdWlyZSgndHlwZWRhcnJheS1wb29sJylcbnZhciBiaXRzID0gcmVxdWlyZSgnYml0LXR3aWRkbGUnKVxudmFyIGJydXRlRm9yY2UgPSByZXF1aXJlKCcuL2JydXRlJylcbnZhciBicnV0ZUZvcmNlUGFydGlhbCA9IGJydXRlRm9yY2UucGFydGlhbFxudmFyIGJydXRlRm9yY2VGdWxsID0gYnJ1dGVGb3JjZS5mdWxsXG52YXIgc3dlZXAgPSByZXF1aXJlKCcuL3N3ZWVwJylcbnZhciBmaW5kTWVkaWFuID0gcmVxdWlyZSgnLi9tZWRpYW4nKVxudmFyIGdlblBhcnRpdGlvbiA9IHJlcXVpcmUoJy4vcGFydGl0aW9uJylcblxuLy9Ud2lkZGxlIHBhcmFtZXRlcnNcbnZhciBCUlVURV9GT1JDRV9DVVRPRkYgICAgPSAxMjggICAgICAgLy9DdXQgb2ZmIGZvciBicnV0ZSBmb3JjZSBzZWFyY2hcbnZhciBTQ0FOX0NVVE9GRiAgICAgICAgICAgPSAoMTw8MjIpICAgLy9DdXQgb2ZmIGZvciB0d28gd2F5IHNjYW5cbnZhciBTQ0FOX0NPTVBMRVRFX0NVVE9GRiAgPSAoMTw8MjIpICBcblxuLy9QYXJ0aXRpb24gZnVuY3Rpb25zXG52YXIgcGFydGl0aW9uSW50ZXJpb3JDb250YWluc0ludGVydmFsID0gZ2VuUGFydGl0aW9uKFxuICAnIShsbz49cDApJiYhKHAxPj1oaSknLCBcbiAgWydwMCcsICdwMSddKVxuXG52YXIgcGFydGl0aW9uU3RhcnRFcXVhbCA9IGdlblBhcnRpdGlvbihcbiAgJ2xvPT09cDAnLFxuICBbJ3AwJ10pXG5cbnZhciBwYXJ0aXRpb25TdGFydExlc3NUaGFuID0gZ2VuUGFydGl0aW9uKFxuICAnbG88cDAnLFxuICBbJ3AwJ10pXG5cbnZhciBwYXJ0aXRpb25FbmRMZXNzVGhhbkVxdWFsID0gZ2VuUGFydGl0aW9uKFxuICAnaGk8PXAwJyxcbiAgWydwMCddKVxuXG52YXIgcGFydGl0aW9uQ29udGFpbnNQb2ludCA9IGdlblBhcnRpdGlvbihcbiAgJ2xvPD1wMCYmcDA8PWhpJyxcbiAgWydwMCddKVxuXG52YXIgcGFydGl0aW9uQ29udGFpbnNQb2ludFByb3BlciA9IGdlblBhcnRpdGlvbihcbiAgJ2xvPHAwJiZwMDw9aGknLFxuICBbJ3AwJ10pXG5cbi8vRnJhbWUgc2l6ZSBmb3IgaXRlcmF0aXZlIGxvb3BcbnZhciBJRlJBTUVfU0laRSA9IDZcbnZhciBERlJBTUVfU0laRSA9IDJcblxuLy9EYXRhIGZvciBib3ggc3RhdGNrXG52YXIgSU5JVF9DQVBBQ0lUWSA9IDEwMjRcbnZhciBCT1hfSVNUQUNLICA9IHBvb2wubWFsbG9jSW50MzIoSU5JVF9DQVBBQ0lUWSlcbnZhciBCT1hfRFNUQUNLICA9IHBvb2wubWFsbG9jRG91YmxlKElOSVRfQ0FQQUNJVFkpXG5cbi8vSW5pdGlhbGl6ZSBpdGVyYXRpdmUgbG9vcCBxdWV1ZVxuZnVuY3Rpb24gaXRlckluaXQoZCwgY291bnQpIHtcbiAgdmFyIGxldmVscyA9ICg4ICogYml0cy5sb2cyKGNvdW50KzEpICogKGQrMSkpfDBcbiAgdmFyIG1heEludHMgPSBiaXRzLm5leHRQb3cyKElGUkFNRV9TSVpFKmxldmVscylcbiAgaWYoQk9YX0lTVEFDSy5sZW5ndGggPCBtYXhJbnRzKSB7XG4gICAgcG9vbC5mcmVlKEJPWF9JU1RBQ0spXG4gICAgQk9YX0lTVEFDSyA9IHBvb2wubWFsbG9jSW50MzIobWF4SW50cylcbiAgfVxuICB2YXIgbWF4RG91YmxlcyA9IGJpdHMubmV4dFBvdzIoREZSQU1FX1NJWkUqbGV2ZWxzKVxuICBpZihCT1hfRFNUQUNLIDwgbWF4RG91Ymxlcykge1xuICAgIHBvb2wuZnJlZShCT1hfRFNUQUNLKVxuICAgIEJPWF9EU1RBQ0sgPSBwb29sLm1hbGxvY0RvdWJsZShtYXhEb3VibGVzKVxuICB9XG59XG5cbi8vQXBwZW5kIGl0ZW0gdG8gcXVldWVcbmZ1bmN0aW9uIGl0ZXJQdXNoKHB0cixcbiAgYXhpcywgXG4gIHJlZFN0YXJ0LCByZWRFbmQsIFxuICBibHVlU3RhcnQsIGJsdWVFbmQsIFxuICBzdGF0ZSwgXG4gIGxvLCBoaSkge1xuXG4gIHZhciBpcHRyID0gSUZSQU1FX1NJWkUgKiBwdHJcbiAgQk9YX0lTVEFDS1tpcHRyXSAgID0gYXhpc1xuICBCT1hfSVNUQUNLW2lwdHIrMV0gPSByZWRTdGFydFxuICBCT1hfSVNUQUNLW2lwdHIrMl0gPSByZWRFbmRcbiAgQk9YX0lTVEFDS1tpcHRyKzNdID0gYmx1ZVN0YXJ0XG4gIEJPWF9JU1RBQ0tbaXB0cis0XSA9IGJsdWVFbmRcbiAgQk9YX0lTVEFDS1tpcHRyKzVdID0gc3RhdGVcblxuICB2YXIgZHB0ciA9IERGUkFNRV9TSVpFICogcHRyXG4gIEJPWF9EU1RBQ0tbZHB0cl0gICA9IGxvXG4gIEJPWF9EU1RBQ0tbZHB0cisxXSA9IGhpXG59XG5cbi8vU3BlY2lhbCBjYXNlOiAgSW50ZXJzZWN0IHNpbmdsZSBwb2ludCB3aXRoIGxpc3Qgb2YgaW50ZXJ2YWxzXG5mdW5jdGlvbiBvbmVQb2ludFBhcnRpYWwoXG4gIGQsIGF4aXMsIHZpc2l0LCBmbGlwLFxuICByZWRTdGFydCwgcmVkRW5kLCByZWQsIHJlZEluZGV4LFxuICBibHVlT2Zmc2V0LCBibHVlLCBibHVlSWQpIHtcblxuICB2YXIgZWxlbVNpemUgPSAyICogZFxuICB2YXIgYmx1ZVB0ciAgPSBibHVlT2Zmc2V0ICogZWxlbVNpemVcbiAgdmFyIGJsdWVYICAgID0gYmx1ZVtibHVlUHRyICsgYXhpc11cblxucmVkX2xvb3A6XG4gIGZvcih2YXIgaT1yZWRTdGFydCwgcmVkUHRyPXJlZFN0YXJ0KmVsZW1TaXplOyBpPHJlZEVuZDsgKytpLCByZWRQdHIrPWVsZW1TaXplKSB7XG4gICAgdmFyIHIwID0gcmVkW3JlZFB0citheGlzXVxuICAgIHZhciByMSA9IHJlZFtyZWRQdHIrYXhpcytkXVxuICAgIGlmKGJsdWVYIDwgcjAgfHwgcjEgPCBibHVlWCkge1xuICAgICAgY29udGludWVcbiAgICB9XG4gICAgaWYoZmxpcCAmJiBibHVlWCA9PT0gcjApIHtcbiAgICAgIGNvbnRpbnVlXG4gICAgfVxuICAgIHZhciByZWRJZCA9IHJlZEluZGV4W2ldXG4gICAgZm9yKHZhciBqPWF4aXMrMTsgajxkOyArK2opIHtcbiAgICAgIHZhciByMCA9IHJlZFtyZWRQdHIral1cbiAgICAgIHZhciByMSA9IHJlZFtyZWRQdHIraitkXVxuICAgICAgdmFyIGIwID0gYmx1ZVtibHVlUHRyK2pdXG4gICAgICB2YXIgYjEgPSBibHVlW2JsdWVQdHIraitkXVxuICAgICAgaWYocjEgPCBiMCB8fCBiMSA8IHIwKSB7XG4gICAgICAgIGNvbnRpbnVlIHJlZF9sb29wXG4gICAgICB9XG4gICAgfVxuICAgIHZhciByZXR2YWxcbiAgICBpZihmbGlwKSB7XG4gICAgICByZXR2YWwgPSB2aXNpdChibHVlSWQsIHJlZElkKVxuICAgIH0gZWxzZSB7XG4gICAgICByZXR2YWwgPSB2aXNpdChyZWRJZCwgYmx1ZUlkKVxuICAgIH1cbiAgICBpZihyZXR2YWwgIT09IHZvaWQgMCkge1xuICAgICAgcmV0dXJuIHJldHZhbFxuICAgIH1cbiAgfVxufVxuXG4vL1NwZWNpYWwgY2FzZTogIEludGVyc2VjdCBvbmUgcG9pbnQgd2l0aCBsaXN0IG9mIGludGVydmFsc1xuZnVuY3Rpb24gb25lUG9pbnRGdWxsKFxuICBkLCBheGlzLCB2aXNpdCxcbiAgcmVkU3RhcnQsIHJlZEVuZCwgcmVkLCByZWRJbmRleCxcbiAgYmx1ZU9mZnNldCwgYmx1ZSwgYmx1ZUlkKSB7XG5cbiAgdmFyIGVsZW1TaXplID0gMiAqIGRcbiAgdmFyIGJsdWVQdHIgID0gYmx1ZU9mZnNldCAqIGVsZW1TaXplXG4gIHZhciBibHVlWCAgICA9IGJsdWVbYmx1ZVB0ciArIGF4aXNdXG5cbnJlZF9sb29wOlxuICBmb3IodmFyIGk9cmVkU3RhcnQsIHJlZFB0cj1yZWRTdGFydCplbGVtU2l6ZTsgaTxyZWRFbmQ7ICsraSwgcmVkUHRyKz1lbGVtU2l6ZSkge1xuICAgIHZhciByZWRJZCA9IHJlZEluZGV4W2ldXG4gICAgaWYocmVkSWQgPT09IGJsdWVJZCkge1xuICAgICAgY29udGludWVcbiAgICB9XG4gICAgdmFyIHIwID0gcmVkW3JlZFB0citheGlzXVxuICAgIHZhciByMSA9IHJlZFtyZWRQdHIrYXhpcytkXVxuICAgIGlmKGJsdWVYIDwgcjAgfHwgcjEgPCBibHVlWCkge1xuICAgICAgY29udGludWVcbiAgICB9XG4gICAgZm9yKHZhciBqPWF4aXMrMTsgajxkOyArK2opIHtcbiAgICAgIHZhciByMCA9IHJlZFtyZWRQdHIral1cbiAgICAgIHZhciByMSA9IHJlZFtyZWRQdHIraitkXVxuICAgICAgdmFyIGIwID0gYmx1ZVtibHVlUHRyK2pdXG4gICAgICB2YXIgYjEgPSBibHVlW2JsdWVQdHIraitkXVxuICAgICAgaWYocjEgPCBiMCB8fCBiMSA8IHIwKSB7XG4gICAgICAgIGNvbnRpbnVlIHJlZF9sb29wXG4gICAgICB9XG4gICAgfVxuICAgIHZhciByZXR2YWwgPSB2aXNpdChyZWRJZCwgYmx1ZUlkKVxuICAgIGlmKHJldHZhbCAhPT0gdm9pZCAwKSB7XG4gICAgICByZXR1cm4gcmV0dmFsXG4gICAgfVxuICB9XG59XG5cbi8vVGhlIG1haW4gYm94IGludGVyc2VjdGlvbiByb3V0aW5lXG5mdW5jdGlvbiBib3hJbnRlcnNlY3RJdGVyKFxuICBkLCB2aXNpdCwgaW5pdEZ1bGwsXG4gIHhTaXplLCB4Qm94ZXMsIHhJbmRleCxcbiAgeVNpemUsIHlCb3hlcywgeUluZGV4KSB7XG5cbiAgLy9SZXNlcnZlIG1lbW9yeSBmb3Igc3RhY2tcbiAgaXRlckluaXQoZCwgeFNpemUgKyB5U2l6ZSlcblxuICB2YXIgdG9wICA9IDBcbiAgdmFyIGVsZW1TaXplID0gMiAqIGRcbiAgdmFyIHJldHZhbFxuXG4gIGl0ZXJQdXNoKHRvcCsrLFxuICAgICAgMCxcbiAgICAgIDAsIHhTaXplLFxuICAgICAgMCwgeVNpemUsXG4gICAgICBpbml0RnVsbCA/IDE2IDogMCwgXG4gICAgICAtSW5maW5pdHksIEluZmluaXR5KVxuICBpZighaW5pdEZ1bGwpIHtcbiAgICBpdGVyUHVzaCh0b3ArKyxcbiAgICAgIDAsXG4gICAgICAwLCB5U2l6ZSxcbiAgICAgIDAsIHhTaXplLFxuICAgICAgMSwgXG4gICAgICAtSW5maW5pdHksIEluZmluaXR5KVxuICB9XG5cbiAgd2hpbGUodG9wID4gMCkge1xuICAgIHRvcCAgLT0gMVxuXG4gICAgdmFyIGlwdHIgPSB0b3AgKiBJRlJBTUVfU0laRVxuICAgIHZhciBheGlzICAgICAgPSBCT1hfSVNUQUNLW2lwdHJdXG4gICAgdmFyIHJlZFN0YXJ0ICA9IEJPWF9JU1RBQ0tbaXB0cisxXVxuICAgIHZhciByZWRFbmQgICAgPSBCT1hfSVNUQUNLW2lwdHIrMl1cbiAgICB2YXIgYmx1ZVN0YXJ0ID0gQk9YX0lTVEFDS1tpcHRyKzNdXG4gICAgdmFyIGJsdWVFbmQgICA9IEJPWF9JU1RBQ0tbaXB0cis0XVxuICAgIHZhciBzdGF0ZSAgICAgPSBCT1hfSVNUQUNLW2lwdHIrNV1cblxuICAgIHZhciBkcHRyID0gdG9wICogREZSQU1FX1NJWkVcbiAgICB2YXIgbG8gICAgICAgID0gQk9YX0RTVEFDS1tkcHRyXVxuICAgIHZhciBoaSAgICAgICAgPSBCT1hfRFNUQUNLW2RwdHIrMV1cblxuICAgIC8vVW5wYWNrIHN0YXRlIGluZm9cbiAgICB2YXIgZmxpcCAgICAgID0gKHN0YXRlICYgMSlcbiAgICB2YXIgZnVsbCAgICAgID0gISEoc3RhdGUgJiAxNilcblxuICAgIC8vVW5wYWNrIGluZGljZXNcbiAgICB2YXIgcmVkICAgICAgID0geEJveGVzXG4gICAgdmFyIHJlZEluZGV4ICA9IHhJbmRleFxuICAgIHZhciBibHVlICAgICAgPSB5Qm94ZXNcbiAgICB2YXIgYmx1ZUluZGV4ID0geUluZGV4XG4gICAgaWYoZmxpcCkge1xuICAgICAgcmVkICAgICAgICAgPSB5Qm94ZXNcbiAgICAgIHJlZEluZGV4ICAgID0geUluZGV4XG4gICAgICBibHVlICAgICAgICA9IHhCb3hlc1xuICAgICAgYmx1ZUluZGV4ICAgPSB4SW5kZXhcbiAgICB9XG5cbiAgICBpZihzdGF0ZSAmIDIpIHtcbiAgICAgIHJlZEVuZCA9IHBhcnRpdGlvblN0YXJ0TGVzc1RoYW4oXG4gICAgICAgIGQsIGF4aXMsXG4gICAgICAgIHJlZFN0YXJ0LCByZWRFbmQsIHJlZCwgcmVkSW5kZXgsXG4gICAgICAgIGhpKVxuICAgICAgaWYocmVkU3RhcnQgPj0gcmVkRW5kKSB7XG4gICAgICAgIGNvbnRpbnVlXG4gICAgICB9XG4gICAgfVxuICAgIGlmKHN0YXRlICYgNCkge1xuICAgICAgcmVkU3RhcnQgPSBwYXJ0aXRpb25FbmRMZXNzVGhhbkVxdWFsKFxuICAgICAgICBkLCBheGlzLFxuICAgICAgICByZWRTdGFydCwgcmVkRW5kLCByZWQsIHJlZEluZGV4LFxuICAgICAgICBsbylcbiAgICAgIGlmKHJlZFN0YXJ0ID49IHJlZEVuZCkge1xuICAgICAgICBjb250aW51ZVxuICAgICAgfVxuICAgIH1cbiAgICBcbiAgICB2YXIgcmVkQ291bnQgID0gcmVkRW5kICAtIHJlZFN0YXJ0XG4gICAgdmFyIGJsdWVDb3VudCA9IGJsdWVFbmQgLSBibHVlU3RhcnRcblxuICAgIGlmKGZ1bGwpIHtcbiAgICAgIGlmKGQgKiByZWRDb3VudCAqIChyZWRDb3VudCArIGJsdWVDb3VudCkgPCBTQ0FOX0NPTVBMRVRFX0NVVE9GRikge1xuICAgICAgICByZXR2YWwgPSBzd2VlcC5zY2FuQ29tcGxldGUoXG4gICAgICAgICAgZCwgYXhpcywgdmlzaXQsIFxuICAgICAgICAgIHJlZFN0YXJ0LCByZWRFbmQsIHJlZCwgcmVkSW5kZXgsXG4gICAgICAgICAgYmx1ZVN0YXJ0LCBibHVlRW5kLCBibHVlLCBibHVlSW5kZXgpXG4gICAgICAgIGlmKHJldHZhbCAhPT0gdm9pZCAwKSB7XG4gICAgICAgICAgcmV0dXJuIHJldHZhbFxuICAgICAgICB9XG4gICAgICAgIGNvbnRpbnVlXG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGlmKGQgKiBNYXRoLm1pbihyZWRDb3VudCwgYmx1ZUNvdW50KSA8IEJSVVRFX0ZPUkNFX0NVVE9GRikge1xuICAgICAgICAvL0lmIGlucHV0IHNtYWxsLCB0aGVuIHVzZSBicnV0ZSBmb3JjZVxuICAgICAgICByZXR2YWwgPSBicnV0ZUZvcmNlUGFydGlhbChcbiAgICAgICAgICAgIGQsIGF4aXMsIHZpc2l0LCBmbGlwLFxuICAgICAgICAgICAgcmVkU3RhcnQsICByZWRFbmQsICByZWQsICByZWRJbmRleCxcbiAgICAgICAgICAgIGJsdWVTdGFydCwgYmx1ZUVuZCwgYmx1ZSwgYmx1ZUluZGV4KVxuICAgICAgICBpZihyZXR2YWwgIT09IHZvaWQgMCkge1xuICAgICAgICAgIHJldHVybiByZXR2YWxcbiAgICAgICAgfVxuICAgICAgICBjb250aW51ZVxuICAgICAgfSBlbHNlIGlmKGQgKiByZWRDb3VudCAqIGJsdWVDb3VudCA8IFNDQU5fQ1VUT0ZGKSB7XG4gICAgICAgIC8vSWYgaW5wdXQgbWVkaXVtIHNpemVkLCB0aGVuIHVzZSBzd2VlcCBhbmQgcHJ1bmVcbiAgICAgICAgcmV0dmFsID0gc3dlZXAuc2NhbkJpcGFydGl0ZShcbiAgICAgICAgICBkLCBheGlzLCB2aXNpdCwgZmxpcCwgXG4gICAgICAgICAgcmVkU3RhcnQsIHJlZEVuZCwgcmVkLCByZWRJbmRleCxcbiAgICAgICAgICBibHVlU3RhcnQsIGJsdWVFbmQsIGJsdWUsIGJsdWVJbmRleClcbiAgICAgICAgaWYocmV0dmFsICE9PSB2b2lkIDApIHtcbiAgICAgICAgICByZXR1cm4gcmV0dmFsXG4gICAgICAgIH1cbiAgICAgICAgY29udGludWVcbiAgICAgIH1cbiAgICB9XG4gICAgXG4gICAgLy9GaXJzdCwgZmluZCBhbGwgcmVkIGludGVydmFscyB3aG9zZSBpbnRlcmlvciBjb250YWlucyAobG8saGkpXG4gICAgdmFyIHJlZDAgPSBwYXJ0aXRpb25JbnRlcmlvckNvbnRhaW5zSW50ZXJ2YWwoXG4gICAgICBkLCBheGlzLCBcbiAgICAgIHJlZFN0YXJ0LCByZWRFbmQsIHJlZCwgcmVkSW5kZXgsXG4gICAgICBsbywgaGkpXG5cbiAgICAvL0xvd2VyIGRpbWVuc2lvbmFsIGNhc2VcbiAgICBpZihyZWRTdGFydCA8IHJlZDApIHtcblxuICAgICAgaWYoZCAqIChyZWQwIC0gcmVkU3RhcnQpIDwgQlJVVEVfRk9SQ0VfQ1VUT0ZGKSB7XG4gICAgICAgIC8vU3BlY2lhbCBjYXNlIGZvciBzbWFsbCBpbnB1dHM6IHVzZSBicnV0ZSBmb3JjZVxuICAgICAgICByZXR2YWwgPSBicnV0ZUZvcmNlRnVsbChcbiAgICAgICAgICBkLCBheGlzKzEsIHZpc2l0LFxuICAgICAgICAgIHJlZFN0YXJ0LCByZWQwLCByZWQsIHJlZEluZGV4LFxuICAgICAgICAgIGJsdWVTdGFydCwgYmx1ZUVuZCwgYmx1ZSwgYmx1ZUluZGV4KVxuICAgICAgICBpZihyZXR2YWwgIT09IHZvaWQgMCkge1xuICAgICAgICAgIHJldHVybiByZXR2YWxcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmKGF4aXMgPT09IGQtMikge1xuICAgICAgICBpZihmbGlwKSB7XG4gICAgICAgICAgcmV0dmFsID0gc3dlZXAuc3dlZXBCaXBhcnRpdGUoXG4gICAgICAgICAgICBkLCB2aXNpdCxcbiAgICAgICAgICAgIGJsdWVTdGFydCwgYmx1ZUVuZCwgYmx1ZSwgYmx1ZUluZGV4LFxuICAgICAgICAgICAgcmVkU3RhcnQsIHJlZDAsIHJlZCwgcmVkSW5kZXgpXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmV0dmFsID0gc3dlZXAuc3dlZXBCaXBhcnRpdGUoXG4gICAgICAgICAgICBkLCB2aXNpdCxcbiAgICAgICAgICAgIHJlZFN0YXJ0LCByZWQwLCByZWQsIHJlZEluZGV4LFxuICAgICAgICAgICAgYmx1ZVN0YXJ0LCBibHVlRW5kLCBibHVlLCBibHVlSW5kZXgpXG4gICAgICAgIH1cbiAgICAgICAgaWYocmV0dmFsICE9PSB2b2lkIDApIHtcbiAgICAgICAgICByZXR1cm4gcmV0dmFsXG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGl0ZXJQdXNoKHRvcCsrLFxuICAgICAgICAgIGF4aXMrMSxcbiAgICAgICAgICByZWRTdGFydCwgcmVkMCxcbiAgICAgICAgICBibHVlU3RhcnQsIGJsdWVFbmQsXG4gICAgICAgICAgZmxpcCxcbiAgICAgICAgICAtSW5maW5pdHksIEluZmluaXR5KVxuICAgICAgICBpdGVyUHVzaCh0b3ArKyxcbiAgICAgICAgICBheGlzKzEsXG4gICAgICAgICAgYmx1ZVN0YXJ0LCBibHVlRW5kLFxuICAgICAgICAgIHJlZFN0YXJ0LCByZWQwLFxuICAgICAgICAgIGZsaXBeMSxcbiAgICAgICAgICAtSW5maW5pdHksIEluZmluaXR5KVxuICAgICAgfVxuICAgIH1cblxuICAgIC8vRGl2aWRlIGFuZCBjb25xdWVyIHBoYXNlXG4gICAgaWYocmVkMCA8IHJlZEVuZCkge1xuXG4gICAgICAvL0N1dCBibHVlIGludG8gMyBwYXJ0czpcbiAgICAgIC8vXG4gICAgICAvLyAgUG9pbnRzIDwgbWlkIHBvaW50XG4gICAgICAvLyAgUG9pbnRzID0gbWlkIHBvaW50XG4gICAgICAvLyAgUG9pbnRzID4gbWlkIHBvaW50XG4gICAgICAvL1xuICAgICAgdmFyIGJsdWUwID0gZmluZE1lZGlhbihcbiAgICAgICAgZCwgYXhpcywgXG4gICAgICAgIGJsdWVTdGFydCwgYmx1ZUVuZCwgYmx1ZSwgYmx1ZUluZGV4KVxuICAgICAgdmFyIG1pZCA9IGJsdWVbZWxlbVNpemUgKiBibHVlMCArIGF4aXNdXG4gICAgICB2YXIgYmx1ZTEgPSBwYXJ0aXRpb25TdGFydEVxdWFsKFxuICAgICAgICBkLCBheGlzLFxuICAgICAgICBibHVlMCwgYmx1ZUVuZCwgYmx1ZSwgYmx1ZUluZGV4LFxuICAgICAgICBtaWQpXG5cbiAgICAgIC8vUmlnaHQgY2FzZVxuICAgICAgaWYoYmx1ZTEgPCBibHVlRW5kKSB7XG4gICAgICAgIGl0ZXJQdXNoKHRvcCsrLFxuICAgICAgICAgIGF4aXMsXG4gICAgICAgICAgcmVkMCwgcmVkRW5kLFxuICAgICAgICAgIGJsdWUxLCBibHVlRW5kLFxuICAgICAgICAgIChmbGlwfDQpICsgKGZ1bGwgPyAxNiA6IDApLFxuICAgICAgICAgIG1pZCwgaGkpXG4gICAgICB9XG5cbiAgICAgIC8vTGVmdCBjYXNlXG4gICAgICBpZihibHVlU3RhcnQgPCBibHVlMCkge1xuICAgICAgICBpdGVyUHVzaCh0b3ArKyxcbiAgICAgICAgICBheGlzLFxuICAgICAgICAgIHJlZDAsIHJlZEVuZCxcbiAgICAgICAgICBibHVlU3RhcnQsIGJsdWUwLFxuICAgICAgICAgIChmbGlwfDIpICsgKGZ1bGwgPyAxNiA6IDApLFxuICAgICAgICAgIGxvLCBtaWQpXG4gICAgICB9XG5cbiAgICAgIC8vQ2VudGVyIGNhc2UgKHRoZSBoYXJkIHBhcnQpXG4gICAgICBpZihibHVlMCArIDEgPT09IGJsdWUxKSB7XG4gICAgICAgIC8vT3B0aW1pemF0aW9uOiBSYW5nZSB3aXRoIGV4YWN0bHkgMSBwb2ludCwgdXNlIGEgYnJ1dGUgZm9yY2Ugc2NhblxuICAgICAgICBpZihmdWxsKSB7XG4gICAgICAgICAgcmV0dmFsID0gb25lUG9pbnRGdWxsKFxuICAgICAgICAgICAgZCwgYXhpcywgdmlzaXQsXG4gICAgICAgICAgICByZWQwLCByZWRFbmQsIHJlZCwgcmVkSW5kZXgsXG4gICAgICAgICAgICBibHVlMCwgYmx1ZSwgYmx1ZUluZGV4W2JsdWUwXSlcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByZXR2YWwgPSBvbmVQb2ludFBhcnRpYWwoXG4gICAgICAgICAgICBkLCBheGlzLCB2aXNpdCwgZmxpcCxcbiAgICAgICAgICAgIHJlZDAsIHJlZEVuZCwgcmVkLCByZWRJbmRleCxcbiAgICAgICAgICAgIGJsdWUwLCBibHVlLCBibHVlSW5kZXhbYmx1ZTBdKVxuICAgICAgICB9XG4gICAgICAgIGlmKHJldHZhbCAhPT0gdm9pZCAwKSB7XG4gICAgICAgICAgcmV0dXJuIHJldHZhbFxuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYoYmx1ZTAgPCBibHVlMSkge1xuICAgICAgICB2YXIgcmVkMVxuICAgICAgICBpZihmdWxsKSB7XG4gICAgICAgICAgLy9JZiBmdWxsIGludGVyc2VjdGlvbiwgbmVlZCB0byBoYW5kbGUgc3BlY2lhbCBjYXNlXG4gICAgICAgICAgcmVkMSA9IHBhcnRpdGlvbkNvbnRhaW5zUG9pbnQoXG4gICAgICAgICAgICBkLCBheGlzLFxuICAgICAgICAgICAgcmVkMCwgcmVkRW5kLCByZWQsIHJlZEluZGV4LFxuICAgICAgICAgICAgbWlkKVxuICAgICAgICAgIGlmKHJlZDAgPCByZWQxKSB7XG4gICAgICAgICAgICB2YXIgcmVkWCA9IHBhcnRpdGlvblN0YXJ0RXF1YWwoXG4gICAgICAgICAgICAgIGQsIGF4aXMsXG4gICAgICAgICAgICAgIHJlZDAsIHJlZDEsIHJlZCwgcmVkSW5kZXgsXG4gICAgICAgICAgICAgIG1pZClcbiAgICAgICAgICAgIGlmKGF4aXMgPT09IGQtMikge1xuICAgICAgICAgICAgICAvL0RlZ2VuZXJhdGUgc3dlZXAgaW50ZXJzZWN0aW9uOlxuICAgICAgICAgICAgICAvLyAgW3JlZDAsIHJlZFhdIHdpdGggW2JsdWUwLCBibHVlMV1cbiAgICAgICAgICAgICAgaWYocmVkMCA8IHJlZFgpIHtcbiAgICAgICAgICAgICAgICByZXR2YWwgPSBzd2VlcC5zd2VlcENvbXBsZXRlKFxuICAgICAgICAgICAgICAgICAgZCwgdmlzaXQsXG4gICAgICAgICAgICAgICAgICByZWQwLCByZWRYLCByZWQsIHJlZEluZGV4LFxuICAgICAgICAgICAgICAgICAgYmx1ZTAsIGJsdWUxLCBibHVlLCBibHVlSW5kZXgpXG4gICAgICAgICAgICAgICAgaWYocmV0dmFsICE9PSB2b2lkIDApIHtcbiAgICAgICAgICAgICAgICAgIHJldHVybiByZXR2YWxcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAvL05vcm1hbCBzd2VlcCBpbnRlcnNlY3Rpb246XG4gICAgICAgICAgICAgIC8vICBbcmVkWCwgcmVkMV0gd2l0aCBbYmx1ZTAsIGJsdWUxXVxuICAgICAgICAgICAgICBpZihyZWRYIDwgcmVkMSkge1xuICAgICAgICAgICAgICAgIHJldHZhbCA9IHN3ZWVwLnN3ZWVwQmlwYXJ0aXRlKFxuICAgICAgICAgICAgICAgICAgZCwgdmlzaXQsXG4gICAgICAgICAgICAgICAgICByZWRYLCByZWQxLCByZWQsIHJlZEluZGV4LFxuICAgICAgICAgICAgICAgICAgYmx1ZTAsIGJsdWUxLCBibHVlLCBibHVlSW5kZXgpXG4gICAgICAgICAgICAgICAgaWYocmV0dmFsICE9PSB2b2lkIDApIHtcbiAgICAgICAgICAgICAgICAgIHJldHVybiByZXR2YWxcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIGlmKHJlZDAgPCByZWRYKSB7XG4gICAgICAgICAgICAgICAgaXRlclB1c2godG9wKyssXG4gICAgICAgICAgICAgICAgICBheGlzKzEsXG4gICAgICAgICAgICAgICAgICByZWQwLCByZWRYLFxuICAgICAgICAgICAgICAgICAgYmx1ZTAsIGJsdWUxLFxuICAgICAgICAgICAgICAgICAgMTYsXG4gICAgICAgICAgICAgICAgICAtSW5maW5pdHksIEluZmluaXR5KVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGlmKHJlZFggPCByZWQxKSB7XG4gICAgICAgICAgICAgICAgaXRlclB1c2godG9wKyssXG4gICAgICAgICAgICAgICAgICBheGlzKzEsXG4gICAgICAgICAgICAgICAgICByZWRYLCByZWQxLFxuICAgICAgICAgICAgICAgICAgYmx1ZTAsIGJsdWUxLFxuICAgICAgICAgICAgICAgICAgMCxcbiAgICAgICAgICAgICAgICAgIC1JbmZpbml0eSwgSW5maW5pdHkpXG4gICAgICAgICAgICAgICAgaXRlclB1c2godG9wKyssXG4gICAgICAgICAgICAgICAgICBheGlzKzEsXG4gICAgICAgICAgICAgICAgICBibHVlMCwgYmx1ZTEsXG4gICAgICAgICAgICAgICAgICByZWRYLCByZWQxLFxuICAgICAgICAgICAgICAgICAgMSxcbiAgICAgICAgICAgICAgICAgIC1JbmZpbml0eSwgSW5maW5pdHkpXG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgaWYoZmxpcCkge1xuICAgICAgICAgICAgcmVkMSA9IHBhcnRpdGlvbkNvbnRhaW5zUG9pbnRQcm9wZXIoXG4gICAgICAgICAgICAgIGQsIGF4aXMsXG4gICAgICAgICAgICAgIHJlZDAsIHJlZEVuZCwgcmVkLCByZWRJbmRleCxcbiAgICAgICAgICAgICAgbWlkKVxuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZWQxID0gcGFydGl0aW9uQ29udGFpbnNQb2ludChcbiAgICAgICAgICAgICAgZCwgYXhpcyxcbiAgICAgICAgICAgICAgcmVkMCwgcmVkRW5kLCByZWQsIHJlZEluZGV4LFxuICAgICAgICAgICAgICBtaWQpXG4gICAgICAgICAgfVxuICAgICAgICAgIGlmKHJlZDAgPCByZWQxKSB7XG4gICAgICAgICAgICBpZihheGlzID09PSBkLTIpIHtcbiAgICAgICAgICAgICAgaWYoZmxpcCkge1xuICAgICAgICAgICAgICAgIHJldHZhbCA9IHN3ZWVwLnN3ZWVwQmlwYXJ0aXRlKFxuICAgICAgICAgICAgICAgICAgZCwgdmlzaXQsXG4gICAgICAgICAgICAgICAgICBibHVlMCwgYmx1ZTEsIGJsdWUsIGJsdWVJbmRleCxcbiAgICAgICAgICAgICAgICAgIHJlZDAsIHJlZDEsIHJlZCwgcmVkSW5kZXgpXG4gICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgcmV0dmFsID0gc3dlZXAuc3dlZXBCaXBhcnRpdGUoXG4gICAgICAgICAgICAgICAgICBkLCB2aXNpdCxcbiAgICAgICAgICAgICAgICAgIHJlZDAsIHJlZDEsIHJlZCwgcmVkSW5kZXgsXG4gICAgICAgICAgICAgICAgICBibHVlMCwgYmx1ZTEsIGJsdWUsIGJsdWVJbmRleClcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgaXRlclB1c2godG9wKyssXG4gICAgICAgICAgICAgICAgYXhpcysxLFxuICAgICAgICAgICAgICAgIHJlZDAsIHJlZDEsXG4gICAgICAgICAgICAgICAgYmx1ZTAsIGJsdWUxLFxuICAgICAgICAgICAgICAgIGZsaXAsXG4gICAgICAgICAgICAgICAgLUluZmluaXR5LCBJbmZpbml0eSlcbiAgICAgICAgICAgICAgaXRlclB1c2godG9wKyssXG4gICAgICAgICAgICAgICAgYXhpcysxLFxuICAgICAgICAgICAgICAgIGJsdWUwLCBibHVlMSxcbiAgICAgICAgICAgICAgICByZWQwLCByZWQxLFxuICAgICAgICAgICAgICAgIGZsaXBeMSxcbiAgICAgICAgICAgICAgICAtSW5maW5pdHksIEluZmluaXR5KVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxufSIsIid1c2Ugc3RyaWN0J1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZpbmRNZWRpYW5cblxudmFyIGdlblBhcnRpdGlvbiA9IHJlcXVpcmUoJy4vcGFydGl0aW9uJylcblxudmFyIHBhcnRpdGlvblN0YXJ0TGVzc1RoYW4gPSBnZW5QYXJ0aXRpb24oJ2xvPHAwJywgWydwMCddKVxuXG52YXIgUEFSVElUSU9OX1RIUkVTSE9MRCA9IDggICAvL0N1dCBvZmYgZm9yIHVzaW5nIGluc2VydGlvbiBzb3J0IGluIGZpbmRNZWRpYW5cblxuLy9CYXNlIGNhc2UgZm9yIG1lZGlhbiBmaW5kaW5nOiAgVXNlIGluc2VydGlvbiBzb3J0XG5mdW5jdGlvbiBpbnNlcnRpb25Tb3J0KGQsIGF4aXMsIHN0YXJ0LCBlbmQsIGJveGVzLCBpZHMpIHtcbiAgdmFyIGVsZW1TaXplID0gMiAqIGRcbiAgdmFyIGJveFB0ciA9IGVsZW1TaXplICogKHN0YXJ0KzEpICsgYXhpc1xuICBmb3IodmFyIGk9c3RhcnQrMTsgaTxlbmQ7ICsraSwgYm94UHRyKz1lbGVtU2l6ZSkge1xuICAgIHZhciB4ID0gYm94ZXNbYm94UHRyXVxuICAgIGZvcih2YXIgaj1pLCBwdHI9ZWxlbVNpemUqKGktMSk7IFxuICAgICAgICBqPnN0YXJ0ICYmIGJveGVzW3B0citheGlzXSA+IHg7IFxuICAgICAgICAtLWosIHB0ci09ZWxlbVNpemUpIHtcbiAgICAgIC8vU3dhcFxuICAgICAgdmFyIGFQdHIgPSBwdHJcbiAgICAgIHZhciBiUHRyID0gcHRyK2VsZW1TaXplXG4gICAgICBmb3IodmFyIGs9MDsgazxlbGVtU2l6ZTsgKytrLCArK2FQdHIsICsrYlB0cikge1xuICAgICAgICB2YXIgeSA9IGJveGVzW2FQdHJdXG4gICAgICAgIGJveGVzW2FQdHJdID0gYm94ZXNbYlB0cl1cbiAgICAgICAgYm94ZXNbYlB0cl0gPSB5XG4gICAgICB9XG4gICAgICB2YXIgdG1wID0gaWRzW2pdXG4gICAgICBpZHNbal0gPSBpZHNbai0xXVxuICAgICAgaWRzW2otMV0gPSB0bXBcbiAgICB9XG4gIH1cbn1cblxuLy9GaW5kIG1lZGlhbiB1c2luZyBxdWljayBzZWxlY3QgYWxnb3JpdGhtXG4vLyAgdGFrZXMgTyhuKSB0aW1lIHdpdGggaGlnaCBwcm9iYWJpbGl0eVxuZnVuY3Rpb24gZmluZE1lZGlhbihkLCBheGlzLCBzdGFydCwgZW5kLCBib3hlcywgaWRzKSB7XG4gIGlmKGVuZCA8PSBzdGFydCsxKSB7XG4gICAgcmV0dXJuIHN0YXJ0XG4gIH1cblxuICB2YXIgbG8gICAgICAgPSBzdGFydFxuICB2YXIgaGkgICAgICAgPSBlbmRcbiAgdmFyIG1pZCAgICAgID0gKChlbmQgKyBzdGFydCkgPj4+IDEpXG4gIHZhciBlbGVtU2l6ZSA9IDIqZFxuICB2YXIgcGl2b3QgICAgPSBtaWRcbiAgdmFyIHZhbHVlICAgID0gYm94ZXNbZWxlbVNpemUqbWlkK2F4aXNdXG4gIFxuICB3aGlsZShsbyA8IGhpKSB7XG4gICAgaWYoaGkgLSBsbyA8IFBBUlRJVElPTl9USFJFU0hPTEQpIHtcbiAgICAgIGluc2VydGlvblNvcnQoZCwgYXhpcywgbG8sIGhpLCBib3hlcywgaWRzKVxuICAgICAgdmFsdWUgPSBib3hlc1tlbGVtU2l6ZSptaWQrYXhpc11cbiAgICAgIGJyZWFrXG4gICAgfVxuICAgIFxuICAgIC8vU2VsZWN0IHBpdm90IHVzaW5nIG1lZGlhbi1vZi0zXG4gICAgdmFyIGNvdW50ICA9IGhpIC0gbG9cbiAgICB2YXIgcGl2b3QwID0gKE1hdGgucmFuZG9tKCkqY291bnQrbG8pfDBcbiAgICB2YXIgdmFsdWUwID0gYm94ZXNbZWxlbVNpemUqcGl2b3QwICsgYXhpc11cbiAgICB2YXIgcGl2b3QxID0gKE1hdGgucmFuZG9tKCkqY291bnQrbG8pfDBcbiAgICB2YXIgdmFsdWUxID0gYm94ZXNbZWxlbVNpemUqcGl2b3QxICsgYXhpc11cbiAgICB2YXIgcGl2b3QyID0gKE1hdGgucmFuZG9tKCkqY291bnQrbG8pfDBcbiAgICB2YXIgdmFsdWUyID0gYm94ZXNbZWxlbVNpemUqcGl2b3QyICsgYXhpc11cbiAgICBpZih2YWx1ZTAgPD0gdmFsdWUxKSB7XG4gICAgICBpZih2YWx1ZTIgPj0gdmFsdWUxKSB7XG4gICAgICAgIHBpdm90ID0gcGl2b3QxXG4gICAgICAgIHZhbHVlID0gdmFsdWUxXG4gICAgICB9IGVsc2UgaWYodmFsdWUwID49IHZhbHVlMikge1xuICAgICAgICBwaXZvdCA9IHBpdm90MFxuICAgICAgICB2YWx1ZSA9IHZhbHVlMFxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcGl2b3QgPSBwaXZvdDJcbiAgICAgICAgdmFsdWUgPSB2YWx1ZTJcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgaWYodmFsdWUxID49IHZhbHVlMikge1xuICAgICAgICBwaXZvdCA9IHBpdm90MVxuICAgICAgICB2YWx1ZSA9IHZhbHVlMVxuICAgICAgfSBlbHNlIGlmKHZhbHVlMiA+PSB2YWx1ZTApIHtcbiAgICAgICAgcGl2b3QgPSBwaXZvdDBcbiAgICAgICAgdmFsdWUgPSB2YWx1ZTBcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHBpdm90ID0gcGl2b3QyXG4gICAgICAgIHZhbHVlID0gdmFsdWUyXG4gICAgICB9XG4gICAgfVxuXG4gICAgLy9Td2FwIHBpdm90IHRvIGVuZCBvZiBhcnJheVxuICAgIHZhciBhUHRyID0gZWxlbVNpemUgKiAoaGktMSlcbiAgICB2YXIgYlB0ciA9IGVsZW1TaXplICogcGl2b3RcbiAgICBmb3IodmFyIGk9MDsgaTxlbGVtU2l6ZTsgKytpLCArK2FQdHIsICsrYlB0cikge1xuICAgICAgdmFyIHggPSBib3hlc1thUHRyXVxuICAgICAgYm94ZXNbYVB0cl0gPSBib3hlc1tiUHRyXVxuICAgICAgYm94ZXNbYlB0cl0gPSB4XG4gICAgfVxuICAgIHZhciB5ID0gaWRzW2hpLTFdXG4gICAgaWRzW2hpLTFdID0gaWRzW3Bpdm90XVxuICAgIGlkc1twaXZvdF0gPSB5XG5cbiAgICAvL1BhcnRpdGlvbiB1c2luZyBwaXZvdFxuICAgIHBpdm90ID0gcGFydGl0aW9uU3RhcnRMZXNzVGhhbihcbiAgICAgIGQsIGF4aXMsIFxuICAgICAgbG8sIGhpLTEsIGJveGVzLCBpZHMsXG4gICAgICB2YWx1ZSlcblxuICAgIC8vU3dhcCBwaXZvdCBiYWNrXG4gICAgdmFyIGFQdHIgPSBlbGVtU2l6ZSAqIChoaS0xKVxuICAgIHZhciBiUHRyID0gZWxlbVNpemUgKiBwaXZvdFxuICAgIGZvcih2YXIgaT0wOyBpPGVsZW1TaXplOyArK2ksICsrYVB0ciwgKytiUHRyKSB7XG4gICAgICB2YXIgeCA9IGJveGVzW2FQdHJdXG4gICAgICBib3hlc1thUHRyXSA9IGJveGVzW2JQdHJdXG4gICAgICBib3hlc1tiUHRyXSA9IHhcbiAgICB9XG4gICAgdmFyIHkgPSBpZHNbaGktMV1cbiAgICBpZHNbaGktMV0gPSBpZHNbcGl2b3RdXG4gICAgaWRzW3Bpdm90XSA9IHlcblxuICAgIC8vU3dhcCBwaXZvdCB0byBsYXN0IHBpdm90XG4gICAgaWYobWlkIDwgcGl2b3QpIHtcbiAgICAgIGhpID0gcGl2b3QtMVxuICAgICAgd2hpbGUobG8gPCBoaSAmJiBcbiAgICAgICAgYm94ZXNbZWxlbVNpemUqKGhpLTEpK2F4aXNdID09PSB2YWx1ZSkge1xuICAgICAgICBoaSAtPSAxXG4gICAgICB9XG4gICAgICBoaSArPSAxXG4gICAgfSBlbHNlIGlmKHBpdm90IDwgbWlkKSB7XG4gICAgICBsbyA9IHBpdm90ICsgMVxuICAgICAgd2hpbGUobG8gPCBoaSAmJlxuICAgICAgICBib3hlc1tlbGVtU2l6ZSpsbytheGlzXSA9PT0gdmFsdWUpIHtcbiAgICAgICAgbG8gKz0gMVxuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBicmVha1xuICAgIH1cbiAgfVxuXG4gIC8vTWFrZSBzdXJlIHBpdm90IGlzIGF0IHN0YXJ0XG4gIHJldHVybiBwYXJ0aXRpb25TdGFydExlc3NUaGFuKFxuICAgIGQsIGF4aXMsIFxuICAgIHN0YXJ0LCBtaWQsIGJveGVzLCBpZHMsXG4gICAgYm94ZXNbZWxlbVNpemUqbWlkK2F4aXNdKVxufSIsIid1c2Ugc3RyaWN0J1xuXG5tb2R1bGUuZXhwb3J0cyA9IGdlblBhcnRpdGlvblxuXG52YXIgY29kZSA9ICdmb3IodmFyIGo9MiphLGs9aipjLGw9ayxtPWMsbj1iLG89YStiLHA9YztkPnA7KytwLGsrPWope3ZhciBfO2lmKCQpaWYobT09PXApbSs9MSxsKz1qO2Vsc2V7Zm9yKHZhciBzPTA7aj5zOysrcyl7dmFyIHQ9ZVtrK3NdO2VbaytzXT1lW2xdLGVbbCsrXT10fXZhciB1PWZbcF07ZltwXT1mW21dLGZbbSsrXT11fX1yZXR1cm4gbSdcblxuZnVuY3Rpb24gZ2VuUGFydGl0aW9uKHByZWRpY2F0ZSwgYXJncykge1xuICB2YXIgZmFyZ3MgPSdhYmNkZWYnLnNwbGl0KCcnKS5jb25jYXQoYXJncylcbiAgdmFyIHJlYWRzID0gW11cbiAgaWYocHJlZGljYXRlLmluZGV4T2YoJ2xvJykgPj0gMCkge1xuICAgIHJlYWRzLnB1c2goJ2xvPWVbaytuXScpXG4gIH1cbiAgaWYocHJlZGljYXRlLmluZGV4T2YoJ2hpJykgPj0gMCkge1xuICAgIHJlYWRzLnB1c2goJ2hpPWVbaytvXScpXG4gIH1cbiAgZmFyZ3MucHVzaChcbiAgICBjb2RlLnJlcGxhY2UoJ18nLCByZWFkcy5qb2luKCkpXG4gICAgICAgIC5yZXBsYWNlKCckJywgcHJlZGljYXRlKSlcbiAgcmV0dXJuIEZ1bmN0aW9uLmFwcGx5KHZvaWQgMCwgZmFyZ3MpXG59IiwiJ3VzZSBzdHJpY3QnO1xuXG4vL1RoaXMgY29kZSBpcyBleHRyYWN0ZWQgZnJvbSBuZGFycmF5LXNvcnRcbi8vSXQgaXMgaW5saW5lZCBoZXJlIGFzIGEgdGVtcG9yYXJ5IHdvcmthcm91bmRcblxubW9kdWxlLmV4cG9ydHMgPSB3cmFwcGVyO1xuXG52YXIgSU5TRVJUX1NPUlRfQ1VUT0ZGID0gMzJcblxuZnVuY3Rpb24gd3JhcHBlcihkYXRhLCBuMCkge1xuICBpZiAobjAgPD0gNCpJTlNFUlRfU09SVF9DVVRPRkYpIHtcbiAgICBpbnNlcnRpb25Tb3J0KDAsIG4wIC0gMSwgZGF0YSk7XG4gIH0gZWxzZSB7XG4gICAgcXVpY2tTb3J0KDAsIG4wIC0gMSwgZGF0YSk7XG4gIH1cbn1cblxuZnVuY3Rpb24gaW5zZXJ0aW9uU29ydChsZWZ0LCByaWdodCwgZGF0YSkge1xuICB2YXIgcHRyID0gMioobGVmdCsxKVxuICBmb3IodmFyIGk9bGVmdCsxOyBpPD1yaWdodDsgKytpKSB7XG4gICAgdmFyIGEgPSBkYXRhW3B0cisrXVxuICAgIHZhciBiID0gZGF0YVtwdHIrK11cbiAgICB2YXIgaiA9IGlcbiAgICB2YXIganB0ciA9IHB0ci0yXG4gICAgd2hpbGUoai0tID4gbGVmdCkge1xuICAgICAgdmFyIHggPSBkYXRhW2pwdHItMl1cbiAgICAgIHZhciB5ID0gZGF0YVtqcHRyLTFdXG4gICAgICBpZih4IDwgYSkge1xuICAgICAgICBicmVha1xuICAgICAgfSBlbHNlIGlmKHggPT09IGEgJiYgeSA8IGIpIHtcbiAgICAgICAgYnJlYWtcbiAgICAgIH1cbiAgICAgIGRhdGFbanB0cl0gICA9IHhcbiAgICAgIGRhdGFbanB0cisxXSA9IHlcbiAgICAgIGpwdHIgLT0gMlxuICAgIH1cbiAgICBkYXRhW2pwdHJdICAgPSBhXG4gICAgZGF0YVtqcHRyKzFdID0gYlxuICB9XG59XG5cbmZ1bmN0aW9uIHN3YXAoaSwgaiwgZGF0YSkge1xuICBpICo9IDJcbiAgaiAqPSAyXG4gIHZhciB4ID0gZGF0YVtpXVxuICB2YXIgeSA9IGRhdGFbaSsxXVxuICBkYXRhW2ldID0gZGF0YVtqXVxuICBkYXRhW2krMV0gPSBkYXRhW2orMV1cbiAgZGF0YVtqXSA9IHhcbiAgZGF0YVtqKzFdID0geVxufVxuXG5mdW5jdGlvbiBtb3ZlKGksIGosIGRhdGEpIHtcbiAgaSAqPSAyXG4gIGogKj0gMlxuICBkYXRhW2ldID0gZGF0YVtqXVxuICBkYXRhW2krMV0gPSBkYXRhW2orMV1cbn1cblxuZnVuY3Rpb24gcm90YXRlKGksIGosIGssIGRhdGEpIHtcbiAgaSAqPSAyXG4gIGogKj0gMlxuICBrICo9IDJcbiAgdmFyIHggPSBkYXRhW2ldXG4gIHZhciB5ID0gZGF0YVtpKzFdXG4gIGRhdGFbaV0gPSBkYXRhW2pdXG4gIGRhdGFbaSsxXSA9IGRhdGFbaisxXVxuICBkYXRhW2pdID0gZGF0YVtrXVxuICBkYXRhW2orMV0gPSBkYXRhW2srMV1cbiAgZGF0YVtrXSA9IHhcbiAgZGF0YVtrKzFdID0geVxufVxuXG5mdW5jdGlvbiBzaHVmZmxlUGl2b3QoaSwgaiwgcHgsIHB5LCBkYXRhKSB7XG4gIGkgKj0gMlxuICBqICo9IDJcbiAgZGF0YVtpXSA9IGRhdGFbal1cbiAgZGF0YVtqXSA9IHB4XG4gIGRhdGFbaSsxXSA9IGRhdGFbaisxXVxuICBkYXRhW2orMV0gPSBweVxufVxuXG5mdW5jdGlvbiBjb21wYXJlKGksIGosIGRhdGEpIHtcbiAgaSAqPSAyXG4gIGogKj0gMlxuICB2YXIgeCA9IGRhdGFbaV0sXG4gICAgICB5ID0gZGF0YVtqXVxuICBpZih4IDwgeSkge1xuICAgIHJldHVybiBmYWxzZVxuICB9IGVsc2UgaWYoeCA9PT0geSkge1xuICAgIHJldHVybiBkYXRhW2krMV0gPiBkYXRhW2orMV1cbiAgfVxuICByZXR1cm4gdHJ1ZVxufVxuXG5mdW5jdGlvbiBjb21wYXJlUGl2b3QoaSwgeSwgYiwgZGF0YSkge1xuICBpICo9IDJcbiAgdmFyIHggPSBkYXRhW2ldXG4gIGlmKHggPCB5KSB7XG4gICAgcmV0dXJuIHRydWVcbiAgfSBlbHNlIGlmKHggPT09IHkpIHtcbiAgICByZXR1cm4gZGF0YVtpKzFdIDwgYlxuICB9XG4gIHJldHVybiBmYWxzZVxufVxuXG5mdW5jdGlvbiBxdWlja1NvcnQobGVmdCwgcmlnaHQsIGRhdGEpIHtcbiAgdmFyIHNpeHRoID0gKHJpZ2h0IC0gbGVmdCArIDEpIC8gNiB8IDAsIFxuICAgICAgaW5kZXgxID0gbGVmdCArIHNpeHRoLCBcbiAgICAgIGluZGV4NSA9IHJpZ2h0IC0gc2l4dGgsIFxuICAgICAgaW5kZXgzID0gbGVmdCArIHJpZ2h0ID4+IDEsIFxuICAgICAgaW5kZXgyID0gaW5kZXgzIC0gc2l4dGgsIFxuICAgICAgaW5kZXg0ID0gaW5kZXgzICsgc2l4dGgsIFxuICAgICAgZWwxID0gaW5kZXgxLCBcbiAgICAgIGVsMiA9IGluZGV4MiwgXG4gICAgICBlbDMgPSBpbmRleDMsIFxuICAgICAgZWw0ID0gaW5kZXg0LCBcbiAgICAgIGVsNSA9IGluZGV4NSwgXG4gICAgICBsZXNzID0gbGVmdCArIDEsIFxuICAgICAgZ3JlYXQgPSByaWdodCAtIDEsIFxuICAgICAgdG1wID0gMFxuICBpZihjb21wYXJlKGVsMSwgZWwyLCBkYXRhKSkge1xuICAgIHRtcCA9IGVsMVxuICAgIGVsMSA9IGVsMlxuICAgIGVsMiA9IHRtcFxuICB9XG4gIGlmKGNvbXBhcmUoZWw0LCBlbDUsIGRhdGEpKSB7XG4gICAgdG1wID0gZWw0XG4gICAgZWw0ID0gZWw1XG4gICAgZWw1ID0gdG1wXG4gIH1cbiAgaWYoY29tcGFyZShlbDEsIGVsMywgZGF0YSkpIHtcbiAgICB0bXAgPSBlbDFcbiAgICBlbDEgPSBlbDNcbiAgICBlbDMgPSB0bXBcbiAgfVxuICBpZihjb21wYXJlKGVsMiwgZWwzLCBkYXRhKSkge1xuICAgIHRtcCA9IGVsMlxuICAgIGVsMiA9IGVsM1xuICAgIGVsMyA9IHRtcFxuICB9XG4gIGlmKGNvbXBhcmUoZWwxLCBlbDQsIGRhdGEpKSB7XG4gICAgdG1wID0gZWwxXG4gICAgZWwxID0gZWw0XG4gICAgZWw0ID0gdG1wXG4gIH1cbiAgaWYoY29tcGFyZShlbDMsIGVsNCwgZGF0YSkpIHtcbiAgICB0bXAgPSBlbDNcbiAgICBlbDMgPSBlbDRcbiAgICBlbDQgPSB0bXBcbiAgfVxuICBpZihjb21wYXJlKGVsMiwgZWw1LCBkYXRhKSkge1xuICAgIHRtcCA9IGVsMlxuICAgIGVsMiA9IGVsNVxuICAgIGVsNSA9IHRtcFxuICB9XG4gIGlmKGNvbXBhcmUoZWwyLCBlbDMsIGRhdGEpKSB7XG4gICAgdG1wID0gZWwyXG4gICAgZWwyID0gZWwzXG4gICAgZWwzID0gdG1wXG4gIH1cbiAgaWYoY29tcGFyZShlbDQsIGVsNSwgZGF0YSkpIHtcbiAgICB0bXAgPSBlbDRcbiAgICBlbDQgPSBlbDVcbiAgICBlbDUgPSB0bXBcbiAgfVxuXG4gIHZhciBwaXZvdDFYID0gZGF0YVsyKmVsMl1cbiAgdmFyIHBpdm90MVkgPSBkYXRhWzIqZWwyKzFdXG4gIHZhciBwaXZvdDJYID0gZGF0YVsyKmVsNF1cbiAgdmFyIHBpdm90MlkgPSBkYXRhWzIqZWw0KzFdXG5cbiAgdmFyIHB0cjAgPSAyICogZWwxO1xuICB2YXIgcHRyMiA9IDIgKiBlbDM7XG4gIHZhciBwdHI0ID0gMiAqIGVsNTtcbiAgdmFyIHB0cjUgPSAyICogaW5kZXgxO1xuICB2YXIgcHRyNiA9IDIgKiBpbmRleDM7XG4gIHZhciBwdHI3ID0gMiAqIGluZGV4NTtcbiAgZm9yICh2YXIgaTEgPSAwOyBpMSA8IDI7ICsraTEpIHtcbiAgICB2YXIgeCA9IGRhdGFbcHRyMCtpMV07XG4gICAgdmFyIHkgPSBkYXRhW3B0cjIraTFdO1xuICAgIHZhciB6ID0gZGF0YVtwdHI0K2kxXTtcbiAgICBkYXRhW3B0cjUraTFdID0geDtcbiAgICBkYXRhW3B0cjYraTFdID0geTtcbiAgICBkYXRhW3B0cjcraTFdID0gejtcbiAgfVxuXG4gIG1vdmUoaW5kZXgyLCBsZWZ0LCBkYXRhKVxuICBtb3ZlKGluZGV4NCwgcmlnaHQsIGRhdGEpXG4gIGZvciAodmFyIGsgPSBsZXNzOyBrIDw9IGdyZWF0OyArK2spIHtcbiAgICBpZiAoY29tcGFyZVBpdm90KGssIHBpdm90MVgsIHBpdm90MVksIGRhdGEpKSB7XG4gICAgICBpZiAoayAhPT0gbGVzcykge1xuICAgICAgICBzd2FwKGssIGxlc3MsIGRhdGEpXG4gICAgICB9XG4gICAgICArK2xlc3M7XG4gICAgfSBlbHNlIHtcbiAgICAgIGlmICghY29tcGFyZVBpdm90KGssIHBpdm90MlgsIHBpdm90MlksIGRhdGEpKSB7XG4gICAgICAgIHdoaWxlICh0cnVlKSB7XG4gICAgICAgICAgaWYgKCFjb21wYXJlUGl2b3QoZ3JlYXQsIHBpdm90MlgsIHBpdm90MlksIGRhdGEpKSB7XG4gICAgICAgICAgICBpZiAoLS1ncmVhdCA8IGspIHtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgaWYgKGNvbXBhcmVQaXZvdChncmVhdCwgcGl2b3QxWCwgcGl2b3QxWSwgZGF0YSkpIHtcbiAgICAgICAgICAgICAgcm90YXRlKGssIGxlc3MsIGdyZWF0LCBkYXRhKVxuICAgICAgICAgICAgICArK2xlc3M7XG4gICAgICAgICAgICAgIC0tZ3JlYXQ7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBzd2FwKGssIGdyZWF0LCBkYXRhKVxuICAgICAgICAgICAgICAtLWdyZWF0O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG4gIHNodWZmbGVQaXZvdChsZWZ0LCBsZXNzLTEsIHBpdm90MVgsIHBpdm90MVksIGRhdGEpXG4gIHNodWZmbGVQaXZvdChyaWdodCwgZ3JlYXQrMSwgcGl2b3QyWCwgcGl2b3QyWSwgZGF0YSlcbiAgaWYgKGxlc3MgLSAyIC0gbGVmdCA8PSBJTlNFUlRfU09SVF9DVVRPRkYpIHtcbiAgICBpbnNlcnRpb25Tb3J0KGxlZnQsIGxlc3MgLSAyLCBkYXRhKTtcbiAgfSBlbHNlIHtcbiAgICBxdWlja1NvcnQobGVmdCwgbGVzcyAtIDIsIGRhdGEpO1xuICB9XG4gIGlmIChyaWdodCAtIChncmVhdCArIDIpIDw9IElOU0VSVF9TT1JUX0NVVE9GRikge1xuICAgIGluc2VydGlvblNvcnQoZ3JlYXQgKyAyLCByaWdodCwgZGF0YSk7XG4gIH0gZWxzZSB7XG4gICAgcXVpY2tTb3J0KGdyZWF0ICsgMiwgcmlnaHQsIGRhdGEpO1xuICB9XG4gIGlmIChncmVhdCAtIGxlc3MgPD0gSU5TRVJUX1NPUlRfQ1VUT0ZGKSB7XG4gICAgaW5zZXJ0aW9uU29ydChsZXNzLCBncmVhdCwgZGF0YSk7XG4gIH0gZWxzZSB7XG4gICAgcXVpY2tTb3J0KGxlc3MsIGdyZWF0LCBkYXRhKTtcbiAgfVxufSIsIid1c2Ugc3RyaWN0J1xuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgaW5pdDogICAgICAgICAgIHNxSW5pdCxcbiAgc3dlZXBCaXBhcnRpdGU6IHN3ZWVwQmlwYXJ0aXRlLFxuICBzd2VlcENvbXBsZXRlOiAgc3dlZXBDb21wbGV0ZSxcbiAgc2NhbkJpcGFydGl0ZTogIHNjYW5CaXBhcnRpdGUsXG4gIHNjYW5Db21wbGV0ZTogICBzY2FuQ29tcGxldGVcbn1cblxudmFyIHBvb2wgID0gcmVxdWlyZSgndHlwZWRhcnJheS1wb29sJylcbnZhciBiaXRzICA9IHJlcXVpcmUoJ2JpdC10d2lkZGxlJylcbnZhciBpc29ydCA9IHJlcXVpcmUoJy4vc29ydCcpXG5cbi8vRmxhZyBmb3IgYmx1ZVxudmFyIEJMVUVfRkxBRyA9ICgxPDwyOClcblxuLy8xRCBzd2VlcCBldmVudCBxdWV1ZSBzdHVmZiAodXNlIHBvb2wgdG8gc2F2ZSBzcGFjZSlcbnZhciBJTklUX0NBUEFDSVRZICAgICAgPSAxMDI0XG52YXIgUkVEX1NXRUVQX1FVRVVFICAgID0gcG9vbC5tYWxsb2NJbnQzMihJTklUX0NBUEFDSVRZKVxudmFyIFJFRF9TV0VFUF9JTkRFWCAgICA9IHBvb2wubWFsbG9jSW50MzIoSU5JVF9DQVBBQ0lUWSlcbnZhciBCTFVFX1NXRUVQX1FVRVVFICAgPSBwb29sLm1hbGxvY0ludDMyKElOSVRfQ0FQQUNJVFkpXG52YXIgQkxVRV9TV0VFUF9JTkRFWCAgID0gcG9vbC5tYWxsb2NJbnQzMihJTklUX0NBUEFDSVRZKVxudmFyIENPTU1PTl9TV0VFUF9RVUVVRSA9IHBvb2wubWFsbG9jSW50MzIoSU5JVF9DQVBBQ0lUWSlcbnZhciBDT01NT05fU1dFRVBfSU5ERVggPSBwb29sLm1hbGxvY0ludDMyKElOSVRfQ0FQQUNJVFkpXG52YXIgU1dFRVBfRVZFTlRTICAgICAgID0gcG9vbC5tYWxsb2NEb3VibGUoSU5JVF9DQVBBQ0lUWSAqIDgpXG5cbi8vUmVzZXJ2ZXMgbWVtb3J5IGZvciB0aGUgMUQgc3dlZXAgZGF0YSBzdHJ1Y3R1cmVzXG5mdW5jdGlvbiBzcUluaXQoY291bnQpIHtcbiAgdmFyIHJjb3VudCA9IGJpdHMubmV4dFBvdzIoY291bnQpXG4gIGlmKFJFRF9TV0VFUF9RVUVVRS5sZW5ndGggPCByY291bnQpIHtcbiAgICBwb29sLmZyZWUoUkVEX1NXRUVQX1FVRVVFKVxuICAgIFJFRF9TV0VFUF9RVUVVRSA9IHBvb2wubWFsbG9jSW50MzIocmNvdW50KVxuICB9XG4gIGlmKFJFRF9TV0VFUF9JTkRFWC5sZW5ndGggPCByY291bnQpIHtcbiAgICBwb29sLmZyZWUoUkVEX1NXRUVQX0lOREVYKVxuICAgIFJFRF9TV0VFUF9JTkRFWCA9IHBvb2wubWFsbG9jSW50MzIocmNvdW50KVxuICB9XG4gIGlmKEJMVUVfU1dFRVBfUVVFVUUubGVuZ3RoIDwgcmNvdW50KSB7XG4gICAgcG9vbC5mcmVlKEJMVUVfU1dFRVBfUVVFVUUpXG4gICAgQkxVRV9TV0VFUF9RVUVVRSA9IHBvb2wubWFsbG9jSW50MzIocmNvdW50KVxuICB9XG4gIGlmKEJMVUVfU1dFRVBfSU5ERVgubGVuZ3RoIDwgcmNvdW50KSB7XG4gICAgcG9vbC5mcmVlKEJMVUVfU1dFRVBfSU5ERVgpXG4gICAgQkxVRV9TV0VFUF9JTkRFWCA9IHBvb2wubWFsbG9jSW50MzIocmNvdW50KVxuICB9XG4gIGlmKENPTU1PTl9TV0VFUF9RVUVVRS5sZW5ndGggPCByY291bnQpIHtcbiAgICBwb29sLmZyZWUoQ09NTU9OX1NXRUVQX1FVRVVFKVxuICAgIENPTU1PTl9TV0VFUF9RVUVVRSA9IHBvb2wubWFsbG9jSW50MzIocmNvdW50KVxuICB9XG4gIGlmKENPTU1PTl9TV0VFUF9JTkRFWC5sZW5ndGggPCByY291bnQpIHtcbiAgICBwb29sLmZyZWUoQ09NTU9OX1NXRUVQX0lOREVYKVxuICAgIENPTU1PTl9TV0VFUF9JTkRFWCA9IHBvb2wubWFsbG9jSW50MzIocmNvdW50KVxuICB9XG4gIHZhciBldmVudExlbmd0aCA9IDggKiByY291bnRcbiAgaWYoU1dFRVBfRVZFTlRTLmxlbmd0aCA8IGV2ZW50TGVuZ3RoKSB7XG4gICAgcG9vbC5mcmVlKFNXRUVQX0VWRU5UUylcbiAgICBTV0VFUF9FVkVOVFMgPSBwb29sLm1hbGxvY0RvdWJsZShldmVudExlbmd0aClcbiAgfVxufVxuXG4vL1JlbW92ZSBhbiBpdGVtIGZyb20gdGhlIGFjdGl2ZSBxdWV1ZSBpbiBPKDEpXG5mdW5jdGlvbiBzcVBvcChxdWV1ZSwgaW5kZXgsIGNvdW50LCBpdGVtKSB7XG4gIHZhciBpZHggPSBpbmRleFtpdGVtXVxuICB2YXIgdG9wID0gcXVldWVbY291bnQtMV1cbiAgcXVldWVbaWR4XSA9IHRvcFxuICBpbmRleFt0b3BdID0gaWR4XG59XG5cbi8vSW5zZXJ0IGFuIGl0ZW0gaW50byB0aGUgYWN0aXZlIHF1ZXVlIGluIE8oMSlcbmZ1bmN0aW9uIHNxUHVzaChxdWV1ZSwgaW5kZXgsIGNvdW50LCBpdGVtKSB7XG4gIHF1ZXVlW2NvdW50XSA9IGl0ZW1cbiAgaW5kZXhbaXRlbV0gID0gY291bnRcbn1cblxuLy9SZWN1cnNpb24gYmFzZSBjYXNlOiB1c2UgMUQgc3dlZXAgYWxnb3JpdGhtXG5mdW5jdGlvbiBzd2VlcEJpcGFydGl0ZShcbiAgICBkLCB2aXNpdCxcbiAgICByZWRTdGFydCwgIHJlZEVuZCwgcmVkLCByZWRJbmRleCxcbiAgICBibHVlU3RhcnQsIGJsdWVFbmQsIGJsdWUsIGJsdWVJbmRleCkge1xuXG4gIC8vc3RvcmUgZXZlbnRzIGFzIHBhaXJzIFtjb29yZGluYXRlLCBpZHhdXG4gIC8vXG4gIC8vICByZWQgY3JlYXRlOiAgLShpZHgrMSlcbiAgLy8gIHJlZCBkZXN0cm95OiBpZHhcbiAgLy8gIGJsdWUgY3JlYXRlOiAtKGlkeCtCTFVFX0ZMQUcpXG4gIC8vICBibHVlIGRlc3Ryb3k6IGlkeCtCTFVFX0ZMQUdcbiAgLy9cbiAgdmFyIHB0ciAgICAgID0gMFxuICB2YXIgZWxlbVNpemUgPSAyKmRcbiAgdmFyIGlzdGFydCAgID0gZC0xXG4gIHZhciBpZW5kICAgICA9IGVsZW1TaXplLTFcblxuICBmb3IodmFyIGk9cmVkU3RhcnQ7IGk8cmVkRW5kOyArK2kpIHtcbiAgICB2YXIgaWR4ID0gcmVkSW5kZXhbaV1cbiAgICB2YXIgcmVkT2Zmc2V0ID0gZWxlbVNpemUqaVxuICAgIFNXRUVQX0VWRU5UU1twdHIrK10gPSByZWRbcmVkT2Zmc2V0K2lzdGFydF1cbiAgICBTV0VFUF9FVkVOVFNbcHRyKytdID0gLShpZHgrMSlcbiAgICBTV0VFUF9FVkVOVFNbcHRyKytdID0gcmVkW3JlZE9mZnNldCtpZW5kXVxuICAgIFNXRUVQX0VWRU5UU1twdHIrK10gPSBpZHhcbiAgfVxuXG4gIGZvcih2YXIgaT1ibHVlU3RhcnQ7IGk8Ymx1ZUVuZDsgKytpKSB7XG4gICAgdmFyIGlkeCA9IGJsdWVJbmRleFtpXStCTFVFX0ZMQUdcbiAgICB2YXIgYmx1ZU9mZnNldCA9IGVsZW1TaXplKmlcbiAgICBTV0VFUF9FVkVOVFNbcHRyKytdID0gYmx1ZVtibHVlT2Zmc2V0K2lzdGFydF1cbiAgICBTV0VFUF9FVkVOVFNbcHRyKytdID0gLWlkeFxuICAgIFNXRUVQX0VWRU5UU1twdHIrK10gPSBibHVlW2JsdWVPZmZzZXQraWVuZF1cbiAgICBTV0VFUF9FVkVOVFNbcHRyKytdID0gaWR4XG4gIH1cblxuICAvL3Byb2Nlc3MgZXZlbnRzIGZyb20gbGVmdC0+cmlnaHRcbiAgdmFyIG4gPSBwdHIgPj4+IDFcbiAgaXNvcnQoU1dFRVBfRVZFTlRTLCBuKVxuICBcbiAgdmFyIHJlZEFjdGl2ZSAgPSAwXG4gIHZhciBibHVlQWN0aXZlID0gMFxuICBmb3IodmFyIGk9MDsgaTxuOyArK2kpIHtcbiAgICB2YXIgZSA9IFNXRUVQX0VWRU5UU1syKmkrMV18MFxuICAgIGlmKGUgPj0gQkxVRV9GTEFHKSB7XG4gICAgICAvL2JsdWUgZGVzdHJveSBldmVudFxuICAgICAgZSA9IChlLUJMVUVfRkxBRyl8MFxuICAgICAgc3FQb3AoQkxVRV9TV0VFUF9RVUVVRSwgQkxVRV9TV0VFUF9JTkRFWCwgYmx1ZUFjdGl2ZS0tLCBlKVxuICAgIH0gZWxzZSBpZihlID49IDApIHtcbiAgICAgIC8vcmVkIGRlc3Ryb3kgZXZlbnRcbiAgICAgIHNxUG9wKFJFRF9TV0VFUF9RVUVVRSwgUkVEX1NXRUVQX0lOREVYLCByZWRBY3RpdmUtLSwgZSlcbiAgICB9IGVsc2UgaWYoZSA8PSAtQkxVRV9GTEFHKSB7XG4gICAgICAvL2JsdWUgY3JlYXRlIGV2ZW50XG4gICAgICBlID0gKC1lLUJMVUVfRkxBRyl8MFxuICAgICAgZm9yKHZhciBqPTA7IGo8cmVkQWN0aXZlOyArK2opIHtcbiAgICAgICAgdmFyIHJldHZhbCA9IHZpc2l0KFJFRF9TV0VFUF9RVUVVRVtqXSwgZSlcbiAgICAgICAgaWYocmV0dmFsICE9PSB2b2lkIDApIHtcbiAgICAgICAgICByZXR1cm4gcmV0dmFsXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHNxUHVzaChCTFVFX1NXRUVQX1FVRVVFLCBCTFVFX1NXRUVQX0lOREVYLCBibHVlQWN0aXZlKyssIGUpXG4gICAgfSBlbHNlIHtcbiAgICAgIC8vcmVkIGNyZWF0ZSBldmVudFxuICAgICAgZSA9ICgtZS0xKXwwXG4gICAgICBmb3IodmFyIGo9MDsgajxibHVlQWN0aXZlOyArK2opIHtcbiAgICAgICAgdmFyIHJldHZhbCA9IHZpc2l0KGUsIEJMVUVfU1dFRVBfUVVFVUVbal0pXG4gICAgICAgIGlmKHJldHZhbCAhPT0gdm9pZCAwKSB7XG4gICAgICAgICAgcmV0dXJuIHJldHZhbFxuICAgICAgICB9XG4gICAgICB9XG4gICAgICBzcVB1c2goUkVEX1NXRUVQX1FVRVVFLCBSRURfU1dFRVBfSU5ERVgsIHJlZEFjdGl2ZSsrLCBlKVxuICAgIH1cbiAgfVxufVxuXG4vL0NvbXBsZXRlIHN3ZWVwXG5mdW5jdGlvbiBzd2VlcENvbXBsZXRlKGQsIHZpc2l0LCBcbiAgcmVkU3RhcnQsIHJlZEVuZCwgcmVkLCByZWRJbmRleCxcbiAgYmx1ZVN0YXJ0LCBibHVlRW5kLCBibHVlLCBibHVlSW5kZXgpIHtcblxuICB2YXIgcHRyICAgICAgPSAwXG4gIHZhciBlbGVtU2l6ZSA9IDIqZFxuICB2YXIgaXN0YXJ0ICAgPSBkLTFcbiAgdmFyIGllbmQgICAgID0gZWxlbVNpemUtMVxuXG4gIGZvcih2YXIgaT1yZWRTdGFydDsgaTxyZWRFbmQ7ICsraSkge1xuICAgIHZhciBpZHggPSAocmVkSW5kZXhbaV0rMSk8PDFcbiAgICB2YXIgcmVkT2Zmc2V0ID0gZWxlbVNpemUqaVxuICAgIFNXRUVQX0VWRU5UU1twdHIrK10gPSByZWRbcmVkT2Zmc2V0K2lzdGFydF1cbiAgICBTV0VFUF9FVkVOVFNbcHRyKytdID0gLWlkeFxuICAgIFNXRUVQX0VWRU5UU1twdHIrK10gPSByZWRbcmVkT2Zmc2V0K2llbmRdXG4gICAgU1dFRVBfRVZFTlRTW3B0cisrXSA9IGlkeFxuICB9XG5cbiAgZm9yKHZhciBpPWJsdWVTdGFydDsgaTxibHVlRW5kOyArK2kpIHtcbiAgICB2YXIgaWR4ID0gKGJsdWVJbmRleFtpXSsxKTw8MVxuICAgIHZhciBibHVlT2Zmc2V0ID0gZWxlbVNpemUqaVxuICAgIFNXRUVQX0VWRU5UU1twdHIrK10gPSBibHVlW2JsdWVPZmZzZXQraXN0YXJ0XVxuICAgIFNXRUVQX0VWRU5UU1twdHIrK10gPSAoLWlkeCl8MVxuICAgIFNXRUVQX0VWRU5UU1twdHIrK10gPSBibHVlW2JsdWVPZmZzZXQraWVuZF1cbiAgICBTV0VFUF9FVkVOVFNbcHRyKytdID0gaWR4fDFcbiAgfVxuXG4gIC8vcHJvY2VzcyBldmVudHMgZnJvbSBsZWZ0LT5yaWdodFxuICB2YXIgbiA9IHB0ciA+Pj4gMVxuICBpc29ydChTV0VFUF9FVkVOVFMsIG4pXG4gIFxuICB2YXIgcmVkQWN0aXZlICAgID0gMFxuICB2YXIgYmx1ZUFjdGl2ZSAgID0gMFxuICB2YXIgY29tbW9uQWN0aXZlID0gMFxuICBmb3IodmFyIGk9MDsgaTxuOyArK2kpIHtcbiAgICB2YXIgZSAgICAgPSBTV0VFUF9FVkVOVFNbMippKzFdfDBcbiAgICB2YXIgY29sb3IgPSBlJjFcbiAgICBpZihpIDwgbi0xICYmIChlPj4xKSA9PT0gKFNXRUVQX0VWRU5UU1syKmkrM10+PjEpKSB7XG4gICAgICBjb2xvciA9IDJcbiAgICAgIGkgKz0gMVxuICAgIH1cbiAgICBcbiAgICBpZihlIDwgMCkge1xuICAgICAgLy9DcmVhdGUgZXZlbnRcbiAgICAgIHZhciBpZCA9IC0oZT4+MSkgLSAxXG5cbiAgICAgIC8vSW50ZXJzZWN0IHdpdGggY29tbW9uXG4gICAgICBmb3IodmFyIGo9MDsgajxjb21tb25BY3RpdmU7ICsraikge1xuICAgICAgICB2YXIgcmV0dmFsID0gdmlzaXQoQ09NTU9OX1NXRUVQX1FVRVVFW2pdLCBpZClcbiAgICAgICAgaWYocmV0dmFsICE9PSB2b2lkIDApIHtcbiAgICAgICAgICByZXR1cm4gcmV0dmFsXG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgaWYoY29sb3IgIT09IDApIHtcbiAgICAgICAgLy9JbnRlcnNlY3Qgd2l0aCByZWRcbiAgICAgICAgZm9yKHZhciBqPTA7IGo8cmVkQWN0aXZlOyArK2opIHtcbiAgICAgICAgICB2YXIgcmV0dmFsID0gdmlzaXQoUkVEX1NXRUVQX1FVRVVFW2pdLCBpZClcbiAgICAgICAgICBpZihyZXR2YWwgIT09IHZvaWQgMCkge1xuICAgICAgICAgICAgcmV0dXJuIHJldHZhbFxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBpZihjb2xvciAhPT0gMSkge1xuICAgICAgICAvL0ludGVyc2VjdCB3aXRoIGJsdWVcbiAgICAgICAgZm9yKHZhciBqPTA7IGo8Ymx1ZUFjdGl2ZTsgKytqKSB7XG4gICAgICAgICAgdmFyIHJldHZhbCA9IHZpc2l0KEJMVUVfU1dFRVBfUVVFVUVbal0sIGlkKVxuICAgICAgICAgIGlmKHJldHZhbCAhPT0gdm9pZCAwKSB7XG4gICAgICAgICAgICByZXR1cm4gcmV0dmFsXG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGlmKGNvbG9yID09PSAwKSB7XG4gICAgICAgIC8vUmVkXG4gICAgICAgIHNxUHVzaChSRURfU1dFRVBfUVVFVUUsIFJFRF9TV0VFUF9JTkRFWCwgcmVkQWN0aXZlKyssIGlkKVxuICAgICAgfSBlbHNlIGlmKGNvbG9yID09PSAxKSB7XG4gICAgICAgIC8vQmx1ZVxuICAgICAgICBzcVB1c2goQkxVRV9TV0VFUF9RVUVVRSwgQkxVRV9TV0VFUF9JTkRFWCwgYmx1ZUFjdGl2ZSsrLCBpZClcbiAgICAgIH0gZWxzZSBpZihjb2xvciA9PT0gMikge1xuICAgICAgICAvL0JvdGhcbiAgICAgICAgc3FQdXNoKENPTU1PTl9TV0VFUF9RVUVVRSwgQ09NTU9OX1NXRUVQX0lOREVYLCBjb21tb25BY3RpdmUrKywgaWQpXG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vRGVzdHJveSBldmVudFxuICAgICAgdmFyIGlkID0gKGU+PjEpIC0gMVxuICAgICAgaWYoY29sb3IgPT09IDApIHtcbiAgICAgICAgLy9SZWRcbiAgICAgICAgc3FQb3AoUkVEX1NXRUVQX1FVRVVFLCBSRURfU1dFRVBfSU5ERVgsIHJlZEFjdGl2ZS0tLCBpZClcbiAgICAgIH0gZWxzZSBpZihjb2xvciA9PT0gMSkge1xuICAgICAgICAvL0JsdWVcbiAgICAgICAgc3FQb3AoQkxVRV9TV0VFUF9RVUVVRSwgQkxVRV9TV0VFUF9JTkRFWCwgYmx1ZUFjdGl2ZS0tLCBpZClcbiAgICAgIH0gZWxzZSBpZihjb2xvciA9PT0gMikge1xuICAgICAgICAvL0JvdGhcbiAgICAgICAgc3FQb3AoQ09NTU9OX1NXRUVQX1FVRVVFLCBDT01NT05fU1dFRVBfSU5ERVgsIGNvbW1vbkFjdGl2ZS0tLCBpZClcbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cblxuLy9Td2VlcCBhbmQgcHJ1bmUvc2NhbmxpbmUgYWxnb3JpdGhtOlxuLy8gIFNjYW4gYWxvbmcgYXhpcywgZGV0ZWN0IGludGVyc2VjdGlvbnNcbi8vICBCcnV0ZSBmb3JjZSBhbGwgYm94ZXMgYWxvbmcgYXhpc1xuZnVuY3Rpb24gc2NhbkJpcGFydGl0ZShcbiAgZCwgYXhpcywgdmlzaXQsIGZsaXAsXG4gIHJlZFN0YXJ0LCAgcmVkRW5kLCByZWQsIHJlZEluZGV4LFxuICBibHVlU3RhcnQsIGJsdWVFbmQsIGJsdWUsIGJsdWVJbmRleCkge1xuICBcbiAgdmFyIHB0ciAgICAgID0gMFxuICB2YXIgZWxlbVNpemUgPSAyKmRcbiAgdmFyIGlzdGFydCAgID0gYXhpc1xuICB2YXIgaWVuZCAgICAgPSBheGlzK2RcblxuICB2YXIgcmVkU2hpZnQgID0gMVxuICB2YXIgYmx1ZVNoaWZ0ID0gMVxuICBpZihmbGlwKSB7XG4gICAgYmx1ZVNoaWZ0ID0gQkxVRV9GTEFHXG4gIH0gZWxzZSB7XG4gICAgcmVkU2hpZnQgID0gQkxVRV9GTEFHXG4gIH1cblxuICBmb3IodmFyIGk9cmVkU3RhcnQ7IGk8cmVkRW5kOyArK2kpIHtcbiAgICB2YXIgaWR4ID0gaSArIHJlZFNoaWZ0XG4gICAgdmFyIHJlZE9mZnNldCA9IGVsZW1TaXplKmlcbiAgICBTV0VFUF9FVkVOVFNbcHRyKytdID0gcmVkW3JlZE9mZnNldCtpc3RhcnRdXG4gICAgU1dFRVBfRVZFTlRTW3B0cisrXSA9IC1pZHhcbiAgICBTV0VFUF9FVkVOVFNbcHRyKytdID0gcmVkW3JlZE9mZnNldCtpZW5kXVxuICAgIFNXRUVQX0VWRU5UU1twdHIrK10gPSBpZHhcbiAgfVxuICBmb3IodmFyIGk9Ymx1ZVN0YXJ0OyBpPGJsdWVFbmQ7ICsraSkge1xuICAgIHZhciBpZHggPSBpICsgYmx1ZVNoaWZ0XG4gICAgdmFyIGJsdWVPZmZzZXQgPSBlbGVtU2l6ZSppXG4gICAgU1dFRVBfRVZFTlRTW3B0cisrXSA9IGJsdWVbYmx1ZU9mZnNldCtpc3RhcnRdXG4gICAgU1dFRVBfRVZFTlRTW3B0cisrXSA9IC1pZHhcbiAgfVxuXG4gIC8vcHJvY2VzcyBldmVudHMgZnJvbSBsZWZ0LT5yaWdodFxuICB2YXIgbiA9IHB0ciA+Pj4gMVxuICBpc29ydChTV0VFUF9FVkVOVFMsIG4pXG4gIFxuICB2YXIgcmVkQWN0aXZlICAgID0gMFxuICBmb3IodmFyIGk9MDsgaTxuOyArK2kpIHtcbiAgICB2YXIgZSA9IFNXRUVQX0VWRU5UU1syKmkrMV18MFxuICAgIGlmKGUgPCAwKSB7XG4gICAgICB2YXIgaWR4ICAgPSAtZVxuICAgICAgdmFyIGlzUmVkID0gZmFsc2VcbiAgICAgIGlmKGlkeCA+PSBCTFVFX0ZMQUcpIHtcbiAgICAgICAgaXNSZWQgPSAhZmxpcFxuICAgICAgICBpZHggLT0gQkxVRV9GTEFHIFxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaXNSZWQgPSAhIWZsaXBcbiAgICAgICAgaWR4IC09IDFcbiAgICAgIH1cbiAgICAgIGlmKGlzUmVkKSB7XG4gICAgICAgIHNxUHVzaChSRURfU1dFRVBfUVVFVUUsIFJFRF9TV0VFUF9JTkRFWCwgcmVkQWN0aXZlKyssIGlkeClcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHZhciBibHVlSWQgID0gYmx1ZUluZGV4W2lkeF1cbiAgICAgICAgdmFyIGJsdWVQdHIgPSBlbGVtU2l6ZSAqIGlkeFxuICAgICAgICBcbiAgICAgICAgdmFyIGIwID0gYmx1ZVtibHVlUHRyK2F4aXMrMV1cbiAgICAgICAgdmFyIGIxID0gYmx1ZVtibHVlUHRyK2F4aXMrMStkXVxuXG5yZWRfbG9vcDpcbiAgICAgICAgZm9yKHZhciBqPTA7IGo8cmVkQWN0aXZlOyArK2opIHtcbiAgICAgICAgICB2YXIgb2lkeCAgID0gUkVEX1NXRUVQX1FVRVVFW2pdXG4gICAgICAgICAgdmFyIHJlZFB0ciA9IGVsZW1TaXplICogb2lkeFxuXG4gICAgICAgICAgaWYoYjEgPCByZWRbcmVkUHRyK2F4aXMrMV0gfHwgXG4gICAgICAgICAgICAgcmVkW3JlZFB0citheGlzKzErZF0gPCBiMCkge1xuICAgICAgICAgICAgY29udGludWVcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBmb3IodmFyIGs9YXhpcysyOyBrPGQ7ICsraykge1xuICAgICAgICAgICAgaWYoYmx1ZVtibHVlUHRyICsgayArIGRdIDwgcmVkW3JlZFB0ciArIGtdIHx8IFxuICAgICAgICAgICAgICAgcmVkW3JlZFB0ciArIGsgKyBkXSA8IGJsdWVbYmx1ZVB0ciArIGtdKSB7XG4gICAgICAgICAgICAgIGNvbnRpbnVlIHJlZF9sb29wXG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgdmFyIHJlZElkICA9IHJlZEluZGV4W29pZHhdXG4gICAgICAgICAgdmFyIHJldHZhbFxuICAgICAgICAgIGlmKGZsaXApIHtcbiAgICAgICAgICAgIHJldHZhbCA9IHZpc2l0KGJsdWVJZCwgcmVkSWQpXG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJldHZhbCA9IHZpc2l0KHJlZElkLCBibHVlSWQpXG4gICAgICAgICAgfVxuICAgICAgICAgIGlmKHJldHZhbCAhPT0gdm9pZCAwKSB7XG4gICAgICAgICAgICByZXR1cm4gcmV0dmFsIFxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBzcVBvcChSRURfU1dFRVBfUVVFVUUsIFJFRF9TV0VFUF9JTkRFWCwgcmVkQWN0aXZlLS0sIGUgLSByZWRTaGlmdClcbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gc2NhbkNvbXBsZXRlKFxuICBkLCBheGlzLCB2aXNpdCxcbiAgcmVkU3RhcnQsICByZWRFbmQsIHJlZCwgcmVkSW5kZXgsXG4gIGJsdWVTdGFydCwgYmx1ZUVuZCwgYmx1ZSwgYmx1ZUluZGV4KSB7XG5cbiAgdmFyIHB0ciAgICAgID0gMFxuICB2YXIgZWxlbVNpemUgPSAyKmRcbiAgdmFyIGlzdGFydCAgID0gYXhpc1xuICB2YXIgaWVuZCAgICAgPSBheGlzK2RcblxuICBmb3IodmFyIGk9cmVkU3RhcnQ7IGk8cmVkRW5kOyArK2kpIHtcbiAgICB2YXIgaWR4ID0gaSArIEJMVUVfRkxBR1xuICAgIHZhciByZWRPZmZzZXQgPSBlbGVtU2l6ZSppXG4gICAgU1dFRVBfRVZFTlRTW3B0cisrXSA9IHJlZFtyZWRPZmZzZXQraXN0YXJ0XVxuICAgIFNXRUVQX0VWRU5UU1twdHIrK10gPSAtaWR4XG4gICAgU1dFRVBfRVZFTlRTW3B0cisrXSA9IHJlZFtyZWRPZmZzZXQraWVuZF1cbiAgICBTV0VFUF9FVkVOVFNbcHRyKytdID0gaWR4XG4gIH1cbiAgZm9yKHZhciBpPWJsdWVTdGFydDsgaTxibHVlRW5kOyArK2kpIHtcbiAgICB2YXIgaWR4ID0gaSArIDFcbiAgICB2YXIgYmx1ZU9mZnNldCA9IGVsZW1TaXplKmlcbiAgICBTV0VFUF9FVkVOVFNbcHRyKytdID0gYmx1ZVtibHVlT2Zmc2V0K2lzdGFydF1cbiAgICBTV0VFUF9FVkVOVFNbcHRyKytdID0gLWlkeFxuICB9XG5cbiAgLy9wcm9jZXNzIGV2ZW50cyBmcm9tIGxlZnQtPnJpZ2h0XG4gIHZhciBuID0gcHRyID4+PiAxXG4gIGlzb3J0KFNXRUVQX0VWRU5UUywgbilcbiAgXG4gIHZhciByZWRBY3RpdmUgICAgPSAwXG4gIGZvcih2YXIgaT0wOyBpPG47ICsraSkge1xuICAgIHZhciBlID0gU1dFRVBfRVZFTlRTWzIqaSsxXXwwXG4gICAgaWYoZSA8IDApIHtcbiAgICAgIHZhciBpZHggICA9IC1lXG4gICAgICBpZihpZHggPj0gQkxVRV9GTEFHKSB7XG4gICAgICAgIFJFRF9TV0VFUF9RVUVVRVtyZWRBY3RpdmUrK10gPSBpZHggLSBCTFVFX0ZMQUdcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGlkeCAtPSAxXG4gICAgICAgIHZhciBibHVlSWQgID0gYmx1ZUluZGV4W2lkeF1cbiAgICAgICAgdmFyIGJsdWVQdHIgPSBlbGVtU2l6ZSAqIGlkeFxuXG4gICAgICAgIHZhciBiMCA9IGJsdWVbYmx1ZVB0citheGlzKzFdXG4gICAgICAgIHZhciBiMSA9IGJsdWVbYmx1ZVB0citheGlzKzErZF1cblxucmVkX2xvb3A6XG4gICAgICAgIGZvcih2YXIgaj0wOyBqPHJlZEFjdGl2ZTsgKytqKSB7XG4gICAgICAgICAgdmFyIG9pZHggICA9IFJFRF9TV0VFUF9RVUVVRVtqXVxuICAgICAgICAgIHZhciByZWRJZCAgPSByZWRJbmRleFtvaWR4XVxuXG4gICAgICAgICAgaWYocmVkSWQgPT09IGJsdWVJZCkge1xuICAgICAgICAgICAgYnJlYWtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICB2YXIgcmVkUHRyID0gZWxlbVNpemUgKiBvaWR4XG4gICAgICAgICAgaWYoYjEgPCByZWRbcmVkUHRyK2F4aXMrMV0gfHwgXG4gICAgICAgICAgICByZWRbcmVkUHRyK2F4aXMrMStkXSA8IGIwKSB7XG4gICAgICAgICAgICBjb250aW51ZVxuICAgICAgICAgIH1cbiAgICAgICAgICBmb3IodmFyIGs9YXhpcysyOyBrPGQ7ICsraykge1xuICAgICAgICAgICAgaWYoYmx1ZVtibHVlUHRyICsgayArIGRdIDwgcmVkW3JlZFB0ciArIGtdIHx8IFxuICAgICAgICAgICAgICAgcmVkW3JlZFB0ciArIGsgKyBkXSAgIDwgYmx1ZVtibHVlUHRyICsga10pIHtcbiAgICAgICAgICAgICAgY29udGludWUgcmVkX2xvb3BcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG5cbiAgICAgICAgICB2YXIgcmV0dmFsID0gdmlzaXQocmVkSWQsIGJsdWVJZClcbiAgICAgICAgICBpZihyZXR2YWwgIT09IHZvaWQgMCkge1xuICAgICAgICAgICAgcmV0dXJuIHJldHZhbCBcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgdmFyIGlkeCA9IGUgLSBCTFVFX0ZMQUdcbiAgICAgIGZvcih2YXIgaj1yZWRBY3RpdmUtMTsgaj49MDsgLS1qKSB7XG4gICAgICAgIGlmKFJFRF9TV0VFUF9RVUVVRVtqXSA9PT0gaWR4KSB7XG4gICAgICAgICAgZm9yKHZhciBrPWorMTsgazxyZWRBY3RpdmU7ICsraykge1xuICAgICAgICAgICAgUkVEX1NXRUVQX1FVRVVFW2stMV0gPSBSRURfU1dFRVBfUVVFVUVba11cbiAgICAgICAgICB9XG4gICAgICAgICAgYnJlYWtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgLS1yZWRBY3RpdmVcbiAgICB9XG4gIH1cbn0iLCJcInVzZSBzdHJpY3RcIlxuXG5mdW5jdGlvbiBkdXBlX2FycmF5KGNvdW50LCB2YWx1ZSwgaSkge1xuICB2YXIgYyA9IGNvdW50W2ldfDBcbiAgaWYoYyA8PSAwKSB7XG4gICAgcmV0dXJuIFtdXG4gIH1cbiAgdmFyIHJlc3VsdCA9IG5ldyBBcnJheShjKSwgalxuICBpZihpID09PSBjb3VudC5sZW5ndGgtMSkge1xuICAgIGZvcihqPTA7IGo8YzsgKytqKSB7XG4gICAgICByZXN1bHRbal0gPSB2YWx1ZVxuICAgIH1cbiAgfSBlbHNlIHtcbiAgICBmb3Ioaj0wOyBqPGM7ICsraikge1xuICAgICAgcmVzdWx0W2pdID0gZHVwZV9hcnJheShjb3VudCwgdmFsdWUsIGkrMSlcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHJlc3VsdFxufVxuXG5mdW5jdGlvbiBkdXBlX251bWJlcihjb3VudCwgdmFsdWUpIHtcbiAgdmFyIHJlc3VsdCwgaVxuICByZXN1bHQgPSBuZXcgQXJyYXkoY291bnQpXG4gIGZvcihpPTA7IGk8Y291bnQ7ICsraSkge1xuICAgIHJlc3VsdFtpXSA9IHZhbHVlXG4gIH1cbiAgcmV0dXJuIHJlc3VsdFxufVxuXG5mdW5jdGlvbiBkdXBlKGNvdW50LCB2YWx1ZSkge1xuICBpZih0eXBlb2YgdmFsdWUgPT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICB2YWx1ZSA9IDBcbiAgfVxuICBzd2l0Y2godHlwZW9mIGNvdW50KSB7XG4gICAgY2FzZSBcIm51bWJlclwiOlxuICAgICAgaWYoY291bnQgPiAwKSB7XG4gICAgICAgIHJldHVybiBkdXBlX251bWJlcihjb3VudHwwLCB2YWx1ZSlcbiAgICAgIH1cbiAgICBicmVha1xuICAgIGNhc2UgXCJvYmplY3RcIjpcbiAgICAgIGlmKHR5cGVvZiAoY291bnQubGVuZ3RoKSA9PT0gXCJudW1iZXJcIikge1xuICAgICAgICByZXR1cm4gZHVwZV9hcnJheShjb3VudCwgdmFsdWUsIDApXG4gICAgICB9XG4gICAgYnJlYWtcbiAgfVxuICByZXR1cm4gW11cbn1cblxubW9kdWxlLmV4cG9ydHMgPSBkdXBlIiwiJ3VzZSBzdHJpY3QnXG5cbnZhciBiaXRzID0gcmVxdWlyZSgnYml0LXR3aWRkbGUnKVxudmFyIGR1cCA9IHJlcXVpcmUoJ2R1cCcpXG5cbi8vTGVnYWN5IHBvb2wgc3VwcG9ydFxuaWYoIWdsb2JhbC5fX1RZUEVEQVJSQVlfUE9PTCkge1xuICBnbG9iYWwuX19UWVBFREFSUkFZX1BPT0wgPSB7XG4gICAgICBVSU5UOCAgIDogZHVwKFszMiwgMF0pXG4gICAgLCBVSU5UMTYgIDogZHVwKFszMiwgMF0pXG4gICAgLCBVSU5UMzIgIDogZHVwKFszMiwgMF0pXG4gICAgLCBJTlQ4ICAgIDogZHVwKFszMiwgMF0pXG4gICAgLCBJTlQxNiAgIDogZHVwKFszMiwgMF0pXG4gICAgLCBJTlQzMiAgIDogZHVwKFszMiwgMF0pXG4gICAgLCBGTE9BVCAgIDogZHVwKFszMiwgMF0pXG4gICAgLCBET1VCTEUgIDogZHVwKFszMiwgMF0pXG4gICAgLCBEQVRBICAgIDogZHVwKFszMiwgMF0pXG4gICAgLCBVSU5UOEMgIDogZHVwKFszMiwgMF0pXG4gICAgLCBCVUZGRVIgIDogZHVwKFszMiwgMF0pXG4gIH1cbn1cblxudmFyIGhhc1VpbnQ4QyA9ICh0eXBlb2YgVWludDhDbGFtcGVkQXJyYXkpICE9PSAndW5kZWZpbmVkJ1xudmFyIFBPT0wgPSBnbG9iYWwuX19UWVBFREFSUkFZX1BPT0xcblxuLy9VcGdyYWRlIHBvb2xcbmlmKCFQT09MLlVJTlQ4Qykge1xuICBQT09MLlVJTlQ4QyA9IGR1cChbMzIsIDBdKVxufVxuaWYoIVBPT0wuQlVGRkVSKSB7XG4gIFBPT0wuQlVGRkVSID0gZHVwKFszMiwgMF0pXG59XG5cbi8vTmV3IHRlY2huaXF1ZTogT25seSBhbGxvY2F0ZSBmcm9tIEFycmF5QnVmZmVyVmlldyBhbmQgQnVmZmVyXG52YXIgREFUQSAgICA9IFBPT0wuREFUQVxuICAsIEJVRkZFUiAgPSBQT09MLkJVRkZFUlxuXG5leHBvcnRzLmZyZWUgPSBmdW5jdGlvbiBmcmVlKGFycmF5KSB7XG4gIGlmKEJ1ZmZlci5pc0J1ZmZlcihhcnJheSkpIHtcbiAgICBCVUZGRVJbYml0cy5sb2cyKGFycmF5Lmxlbmd0aCldLnB1c2goYXJyYXkpXG4gIH0gZWxzZSB7XG4gICAgaWYoT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKGFycmF5KSAhPT0gJ1tvYmplY3QgQXJyYXlCdWZmZXJdJykge1xuICAgICAgYXJyYXkgPSBhcnJheS5idWZmZXJcbiAgICB9XG4gICAgaWYoIWFycmF5KSB7XG4gICAgICByZXR1cm5cbiAgICB9XG4gICAgdmFyIG4gPSBhcnJheS5sZW5ndGggfHwgYXJyYXkuYnl0ZUxlbmd0aFxuICAgIHZhciBsb2dfbiA9IGJpdHMubG9nMihuKXwwXG4gICAgREFUQVtsb2dfbl0ucHVzaChhcnJheSlcbiAgfVxufVxuXG5mdW5jdGlvbiBmcmVlQXJyYXlCdWZmZXIoYnVmZmVyKSB7XG4gIGlmKCFidWZmZXIpIHtcbiAgICByZXR1cm5cbiAgfVxuICB2YXIgbiA9IGJ1ZmZlci5sZW5ndGggfHwgYnVmZmVyLmJ5dGVMZW5ndGhcbiAgdmFyIGxvZ19uID0gYml0cy5sb2cyKG4pXG4gIERBVEFbbG9nX25dLnB1c2goYnVmZmVyKVxufVxuXG5mdW5jdGlvbiBmcmVlVHlwZWRBcnJheShhcnJheSkge1xuICBmcmVlQXJyYXlCdWZmZXIoYXJyYXkuYnVmZmVyKVxufVxuXG5leHBvcnRzLmZyZWVVaW50OCA9XG5leHBvcnRzLmZyZWVVaW50MTYgPVxuZXhwb3J0cy5mcmVlVWludDMyID1cbmV4cG9ydHMuZnJlZUludDggPVxuZXhwb3J0cy5mcmVlSW50MTYgPVxuZXhwb3J0cy5mcmVlSW50MzIgPVxuZXhwb3J0cy5mcmVlRmxvYXQzMiA9IFxuZXhwb3J0cy5mcmVlRmxvYXQgPVxuZXhwb3J0cy5mcmVlRmxvYXQ2NCA9IFxuZXhwb3J0cy5mcmVlRG91YmxlID0gXG5leHBvcnRzLmZyZWVVaW50OENsYW1wZWQgPSBcbmV4cG9ydHMuZnJlZURhdGFWaWV3ID0gZnJlZVR5cGVkQXJyYXlcblxuZXhwb3J0cy5mcmVlQXJyYXlCdWZmZXIgPSBmcmVlQXJyYXlCdWZmZXJcblxuZXhwb3J0cy5mcmVlQnVmZmVyID0gZnVuY3Rpb24gZnJlZUJ1ZmZlcihhcnJheSkge1xuICBCVUZGRVJbYml0cy5sb2cyKGFycmF5Lmxlbmd0aCldLnB1c2goYXJyYXkpXG59XG5cbmV4cG9ydHMubWFsbG9jID0gZnVuY3Rpb24gbWFsbG9jKG4sIGR0eXBlKSB7XG4gIGlmKGR0eXBlID09PSB1bmRlZmluZWQgfHwgZHR5cGUgPT09ICdhcnJheWJ1ZmZlcicpIHtcbiAgICByZXR1cm4gbWFsbG9jQXJyYXlCdWZmZXIobilcbiAgfSBlbHNlIHtcbiAgICBzd2l0Y2goZHR5cGUpIHtcbiAgICAgIGNhc2UgJ3VpbnQ4JzpcbiAgICAgICAgcmV0dXJuIG1hbGxvY1VpbnQ4KG4pXG4gICAgICBjYXNlICd1aW50MTYnOlxuICAgICAgICByZXR1cm4gbWFsbG9jVWludDE2KG4pXG4gICAgICBjYXNlICd1aW50MzInOlxuICAgICAgICByZXR1cm4gbWFsbG9jVWludDMyKG4pXG4gICAgICBjYXNlICdpbnQ4JzpcbiAgICAgICAgcmV0dXJuIG1hbGxvY0ludDgobilcbiAgICAgIGNhc2UgJ2ludDE2JzpcbiAgICAgICAgcmV0dXJuIG1hbGxvY0ludDE2KG4pXG4gICAgICBjYXNlICdpbnQzMic6XG4gICAgICAgIHJldHVybiBtYWxsb2NJbnQzMihuKVxuICAgICAgY2FzZSAnZmxvYXQnOlxuICAgICAgY2FzZSAnZmxvYXQzMic6XG4gICAgICAgIHJldHVybiBtYWxsb2NGbG9hdChuKVxuICAgICAgY2FzZSAnZG91YmxlJzpcbiAgICAgIGNhc2UgJ2Zsb2F0NjQnOlxuICAgICAgICByZXR1cm4gbWFsbG9jRG91YmxlKG4pXG4gICAgICBjYXNlICd1aW50OF9jbGFtcGVkJzpcbiAgICAgICAgcmV0dXJuIG1hbGxvY1VpbnQ4Q2xhbXBlZChuKVxuICAgICAgY2FzZSAnYnVmZmVyJzpcbiAgICAgICAgcmV0dXJuIG1hbGxvY0J1ZmZlcihuKVxuICAgICAgY2FzZSAnZGF0YSc6XG4gICAgICBjYXNlICdkYXRhdmlldyc6XG4gICAgICAgIHJldHVybiBtYWxsb2NEYXRhVmlldyhuKVxuXG4gICAgICBkZWZhdWx0OlxuICAgICAgICByZXR1cm4gbnVsbFxuICAgIH1cbiAgfVxuICByZXR1cm4gbnVsbFxufVxuXG5mdW5jdGlvbiBtYWxsb2NBcnJheUJ1ZmZlcihuKSB7XG4gIHZhciBuID0gYml0cy5uZXh0UG93MihuKVxuICB2YXIgbG9nX24gPSBiaXRzLmxvZzIobilcbiAgdmFyIGQgPSBEQVRBW2xvZ19uXVxuICBpZihkLmxlbmd0aCA+IDApIHtcbiAgICByZXR1cm4gZC5wb3AoKVxuICB9XG4gIHJldHVybiBuZXcgQXJyYXlCdWZmZXIobilcbn1cbmV4cG9ydHMubWFsbG9jQXJyYXlCdWZmZXIgPSBtYWxsb2NBcnJheUJ1ZmZlclxuXG5mdW5jdGlvbiBtYWxsb2NVaW50OChuKSB7XG4gIHJldHVybiBuZXcgVWludDhBcnJheShtYWxsb2NBcnJheUJ1ZmZlcihuKSwgMCwgbilcbn1cbmV4cG9ydHMubWFsbG9jVWludDggPSBtYWxsb2NVaW50OFxuXG5mdW5jdGlvbiBtYWxsb2NVaW50MTYobikge1xuICByZXR1cm4gbmV3IFVpbnQxNkFycmF5KG1hbGxvY0FycmF5QnVmZmVyKDIqbiksIDAsIG4pXG59XG5leHBvcnRzLm1hbGxvY1VpbnQxNiA9IG1hbGxvY1VpbnQxNlxuXG5mdW5jdGlvbiBtYWxsb2NVaW50MzIobikge1xuICByZXR1cm4gbmV3IFVpbnQzMkFycmF5KG1hbGxvY0FycmF5QnVmZmVyKDQqbiksIDAsIG4pXG59XG5leHBvcnRzLm1hbGxvY1VpbnQzMiA9IG1hbGxvY1VpbnQzMlxuXG5mdW5jdGlvbiBtYWxsb2NJbnQ4KG4pIHtcbiAgcmV0dXJuIG5ldyBJbnQ4QXJyYXkobWFsbG9jQXJyYXlCdWZmZXIobiksIDAsIG4pXG59XG5leHBvcnRzLm1hbGxvY0ludDggPSBtYWxsb2NJbnQ4XG5cbmZ1bmN0aW9uIG1hbGxvY0ludDE2KG4pIHtcbiAgcmV0dXJuIG5ldyBJbnQxNkFycmF5KG1hbGxvY0FycmF5QnVmZmVyKDIqbiksIDAsIG4pXG59XG5leHBvcnRzLm1hbGxvY0ludDE2ID0gbWFsbG9jSW50MTZcblxuZnVuY3Rpb24gbWFsbG9jSW50MzIobikge1xuICByZXR1cm4gbmV3IEludDMyQXJyYXkobWFsbG9jQXJyYXlCdWZmZXIoNCpuKSwgMCwgbilcbn1cbmV4cG9ydHMubWFsbG9jSW50MzIgPSBtYWxsb2NJbnQzMlxuXG5mdW5jdGlvbiBtYWxsb2NGbG9hdChuKSB7XG4gIHJldHVybiBuZXcgRmxvYXQzMkFycmF5KG1hbGxvY0FycmF5QnVmZmVyKDQqbiksIDAsIG4pXG59XG5leHBvcnRzLm1hbGxvY0Zsb2F0MzIgPSBleHBvcnRzLm1hbGxvY0Zsb2F0ID0gbWFsbG9jRmxvYXRcblxuZnVuY3Rpb24gbWFsbG9jRG91YmxlKG4pIHtcbiAgcmV0dXJuIG5ldyBGbG9hdDY0QXJyYXkobWFsbG9jQXJyYXlCdWZmZXIoOCpuKSwgMCwgbilcbn1cbmV4cG9ydHMubWFsbG9jRmxvYXQ2NCA9IGV4cG9ydHMubWFsbG9jRG91YmxlID0gbWFsbG9jRG91YmxlXG5cbmZ1bmN0aW9uIG1hbGxvY1VpbnQ4Q2xhbXBlZChuKSB7XG4gIGlmKGhhc1VpbnQ4Qykge1xuICAgIHJldHVybiBuZXcgVWludDhDbGFtcGVkQXJyYXkobWFsbG9jQXJyYXlCdWZmZXIobiksIDAsIG4pXG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIG1hbGxvY1VpbnQ4KG4pXG4gIH1cbn1cbmV4cG9ydHMubWFsbG9jVWludDhDbGFtcGVkID0gbWFsbG9jVWludDhDbGFtcGVkXG5cbmZ1bmN0aW9uIG1hbGxvY0RhdGFWaWV3KG4pIHtcbiAgcmV0dXJuIG5ldyBEYXRhVmlldyhtYWxsb2NBcnJheUJ1ZmZlcihuKSwgMCwgbilcbn1cbmV4cG9ydHMubWFsbG9jRGF0YVZpZXcgPSBtYWxsb2NEYXRhVmlld1xuXG5mdW5jdGlvbiBtYWxsb2NCdWZmZXIobikge1xuICBuID0gYml0cy5uZXh0UG93MihuKVxuICB2YXIgbG9nX24gPSBiaXRzLmxvZzIobilcbiAgdmFyIGNhY2hlID0gQlVGRkVSW2xvZ19uXVxuICBpZihjYWNoZS5sZW5ndGggPiAwKSB7XG4gICAgcmV0dXJuIGNhY2hlLnBvcCgpXG4gIH1cbiAgcmV0dXJuIG5ldyBCdWZmZXIobilcbn1cbmV4cG9ydHMubWFsbG9jQnVmZmVyID0gbWFsbG9jQnVmZmVyXG5cbmV4cG9ydHMuY2xlYXJDYWNoZSA9IGZ1bmN0aW9uIGNsZWFyQ2FjaGUoKSB7XG4gIGZvcih2YXIgaT0wOyBpPDMyOyArK2kpIHtcbiAgICBQT09MLlVJTlQ4W2ldLmxlbmd0aCA9IDBcbiAgICBQT09MLlVJTlQxNltpXS5sZW5ndGggPSAwXG4gICAgUE9PTC5VSU5UMzJbaV0ubGVuZ3RoID0gMFxuICAgIFBPT0wuSU5UOFtpXS5sZW5ndGggPSAwXG4gICAgUE9PTC5JTlQxNltpXS5sZW5ndGggPSAwXG4gICAgUE9PTC5JTlQzMltpXS5sZW5ndGggPSAwXG4gICAgUE9PTC5GTE9BVFtpXS5sZW5ndGggPSAwXG4gICAgUE9PTC5ET1VCTEVbaV0ubGVuZ3RoID0gMFxuICAgIFBPT0wuVUlOVDhDW2ldLmxlbmd0aCA9IDBcbiAgICBEQVRBW2ldLmxlbmd0aCA9IDBcbiAgICBCVUZGRVJbaV0ubGVuZ3RoID0gMFxuICB9XG59IiwibW9kdWxlLmV4cG9ydHMgPSBjb21wYXJlQ2VsbHNcblxudmFyIG1pbiA9IE1hdGgubWluXG5cbmZ1bmN0aW9uIGNvbXBhcmVJbnQoYSwgYikge1xuICByZXR1cm4gYSAtIGJcbn1cblxuZnVuY3Rpb24gY29tcGFyZUNlbGxzKGEsIGIpIHtcbiAgdmFyIG4gPSBhLmxlbmd0aFxuICAgICwgdCA9IGEubGVuZ3RoIC0gYi5sZW5ndGhcbiAgaWYodCkge1xuICAgIHJldHVybiB0XG4gIH1cbiAgc3dpdGNoKG4pIHtcbiAgICBjYXNlIDA6XG4gICAgICByZXR1cm4gMFxuICAgIGNhc2UgMTpcbiAgICAgIHJldHVybiBhWzBdIC0gYlswXVxuICAgIGNhc2UgMjpcbiAgICAgIHJldHVybiAoYVswXSthWzFdLWJbMF0tYlsxXSkgfHxcbiAgICAgICAgICAgICBtaW4oYVswXSxhWzFdKSAtIG1pbihiWzBdLGJbMV0pXG4gICAgY2FzZSAzOlxuICAgICAgdmFyIGwxID0gYVswXSthWzFdXG4gICAgICAgICwgbTEgPSBiWzBdK2JbMV1cbiAgICAgIHQgPSBsMSthWzJdIC0gKG0xK2JbMl0pXG4gICAgICBpZih0KSB7XG4gICAgICAgIHJldHVybiB0XG4gICAgICB9XG4gICAgICB2YXIgbDAgPSBtaW4oYVswXSwgYVsxXSlcbiAgICAgICAgLCBtMCA9IG1pbihiWzBdLCBiWzFdKVxuICAgICAgcmV0dXJuIG1pbihsMCwgYVsyXSkgLSBtaW4obTAsIGJbMl0pIHx8XG4gICAgICAgICAgICAgbWluKGwwK2FbMl0sIGwxKSAtIG1pbihtMCtiWzJdLCBtMSlcbiAgICBjYXNlIDQ6XG4gICAgICB2YXIgYXc9YVswXSwgYXg9YVsxXSwgYXk9YVsyXSwgYXo9YVszXVxuICAgICAgICAsIGJ3PWJbMF0sIGJ4PWJbMV0sIGJ5PWJbMl0sIGJ6PWJbM11cbiAgICAgIHJldHVybiAoYXcrYXgrYXkrYXopLShidytieCtieStieikgfHxcbiAgICAgICAgICAgICBtaW4oYXcsYXgsYXksYXopLW1pbihidyxieCxieSxieixidykgfHxcbiAgICAgICAgICAgICBtaW4oYXcrYXgsYXcrYXksYXcrYXosYXgrYXksYXgrYXosYXkrYXopIC1cbiAgICAgICAgICAgICAgIG1pbihidytieCxidytieSxidytieixieCtieSxieCtieixieStieikgfHxcbiAgICAgICAgICAgICBtaW4oYXcrYXgrYXksYXcrYXgrYXosYXcrYXkrYXosYXgrYXkrYXopIC1cbiAgICAgICAgICAgICAgIG1pbihidytieCtieSxidytieCtieixidytieStieixieCtieStieilcbiAgICBkZWZhdWx0OlxuICAgICAgdmFyIGFzID0gYS5zbGljZSgpLnNvcnQoY29tcGFyZUludClcbiAgICAgIHZhciBicyA9IGIuc2xpY2UoKS5zb3J0KGNvbXBhcmVJbnQpXG4gICAgICBmb3IodmFyIGk9MDsgaTxuOyArK2kpIHtcbiAgICAgICAgdCA9IGFzW2ldIC0gYnNbaV1cbiAgICAgICAgaWYodCkge1xuICAgICAgICAgIHJldHVybiB0XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiAwXG4gIH1cbn1cbiIsIlwidXNlIHN0cmljdFwiXG5cbnZhciBkb3VibGVCaXRzID0gcmVxdWlyZShcImRvdWJsZS1iaXRzXCIpXG5cbnZhciBTTUFMTEVTVF9ERU5PUk0gPSBNYXRoLnBvdygyLCAtMTA3NClcbnZhciBVSU5UX01BWCA9ICgtMSk+Pj4wXG5cbm1vZHVsZS5leHBvcnRzID0gbmV4dGFmdGVyXG5cbmZ1bmN0aW9uIG5leHRhZnRlcih4LCB5KSB7XG4gIGlmKGlzTmFOKHgpIHx8IGlzTmFOKHkpKSB7XG4gICAgcmV0dXJuIE5hTlxuICB9XG4gIGlmKHggPT09IHkpIHtcbiAgICByZXR1cm4geFxuICB9XG4gIGlmKHggPT09IDApIHtcbiAgICBpZih5IDwgMCkge1xuICAgICAgcmV0dXJuIC1TTUFMTEVTVF9ERU5PUk1cbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIFNNQUxMRVNUX0RFTk9STVxuICAgIH1cbiAgfVxuICB2YXIgaGkgPSBkb3VibGVCaXRzLmhpKHgpXG4gIHZhciBsbyA9IGRvdWJsZUJpdHMubG8oeClcbiAgaWYoKHkgPiB4KSA9PT0gKHggPiAwKSkge1xuICAgIGlmKGxvID09PSBVSU5UX01BWCkge1xuICAgICAgaGkgKz0gMVxuICAgICAgbG8gPSAwXG4gICAgfSBlbHNlIHtcbiAgICAgIGxvICs9IDFcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgaWYobG8gPT09IDApIHtcbiAgICAgIGxvID0gVUlOVF9NQVhcbiAgICAgIGhpIC09IDFcbiAgICB9IGVsc2Uge1xuICAgICAgbG8gLT0gMVxuICAgIH1cbiAgfVxuICByZXR1cm4gZG91YmxlQml0cy5wYWNrKGxvLCBoaSlcbn0iLCJ2YXIgaGFzVHlwZWRBcnJheXMgPSBmYWxzZVxuaWYodHlwZW9mIEZsb2F0NjRBcnJheSAhPT0gXCJ1bmRlZmluZWRcIikge1xuICB2YXIgRE9VQkxFX1ZJRVcgPSBuZXcgRmxvYXQ2NEFycmF5KDEpXG4gICAgLCBVSU5UX1ZJRVcgICA9IG5ldyBVaW50MzJBcnJheShET1VCTEVfVklFVy5idWZmZXIpXG4gIERPVUJMRV9WSUVXWzBdID0gMS4wXG4gIGhhc1R5cGVkQXJyYXlzID0gdHJ1ZVxuICBpZihVSU5UX1ZJRVdbMV0gPT09IDB4M2ZmMDAwMDApIHtcbiAgICAvL1VzZSBsaXR0bGUgZW5kaWFuXG4gICAgbW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBkb3VibGVCaXRzTEUobikge1xuICAgICAgRE9VQkxFX1ZJRVdbMF0gPSBuXG4gICAgICByZXR1cm4gWyBVSU5UX1ZJRVdbMF0sIFVJTlRfVklFV1sxXSBdXG4gICAgfVxuICAgIGZ1bmN0aW9uIHRvRG91YmxlTEUobG8sIGhpKSB7XG4gICAgICBVSU5UX1ZJRVdbMF0gPSBsb1xuICAgICAgVUlOVF9WSUVXWzFdID0gaGlcbiAgICAgIHJldHVybiBET1VCTEVfVklFV1swXVxuICAgIH1cbiAgICBtb2R1bGUuZXhwb3J0cy5wYWNrID0gdG9Eb3VibGVMRVxuICAgIGZ1bmN0aW9uIGxvd1VpbnRMRShuKSB7XG4gICAgICBET1VCTEVfVklFV1swXSA9IG5cbiAgICAgIHJldHVybiBVSU5UX1ZJRVdbMF1cbiAgICB9XG4gICAgbW9kdWxlLmV4cG9ydHMubG8gPSBsb3dVaW50TEVcbiAgICBmdW5jdGlvbiBoaWdoVWludExFKG4pIHtcbiAgICAgIERPVUJMRV9WSUVXWzBdID0gblxuICAgICAgcmV0dXJuIFVJTlRfVklFV1sxXVxuICAgIH1cbiAgICBtb2R1bGUuZXhwb3J0cy5oaSA9IGhpZ2hVaW50TEVcbiAgfSBlbHNlIGlmKFVJTlRfVklFV1swXSA9PT0gMHgzZmYwMDAwMCkge1xuICAgIC8vVXNlIGJpZyBlbmRpYW5cbiAgICBtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGRvdWJsZUJpdHNCRShuKSB7XG4gICAgICBET1VCTEVfVklFV1swXSA9IG5cbiAgICAgIHJldHVybiBbIFVJTlRfVklFV1sxXSwgVUlOVF9WSUVXWzBdIF1cbiAgICB9XG4gICAgZnVuY3Rpb24gdG9Eb3VibGVCRShsbywgaGkpIHtcbiAgICAgIFVJTlRfVklFV1sxXSA9IGxvXG4gICAgICBVSU5UX1ZJRVdbMF0gPSBoaVxuICAgICAgcmV0dXJuIERPVUJMRV9WSUVXWzBdXG4gICAgfVxuICAgIG1vZHVsZS5leHBvcnRzLnBhY2sgPSB0b0RvdWJsZUJFXG4gICAgZnVuY3Rpb24gbG93VWludEJFKG4pIHtcbiAgICAgIERPVUJMRV9WSUVXWzBdID0gblxuICAgICAgcmV0dXJuIFVJTlRfVklFV1sxXVxuICAgIH1cbiAgICBtb2R1bGUuZXhwb3J0cy5sbyA9IGxvd1VpbnRCRVxuICAgIGZ1bmN0aW9uIGhpZ2hVaW50QkUobikge1xuICAgICAgRE9VQkxFX1ZJRVdbMF0gPSBuXG4gICAgICByZXR1cm4gVUlOVF9WSUVXWzBdXG4gICAgfVxuICAgIG1vZHVsZS5leHBvcnRzLmhpID0gaGlnaFVpbnRCRVxuICB9IGVsc2Uge1xuICAgIGhhc1R5cGVkQXJyYXlzID0gZmFsc2VcbiAgfVxufVxuaWYoIWhhc1R5cGVkQXJyYXlzKSB7XG4gIHZhciBidWZmZXIgPSBuZXcgQnVmZmVyKDgpXG4gIG1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gZG91YmxlQml0cyhuKSB7XG4gICAgYnVmZmVyLndyaXRlRG91YmxlTEUobiwgMCwgdHJ1ZSlcbiAgICByZXR1cm4gWyBidWZmZXIucmVhZFVJbnQzMkxFKDAsIHRydWUpLCBidWZmZXIucmVhZFVJbnQzMkxFKDQsIHRydWUpIF1cbiAgfVxuICBmdW5jdGlvbiB0b0RvdWJsZShsbywgaGkpIHtcbiAgICBidWZmZXIud3JpdGVVSW50MzJMRShsbywgMCwgdHJ1ZSlcbiAgICBidWZmZXIud3JpdGVVSW50MzJMRShoaSwgNCwgdHJ1ZSlcbiAgICByZXR1cm4gYnVmZmVyLnJlYWREb3VibGVMRSgwLCB0cnVlKVxuICB9XG4gIG1vZHVsZS5leHBvcnRzLnBhY2sgPSB0b0RvdWJsZSAgXG4gIGZ1bmN0aW9uIGxvd1VpbnQobikge1xuICAgIGJ1ZmZlci53cml0ZURvdWJsZUxFKG4sIDAsIHRydWUpXG4gICAgcmV0dXJuIGJ1ZmZlci5yZWFkVUludDMyTEUoMCwgdHJ1ZSlcbiAgfVxuICBtb2R1bGUuZXhwb3J0cy5sbyA9IGxvd1VpbnRcbiAgZnVuY3Rpb24gaGlnaFVpbnQobikge1xuICAgIGJ1ZmZlci53cml0ZURvdWJsZUxFKG4sIDAsIHRydWUpXG4gICAgcmV0dXJuIGJ1ZmZlci5yZWFkVUludDMyTEUoNCwgdHJ1ZSlcbiAgfVxuICBtb2R1bGUuZXhwb3J0cy5oaSA9IGhpZ2hVaW50XG59XG5cbm1vZHVsZS5leHBvcnRzLnNpZ24gPSBmdW5jdGlvbihuKSB7XG4gIHJldHVybiBtb2R1bGUuZXhwb3J0cy5oaShuKSA+Pj4gMzFcbn1cblxubW9kdWxlLmV4cG9ydHMuZXhwb25lbnQgPSBmdW5jdGlvbihuKSB7XG4gIHZhciBiID0gbW9kdWxlLmV4cG9ydHMuaGkobilcbiAgcmV0dXJuICgoYjw8MSkgPj4+IDIxKSAtIDEwMjNcbn1cblxubW9kdWxlLmV4cG9ydHMuZnJhY3Rpb24gPSBmdW5jdGlvbihuKSB7XG4gIHZhciBsbyA9IG1vZHVsZS5leHBvcnRzLmxvKG4pXG4gIHZhciBoaSA9IG1vZHVsZS5leHBvcnRzLmhpKG4pXG4gIHZhciBiID0gaGkgJiAoKDE8PDIwKSAtIDEpXG4gIGlmKGhpICYgMHg3ZmYwMDAwMCkge1xuICAgIGIgKz0gKDE8PDIwKVxuICB9XG4gIHJldHVybiBbbG8sIGJdXG59XG5cbm1vZHVsZS5leHBvcnRzLmRlbm9ybWFsaXplZCA9IGZ1bmN0aW9uKG4pIHtcbiAgdmFyIGhpID0gbW9kdWxlLmV4cG9ydHMuaGkobilcbiAgcmV0dXJuICEoaGkgJiAweDdmZjAwMDAwKVxufSIsIid1c2Ugc3RyaWN0J1xuXG52YXIgYm5hZGQgPSByZXF1aXJlKCdiaWctcmF0L2FkZCcpXG5cbm1vZHVsZS5leHBvcnRzID0gYWRkXG5cbmZ1bmN0aW9uIGFkZChhLCBiKSB7XG4gIHZhciBuID0gYS5sZW5ndGhcbiAgdmFyIHIgPSBuZXcgQXJyYXkobilcbiAgICBmb3IodmFyIGk9MDsgaTxuOyArK2kpIHtcbiAgICByW2ldID0gYm5hZGQoYVtpXSwgYltpXSlcbiAgfVxuICByZXR1cm4gclxufVxuIiwiJ3VzZSBzdHJpY3QnXG5cbm1vZHVsZS5leHBvcnRzID0gZmxvYXQycmF0XG5cbnZhciByYXQgPSByZXF1aXJlKCdiaWctcmF0JylcblxuZnVuY3Rpb24gZmxvYXQycmF0KHYpIHtcbiAgdmFyIHJlc3VsdCA9IG5ldyBBcnJheSh2Lmxlbmd0aClcbiAgZm9yKHZhciBpPTA7IGk8di5sZW5ndGg7ICsraSkge1xuICAgIHJlc3VsdFtpXSA9IHJhdCh2W2ldKVxuICB9XG4gIHJldHVybiByZXN1bHRcbn1cbiIsIid1c2Ugc3RyaWN0J1xuXG52YXIgcmF0ID0gcmVxdWlyZSgnYmlnLXJhdCcpXG52YXIgbXVsID0gcmVxdWlyZSgnYmlnLXJhdC9tdWwnKVxuXG5tb2R1bGUuZXhwb3J0cyA9IG11bHNcblxuZnVuY3Rpb24gbXVscyhhLCB4KSB7XG4gIHZhciBzID0gcmF0KHgpXG4gIHZhciBuID0gYS5sZW5ndGhcbiAgdmFyIHIgPSBuZXcgQXJyYXkobilcbiAgZm9yKHZhciBpPTA7IGk8bjsgKytpKSB7XG4gICAgcltpXSA9IG11bChhW2ldLCBzKVxuICB9XG4gIHJldHVybiByXG59XG4iLCIndXNlIHN0cmljdCdcblxudmFyIGJuc3ViID0gcmVxdWlyZSgnYmlnLXJhdC9zdWInKVxuXG5tb2R1bGUuZXhwb3J0cyA9IHN1YlxuXG5mdW5jdGlvbiBzdWIoYSwgYikge1xuICB2YXIgbiA9IGEubGVuZ3RoXG4gIHZhciByID0gbmV3IEFycmF5KG4pXG4gICAgZm9yKHZhciBpPTA7IGk8bjsgKytpKSB7XG4gICAgcltpXSA9IGJuc3ViKGFbaV0sIGJbaV0pXG4gIH1cbiAgcmV0dXJuIHJcbn1cbiIsIlwidXNlIHN0cmljdFwiXG5cbm1vZHVsZS5leHBvcnRzID0gc2VnbWVudHNJbnRlcnNlY3RcblxudmFyIG9yaWVudCA9IHJlcXVpcmUoXCJyb2J1c3Qtb3JpZW50YXRpb25cIilbM11cblxuZnVuY3Rpb24gY2hlY2tDb2xsaW5lYXIoYTAsIGExLCBiMCwgYjEpIHtcblxuICBmb3IodmFyIGQ9MDsgZDwyOyArK2QpIHtcbiAgICB2YXIgeDAgPSBhMFtkXVxuICAgIHZhciB5MCA9IGExW2RdXG4gICAgdmFyIGwwID0gTWF0aC5taW4oeDAsIHkwKVxuICAgIHZhciBoMCA9IE1hdGgubWF4KHgwLCB5MCkgICAgXG5cbiAgICB2YXIgeDEgPSBiMFtkXVxuICAgIHZhciB5MSA9IGIxW2RdXG4gICAgdmFyIGwxID0gTWF0aC5taW4oeDEsIHkxKVxuICAgIHZhciBoMSA9IE1hdGgubWF4KHgxLCB5MSkgICAgXG5cbiAgICBpZihoMSA8IGwwIHx8IGgwIDwgbDEpIHtcbiAgICAgIHJldHVybiBmYWxzZVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiB0cnVlXG59XG5cbmZ1bmN0aW9uIHNlZ21lbnRzSW50ZXJzZWN0KGEwLCBhMSwgYjAsIGIxKSB7XG4gIHZhciB4MCA9IG9yaWVudChhMCwgYjAsIGIxKVxuICB2YXIgeTAgPSBvcmllbnQoYTEsIGIwLCBiMSlcbiAgaWYoKHgwID4gMCAmJiB5MCA+IDApIHx8ICh4MCA8IDAgJiYgeTAgPCAwKSkge1xuICAgIHJldHVybiBmYWxzZVxuICB9XG5cbiAgdmFyIHgxID0gb3JpZW50KGIwLCBhMCwgYTEpXG4gIHZhciB5MSA9IG9yaWVudChiMSwgYTAsIGExKVxuICBpZigoeDEgPiAwICYmIHkxID4gMCkgfHwgKHgxIDwgMCAmJiB5MSA8IDApKSB7XG4gICAgcmV0dXJuIGZhbHNlXG4gIH1cblxuICAvL0NoZWNrIGZvciBkZWdlbmVyYXRlIGNvbGxpbmVhciBjYXNlXG4gIGlmKHgwID09PSAwICYmIHkwID09PSAwICYmIHgxID09PSAwICYmIHkxID09PSAwKSB7XG4gICAgcmV0dXJuIGNoZWNrQ29sbGluZWFyKGEwLCBhMSwgYjAsIGIxKVxuICB9XG5cbiAgcmV0dXJuIHRydWVcbn0iLCJcInVzZSBzdHJpY3RcIjsgXCJ1c2UgcmVzdHJpY3RcIjtcblxubW9kdWxlLmV4cG9ydHMgPSBVbmlvbkZpbmQ7XG5cbmZ1bmN0aW9uIFVuaW9uRmluZChjb3VudCkge1xuICB0aGlzLnJvb3RzID0gbmV3IEFycmF5KGNvdW50KTtcbiAgdGhpcy5yYW5rcyA9IG5ldyBBcnJheShjb3VudCk7XG4gIFxuICBmb3IodmFyIGk9MDsgaTxjb3VudDsgKytpKSB7XG4gICAgdGhpcy5yb290c1tpXSA9IGk7XG4gICAgdGhpcy5yYW5rc1tpXSA9IDA7XG4gIH1cbn1cblxudmFyIHByb3RvID0gVW5pb25GaW5kLnByb3RvdHlwZVxuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkocHJvdG8sIFwibGVuZ3RoXCIsIHtcbiAgXCJnZXRcIjogZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIHRoaXMucm9vdHMubGVuZ3RoXG4gIH1cbn0pXG5cbnByb3RvLm1ha2VTZXQgPSBmdW5jdGlvbigpIHtcbiAgdmFyIG4gPSB0aGlzLnJvb3RzLmxlbmd0aDtcbiAgdGhpcy5yb290cy5wdXNoKG4pO1xuICB0aGlzLnJhbmtzLnB1c2goMCk7XG4gIHJldHVybiBuO1xufVxuXG5wcm90by5maW5kID0gZnVuY3Rpb24oeCkge1xuICB2YXIgeDAgPSB4XG4gIHZhciByb290cyA9IHRoaXMucm9vdHM7XG4gIHdoaWxlKHJvb3RzW3hdICE9PSB4KSB7XG4gICAgeCA9IHJvb3RzW3hdXG4gIH1cbiAgd2hpbGUocm9vdHNbeDBdICE9PSB4KSB7XG4gICAgdmFyIHkgPSByb290c1t4MF1cbiAgICByb290c1t4MF0gPSB4XG4gICAgeDAgPSB5XG4gIH1cbiAgcmV0dXJuIHg7XG59XG5cbnByb3RvLmxpbmsgPSBmdW5jdGlvbih4LCB5KSB7XG4gIHZhciB4ciA9IHRoaXMuZmluZCh4KVxuICAgICwgeXIgPSB0aGlzLmZpbmQoeSk7XG4gIGlmKHhyID09PSB5cikge1xuICAgIHJldHVybjtcbiAgfVxuICB2YXIgcmFua3MgPSB0aGlzLnJhbmtzXG4gICAgLCByb290cyA9IHRoaXMucm9vdHNcbiAgICAsIHhkICAgID0gcmFua3NbeHJdXG4gICAgLCB5ZCAgICA9IHJhbmtzW3lyXTtcbiAgaWYoeGQgPCB5ZCkge1xuICAgIHJvb3RzW3hyXSA9IHlyO1xuICB9IGVsc2UgaWYoeWQgPCB4ZCkge1xuICAgIHJvb3RzW3lyXSA9IHhyO1xuICB9IGVsc2Uge1xuICAgIHJvb3RzW3lyXSA9IHhyO1xuICAgICsrcmFua3NbeHJdO1xuICB9XG59IiwiJ3VzZSBzdHJpY3QnXG5cbm1vZHVsZS5leHBvcnRzID0gYm91bmRhcnlcblxudmFyIGJuZCA9IHJlcXVpcmUoJ2JvdW5kYXJ5LWNlbGxzJylcbnZhciByZWR1Y2UgPSByZXF1aXJlKCdyZWR1Y2Utc2ltcGxpY2lhbC1jb21wbGV4JylcblxuZnVuY3Rpb24gYm91bmRhcnkoY2VsbHMpIHtcbiAgcmV0dXJuIHJlZHVjZShibmQoY2VsbHMpKVxufVxuIiwiXCJ1c2Ugc3RyaWN0XCJcblxubW9kdWxlLmV4cG9ydHMgPSBib3VuZGFyeVxuXG5mdW5jdGlvbiBib3VuZGFyeShjZWxscykge1xuICB2YXIgbiA9IGNlbGxzLmxlbmd0aFxuICB2YXIgc3ogPSAwXG4gIGZvcih2YXIgaT0wOyBpPG47ICsraSkge1xuICAgIHN6ICs9IGNlbGxzW2ldLmxlbmd0aFxuICB9XG4gIHZhciByZXN1bHQgPSBuZXcgQXJyYXkoc3opXG4gIHZhciBwdHIgPSAwXG4gIGZvcih2YXIgaT0wOyBpPG47ICsraSkge1xuICAgIHZhciBjID0gY2VsbHNbaV1cbiAgICB2YXIgZCA9IGMubGVuZ3RoXG4gICAgZm9yKHZhciBqPTA7IGo8ZDsgKytqKSB7XG4gICAgICB2YXIgYiA9IHJlc3VsdFtwdHIrK10gPSBuZXcgQXJyYXkoZC0xKVxuICAgICAgZm9yKHZhciBrPTE7IGs8ZDsgKytrKSB7XG4gICAgICAgIGJbay0xXSA9IGNbKGorayklZF1cbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgcmV0dXJuIHJlc3VsdFxufVxuIiwiJ3VzZSBzdHJpY3QnXG5cbm1vZHVsZS5leHBvcnRzID0gb3JpZW50YXRpb25cblxuZnVuY3Rpb24gb3JpZW50YXRpb24ocykge1xuICB2YXIgcCA9IDFcbiAgZm9yKHZhciBpPTE7IGk8cy5sZW5ndGg7ICsraSkge1xuICAgIGZvcih2YXIgaj0wOyBqPGk7ICsraikge1xuICAgICAgaWYoc1tpXSA8IHNbal0pIHtcbiAgICAgICAgcCA9IC1wXG4gICAgICB9IGVsc2UgaWYoc1tqXSA9PT0gc1tpXSkge1xuICAgICAgICByZXR1cm4gMFxuICAgICAgfVxuICAgIH1cbiAgfVxuICByZXR1cm4gcFxufVxuIiwiJ3VzZSBzdHJpY3QnXG5cbnZhciBjb21wYXJlQ2VsbHMgPSByZXF1aXJlKCdjb21wYXJlLWNlbGwnKVxudmFyIHBhcml0eSA9IHJlcXVpcmUoJ2NlbGwtb3JpZW50YXRpb24nKVxuXG5tb2R1bGUuZXhwb3J0cyA9IGNvbXBhcmVPcmllbnRlZENlbGxzXG5cbmZ1bmN0aW9uIGNvbXBhcmVPcmllbnRlZENlbGxzKGEsIGIpIHtcbiAgcmV0dXJuIGNvbXBhcmVDZWxscyhhLCBiKSB8fCBwYXJpdHkoYSkgLSBwYXJpdHkoYilcbn1cbiIsIid1c2Ugc3RyaWN0J1xuXG52YXIgY29tcGFyZUNlbGwgPSByZXF1aXJlKCdjb21wYXJlLWNlbGwnKVxudmFyIGNvbXBhcmVPcmllbnRlZENlbGwgPSByZXF1aXJlKCdjb21wYXJlLW9yaWVudGVkLWNlbGwnKVxudmFyIG9yaWVudGF0aW9uID0gcmVxdWlyZSgnY2VsbC1vcmllbnRhdGlvbicpXG5cbm1vZHVsZS5leHBvcnRzID0gcmVkdWNlQ2VsbENvbXBsZXhcblxuZnVuY3Rpb24gcmVkdWNlQ2VsbENvbXBsZXgoY2VsbHMpIHtcbiAgY2VsbHMuc29ydChjb21wYXJlT3JpZW50ZWRDZWxsKVxuICB2YXIgbiA9IGNlbGxzLmxlbmd0aFxuICB2YXIgcHRyID0gMFxuICBmb3IodmFyIGk9MDsgaTxuOyArK2kpIHtcbiAgICB2YXIgYyA9IGNlbGxzW2ldXG4gICAgdmFyIG8gPSBvcmllbnRhdGlvbihjKVxuICAgIGlmKG8gPT09IDApIHtcbiAgICAgIGNvbnRpbnVlXG4gICAgfVxuICAgIGlmKHB0ciA+IDApIHtcbiAgICAgIHZhciBmID0gY2VsbHNbcHRyLTFdXG4gICAgICBpZihjb21wYXJlQ2VsbChjLCBmKSA9PT0gMCAmJlxuICAgICAgICAgb3JpZW50YXRpb24oZikgICAgIT09IG8pIHtcbiAgICAgICAgcHRyIC09IDFcbiAgICAgICAgY29udGludWVcbiAgICAgIH1cbiAgICB9XG4gICAgY2VsbHNbcHRyKytdID0gY1xuICB9XG4gIGNlbGxzLmxlbmd0aCA9IHB0clxuICByZXR1cm4gY2VsbHNcbn1cbiIsIid1c2Ugc3RyaWN0J1xuXG52YXIgc25hcFJvdW5kID0gcmVxdWlyZSgnY2xlYW4tcHNsZycpXG52YXIgY2R0MmQgPSByZXF1aXJlKCdjZHQyZCcpXG52YXIgYnNlYXJjaCA9IHJlcXVpcmUoJ2JpbmFyeS1zZWFyY2gtYm91bmRzJylcbnZhciBib3VuZGFyeSA9IHJlcXVpcmUoJ3NpbXBsaWNpYWwtY29tcGxleC1ib3VuZGFyeScpXG5cbm1vZHVsZS5leHBvcnRzID0gb3ZlcmxheVBTTEdcblxudmFyIFJFRCAgPSAwXG52YXIgQkxVRSA9IDFcblxudmFyIE9QRVJBVE9SUyA9IHtcbiAgJ3hvcic6ICBbMCwgMSwgMSwgMF0sXG4gICdvcic6ICAgWzAsIDEsIDEsIDFdLFxuICAnYW5kJzogIFswLCAwLCAwLCAxXSxcbiAgJ3N1Yic6ICBbMCwgMSwgMCwgMF0sXG4gICdyc3ViJzogWzAsIDAsIDEsIDBdXG59XG5cbmZ1bmN0aW9uIGdldFRhYmxlKG9wKSB7XG4gIGlmKHR5cGVvZiBvcCAhPT0gJ3N0cmluZycpIHtcbiAgICByZXR1cm4gT1BFUkFUT1JTLnhvclxuICB9XG4gIHZhciB4ID0gT1BFUkFUT1JTW29wLnRvTG93ZXJDYXNlKCldXG4gIGlmKHgpIHtcbiAgICByZXR1cm4geFxuICB9XG4gIHJldHVybiBPUEVSQVRPUlMueG9yXG59XG5cblxuZnVuY3Rpb24gY29tcGFyZUVkZ2UoYSwgYikge1xuICByZXR1cm4gTWF0aC5taW4oYVswXSwgYVsxXSkgLSBNYXRoLm1pbihiWzBdLCBiWzFdKSB8fFxuICAgICAgICAgTWF0aC5tYXgoYVswXSwgYVsxXSkgLSBNYXRoLm1heChiWzBdLCBiWzFdKVxufVxuXG5mdW5jdGlvbiBlZGdlQ2VsbEluZGV4KGVkZ2UsIGNlbGwpIHtcbiAgdmFyIGEgPSBlZGdlWzBdXG4gIHZhciBiID0gZWRnZVsxXVxuICBmb3IodmFyIGk9MDsgaTwzOyArK2kpIHtcbiAgICBpZihjZWxsW2ldICE9PSBhICYmIGNlbGxbaV0gIT09IGIpIHtcbiAgICAgIHJldHVybiBpXG4gICAgfVxuICB9XG4gIHJldHVybiAtMVxufVxuXG5mdW5jdGlvbiBidWlsZENlbGxJbmRleChjZWxscykge1xuICAvL0luaXRpYWxpemUgY2VsbCBpbmRleFxuICB2YXIgY2VsbEluZGV4ID0gbmV3IEFycmF5KDMqY2VsbHMubGVuZ3RoKVxuICBmb3IodmFyIGk9MDsgaTwzKmNlbGxzLmxlbmd0aDsgKytpKSB7XG4gICAgY2VsbEluZGV4W2ldID0gLTFcbiAgfVxuXG4gIC8vU29ydCBlZGdlc1xuICB2YXIgZWRnZXMgPSBbXVxuICBmb3IodmFyIGk9MDsgaTxjZWxscy5sZW5ndGg7ICsraSkge1xuICAgIHZhciBjID0gY2VsbHNbaV1cbiAgICBmb3IodmFyIGo9MDsgajwzOyArK2opIHtcbiAgICAgIGVkZ2VzLnB1c2goW2Nbal0sIGNbKGorMSklM10sIGldKVxuICAgIH1cbiAgfVxuICBlZGdlcy5zb3J0KGNvbXBhcmVFZGdlKVxuXG4gIC8vRm9yIGVhY2ggcGFpciBvZiBlZGdlcywgbGluayBhZGphY2VudCBjZWxsc1xuICBmb3IodmFyIGk9MTsgaTxlZGdlcy5sZW5ndGg7ICsraSkge1xuICAgIHZhciBlID0gZWRnZXNbaV1cbiAgICB2YXIgZiA9IGVkZ2VzW2ktMV1cbiAgICBpZihjb21wYXJlRWRnZShlLCBmKSAhPT0gMCkge1xuICAgICAgY29udGludWVcbiAgICB9XG4gICAgdmFyIGNlID0gZVsyXVxuICAgIHZhciBjZiA9IGZbMl1cbiAgICB2YXIgZWkgPSBlZGdlQ2VsbEluZGV4KGUsIGNlbGxzW2NlXSlcbiAgICB2YXIgZmkgPSBlZGdlQ2VsbEluZGV4KGYsIGNlbGxzW2NmXSlcbiAgICBjZWxsSW5kZXhbMypjZStlaV0gPSBjZlxuICAgIGNlbGxJbmRleFszKmNmK2ZpXSA9IGNlXG4gIH1cblxuICByZXR1cm4gY2VsbEluZGV4XG59XG5cbmZ1bmN0aW9uIGNvbXBhcmVMZXgyKGEsIGIpIHtcbiAgcmV0dXJuIGFbMF0tYlswXSB8fCBhWzFdLWJbMV1cbn1cblxuZnVuY3Rpb24gY2Fub25pY2FsaXplRWRnZXMoZWRnZXMpIHtcbiAgZm9yKHZhciBpPTA7IGk8ZWRnZXMubGVuZ3RoOyArK2kpIHtcbiAgICB2YXIgZSA9IGVkZ2VzW2ldXG4gICAgdmFyIGEgPSBlWzBdXG4gICAgdmFyIGIgPSBlWzFdXG4gICAgZVswXSA9IE1hdGgubWluKGEsIGIpXG4gICAgZVsxXSA9IE1hdGgubWF4KGEsIGIpXG4gIH1cbiAgZWRnZXMuc29ydChjb21wYXJlTGV4Milcbn1cblxuXG52YXIgVE1QID0gWzAsMF1cbmZ1bmN0aW9uIGlzQ29uc3RyYWludChlZGdlcywgYSwgYikge1xuICBUTVBbMF0gPSBNYXRoLm1pbihhLGIpXG4gIFRNUFsxXSA9IE1hdGgubWF4KGEsYilcbiAgcmV0dXJuIGJzZWFyY2guZXEoZWRnZXMsIFRNUCwgY29tcGFyZUxleDIpID49IDBcbn1cblxuLy9DbGFzc2lmeSBhbGwgY2VsbHMgd2l0aGluIGJvdW5kYXJ5XG5mdW5jdGlvbiBtYXJrQ2VsbHMoY2VsbHMsIGFkaiwgZWRnZXMpIHtcblxuICAvL0luaXRpYWxpemUgYWN0aXZlL25leHQgcXVldWVzIGFuZCBmbGFnc1xuICB2YXIgZmxhZ3MgPSBuZXcgQXJyYXkoY2VsbHMubGVuZ3RoKVxuICB2YXIgY29uc3RyYWludCA9IG5ldyBBcnJheSgzKmNlbGxzLmxlbmd0aClcbiAgZm9yKHZhciBpPTA7IGk8MypjZWxscy5sZW5ndGg7ICsraSkge1xuICAgIGNvbnN0cmFpbnRbaV0gPSBmYWxzZVxuICB9XG4gIHZhciBhY3RpdmUgPSBbXVxuICB2YXIgbmV4dCAgID0gW11cbiAgZm9yKHZhciBpPTA7IGk8Y2VsbHMubGVuZ3RoOyArK2kpIHtcbiAgICB2YXIgYyA9IGNlbGxzW2ldXG4gICAgZmxhZ3NbaV0gPSAwXG4gICAgZm9yKHZhciBqPTA7IGo8MzsgKytqKSB7XG4gICAgICB2YXIgYSA9IGNbKGorMSklM11cbiAgICAgIHZhciBiID0gY1soaisyKSUzXVxuICAgICAgdmFyIGNvbnN0ciA9IGNvbnN0cmFpbnRbMyppK2pdID0gaXNDb25zdHJhaW50KGVkZ2VzLCBhLCBiKVxuICAgICAgaWYoYWRqWzMqaStqXSA+PSAwKSB7XG4gICAgICAgIGNvbnRpbnVlXG4gICAgICB9XG4gICAgICBpZihjb25zdHIpIHtcbiAgICAgICAgbmV4dC5wdXNoKGkpXG4gICAgICB9IGVsc2Uge1xuICAgICAgICBmbGFnc1tpXSA9IDFcbiAgICAgICAgYWN0aXZlLnB1c2goaSlcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICAvL01hcmsgZmxhZ3NcbiAgdmFyIHNpZGUgPSAxXG4gIHdoaWxlKGFjdGl2ZS5sZW5ndGggPiAwIHx8IG5leHQubGVuZ3RoID4gMCkge1xuICAgIHdoaWxlKGFjdGl2ZS5sZW5ndGggPiAwKSB7XG4gICAgICB2YXIgdCA9IGFjdGl2ZS5wb3AoKVxuICAgICAgaWYoZmxhZ3NbdF0gPT09IC1zaWRlKSB7XG4gICAgICAgIGNvbnRpbnVlXG4gICAgICB9XG4gICAgICBmbGFnc1t0XSA9IHNpZGVcbiAgICAgIHZhciBjID0gY2VsbHNbdF1cbiAgICAgIGZvcih2YXIgaj0wOyBqPDM7ICsraikge1xuICAgICAgICB2YXIgZiA9IGFkalszKnQral1cbiAgICAgICAgaWYoZiA+PSAwICYmIGZsYWdzW2ZdID09PSAwKSB7XG4gICAgICAgICAgaWYoY29uc3RyYWludFszKnQral0pIHtcbiAgICAgICAgICAgIG5leHQucHVzaChmKVxuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBhY3RpdmUucHVzaChmKVxuICAgICAgICAgICAgZmxhZ3NbZl0gPSBzaWRlXG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy9Td2FwIGFycmF5cyBhbmQgbG9vcFxuICAgIHZhciB0bXAgPSBuZXh0XG4gICAgbmV4dCA9IGFjdGl2ZVxuICAgIGFjdGl2ZSA9IHRtcFxuICAgIG5leHQubGVuZ3RoID0gMFxuICAgIHNpZGUgPSAtc2lkZVxuICB9XG5cbiAgcmV0dXJuIGZsYWdzXG59XG5cbmZ1bmN0aW9uIHNldEludGVyc2VjdChjb2xvcmVkLCBlZGdlcykge1xuICB2YXIgcHRyID0gMFxuICBmb3IodmFyIGk9MCxqPTA7IGk8Y29sb3JlZC5sZW5ndGgmJmo8ZWRnZXMubGVuZ3RoOyApIHtcbiAgICB2YXIgZSA9IGNvbG9yZWRbaV1cbiAgICB2YXIgZiA9IGVkZ2VzW2pdXG4gICAgdmFyIGQgPSBlWzBdLWZbMF0gfHwgZVsxXS1mWzFdXG4gICAgaWYoZCA8IDApIHtcbiAgICAgIGkgKz0gMVxuICAgIH0gZWxzZSBpZihkID4gMCkge1xuICAgICAgaiArPSAxXG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbG9yZWRbcHRyKytdID0gY29sb3JlZFtpXVxuICAgICAgaSArPSAxXG4gICAgICBqICs9IDFcbiAgICB9XG4gIH1cbiAgY29sb3JlZC5sZW5ndGggPSBwdHJcbiAgcmV0dXJuIGNvbG9yZWRcbn1cblxuZnVuY3Rpb24gcmVsYWJlbEVkZ2VzKGVkZ2VzLCBsYWJlbHMpIHtcbiAgZm9yKHZhciBpPTA7IGk8ZWRnZXMubGVuZ3RoOyArK2kpIHtcbiAgICB2YXIgZSA9IGVkZ2VzW2ldXG4gICAgZVswXSA9IGxhYmVsc1tlWzBdXVxuICAgIGVbMV0gPSBsYWJlbHNbZVsxXV1cbiAgfVxufVxuXG5mdW5jdGlvbiBtYXJrRWRnZXNBY3RpdmUoZWRnZXMsIGxhYmVscykge1xuICBmb3IodmFyIGk9MDsgaTxlZGdlcy5sZW5ndGg7ICsraSkge1xuICAgIHZhciBlID0gZWRnZXNbaV1cbiAgICBsYWJlbHNbZVswXV0gPSBsYWJlbHNbZVsxXV0gPSAxXG4gIH1cbn1cblxuZnVuY3Rpb24gcmVtb3ZlVW51c2VkUG9pbnRzKHBvaW50cywgcmVkRSwgYmx1ZUUpIHtcbiAgdmFyIGxhYmVscyA9IG5ldyBBcnJheShwb2ludHMubGVuZ3RoKVxuICBmb3IodmFyIGk9MDsgaTxsYWJlbHMubGVuZ3RoOyArK2kpIHtcbiAgICBsYWJlbHNbaV0gPSAtMVxuICB9XG4gIG1hcmtFZGdlc0FjdGl2ZShyZWRFLCBsYWJlbHMpXG4gIG1hcmtFZGdlc0FjdGl2ZShibHVlRSwgbGFiZWxzKVxuXG4gIHZhciBwdHIgPSAwXG4gIGZvcih2YXIgaT0wOyBpPHBvaW50cy5sZW5ndGg7ICsraSkge1xuICAgIGlmKGxhYmVsc1tpXSA+IDApIHtcbiAgICAgIGxhYmVsc1tpXSA9IHB0clxuICAgICAgcG9pbnRzW3B0cisrXSA9IHBvaW50c1tpXVxuICAgIH1cbiAgfVxuICBwb2ludHMubGVuZ3RoID0gcHRyXG4gIHJlbGFiZWxFZGdlcyhyZWRFLCBsYWJlbHMpXG4gIHJlbGFiZWxFZGdlcyhibHVlRSwgbGFiZWxzKVxufVxuXG5mdW5jdGlvbiBvdmVybGF5UFNMRyhyZWRQb2ludHMsIHJlZEVkZ2VzLCBibHVlUG9pbnRzLCBibHVlRWRnZXMsIG9wKSB7XG4gIC8vMS4gIGNvbmNhdGVuYXRlIHBvaW50c1xuICB2YXIgbnVtUmVkUG9pbnRzID0gcmVkUG9pbnRzLmxlbmd0aFxuICB2YXIgcG9pbnRzID0gcmVkUG9pbnRzLmNvbmNhdChibHVlUG9pbnRzKVxuXG4gIC8vMi4gIGNvbmNhdGVuYXRlIGVkZ2VzXG4gIHZhciBudW1SZWRFZGdlcyAgPSByZWRFZGdlcy5sZW5ndGhcbiAgdmFyIG51bUJsdWVFZGdlcyA9IGJsdWVFZGdlcy5sZW5ndGhcbiAgdmFyIGVkZ2VzICAgICAgICA9IG5ldyBBcnJheShudW1SZWRFZGdlcyArIG51bUJsdWVFZGdlcylcbiAgdmFyIGNvbG9ycyAgICAgICA9IG5ldyBBcnJheShudW1SZWRFZGdlcyArIG51bUJsdWVFZGdlcylcbiAgZm9yKHZhciBpPTA7IGk8cmVkRWRnZXMubGVuZ3RoOyArK2kpIHtcbiAgICB2YXIgZSAgICAgID0gcmVkRWRnZXNbaV1cbiAgICBjb2xvcnNbaV0gID0gUkVEXG4gICAgZWRnZXNbaV0gICA9IFsgZVswXSwgZVsxXSBdXG4gIH1cbiAgZm9yKHZhciBpPTA7IGk8Ymx1ZUVkZ2VzLmxlbmd0aDsgKytpKSB7XG4gICAgdmFyIGUgICAgICA9IGJsdWVFZGdlc1tpXVxuICAgIGNvbG9yc1tpK251bVJlZEVkZ2VzXSAgPSBCTFVFXG4gICAgZWRnZXNbaStudW1SZWRFZGdlc10gICA9IFsgZVswXStudW1SZWRQb2ludHMsIGVbMV0rbnVtUmVkUG9pbnRzIF1cbiAgfVxuXG4gIC8vMy4gIHJ1biBzbmFwIHJvdW5kaW5nIHdpdGggZWRnZSBjb2xvcnNcbiAgc25hcFJvdW5kKHBvaW50cywgZWRnZXMsIGNvbG9ycylcblxuICAvLzQuIFNvcnQgZWRnZXNcbiAgY2Fub25pY2FsaXplRWRnZXMoZWRnZXMpXG5cbiAgLy81LiAgZXh0cmFjdCByZWQgYW5kIGJsdWUgZWRnZXNcbiAgdmFyIHJlZEUgPSBbXSwgYmx1ZUUgPSBbXVxuICBmb3IodmFyIGk9MDsgaTxlZGdlcy5sZW5ndGg7ICsraSkge1xuICAgIGlmKGNvbG9yc1tpXSA9PT0gUkVEKSB7XG4gICAgICByZWRFLnB1c2goZWRnZXNbaV0pXG4gICAgfSBlbHNlIHtcbiAgICAgIGJsdWVFLnB1c2goZWRnZXNbaV0pXG4gICAgfVxuICB9XG5cbiAgLy82LiAgdHJpYW5ndWxhdGVcbiAgdmFyIGNlbGxzID0gY2R0MmQocG9pbnRzLCBlZGdlcywgeyBkZWxhdW5heTogZmFsc2UgfSlcblxuICAvLzcuIGJ1aWxkIGFkamFjZW5jeSBkYXRhIHN0cnVjdHVyZVxuICB2YXIgYWRqID0gYnVpbGRDZWxsSW5kZXgoY2VsbHMpXG5cbiAgLy84LiBjbGFzc2lmeSB0cmlhbmdsZXNcbiAgdmFyIHJlZEZsYWdzID0gbWFya0NlbGxzKGNlbGxzLCBhZGosIHJlZEUpXG4gIHZhciBibHVlRmxhZ3MgPSBtYXJrQ2VsbHMoY2VsbHMsIGFkaiwgYmx1ZUUpXG5cbiAgLy85LiBmaWx0ZXIgb3V0IGNlbHMgd2hpY2ggYXJlIG5vdCBwYXJ0IG9mIHRyaWFuZ3VsYXRpb25cbiAgdmFyIHRhYmxlID0gZ2V0VGFibGUob3ApXG4gIHZhciBwdHIgPSAwXG4gIGZvcih2YXIgaT0wOyBpPGNlbGxzLmxlbmd0aDsgKytpKSB7XG4gICAgdmFyIGNvZGUgPSAoKHJlZEZsYWdzW2ldIDwgMCk8PDEpICsgKGJsdWVGbGFnc1tpXSA8IDApXG4gICAgaWYodGFibGVbY29kZV0pIHtcbiAgICAgIGNlbGxzW3B0cisrXSA9IGNlbGxzW2ldXG4gICAgfVxuICB9XG4gIGNlbGxzLmxlbmd0aCA9IHB0clxuXG4gIC8vMTAuIGV4dHJhY3QgYm91bmRhcnlcbiAgdmFyIGJuZCA9IGJvdW5kYXJ5KGNlbGxzKVxuICBjYW5vbmljYWxpemVFZGdlcyhibmQpXG5cbiAgLy8xMS4gSW50ZXJzZWN0IGNvbnN0cmFpbnQgZWRnZXMgd2l0aCBib3VuZGFyeVxuICByZWRFID0gc2V0SW50ZXJzZWN0KHJlZEUsIGJuZClcbiAgYmx1ZUUgPSBzZXRJbnRlcnNlY3QoYmx1ZUUsIGJuZClcblxuICAvLzEyLiBmaWx0ZXIgb2xkIHBvaW50c1xuICByZW1vdmVVbnVzZWRQb2ludHMocG9pbnRzLCByZWRFLCBibHVlRSlcblxuICByZXR1cm4ge1xuICAgIHBvaW50czogcG9pbnRzLFxuICAgIHJlZDogICAgcmVkRSxcbiAgICBibHVlOiAgIGJsdWVFXG4gIH1cbn1cbiIsInZhciBoYXNUeXBlZEFycmF5cyA9IGZhbHNlXG5pZih0eXBlb2YgRmxvYXQ2NEFycmF5ICE9PSBcInVuZGVmaW5lZFwiKSB7XG4gIHZhciBET1VCTEVfVklFVyA9IG5ldyBGbG9hdDY0QXJyYXkoMSlcbiAgICAsIFVJTlRfVklFVyAgID0gbmV3IFVpbnQzMkFycmF5KERPVUJMRV9WSUVXLmJ1ZmZlcilcbiAgRE9VQkxFX1ZJRVdbMF0gPSAxLjBcbiAgaGFzVHlwZWRBcnJheXMgPSB0cnVlXG4gIGlmKFVJTlRfVklFV1sxXSA9PT0gMHgzZmYwMDAwMCkge1xuICAgIC8vVXNlIGxpdHRsZSBlbmRpYW5cbiAgICBtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGRvdWJsZUJpdHNMRShuKSB7XG4gICAgICBET1VCTEVfVklFV1swXSA9IG5cbiAgICAgIHJldHVybiBbIFVJTlRfVklFV1swXSwgVUlOVF9WSUVXWzFdIF1cbiAgICB9XG4gICAgZnVuY3Rpb24gdG9Eb3VibGVMRShsbywgaGkpIHtcbiAgICAgIFVJTlRfVklFV1swXSA9IGxvXG4gICAgICBVSU5UX1ZJRVdbMV0gPSBoaVxuICAgICAgcmV0dXJuIERPVUJMRV9WSUVXWzBdXG4gICAgfVxuICAgIG1vZHVsZS5leHBvcnRzLnBhY2sgPSB0b0RvdWJsZUxFXG4gICAgZnVuY3Rpb24gbG93VWludExFKG4pIHtcbiAgICAgIERPVUJMRV9WSUVXWzBdID0gblxuICAgICAgcmV0dXJuIFVJTlRfVklFV1swXVxuICAgIH1cbiAgICBtb2R1bGUuZXhwb3J0cy5sbyA9IGxvd1VpbnRMRVxuICAgIGZ1bmN0aW9uIGhpZ2hVaW50TEUobikge1xuICAgICAgRE9VQkxFX1ZJRVdbMF0gPSBuXG4gICAgICByZXR1cm4gVUlOVF9WSUVXWzFdXG4gICAgfVxuICAgIG1vZHVsZS5leHBvcnRzLmhpID0gaGlnaFVpbnRMRVxuICB9IGVsc2UgaWYoVUlOVF9WSUVXWzBdID09PSAweDNmZjAwMDAwKSB7XG4gICAgLy9Vc2UgYmlnIGVuZGlhblxuICAgIG1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gZG91YmxlQml0c0JFKG4pIHtcbiAgICAgIERPVUJMRV9WSUVXWzBdID0gblxuICAgICAgcmV0dXJuIFsgVUlOVF9WSUVXWzFdLCBVSU5UX1ZJRVdbMF0gXVxuICAgIH1cbiAgICBmdW5jdGlvbiB0b0RvdWJsZUJFKGxvLCBoaSkge1xuICAgICAgVUlOVF9WSUVXWzFdID0gbG9cbiAgICAgIFVJTlRfVklFV1swXSA9IGhpXG4gICAgICByZXR1cm4gRE9VQkxFX1ZJRVdbMF1cbiAgICB9XG4gICAgbW9kdWxlLmV4cG9ydHMucGFjayA9IHRvRG91YmxlQkVcbiAgICBmdW5jdGlvbiBsb3dVaW50QkUobikge1xuICAgICAgRE9VQkxFX1ZJRVdbMF0gPSBuXG4gICAgICByZXR1cm4gVUlOVF9WSUVXWzFdXG4gICAgfVxuICAgIG1vZHVsZS5leHBvcnRzLmxvID0gbG93VWludEJFXG4gICAgZnVuY3Rpb24gaGlnaFVpbnRCRShuKSB7XG4gICAgICBET1VCTEVfVklFV1swXSA9IG5cbiAgICAgIHJldHVybiBVSU5UX1ZJRVdbMF1cbiAgICB9XG4gICAgbW9kdWxlLmV4cG9ydHMuaGkgPSBoaWdoVWludEJFXG4gIH0gZWxzZSB7XG4gICAgaGFzVHlwZWRBcnJheXMgPSBmYWxzZVxuICB9XG59XG5pZighaGFzVHlwZWRBcnJheXMpIHtcbiAgdmFyIGJ1ZmZlciA9IG5ldyBCdWZmZXIoOClcbiAgbW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBkb3VibGVCaXRzKG4pIHtcbiAgICBidWZmZXIud3JpdGVEb3VibGVMRShuLCAwLCB0cnVlKVxuICAgIHJldHVybiBbIGJ1ZmZlci5yZWFkVUludDMyTEUoMCwgdHJ1ZSksIGJ1ZmZlci5yZWFkVUludDMyTEUoNCwgdHJ1ZSkgXVxuICB9XG4gIGZ1bmN0aW9uIHRvRG91YmxlKGxvLCBoaSkge1xuICAgIGJ1ZmZlci53cml0ZVVJbnQzMkxFKGxvLCAwLCB0cnVlKVxuICAgIGJ1ZmZlci53cml0ZVVJbnQzMkxFKGhpLCA0LCB0cnVlKVxuICAgIHJldHVybiBidWZmZXIucmVhZERvdWJsZUxFKDAsIHRydWUpXG4gIH1cbiAgbW9kdWxlLmV4cG9ydHMucGFjayA9IHRvRG91YmxlICBcbiAgZnVuY3Rpb24gbG93VWludChuKSB7XG4gICAgYnVmZmVyLndyaXRlRG91YmxlTEUobiwgMCwgdHJ1ZSlcbiAgICByZXR1cm4gYnVmZmVyLnJlYWRVSW50MzJMRSgwLCB0cnVlKVxuICB9XG4gIG1vZHVsZS5leHBvcnRzLmxvID0gbG93VWludFxuICBmdW5jdGlvbiBoaWdoVWludChuKSB7XG4gICAgYnVmZmVyLndyaXRlRG91YmxlTEUobiwgMCwgdHJ1ZSlcbiAgICByZXR1cm4gYnVmZmVyLnJlYWRVSW50MzJMRSg0LCB0cnVlKVxuICB9XG4gIG1vZHVsZS5leHBvcnRzLmhpID0gaGlnaFVpbnRcbn1cblxubW9kdWxlLmV4cG9ydHMuc2lnbiA9IGZ1bmN0aW9uKG4pIHtcbiAgcmV0dXJuIG1vZHVsZS5leHBvcnRzLmhpKG4pID4+PiAzMVxufVxuXG5tb2R1bGUuZXhwb3J0cy5leHBvbmVudCA9IGZ1bmN0aW9uKG4pIHtcbiAgdmFyIGIgPSBtb2R1bGUuZXhwb3J0cy5oaShuKVxuICByZXR1cm4gKChiPDwxKSA+Pj4gMjEpIC0gMTAyM1xufVxuXG5tb2R1bGUuZXhwb3J0cy5mcmFjdGlvbiA9IGZ1bmN0aW9uKG4pIHtcbiAgdmFyIGxvID0gbW9kdWxlLmV4cG9ydHMubG8obilcbiAgdmFyIGhpID0gbW9kdWxlLmV4cG9ydHMuaGkobilcbiAgdmFyIGIgPSBoaSAmICgoMTw8MjApIC0gMSlcbiAgaWYoaGkgJiAweDdmZjAwMDAwKSB7XG4gICAgYiArPSAoMTw8MjApXG4gIH1cbiAgcmV0dXJuIFtsbywgYl1cbn1cblxubW9kdWxlLmV4cG9ydHMuZGVub3JtYWxpemVkID0gZnVuY3Rpb24obikge1xuICB2YXIgaGkgPSBtb2R1bGUuZXhwb3J0cy5oaShuKVxuICByZXR1cm4gIShoaSAmIDB4N2ZmMDAwMDApXG59IiwiJ3VzZSBzdHJpY3QnXG5cbnZhciBiaXRzID0gcmVxdWlyZSgnYml0LXR3aWRkbGUnKVxudmFyIGR1cCA9IHJlcXVpcmUoJ2R1cCcpXG5cbi8vTGVnYWN5IHBvb2wgc3VwcG9ydFxuaWYoIWdsb2JhbC5fX1RZUEVEQVJSQVlfUE9PTCkge1xuICBnbG9iYWwuX19UWVBFREFSUkFZX1BPT0wgPSB7XG4gICAgICBVSU5UOCAgIDogZHVwKFszMiwgMF0pXG4gICAgLCBVSU5UMTYgIDogZHVwKFszMiwgMF0pXG4gICAgLCBVSU5UMzIgIDogZHVwKFszMiwgMF0pXG4gICAgLCBJTlQ4ICAgIDogZHVwKFszMiwgMF0pXG4gICAgLCBJTlQxNiAgIDogZHVwKFszMiwgMF0pXG4gICAgLCBJTlQzMiAgIDogZHVwKFszMiwgMF0pXG4gICAgLCBGTE9BVCAgIDogZHVwKFszMiwgMF0pXG4gICAgLCBET1VCTEUgIDogZHVwKFszMiwgMF0pXG4gICAgLCBEQVRBICAgIDogZHVwKFszMiwgMF0pXG4gICAgLCBVSU5UOEMgIDogZHVwKFszMiwgMF0pXG4gICAgLCBCVUZGRVIgIDogZHVwKFszMiwgMF0pXG4gIH1cbn1cblxudmFyIGhhc1VpbnQ4QyA9ICh0eXBlb2YgVWludDhDbGFtcGVkQXJyYXkpICE9PSAndW5kZWZpbmVkJ1xudmFyIFBPT0wgPSBnbG9iYWwuX19UWVBFREFSUkFZX1BPT0xcblxuLy9VcGdyYWRlIHBvb2xcbmlmKCFQT09MLlVJTlQ4Qykge1xuICBQT09MLlVJTlQ4QyA9IGR1cChbMzIsIDBdKVxufVxuaWYoIVBPT0wuQlVGRkVSKSB7XG4gIFBPT0wuQlVGRkVSID0gZHVwKFszMiwgMF0pXG59XG5cbi8vTmV3IHRlY2huaXF1ZTogT25seSBhbGxvY2F0ZSBmcm9tIEFycmF5QnVmZmVyVmlldyBhbmQgQnVmZmVyXG52YXIgREFUQSAgICA9IFBPT0wuREFUQVxuICAsIEJVRkZFUiAgPSBQT09MLkJVRkZFUlxuXG5leHBvcnRzLmZyZWUgPSBmdW5jdGlvbiBmcmVlKGFycmF5KSB7XG4gIGlmKEJ1ZmZlci5pc0J1ZmZlcihhcnJheSkpIHtcbiAgICBCVUZGRVJbYml0cy5sb2cyKGFycmF5Lmxlbmd0aCldLnB1c2goYXJyYXkpXG4gIH0gZWxzZSB7XG4gICAgaWYoT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKGFycmF5KSAhPT0gJ1tvYmplY3QgQXJyYXlCdWZmZXJdJykge1xuICAgICAgYXJyYXkgPSBhcnJheS5idWZmZXJcbiAgICB9XG4gICAgaWYoIWFycmF5KSB7XG4gICAgICByZXR1cm5cbiAgICB9XG4gICAgdmFyIG4gPSBhcnJheS5sZW5ndGggfHwgYXJyYXkuYnl0ZUxlbmd0aFxuICAgIHZhciBsb2dfbiA9IGJpdHMubG9nMihuKXwwXG4gICAgREFUQVtsb2dfbl0ucHVzaChhcnJheSlcbiAgfVxufVxuXG5mdW5jdGlvbiBmcmVlQXJyYXlCdWZmZXIoYnVmZmVyKSB7XG4gIGlmKCFidWZmZXIpIHtcbiAgICByZXR1cm5cbiAgfVxuICB2YXIgbiA9IGJ1ZmZlci5sZW5ndGggfHwgYnVmZmVyLmJ5dGVMZW5ndGhcbiAgdmFyIGxvZ19uID0gYml0cy5sb2cyKG4pXG4gIERBVEFbbG9nX25dLnB1c2goYnVmZmVyKVxufVxuXG5mdW5jdGlvbiBmcmVlVHlwZWRBcnJheShhcnJheSkge1xuICBmcmVlQXJyYXlCdWZmZXIoYXJyYXkuYnVmZmVyKVxufVxuXG5leHBvcnRzLmZyZWVVaW50OCA9XG5leHBvcnRzLmZyZWVVaW50MTYgPVxuZXhwb3J0cy5mcmVlVWludDMyID1cbmV4cG9ydHMuZnJlZUludDggPVxuZXhwb3J0cy5mcmVlSW50MTYgPVxuZXhwb3J0cy5mcmVlSW50MzIgPVxuZXhwb3J0cy5mcmVlRmxvYXQzMiA9IFxuZXhwb3J0cy5mcmVlRmxvYXQgPVxuZXhwb3J0cy5mcmVlRmxvYXQ2NCA9IFxuZXhwb3J0cy5mcmVlRG91YmxlID0gXG5leHBvcnRzLmZyZWVVaW50OENsYW1wZWQgPSBcbmV4cG9ydHMuZnJlZURhdGFWaWV3ID0gZnJlZVR5cGVkQXJyYXlcblxuZXhwb3J0cy5mcmVlQXJyYXlCdWZmZXIgPSBmcmVlQXJyYXlCdWZmZXJcblxuZXhwb3J0cy5mcmVlQnVmZmVyID0gZnVuY3Rpb24gZnJlZUJ1ZmZlcihhcnJheSkge1xuICBCVUZGRVJbYml0cy5sb2cyKGFycmF5Lmxlbmd0aCldLnB1c2goYXJyYXkpXG59XG5cbmV4cG9ydHMubWFsbG9jID0gZnVuY3Rpb24gbWFsbG9jKG4sIGR0eXBlKSB7XG4gIGlmKGR0eXBlID09PSB1bmRlZmluZWQgfHwgZHR5cGUgPT09ICdhcnJheWJ1ZmZlcicpIHtcbiAgICByZXR1cm4gbWFsbG9jQXJyYXlCdWZmZXIobilcbiAgfSBlbHNlIHtcbiAgICBzd2l0Y2goZHR5cGUpIHtcbiAgICAgIGNhc2UgJ3VpbnQ4JzpcbiAgICAgICAgcmV0dXJuIG1hbGxvY1VpbnQ4KG4pXG4gICAgICBjYXNlICd1aW50MTYnOlxuICAgICAgICByZXR1cm4gbWFsbG9jVWludDE2KG4pXG4gICAgICBjYXNlICd1aW50MzInOlxuICAgICAgICByZXR1cm4gbWFsbG9jVWludDMyKG4pXG4gICAgICBjYXNlICdpbnQ4JzpcbiAgICAgICAgcmV0dXJuIG1hbGxvY0ludDgobilcbiAgICAgIGNhc2UgJ2ludDE2JzpcbiAgICAgICAgcmV0dXJuIG1hbGxvY0ludDE2KG4pXG4gICAgICBjYXNlICdpbnQzMic6XG4gICAgICAgIHJldHVybiBtYWxsb2NJbnQzMihuKVxuICAgICAgY2FzZSAnZmxvYXQnOlxuICAgICAgY2FzZSAnZmxvYXQzMic6XG4gICAgICAgIHJldHVybiBtYWxsb2NGbG9hdChuKVxuICAgICAgY2FzZSAnZG91YmxlJzpcbiAgICAgIGNhc2UgJ2Zsb2F0NjQnOlxuICAgICAgICByZXR1cm4gbWFsbG9jRG91YmxlKG4pXG4gICAgICBjYXNlICd1aW50OF9jbGFtcGVkJzpcbiAgICAgICAgcmV0dXJuIG1hbGxvY1VpbnQ4Q2xhbXBlZChuKVxuICAgICAgY2FzZSAnYnVmZmVyJzpcbiAgICAgICAgcmV0dXJuIG1hbGxvY0J1ZmZlcihuKVxuICAgICAgY2FzZSAnZGF0YSc6XG4gICAgICBjYXNlICdkYXRhdmlldyc6XG4gICAgICAgIHJldHVybiBtYWxsb2NEYXRhVmlldyhuKVxuXG4gICAgICBkZWZhdWx0OlxuICAgICAgICByZXR1cm4gbnVsbFxuICAgIH1cbiAgfVxuICByZXR1cm4gbnVsbFxufVxuXG5mdW5jdGlvbiBtYWxsb2NBcnJheUJ1ZmZlcihuKSB7XG4gIHZhciBuID0gYml0cy5uZXh0UG93MihuKVxuICB2YXIgbG9nX24gPSBiaXRzLmxvZzIobilcbiAgdmFyIGQgPSBEQVRBW2xvZ19uXVxuICBpZihkLmxlbmd0aCA+IDApIHtcbiAgICByZXR1cm4gZC5wb3AoKVxuICB9XG4gIHJldHVybiBuZXcgQXJyYXlCdWZmZXIobilcbn1cbmV4cG9ydHMubWFsbG9jQXJyYXlCdWZmZXIgPSBtYWxsb2NBcnJheUJ1ZmZlclxuXG5mdW5jdGlvbiBtYWxsb2NVaW50OChuKSB7XG4gIHJldHVybiBuZXcgVWludDhBcnJheShtYWxsb2NBcnJheUJ1ZmZlcihuKSwgMCwgbilcbn1cbmV4cG9ydHMubWFsbG9jVWludDggPSBtYWxsb2NVaW50OFxuXG5mdW5jdGlvbiBtYWxsb2NVaW50MTYobikge1xuICByZXR1cm4gbmV3IFVpbnQxNkFycmF5KG1hbGxvY0FycmF5QnVmZmVyKDIqbiksIDAsIG4pXG59XG5leHBvcnRzLm1hbGxvY1VpbnQxNiA9IG1hbGxvY1VpbnQxNlxuXG5mdW5jdGlvbiBtYWxsb2NVaW50MzIobikge1xuICByZXR1cm4gbmV3IFVpbnQzMkFycmF5KG1hbGxvY0FycmF5QnVmZmVyKDQqbiksIDAsIG4pXG59XG5leHBvcnRzLm1hbGxvY1VpbnQzMiA9IG1hbGxvY1VpbnQzMlxuXG5mdW5jdGlvbiBtYWxsb2NJbnQ4KG4pIHtcbiAgcmV0dXJuIG5ldyBJbnQ4QXJyYXkobWFsbG9jQXJyYXlCdWZmZXIobiksIDAsIG4pXG59XG5leHBvcnRzLm1hbGxvY0ludDggPSBtYWxsb2NJbnQ4XG5cbmZ1bmN0aW9uIG1hbGxvY0ludDE2KG4pIHtcbiAgcmV0dXJuIG5ldyBJbnQxNkFycmF5KG1hbGxvY0FycmF5QnVmZmVyKDIqbiksIDAsIG4pXG59XG5leHBvcnRzLm1hbGxvY0ludDE2ID0gbWFsbG9jSW50MTZcblxuZnVuY3Rpb24gbWFsbG9jSW50MzIobikge1xuICByZXR1cm4gbmV3IEludDMyQXJyYXkobWFsbG9jQXJyYXlCdWZmZXIoNCpuKSwgMCwgbilcbn1cbmV4cG9ydHMubWFsbG9jSW50MzIgPSBtYWxsb2NJbnQzMlxuXG5mdW5jdGlvbiBtYWxsb2NGbG9hdChuKSB7XG4gIHJldHVybiBuZXcgRmxvYXQzMkFycmF5KG1hbGxvY0FycmF5QnVmZmVyKDQqbiksIDAsIG4pXG59XG5leHBvcnRzLm1hbGxvY0Zsb2F0MzIgPSBleHBvcnRzLm1hbGxvY0Zsb2F0ID0gbWFsbG9jRmxvYXRcblxuZnVuY3Rpb24gbWFsbG9jRG91YmxlKG4pIHtcbiAgcmV0dXJuIG5ldyBGbG9hdDY0QXJyYXkobWFsbG9jQXJyYXlCdWZmZXIoOCpuKSwgMCwgbilcbn1cbmV4cG9ydHMubWFsbG9jRmxvYXQ2NCA9IGV4cG9ydHMubWFsbG9jRG91YmxlID0gbWFsbG9jRG91YmxlXG5cbmZ1bmN0aW9uIG1hbGxvY1VpbnQ4Q2xhbXBlZChuKSB7XG4gIGlmKGhhc1VpbnQ4Qykge1xuICAgIHJldHVybiBuZXcgVWludDhDbGFtcGVkQXJyYXkobWFsbG9jQXJyYXlCdWZmZXIobiksIDAsIG4pXG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIG1hbGxvY1VpbnQ4KG4pXG4gIH1cbn1cbmV4cG9ydHMubWFsbG9jVWludDhDbGFtcGVkID0gbWFsbG9jVWludDhDbGFtcGVkXG5cbmZ1bmN0aW9uIG1hbGxvY0RhdGFWaWV3KG4pIHtcbiAgcmV0dXJuIG5ldyBEYXRhVmlldyhtYWxsb2NBcnJheUJ1ZmZlcihuKSwgMCwgbilcbn1cbmV4cG9ydHMubWFsbG9jRGF0YVZpZXcgPSBtYWxsb2NEYXRhVmlld1xuXG5mdW5jdGlvbiBtYWxsb2NCdWZmZXIobikge1xuICBuID0gYml0cy5uZXh0UG93MihuKVxuICB2YXIgbG9nX24gPSBiaXRzLmxvZzIobilcbiAgdmFyIGNhY2hlID0gQlVGRkVSW2xvZ19uXVxuICBpZihjYWNoZS5sZW5ndGggPiAwKSB7XG4gICAgcmV0dXJuIGNhY2hlLnBvcCgpXG4gIH1cbiAgcmV0dXJuIG5ldyBCdWZmZXIobilcbn1cbmV4cG9ydHMubWFsbG9jQnVmZmVyID0gbWFsbG9jQnVmZmVyXG5cbmV4cG9ydHMuY2xlYXJDYWNoZSA9IGZ1bmN0aW9uIGNsZWFyQ2FjaGUoKSB7XG4gIGZvcih2YXIgaT0wOyBpPDMyOyArK2kpIHtcbiAgICBQT09MLlVJTlQ4W2ldLmxlbmd0aCA9IDBcbiAgICBQT09MLlVJTlQxNltpXS5sZW5ndGggPSAwXG4gICAgUE9PTC5VSU5UMzJbaV0ubGVuZ3RoID0gMFxuICAgIFBPT0wuSU5UOFtpXS5sZW5ndGggPSAwXG4gICAgUE9PTC5JTlQxNltpXS5sZW5ndGggPSAwXG4gICAgUE9PTC5JTlQzMltpXS5sZW5ndGggPSAwXG4gICAgUE9PTC5GTE9BVFtpXS5sZW5ndGggPSAwXG4gICAgUE9PTC5ET1VCTEVbaV0ubGVuZ3RoID0gMFxuICAgIFBPT0wuVUlOVDhDW2ldLmxlbmd0aCA9IDBcbiAgICBEQVRBW2ldLmxlbmd0aCA9IDBcbiAgICBCVUZGRVJbaV0ubGVuZ3RoID0gMFxuICB9XG59IiwidmFyIGhhc1R5cGVkQXJyYXlzID0gZmFsc2VcbmlmKHR5cGVvZiBGbG9hdDY0QXJyYXkgIT09IFwidW5kZWZpbmVkXCIpIHtcbiAgdmFyIERPVUJMRV9WSUVXID0gbmV3IEZsb2F0NjRBcnJheSgxKVxuICAgICwgVUlOVF9WSUVXICAgPSBuZXcgVWludDMyQXJyYXkoRE9VQkxFX1ZJRVcuYnVmZmVyKVxuICBET1VCTEVfVklFV1swXSA9IDEuMFxuICBoYXNUeXBlZEFycmF5cyA9IHRydWVcbiAgaWYoVUlOVF9WSUVXWzFdID09PSAweDNmZjAwMDAwKSB7XG4gICAgLy9Vc2UgbGl0dGxlIGVuZGlhblxuICAgIG1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gZG91YmxlQml0c0xFKG4pIHtcbiAgICAgIERPVUJMRV9WSUVXWzBdID0gblxuICAgICAgcmV0dXJuIFsgVUlOVF9WSUVXWzBdLCBVSU5UX1ZJRVdbMV0gXVxuICAgIH1cbiAgICBmdW5jdGlvbiB0b0RvdWJsZUxFKGxvLCBoaSkge1xuICAgICAgVUlOVF9WSUVXWzBdID0gbG9cbiAgICAgIFVJTlRfVklFV1sxXSA9IGhpXG4gICAgICByZXR1cm4gRE9VQkxFX1ZJRVdbMF1cbiAgICB9XG4gICAgbW9kdWxlLmV4cG9ydHMucGFjayA9IHRvRG91YmxlTEVcbiAgICBmdW5jdGlvbiBsb3dVaW50TEUobikge1xuICAgICAgRE9VQkxFX1ZJRVdbMF0gPSBuXG4gICAgICByZXR1cm4gVUlOVF9WSUVXWzBdXG4gICAgfVxuICAgIG1vZHVsZS5leHBvcnRzLmxvID0gbG93VWludExFXG4gICAgZnVuY3Rpb24gaGlnaFVpbnRMRShuKSB7XG4gICAgICBET1VCTEVfVklFV1swXSA9IG5cbiAgICAgIHJldHVybiBVSU5UX1ZJRVdbMV1cbiAgICB9XG4gICAgbW9kdWxlLmV4cG9ydHMuaGkgPSBoaWdoVWludExFXG4gIH0gZWxzZSBpZihVSU5UX1ZJRVdbMF0gPT09IDB4M2ZmMDAwMDApIHtcbiAgICAvL1VzZSBiaWcgZW5kaWFuXG4gICAgbW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBkb3VibGVCaXRzQkUobikge1xuICAgICAgRE9VQkxFX1ZJRVdbMF0gPSBuXG4gICAgICByZXR1cm4gWyBVSU5UX1ZJRVdbMV0sIFVJTlRfVklFV1swXSBdXG4gICAgfVxuICAgIGZ1bmN0aW9uIHRvRG91YmxlQkUobG8sIGhpKSB7XG4gICAgICBVSU5UX1ZJRVdbMV0gPSBsb1xuICAgICAgVUlOVF9WSUVXWzBdID0gaGlcbiAgICAgIHJldHVybiBET1VCTEVfVklFV1swXVxuICAgIH1cbiAgICBtb2R1bGUuZXhwb3J0cy5wYWNrID0gdG9Eb3VibGVCRVxuICAgIGZ1bmN0aW9uIGxvd1VpbnRCRShuKSB7XG4gICAgICBET1VCTEVfVklFV1swXSA9IG5cbiAgICAgIHJldHVybiBVSU5UX1ZJRVdbMV1cbiAgICB9XG4gICAgbW9kdWxlLmV4cG9ydHMubG8gPSBsb3dVaW50QkVcbiAgICBmdW5jdGlvbiBoaWdoVWludEJFKG4pIHtcbiAgICAgIERPVUJMRV9WSUVXWzBdID0gblxuICAgICAgcmV0dXJuIFVJTlRfVklFV1swXVxuICAgIH1cbiAgICBtb2R1bGUuZXhwb3J0cy5oaSA9IGhpZ2hVaW50QkVcbiAgfSBlbHNlIHtcbiAgICBoYXNUeXBlZEFycmF5cyA9IGZhbHNlXG4gIH1cbn1cbmlmKCFoYXNUeXBlZEFycmF5cykge1xuICB2YXIgYnVmZmVyID0gbmV3IEJ1ZmZlcig4KVxuICBtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGRvdWJsZUJpdHMobikge1xuICAgIGJ1ZmZlci53cml0ZURvdWJsZUxFKG4sIDAsIHRydWUpXG4gICAgcmV0dXJuIFsgYnVmZmVyLnJlYWRVSW50MzJMRSgwLCB0cnVlKSwgYnVmZmVyLnJlYWRVSW50MzJMRSg0LCB0cnVlKSBdXG4gIH1cbiAgZnVuY3Rpb24gdG9Eb3VibGUobG8sIGhpKSB7XG4gICAgYnVmZmVyLndyaXRlVUludDMyTEUobG8sIDAsIHRydWUpXG4gICAgYnVmZmVyLndyaXRlVUludDMyTEUoaGksIDQsIHRydWUpXG4gICAgcmV0dXJuIGJ1ZmZlci5yZWFkRG91YmxlTEUoMCwgdHJ1ZSlcbiAgfVxuICBtb2R1bGUuZXhwb3J0cy5wYWNrID0gdG9Eb3VibGUgIFxuICBmdW5jdGlvbiBsb3dVaW50KG4pIHtcbiAgICBidWZmZXIud3JpdGVEb3VibGVMRShuLCAwLCB0cnVlKVxuICAgIHJldHVybiBidWZmZXIucmVhZFVJbnQzMkxFKDAsIHRydWUpXG4gIH1cbiAgbW9kdWxlLmV4cG9ydHMubG8gPSBsb3dVaW50XG4gIGZ1bmN0aW9uIGhpZ2hVaW50KG4pIHtcbiAgICBidWZmZXIud3JpdGVEb3VibGVMRShuLCAwLCB0cnVlKVxuICAgIHJldHVybiBidWZmZXIucmVhZFVJbnQzMkxFKDQsIHRydWUpXG4gIH1cbiAgbW9kdWxlLmV4cG9ydHMuaGkgPSBoaWdoVWludFxufVxuXG5tb2R1bGUuZXhwb3J0cy5zaWduID0gZnVuY3Rpb24obikge1xuICByZXR1cm4gbW9kdWxlLmV4cG9ydHMuaGkobikgPj4+IDMxXG59XG5cbm1vZHVsZS5leHBvcnRzLmV4cG9uZW50ID0gZnVuY3Rpb24obikge1xuICB2YXIgYiA9IG1vZHVsZS5leHBvcnRzLmhpKG4pXG4gIHJldHVybiAoKGI8PDEpID4+PiAyMSkgLSAxMDIzXG59XG5cbm1vZHVsZS5leHBvcnRzLmZyYWN0aW9uID0gZnVuY3Rpb24obikge1xuICB2YXIgbG8gPSBtb2R1bGUuZXhwb3J0cy5sbyhuKVxuICB2YXIgaGkgPSBtb2R1bGUuZXhwb3J0cy5oaShuKVxuICB2YXIgYiA9IGhpICYgKCgxPDwyMCkgLSAxKVxuICBpZihoaSAmIDB4N2ZmMDAwMDApIHtcbiAgICBiICs9ICgxPDwyMClcbiAgfVxuICByZXR1cm4gW2xvLCBiXVxufVxuXG5tb2R1bGUuZXhwb3J0cy5kZW5vcm1hbGl6ZWQgPSBmdW5jdGlvbihuKSB7XG4gIHZhciBoaSA9IG1vZHVsZS5leHBvcnRzLmhpKG4pXG4gIHJldHVybiAhKGhpICYgMHg3ZmYwMDAwMClcbn0iLCIndXNlIHN0cmljdCdcblxubW9kdWxlLmV4cG9ydHMgPSBwb2x5Z29uVG9QU0xHXG5cbnZhciBjbGVhblBTTEcgPSByZXF1aXJlKCdjbGVhbi1wc2xnJylcblxuLy9Db252ZXJ0cyBhIHBvbHlnb24gdG8gYSBwbGFuYXIgc3RyYWlnaHQgbGluZSBncmFwaFxuZnVuY3Rpb24gcG9seWdvblRvUFNMRyhsb29wcywgb3B0aW9ucykge1xuICBpZighQXJyYXkuaXNBcnJheShsb29wcykpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ3BvbHktdG8tcHNsZzogRXJyb3IsIGludmFsaWQgcG9seWdvbicpXG4gIH1cbiAgaWYobG9vcHMubGVuZ3RoID09PSAwKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIHBvaW50czogW10sXG4gICAgICBlZGdlczogIFtdXG4gICAgfVxuICB9XG5cbiAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge31cblxuICB2YXIgbmVzdGVkID0gdHJ1ZVxuICBpZignbmVzdGVkJyBpbiBvcHRpb25zKSB7XG4gICAgbmVzdGVkID0gISFvcHRpb25zLm5lc3RlZFxuICB9IGVsc2UgaWYobG9vcHNbMF0ubGVuZ3RoID09PSAyICYmIHR5cGVvZiBsb29wc1swXVswXSA9PT0gJ251bWJlcicpIHtcbiAgICAvL0hhY2s6ICBJZiB1c2UgZG9lc24ndCBwYXNzIGluIGEgbG9vcCwgdGhlbiB0cnkgdG8gZ3Vlc3MgaWYgaXQgaXMgbmVzdGVkXG4gICAgbmVzdGVkID0gZmFsc2VcbiAgfVxuICBpZighbmVzdGVkKSB7XG4gICAgbG9vcHMgPSBbbG9vcHNdXG4gIH1cblxuICAvL0ZpcnN0IHdlIGp1c3QgdW5yb2xsIGFsbCB0aGUgcG9pbnRzIGluIHRoZSBkdW1iL29idmlvdXMgd2F5XG4gIHZhciBwb2ludHMgPSBbXVxuICB2YXIgZWRnZXMgPSBbXVxuICBmb3IodmFyIGk9MDsgaTxsb29wcy5sZW5ndGg7ICsraSkge1xuICAgIHZhciBsb29wID0gbG9vcHNbaV1cbiAgICB2YXIgb2Zmc2V0ID0gcG9pbnRzLmxlbmd0aFxuICAgIGZvcih2YXIgaj0wOyBqPGxvb3AubGVuZ3RoOyArK2opIHtcbiAgICAgIHBvaW50cy5wdXNoKGxvb3Bbal0pXG4gICAgICBlZGdlcy5wdXNoKFsgb2Zmc2V0K2osIG9mZnNldCsoaisxKSVsb29wLmxlbmd0aCBdKVxuICAgIH1cbiAgfVxuXG4gIC8vVGhlbiB3ZSBydW4gc25hcCByb3VuZGluZyB0byBjbGVhbiB1cCBzZWxmIGludGVyc2VjdGlvbnMgYW5kIGR1cGxpY2F0ZSB2ZXJ0c1xuICB2YXIgY2xlYW4gPSAnY2xlYW4nIGluIG9wdGlvbnMgPyB0cnVlIDogISFvcHRpb25zLmNsZWFuXG4gIGlmKGNsZWFuKSB7XG4gICAgY2xlYW5QU0xHKHBvaW50cywgZWRnZXMpXG4gIH1cblxuICAvL0ZpbmFsbHksIHdlIHJldHVybiB0aGUgcmVzdWx0aW5nIFBTTEdcbiAgcmV0dXJuIHtcbiAgICBwb2ludHM6IHBvaW50cyxcbiAgICBlZGdlczogIGVkZ2VzXG4gIH1cbn1cbiIsIid1c2Ugc3RyaWN0J1xuXG52YXIgY2R0MmQgICAgID0gcmVxdWlyZSgnY2R0MmQnKVxudmFyIGJvdW5kYXJ5ICA9IHJlcXVpcmUoJ3NpbXBsaWNpYWwtY29tcGxleC1ib3VuZGFyeScpXG5cbm1vZHVsZS5leHBvcnRzID0gcHNsZ1RvUG9seWdvblxuXG5mdW5jdGlvbiBwc2xnVG9Qb2x5Z29uKHBvaW50cywgZWRnZXMpIHtcbiAgLy9HZXQgY2VsbHNcbiAgdmFyIGNlbGxzID0gY2R0MmQocG9pbnRzLCBlZGdlcywge1xuICAgIGRlbGF1bmF5OiBmYWxzZSxcbiAgICBleHRlcmlvcjogZmFsc2UgfSlcblxuICAvL0V4dHJhY3QgYm91bmRhcnlcbiAgdmFyIGJuZCA9IGJvdW5kYXJ5KGNlbGxzKVxuXG4gIC8vQ29uc3RydWN0IGFkamFjZW5jeSBsaXN0IGZyb20gYm91bmRhcnlcbiAgdmFyIGFkaiA9IG5ldyBBcnJheShwb2ludHMubGVuZ3RoKVxuICBmb3IodmFyIGk9MDsgaTxwb2ludHMubGVuZ3RoOyArK2kpIHtcbiAgICBhZGpbaV0gPSBbXVxuICB9XG5cbiAgZm9yKHZhciBpPTA7IGk8Ym5kLmxlbmd0aDsgKytpKSB7XG4gICAgdmFyIGUgPSBibmRbaV1cbiAgICBhZGpbZVswXV0ucHVzaChlWzFdKVxuICB9XG5cbiAgLy9FeHRyYWN0IGJvdW5kYXJ5IGN5Y2xlXG4gIHZhciBsb29wcyA9IFtdXG4gIGZvcih2YXIgaT0wOyBpPHBvaW50cy5sZW5ndGg7ICsraSkge1xuICAgIGlmKGFkaltpXS5sZW5ndGggPT09IDApIHtcbiAgICAgIGNvbnRpbnVlXG4gICAgfVxuICAgIHZhciB2ID0gaSwgbG9vcCA9IFtdXG4gICAgZG8ge1xuICAgICAgbG9vcC5wdXNoKHBvaW50c1t2XSlcbiAgICAgIHYgPSBhZGpbdl0ucG9wKClcbiAgICB9IHdoaWxlKHYgIT09IGkpXG4gICAgbG9vcHMucHVzaChsb29wKVxuICB9XG5cbiAgcmV0dXJuIGxvb3BzXG59XG4iLCIvL1xuLy8gUGVybGluIG5vaXNlIG1vZHVsZS5cbi8vXG4vLyBXcml0dGVuIGJ5IFRob20gQ2hpb3ZvbG9uaSwgZGVkaWNhdGVkIGludG8gdGhlIHB1YmxpYyBkb21haW4gKGFzIGV4cGxhaW5lZCBhdFxuLy8gaHR0cDovL2NyZWF0aXZlY29tbW9ucy5vcmcvcHVibGljZG9tYWluL3plcm8vMS4wLykuXG4vL1xudmFyIHF1aWNrTm9pc2UgPSAoZnVuY3Rpb24oKSB7XG5cdCd1c2Ugc3RyaWN0JztcblxuXHRmdW5jdGlvbiBidWlsZFRhYmxlKHJhbmRGdW5jKSB7XG5cdFx0aWYgKCFyYW5kRnVuYykge1xuXHRcdFx0cmFuZEZ1bmMgPSBNYXRoLnJhbmRvbTtcblx0XHR9XG5cdFx0Ly8gQE5PVEUodGhvbSk6IGNvdWxkIG9wdGltaXplIHRoaXMgZm9yIGFsbG9jYXRpb25zLCBidXQgaXRcblx0XHQvLyBzaG91bGRuJ3QgYmUgbmVhciBhbnlib2R5J3MgZmFzdCBwYXRoLi4uXG5cdFx0dmFyIGFyciA9IG5ldyBBcnJheSgyNTYpLm1hcChmdW5jdGlvbih2LCBpKSB7IHJldHVybiBpOyB9KTtcblx0XHQvLyBzaHVmZmxlIG51bWJlcnMgMCB0aHJvdWdoIDI1NVxuXHRcdGZvciAodmFyIGkgPSBhcnIubGVuZ3RoLTE7IGkgPiAwOyAtLWkpIHtcblx0XHRcdHZhciByID0gTWF0aC5mbG9vcihyYW5kRnVuYygpICogKGkrMSkpO1xuXHRcdFx0dmFyIHQgPSBhcnJbcl07XG5cdFx0XHRhcnJbcl0gPSBhcnJbaV07XG5cdFx0XHRhcnJbaV0gPSB0O1xuXHRcdH1cblx0XHRyZXR1cm4gYXJyO1xuXHR9XG5cblx0dmFyIGdyYWRCYXNpcyA9IFsgMSwxLDAsIC0xLDEsMCwgMSwtMSwwLCAtMSwtMSwwLCAxLDAsMSwgLTEsMCwxLCAxLDAsLTEsIC0xLDAsLTEsIDAsMSwxLCAwLC0xLDEsIDAsMSwtMSwgMCwtMSwtMSBdXG5cblx0ZnVuY3Rpb24gaW5pdFRhYmxlcyh0YWIsIHBlcm1UYWJsZSwgZ3JhZFRhYmxlKSB7XG5cdFx0aWYgKHRhYiA9PSBudWxsIHx8IHR5cGVvZiB0YWIgPT09ICdmdW5jdGlvbicpIHtcblx0XHRcdHRhYiA9IGJ1aWxkVGFibGUodGFiKVxuXHRcdH1cblx0XHRlbHNlIGlmICh0YWIubGVuZ3RoICE9PSAyNTYpIHtcblx0XHRcdGNvbnNvbGUuZXJyb3IoXCJjcmVhdGUoKTogRXhwZWN0ZWQgYXJyYXkgb2YgbGVuZ3RoIDI1NiwgZ290IFwiLCB0YWIpO1xuXHRcdFx0dGFiID0gYnVpbGRUYWJsZSgpO1xuXHRcdH1cblx0XHRmb3IgKHZhciBpID0gMDsgaSA8IDI1NjsgKytpKSB7XG5cdFx0XHRwZXJtVGFibGVbaV0gPSB0YWJbaV07XG5cdFx0XHRwZXJtVGFibGVbaSsyNTZdID0gdGFiW2ldO1xuXHRcdH1cblx0XHR2YXIgZ3JhZElkeCA9IDA7XG5cdFx0Zm9yICh2YXIgaSA9IDA7IGkgPCBwZXJtVGFibGUubGVuZ3RoOyArK2kpIHtcblx0XHRcdHZhciB2ID0gKHBlcm1UYWJsZVtpXSUxMikqMztcblx0XHRcdGdyYWRUYWJsZVtncmFkSWR4KytdID0gZ3JhZEJhc2lzW3ZdO1xuXHRcdFx0Z3JhZFRhYmxlW2dyYWRJZHgrK10gPSBncmFkQmFzaXNbdisxXTtcblx0XHRcdGdyYWRUYWJsZVtncmFkSWR4KytdID0gZ3JhZEJhc2lzW3YrMl07XG5cdFx0fVxuXHR9XG5cblx0dmFyIHBlcm1UYWJsZVNpemUgPSAyNTYqMjtcblx0dmFyIGdyYWRUYWJsZVNpemUgPSBwZXJtVGFibGVTaXplKjM7XG5cdHZhciB0b3RhbFNpemUgPSBwZXJtVGFibGVTaXplICsgZ3JhZFRhYmxlU2l6ZTtcblxuXHQvL1xuXHQvLyBmdW5jdGlvbiBxdWlja05vaXNlLmNyZWF0ZSh0YWJsZU9yUm5nPU1hdGgucmFuZG9tKTtcblx0Ly9cblx0Ly8gYHRhYmxlT3JSbmdgIG11c3QgZWl0aGVyIGJlOlxuXHQvL1xuXHQvLyAtIEEgZnVuY3Rpb24gdGhhdCB0YWtlcyAwIGFyZ3VtZW50cyBhbmQgcmV0dXJucyBhIHVuaWZvcm1seSBkaXN0cmlidXRlZFxuXHQvLyAgIHJhbmRvbSBudW1iZXIgYmV0d2VlbiAwIGFuZCAxIChsaWtlIGBNYXRoLnJhbmRvbWApLlxuXHQvLyAtIEFuIGFycmF5IG9mIGxlbmd0aCAyNTYsIHdoZXJlIHRoZSBhcnJheSBpcyBnZW5lcmF0ZWQgYnkgc2h1ZmZsaW5nIGFsbFxuXHQvLyAgIGludGVnZXJzIGJldHdlZW4gMCBhbmQgMjU1IChpbmNsdXNpdmUpLlxuXHQvL1xuXHQvLyBJZiBubyBhcmd1bWVudCAob3IgYSBiYWQgYXJndW1lbnQpIGlzIHByb3ZpZGVkLCBpdCBkZWZhdWx0cyB0byBNYXRoLnJhbmRvbS5cblx0Ly9cblx0Ly8gVGhpcyBjcmVhdGVzIGEgcGVybGluIG5vaXNlIGdlbmVyYXRpb24gZnVuY3Rpb24uIEZvciBtb3JlIGRvY3VtZW50YXRpb24gYWJvdXRcblx0Ly8gdGhlIGZ1bmN0aW9uIHJldHVybmVkIGJ5IHRoaXMgY2FsbCwgc2VlIHRoZSBkb2N1bWVudGF0aW9uIGZvciBgcXVpY2tOb2lzZS5ub2lzZWAsIGJlbG93LlxuXHQvL1xuXHQvLyBJZiB5b3UgcHJvdmlkZSBhIGZ1bmN0aW9uLCB0aGlzIHdpbGwgYmUgdXNlZCBvbmx5IHRvIGdlbmVyYXRlIHRoZSBwZXJtdXRhdGlvbiB0YWJsZSwgYW5kXG5cdC8vIHdpbGwgbm90IGJlIGNhbGxlZCBhZnRlciB0aGlzIGZ1bmN0aW9uIHJldHVybnMuXG5cdC8vXG5cdC8vIFRoZSBhcnJheSBhcmd1bWVudCBwcm92aWRlZCBpbiBjYXNlIHlvdSB3YW50IHRvIHByb3ZpZGUgYSBzcGVjaWZpYyBwZXJtdXRhdGlvbiB0YWJsZS5cblx0Ly9cblxuXHRmdW5jdGlvbiBjcmVhdGUodGFiKSB7XG5cdFx0dmFyIGFiID0gbmV3IEFycmF5QnVmZmVyKHRvdGFsU2l6ZSk7XG5cdFx0dmFyIHBlcm1UYWJsZSA9IG5ldyBVaW50OEFycmF5KGFiLCAwLCBwZXJtVGFibGVTaXplKTtcblx0XHR2YXIgZ3JhZFRhYmxlID0gbmV3IEludDhBcnJheShhYiwgcGVybVRhYmxlU2l6ZSwgZ3JhZFRhYmxlU2l6ZSk7XG5cdFx0aW5pdFRhYmxlcyh0YWIsIHBlcm1UYWJsZSwgZ3JhZFRhYmxlKTtcblxuXHRcdGZ1bmN0aW9uIG5vaXNlKHgsIHksIHosIHhXcmFwLCB5V3JhcCwgeldyYXApIHtcblx0XHRcdC8vIGNvZXJzY2UgdG8gaW50ZWdlcnMgYW5kIGhhbmRsZSBtaXNzaW5nIGFyZ3VtZW50c1xuXHRcdFx0eFdyYXAgPSB4V3JhcCB8IDA7XG5cdFx0XHR5V3JhcCA9IHlXcmFwIHwgMDtcblx0XHRcdHpXcmFwID0geldyYXAgfCAwO1xuXG5cdFx0XHQvLyB0eXBlIGhpbnRzIGZvciB2bVxuXHRcdFx0eCA9ICt4O1xuXHRcdFx0eSA9ICt5O1xuXHRcdFx0eiA9ICt6O1xuXG5cdFx0XHR2YXIgeE1hc2sgPSAoKHhXcmFwLTEpICYgMjU1KSA+Pj4gMDtcblx0XHRcdHZhciB5TWFzayA9ICgoeVdyYXAtMSkgJiAyNTUpID4+PiAwO1xuXHRcdFx0dmFyIHpNYXNrID0gKCh6V3JhcC0xKSAmIDI1NSkgPj4+IDA7XG5cblx0XHRcdHZhciBweCA9IE1hdGguZmxvb3IoeCk7XG5cdFx0XHR2YXIgcHkgPSBNYXRoLmZsb29yKHkpO1xuXHRcdFx0dmFyIHB6ID0gTWF0aC5mbG9vcih6KTtcblxuXHRcdFx0dmFyIHgwID0gKHB4KzApICYgeE1hc2s7XG5cdFx0XHR2YXIgeDEgPSAocHgrMSkgJiB4TWFzaztcblxuXHRcdFx0dmFyIHkwID0gKHB5KzApICYgeU1hc2s7XG5cdFx0XHR2YXIgeTEgPSAocHkrMSkgJiB5TWFzaztcblxuXHRcdFx0dmFyIHowID0gKHB6KzApICYgek1hc2s7XG5cdFx0XHR2YXIgejEgPSAocHorMSkgJiB6TWFzaztcblxuXHRcdFx0eCAtPSBweDtcblx0XHRcdHkgLT0gcHk7XG5cdFx0XHR6IC09IHB6O1xuXG5cdFx0XHR2YXIgdSA9ICgoeCo2LjAtMTUuMCkqeCArIDEwLjApICogeCAqIHggKiB4O1xuXHRcdFx0dmFyIHYgPSAoKHkqNi4wLTE1LjApKnkgKyAxMC4wKSAqIHkgKiB5ICogeTtcblx0XHRcdHZhciB3ID0gKCh6KjYuMC0xNS4wKSp6ICsgMTAuMCkgKiB6ICogeiAqIHo7XG5cblx0XHRcdHZhciByMCA9IHBlcm1UYWJsZVt4MF07XG5cdFx0XHR2YXIgcjEgPSBwZXJtVGFibGVbeDFdO1xuXG5cdFx0XHR2YXIgcjAwID0gcGVybVRhYmxlW3IwK3kwXTtcblx0XHRcdHZhciByMDEgPSBwZXJtVGFibGVbcjAreTFdO1xuXHRcdFx0dmFyIHIxMCA9IHBlcm1UYWJsZVtyMSt5MF07XG5cdFx0XHR2YXIgcjExID0gcGVybVRhYmxlW3IxK3kxXTtcblxuXHRcdFx0dmFyIGgwMDAgPSBwZXJtVGFibGVbcjAwK3owXSAqIDM7XG5cdFx0XHR2YXIgaDAwMSA9IHBlcm1UYWJsZVtyMDArejFdICogMztcblx0XHRcdHZhciBoMDEwID0gcGVybVRhYmxlW3IwMSt6MF0gKiAzO1xuXHRcdFx0dmFyIGgwMTEgPSBwZXJtVGFibGVbcjAxK3oxXSAqIDM7XG5cdFx0XHR2YXIgaDEwMCA9IHBlcm1UYWJsZVtyMTArejBdICogMztcblx0XHRcdHZhciBoMTAxID0gcGVybVRhYmxlW3IxMCt6MV0gKiAzO1xuXHRcdFx0dmFyIGgxMTAgPSBwZXJtVGFibGVbcjExK3owXSAqIDM7XG5cdFx0XHR2YXIgaDExMSA9IHBlcm1UYWJsZVtyMTErejFdICogMztcblxuXHRcdFx0dmFyIG4wMDAgPSBncmFkVGFibGVbaDAwMF0qKHgrMCkgKyBncmFkVGFibGVbaDAwMCsxXSooeSswKSArIGdyYWRUYWJsZVtoMDAwKzJdKih6KzApO1xuXHRcdFx0dmFyIG4wMDEgPSBncmFkVGFibGVbaDAwMV0qKHgrMCkgKyBncmFkVGFibGVbaDAwMSsxXSooeSswKSArIGdyYWRUYWJsZVtoMDAxKzJdKih6LTEpO1xuXHRcdFx0dmFyIG4wMTAgPSBncmFkVGFibGVbaDAxMF0qKHgrMCkgKyBncmFkVGFibGVbaDAxMCsxXSooeS0xKSArIGdyYWRUYWJsZVtoMDEwKzJdKih6KzApO1xuXHRcdFx0dmFyIG4wMTEgPSBncmFkVGFibGVbaDAxMV0qKHgrMCkgKyBncmFkVGFibGVbaDAxMSsxXSooeS0xKSArIGdyYWRUYWJsZVtoMDExKzJdKih6LTEpO1xuXHRcdFx0dmFyIG4xMDAgPSBncmFkVGFibGVbaDEwMF0qKHgtMSkgKyBncmFkVGFibGVbaDEwMCsxXSooeSswKSArIGdyYWRUYWJsZVtoMTAwKzJdKih6KzApO1xuXHRcdFx0dmFyIG4xMDEgPSBncmFkVGFibGVbaDEwMV0qKHgtMSkgKyBncmFkVGFibGVbaDEwMSsxXSooeSswKSArIGdyYWRUYWJsZVtoMTAxKzJdKih6LTEpO1xuXHRcdFx0dmFyIG4xMTAgPSBncmFkVGFibGVbaDExMF0qKHgtMSkgKyBncmFkVGFibGVbaDExMCsxXSooeS0xKSArIGdyYWRUYWJsZVtoMTEwKzJdKih6KzApO1xuXHRcdFx0dmFyIG4xMTEgPSBncmFkVGFibGVbaDExMV0qKHgtMSkgKyBncmFkVGFibGVbaDExMSsxXSooeS0xKSArIGdyYWRUYWJsZVtoMTExKzJdKih6LTEpO1xuXG5cdFx0XHR2YXIgbjAwID0gbjAwMCArIChuMDAxLW4wMDApICogdztcblx0XHRcdHZhciBuMDEgPSBuMDEwICsgKG4wMTEtbjAxMCkgKiB3O1xuXHRcdFx0dmFyIG4xMCA9IG4xMDAgKyAobjEwMS1uMTAwKSAqIHc7XG5cdFx0XHR2YXIgbjExID0gbjExMCArIChuMTExLW4xMTApICogdztcblxuXHRcdFx0dmFyIG4wID0gbjAwICsgKG4wMS1uMDApICogdjtcblx0XHRcdHZhciBuMSA9IG4xMCArIChuMTEtbjEwKSAqIHY7XG5cblx0XHRcdHJldHVybiBuMCArIChuMS1uMCkgKiB1O1xuXHRcdH1cblx0XHRyZXR1cm4gbm9pc2U7XG5cdH1cblxuXHQvL1xuXHQvLyBmdW5jdGlvbiBxdWlja05vaXNlLm5vaXNlKHgsIHksIHosIHhXcmFwPTAsIHlXcmFwPTAsIHpXcmFwPTApO1xuXHQvL1xuXHQvLyAtIGB4YCwgYHlgLCBgemAgYXJlIG51bWJlcnMuXG5cdC8vIC0gYHhXcmFwYCwgYHlXcmFwYCwgYW5kIGB6V3JhcGAgYXJlIGludGVnZXIgcG93ZXJzIG9mIHR3byBiZXR3ZWVuIDAgYW5kIDI1Ni5cblx0Ly8gICAoMCBhbmQgMjU2IGFyZSBlcXVpdmFsZW50KS4gSWYgdGhlc2UgYXJlbid0IHByb3ZpZGVkLCB0aGV5IGRlZmF1bHQgdG8gMC5cblx0Ly9cblx0Ly8gVGhpcyBpbXBsZW1lbnRzIEtlbiBQZXJsaW4ncyByZXZpc2VkIG5vaXNlIGZ1bmN0aW9uIGZyb20gMjAwMiwgaW4gM0QuIEl0XG5cdC8vIGNvbXB1dGVzIGEgcmFuZG9tIHZhbHVlIGZvciB0aGUgY29vcmRpbmF0ZSBgeGAsIGB5YCwgYHpgLCB3aGVyZSBhZGphY2VudFxuXHQvLyB2YWx1ZXMgYXJlIGNvbnRpbnVvdXMgd2l0aCBhIHBlcmlvZCBvZiAxIChWYWx1ZXMgYXQgaW50ZWdlciBwb2ludHMgYXJlXG5cdC8vIGVudGlyZWx5IHVucmVsYXRlZCkuXG5cdC8vXG5cdC8vIFRoaXMgZnVuY3Rpb24gaXMgc2VlZGVkLiBUaGF0IGlzLCBpdCB3aWxsIHJldHVybiB0aGUgc2FtZSByZXN1bHRzIHdoZW5cblx0Ly8gY2FsbGVkIHdpdGggdGhlIHNhbWUgYXJndW1lbnRzLCBhY3Jvc3Mgc3VjY2Vzc2l2ZSBwcm9ncmFtIHJ1bnMuIEFuIHVuc2VlZGVkXG5cdC8vIHZlcnNpb24gbWF5IGJlIGNyZWF0ZWQgd2l0aCB0aGUgYHF1aWNrTm9pc2UuY3JlYXRlYCBmdW5jdGlvbi4gVGhlIHRhYmxlIGl0IGlzXG5cdC8vIHNlZWRlZCBpcyB0aGUgb25lIGZyb20gdGhlIGBzdGJfcGVybGluLmhgIGxpYnJhcnkuXG5cdC8vXG5cdHZhciBub2lzZSA9IGNyZWF0ZShbXG5cdFx0MjMsIDEyNSwgMTYxLCA1MiwgMTAzLCAxMTcsIDcwLCAzNywgMjQ3LCAxMDEsIDIwMywgMTY5LCAxMjQsIDEyNiwgNDQsIDEyMyxcblx0XHQxNTIsIDIzOCwgMTQ1LCA0NSwgMTcxLCAxMTQsIDI1MywgMTAsIDE5MiwgMTM2LCA0LCAxNTcsIDI0OSwgMzAsIDM1LCA3Mixcblx0XHQxNzUsIDYzLCA3NywgOTAsIDE4MSwgMTYsIDk2LCAxMTEsIDEzMywgMTA0LCA3NSwgMTYyLCA5MywgNTYsIDY2LCAyNDAsXG5cdFx0OCwgNTAsIDg0LCAyMjksIDQ5LCAyMTAsIDE3MywgMjM5LCAxNDEsIDEsIDg3LCAxOCwgMiwgMTk4LCAxNDMsIDU3LFxuXHRcdDIyNSwgMTYwLCA1OCwgMjE3LCAxNjgsIDIwNiwgMjQ1LCAyMDQsIDE5OSwgNiwgNzMsIDYwLCAyMCwgMjMwLCAyMTEsIDIzMyxcblx0XHQ5NCwgMjAwLCA4OCwgOSwgNzQsIDE1NSwgMzMsIDE1LCAyMTksIDEzMCwgMjI2LCAyMDIsIDgzLCAyMzYsIDQyLCAxNzIsXG5cdFx0MTY1LCAyMTgsIDU1LCAyMjIsIDQ2LCAxMDcsIDk4LCAxNTQsIDEwOSwgNjcsIDE5NiwgMTc4LCAxMjcsIDE1OCwgMTMsIDI0Myxcblx0XHQ2NSwgNzksIDE2NiwgMjQ4LCAyNSwgMjI0LCAxMTUsIDgwLCA2OCwgNTEsIDE4NCwgMTI4LCAyMzIsIDIwOCwgMTUxLCAxMjIsXG5cdFx0MjYsIDIxMiwgMTA1LCA0MywgMTc5LCAyMTMsIDIzNSwgMTQ4LCAxNDYsIDg5LCAxNCwgMTk1LCAyOCwgNzgsIDExMiwgNzYsXG5cdFx0MjUwLCA0NywgMjQsIDI1MSwgMTQwLCAxMDgsIDE4NiwgMTkwLCAyMjgsIDE3MCwgMTgzLCAxMzksIDM5LCAxODgsIDI0NCwgMjQ2LFxuXHRcdDEzMiwgNDgsIDExOSwgMTQ0LCAxODAsIDEzOCwgMTM0LCAxOTMsIDgyLCAxODIsIDEyMCwgMTIxLCA4NiwgMjIwLCAyMDksIDMsXG5cdFx0OTEsIDI0MSwgMTQ5LCA4NSwgMjA1LCAxNTAsIDExMywgMjE2LCAzMSwgMTAwLCA0MSwgMTY0LCAxNzcsIDIxNCwgMTUzLCAyMzEsXG5cdFx0MzgsIDcxLCAxODUsIDE3NCwgOTcsIDIwMSwgMjksIDk1LCA3LCA5MiwgNTQsIDI1NCwgMTkxLCAxMTgsIDM0LCAyMjEsXG5cdFx0MTMxLCAxMSwgMTYzLCA5OSwgMjM0LCA4MSwgMjI3LCAxNDcsIDE1NiwgMTc2LCAxNywgMTQyLCA2OSwgMTIsIDExMCwgNjIsXG5cdFx0MjcsIDI1NSwgMCwgMTk0LCA1OSwgMTE2LCAyNDIsIDI1MiwgMTksIDIxLCAxODcsIDUzLCAyMDcsIDEyOSwgNjQsIDEzNSxcblx0XHQ2MSwgNDAsIDE2NywgMjM3LCAxMDIsIDIyMywgMTA2LCAxNTksIDE5NywgMTg5LCAyMTUsIDEzNywgMzYsIDMyLCAyMiwgNVxuXHRdKTtcblxuXHRyZXR1cm4ge1xuXHRcdGNyZWF0ZTogY3JlYXRlLFxuXHRcdG5vaXNlOiBub2lzZVxuXHR9O1xuXG59KCkpO1xuXG5pZiAodHlwZW9mIG1vZHVsZSAhPT0gJ3VuZGVmaW5lZCcgJiYgbW9kdWxlLmV4cG9ydHMpIHtcblx0bW9kdWxlLmV4cG9ydHMgPSBxdWlja05vaXNlO1xufVxuIiwiJ3VzZSBzdHJpY3QnXG5jb25zdCB7QVNTRVJUfSA9IHJlcXVpcmUoJy4vZGVidWcnKTtcbmNsYXNzIFZlYzIge1xuXHRjb25zdHJ1Y3Rvcih4LCB5KSB7IHRoaXMueCA9ICt4fHwwLjA7IHRoaXMueSA9ICt5fHwwLjA7IH1cblx0cGVycCgpIHsgcmV0dXJuIG5ldyBWZWMyKC10aGlzLnksIHRoaXMueCk7IH1cblx0dG8obykgeyByZXR1cm4gbmV3IFZlYzIoby54LXRoaXMueCwgby55LXRoaXMueSk7IH1cblx0ZG90KG8pIHsgcmV0dXJuIHRoaXMueCpvLngrdGhpcy55Km8ueTsgfVxuXG5cdHBlcnBEb3QobykgeyByZXR1cm4gLXRoaXMueSpvLngrdGhpcy54Km8ueTsgfVxuXHRwbHVzKG8pIHsgcmV0dXJuIG5ldyBWZWMyKHRoaXMueCtvLngsIHRoaXMueStvLnkpOyB9XG5cblx0bWludXMobykgeyByZXR1cm4gbmV3IFZlYzIodGhpcy54LW8ueCwgdGhpcy55LW8ueSk7IH1cblx0bGVuU3EoKSB7IHJldHVybiB0aGlzLngqdGhpcy54K3RoaXMueSp0aGlzLnk7IH1cblx0bGVuKCkgeyByZXR1cm4gTWF0aC5zcXJ0KHRoaXMueCp0aGlzLnggKyB0aGlzLnkqdGhpcy55KTsgfVxuXHRsZW5ndGgoKSB7IHJldHVybiB0aGlzLmxlbigpOyB9XG5cdGxlbmd0aFNxdWFyZWQoKSB7IHJldHVybiBsZW5TcSgpOyB9XG5cdHNjYWxlZChuKSB7IHJldHVybiBuZXcgVmVjMih0aGlzLngqbiwgdGhpcy55Km4pOyB9XG5cdG5vcm1hbGl6ZSgpIHsgdGhpcy5ub3JtYWxpemVHZXRMZW4oKTsgcmV0dXJuIHRoaXM7IH1cblx0Y2xvbmUoKSB7IHJldHVybiBuZXcgVmVjMih0aGlzLngsIHRoaXMueSk7IH1cblx0Y29weSh7eCwgeX0pIHsgdGhpcy54ID0geDsgOyB0aGlzLnkgPSB5OyByZXR1cm4gdGhpczsgfVxuXG5cdHNjYWxlKG4pIHsgdGhpcy54ICo9IG47IHRoaXMueSAqPSBuOyByZXR1cm4gdGhpczsgfVxuXHRzZXQoeCwgeSkgeyB0aGlzLnggPSB4OyB0aGlzLnkgPSB5OyByZXR1cm4gdGhpczsgfVxuXHRjbGVhcigpIHsgcmV0dXJuIHRoaXMuc2V0KDAuMCwgMC4wKTsgfVxuXHRhZGQobykgeyB0aGlzLnggKz0gby54OyB0aGlzLnkgKz0gby55OyByZXR1cm4gdGhpczsgfVxuXG5cdGFkZFNjYWxlZChvLCBuKSB7IHRoaXMueCArPSBvLngqbjsgdGhpcy55ICs9IG8ueSpuOyByZXR1cm4gdGhpczsgfVxuXG5cdHRyYW5zbGF0ZSh4LCB5KSB7IHRoaXMueCArPSB4OyB0aGlzLnkgKz0geTsgcmV0dXJuIHRoaXM7IH1cblx0bm9ybWFsaXplZCgpIHsgcmV0dXJuIHRoaXMuY2xvbmUoKS5ub3JtYWxpemUoKTsgfVxuXHRzY2FsZWQobikgeyByZXR1cm4gdGhpcy5jbG9uZSgpLnNjYWxlKG4pOyB9XG5cdHRvU3RyaW5nKCkgeyByZXR1cm4gYCgke3RoaXMueH0sICR7dGhpcy55fSlgOyB9XG5cblx0ZGlzdGFuY2Uobykge1xuXHRcdGxldCBkeCA9IHRoaXMueCAtIG8ueCwgZHkgPSB0aGlzLnkgLSBvLnk7XG5cdFx0cmV0dXJuIE1hdGguc3FydChkeCpkeCArIGR5KmR5KTtcblx0fVxuXG5cdGRpc3RhbmNlU3Eobykge1xuXHRcdHRoaXNcblx0XHRsZXQgZHggPSB0aGlzLnggLSBvLngsIGR5ID0gdGhpcy55IC0gby55O1xuXHRcdHJldHVybiBkeCpkeCArIGR5KmR5O1xuXHR9XG5cblx0bm9ybWFsaXplR2V0TGVuKCkge1xuXHRcdGxldCBsMiA9IHRoaXMueCp0aGlzLngrdGhpcy55KnRoaXMueTtcblx0XHRpZiAobDIgPT09IDAuMCkgeyB0aGlzLnggPSAwLjA7IHRoaXMueSA9IDEuMDsgcmV0dXJuIDAuMDAwMDE7IH1cblx0XHRsZXQgaWwgPSAxLjAvTWF0aC5zcXJ0KGwyKTtcblx0XHR0aGlzLnggKj0gaWw7XG5cdFx0dGhpcy55ICo9IGlsO1xuXHRcdHRoaXNcblx0XHRyZXR1cm4gbDIqaWw7XG5cdH1cblxuXHRub3JtYWxpemVPclplcm8oKSB7XG5cdFx0cmV0dXJuIHRoaXMuc2NhbGUoMS4wLyhNYXRoLnNxcnQodGhpcy54KnRoaXMueCt0aGlzLnkqdGhpcy55KSsxZS0zNykpO1xuXHR9XG5cblx0eEZsaXAoYWJvdXQ9MC4wKSB7IHRoaXMueCA9IDIuMCAqIGFib3V0IC0gdGhpcy54OyByZXR1cm4gdGhpczsgfVxuXHR5RmxpcChhYm91dD0wLjApIHsgdGhpcy55ID0gMi4wICogYWJvdXQgLSB0aGlzLnk7IHJldHVybiB0aGlzOyB9XG5cblx0cm90YXRlKGFuZ2xlLCBhYm91dCkge1xuXHRcdGxldCBhYm91dFggPSAwLjAsIGFib3V0WSA9IDAuMDtcblx0XHRpZiAoYWJvdXQpIHsgYWJvdXRYID0gYWJvdXQueDsgYWJvdXRZID0gYWJvdXQueTsgfVxuXHRcdGxldCB4ID0gdGhpcy54IC0gYWJvdXRYO1xuXHRcdGxldCB5ID0gdGhpcy55IC0gYWJvdXRZO1xuXHRcdGxldCBjID0gTWF0aC5jb3MoYW5nbGUpO1xuXHRcdGxldCBzID0gTWF0aC5zaW4oYW5nbGUpO1xuXHRcdGxldCBueCA9IHggKiBjIC0geSAqIHM7XG5cdFx0bGV0IG55ID0geCAqIHMgKyB5ICogYztcblx0XHR0aGlzLnggPSBueCArIGFib3V0WDtcblx0XHR0aGlzLnkgPSBueSArIGFib3V0WTtcblx0XHRyZXR1cm4gdGhpcztcblx0fVxuXG5cdHJvdGF0ZTkwKGFib3V0KSB7XG5cdFx0bGV0IGFib3V0WCA9IDAuMCwgYWJvdXRZID0gMC4wO1xuXHRcdGlmIChhYm91dCkgeyBhYm91dFggPSBhYm91dC54OyBhYm91dFkgPSBhYm91dC55OyB9XG5cdFx0bGV0IHggPSB0aGlzLnggLSBhYm91dFg7XG5cdFx0bGV0IHkgPSB0aGlzLnkgLSBhYm91dFk7XG5cdFx0dGhpcy54ID0gLXkrYWJvdXRYO1xuXHRcdHRoaXMueSA9ICB4K2Fib3V0WTtcblx0XHRyZXR1cm4gdGhpcztcblx0fTtcblxuXHRyb3RhdGUxODAoYWJvdXQpIHtcblx0XHRsZXQgYWJvdXRYID0gMC4wLCBhYm91dFkgPSAwLjA7XG5cdFx0aWYgKGFib3V0KSB7IGFib3V0WCA9IGFib3V0Lng7IGFib3V0WSA9IGFib3V0Lnk7IH1cblx0XHRsZXQgeCA9IHRoaXMueCAtIGFib3V0WDtcblx0XHRsZXQgeSA9IHRoaXMueSAtIGFib3V0WTtcblx0XHR0aGlzLnggPSAteCthYm91dFg7XG5cdFx0dGhpcy55ID0gLXkrYWJvdXRZO1xuXHRcdHJldHVybiB0aGlzO1xuXHR9O1xuXG5cdHJvdGF0ZTI3MChhYm91dCkge1xuXHRcdGxldCBhYm91dFggPSAwLjAsIGFib3V0WSA9IDAuMDtcblx0XHRpZiAoYWJvdXQpIHsgYWJvdXRYID0gYWJvdXQueDsgYWJvdXRZID0gYWJvdXQueTsgfVxuXHRcdGxldCB4ID0gdGhpcy54IC0gYWJvdXRYO1xuXHRcdGxldCB5ID0gdGhpcy55IC0gYWJvdXRZO1xuXHRcdHRoaXMueCA9ICB5K2Fib3V0WDtcblx0XHR0aGlzLnkgPSAteCthYm91dFk7XG5cdFx0cmV0dXJuIHRoaXM7XG5cdH07XG5cblx0cm90YXRlKGFuZ2xlLCBhYm91dCkge1xuXHRcdGxldCBhYm91dFggPSAwLjAsIGFib3V0WSA9IDAuMDtcblx0XHRpZiAoYWJvdXQpIHsgYWJvdXRYID0gYWJvdXQueDsgYWJvdXRZID0gYWJvdXQueTsgfVxuXHRcdGxldCBzaW4gPSBNYXRoLnNpbihhbmdsZSk7XG5cdFx0bGV0IGNvcyA9IE1hdGguY29zKGFuZ2xlKTtcblxuXHRcdGxldCB4ID0gdGhpcy54IC0gYWJvdXRYO1xuXHRcdGxldCB5ID0gdGhpcy55IC0gYWJvdXRZO1xuXHRcdGxldCBueCA9IChjb3MgKiB4KSAtIChzaW4gKiB5KTtcblx0XHRsZXQgbnkgPSAoc2luICogeCkgKyAoY29zICogeSk7XG5cdFx0dGhpcy54ID0gbnggKyBhYm91dFg7XG5cdFx0dGhpcy55ID0gbnkgKyBhYm91dFk7XG5cdFx0cmV0dXJuIHRoaXM7XG5cdH1cblxuXHRyb3RhdGVkOTAoYWJvdXQpIHsgcmV0dXJuIHRoaXMuY2xvbmUoKS5yb3RhdGU5MChhYm91dCk7IH1cblx0cm90YXRlZDE4MChhYm91dCkgeyByZXR1cm4gdGhpcy5jbG9uZSgpLnJvdGF0ZTE4MChhYm91dCk7IH1cblx0cm90YXRlZDI3MChhYm91dCkgeyByZXR1cm4gdGhpcy5jbG9uZSgpLnJvdGF0ZTI3MChhYm91dCk7IH1cblxuXHR4RmxpcHBlZChhYm91dFgpIHsgcmV0dXJuIHRoaXMuY2xvbmUoKS54RmxpcChhYm91dFgpOyB9XG5cdHlGbGlwcGVkKGFib3V0WSkgeyByZXR1cm4gdGhpcy5jbG9uZSgpLnlGbGlwKGFib3V0WSk7IH1cblxuXG5cdG5hbkNoZWNrKCkge1xuXHRcdEFTU0VSVCgrdGhpcy54ID09PSB0aGlzLngpO1xuXHRcdEFTU0VSVCgrdGhpcy55ID09PSB0aGlzLnkpO1xuXHRcdHJldHVybiB0aGlzO1xuXHR9XG59XG5cblZlYzIuWkVSTyA9IE9iamVjdC5mcmVlemUobmV3IFZlYzIoMC4wLCAwLjApKTtcblxuVmVjMi56ZXJvID0gZnVuY3Rpb24oKSB7IHJldHVybiBuZXcgVmVjMigwLjAsIDAuMCk7IH07XG5WZWMyLmZyb21EaXIgPSBmdW5jdGlvbihkaXIpIHsgcmV0dXJuIG5ldyBWZWMyKE1hdGguY29zKGRpciksIE1hdGguc2luKGRpcikpOyB9O1xuVmVjMi50b3dhcmRzID0gZnVuY3Rpb24ocDAsIHAxKSB7IHJldHVybiBuZXcgVmVjMihwMS54IC0gcDAueCwgcDEueSAtIHAwLnkpOyB9O1xuVmVjMi50b3dhcmRzWFkgPSBmdW5jdGlvbih4MCwgeTAsIHgxLCB5MSkgeyByZXR1cm4gbmV3IFZlYzIoeDEgLSB4MCwgeTEgLSB5MCk7IH07XG5cblZlYzIuUG9vbCA9IHtcblx0aXRlbXM6IFtdLFxuXHRjb3VudDogMCxcblx0Z2V0KHgsIHkpIHtcblx0XHRpZiAodGhpcy5jb3VudCA9PT0gdGhpcy5pdGVtcy5sZW5ndGgpXG5cdFx0XHR0aGlzLml0ZW1zLnB1c2gobmV3IFZlYzIoMC4wLCAwLjApKTtcblx0XHRyZXR1cm4gdGhpcy5pdGVtc1t0aGlzLmNvdW50KytdLnNldCgreHx8MC4wLCAreXx8MC4wKTtcblx0fSxcblx0cmVzZXQoKSB7IHRoaXMuY291bnQgPSAwOyB9LFxuXHR1cGRhdGUoKSB7IHRoaXMuY291bnQgPSAwOyB9XG59XG5cblZlYzIudGVtcCA9IGZ1bmN0aW9uKHgsIHkpIHsgcmV0dXJuIFZlYzIuUG9vbC5nZXQoeCwgeSk7IH07XG5cblxubW9kdWxlLmV4cG9ydHMgPSBWZWMyO1xuIiwiJ3VzZSBzdHJpY3QnO1xubGV0IHtSTkd9ID0gcmVxdWlyZSgnLi9yYW5kJyk7XG5cbmZ1bmN0aW9uIHNvdW5kVmFyaWF0aW9ucyhzcmMsIG1pbj0wLjgsIG1heD0xLjUsIGNvdW50PTEwKSB7XG5cdGxldCByZXMgPSBbXG5cdFx0bmV3IEhvd2woeyBzcmM6IHNyYywgdm9sdW1lOiAwLjIsIHJhdGU6IDEgfSksXG5cdF07XG5cdGZvciAobGV0IHJhdGUgPSBtaW47IHJhdGUgPD0gbWF4OyByYXRlICs9IChtYXgtbWluKS9jb3VudClcblx0XHRyZXMucHVzaChuZXcgSG93bCh7IHJhdGUsIHNyYzogc3JjLCB2b2x1bWU6IDAuMiB9KSk7XG5cdHJldHVybiByZXM7XG59XG5sZXQgU291bmRzID0ge1xuXHRjdXJyZW50U29uZzogbnVsbCxcblx0Ym9vbTogc291bmRWYXJpYXRpb25zKFsncmVzL2Jvb20xLndhdiddKSxcblx0YmFuZzogc291bmRWYXJpYXRpb25zKFsncmVzL2JhbmcyLm1wMyddLCAxLCAxLjEsIDUpLFxuXHRvdWNoOiBzb3VuZFZhcmlhdGlvbnMoWydyZXMvYmlnLW91Y2gubXAzJ10pLFxuXHRtb25zdE91Y2g6IHNvdW5kVmFyaWF0aW9ucyhbJ3Jlcy9tb25zdC1vdWNoLm1wMyddKSxcblx0Z3Jvd2w6IHNvdW5kVmFyaWF0aW9ucyhbJ3Jlcy9ncm93bC5tcDMnXSwgMS4wLCAyLjApLFxuXHR1bmxvY2s6IHNvdW5kVmFyaWF0aW9ucyhbJ3Jlcy91bmxvY2sud2F2J10pLFxuXHRkaWU6IHNvdW5kVmFyaWF0aW9ucyhbJ3Jlcy9kaWUubXAzJ10sIDAuOSwgMS4wKSxcblx0c3RvcDogW25ldyBIb3dsKHsgc3JjOiBbJ3Jlcy9zdG9wLm1wMyddLCB2b2x1bWU6IDAuMiB9KV0sXG5cdHdhaXQ6IFtuZXcgSG93bCh7IHNyYzogWydyZXMvd2FpdC5tcDMnXSwgdm9sdW1lOiAwLjIgfSldLFxuXG5cdGJhbmdzOiBbXG5cdFx0bmV3IEhvd2woeyBzcmM6IFsncmVzL2JhbmcxLndhdiddLCByYXRlOiAxIH0pLFxuXHRcdG5ldyBIb3dsKHsgc3JjOiBbJ3Jlcy9iYW5nMS53YXYnXSwgcmF0ZTogMC45IH0pLFxuXHRcdG5ldyBIb3dsKHsgc3JjOiBbJ3Jlcy9iYW5nMS53YXYnXSwgcmF0ZTogMS4xIH0pLFxuXHRcdG5ldyBIb3dsKHsgc3JjOiBbJ3Jlcy9iYW5nMS53YXYnXSwgcmF0ZTogMS41IH0pLFxuXHRcdG5ldyBIb3dsKHsgc3JjOiBbJ3Jlcy9iYW5nMS53YXYnXSwgcmF0ZTogMC44IH0pLFxuXHRdLFxuXHRzb25nMTogbmV3IEhvd2woeyBzcmM6IFsncmVzL21lbnViZy5vZ2cnLCAncmVzL21lbnViZy5tcDMnXSwgbG9vcDogdHJ1ZSwgdm9sdW1lOiAwLjUgfSksXG5cdHNvbmcyOiBuZXcgSG93bCh7IHNyYzogWydyZXMvc29uZzIub2dnJywgJ3Jlcy9zb25nMi5tcDMnXSwgbG9vcDogdHJ1ZSwgdm9sdW1lOiAwLjUgfSksXG5cdHNvbmczOiBuZXcgSG93bCh7IHNyYzogWydyZXMvc29uZzMub2dnJywgJ3Jlcy9zb25nMy5tcDMnXSwgbG9vcDogdHJ1ZSwgdm9sdW1lOiAwLjUgfSksXG5cdHdvYmJsZXM6IG5ldyBIb3dsKHtcblx0XHRzcmM6IFsncmVzL3dvYmJsZXMub2dnJywgJ3Jlcy93b2JibGVzLm1wMyddLFxuXHRcdHNwcml0ZToge1xuXHRcdFx0d29iYmxlMDogWzAsIDgwMDBdLFxuXHRcdFx0d29iYmxlMTogWzEyNTAwLCAxOTAwMF0sXG5cdFx0XHR3b2JibGUyOiBbMjQyMDAsIDMxNjAwXSxcblx0XHRcdHdvYmJsZTM6IFszNjMwMCwgNDM2MDBdLFxuXHRcdFx0d29iYmxlNDogWzQ3ODAwLCA1NjAwMF0sXG5cdFx0XHR3b2JibGU1OiBbNTk0MDAsIDY3ODAwXSxcblx0XHR9XG5cdH0pLFxuXG5cdHN0b3BNdXNpYyhmYWRlPWZhbHNlKSB7XG5cdFx0aWYgKHRoaXMuY3VycmVudFNvbmcgPT0gbnVsbCkgcmV0dXJuO1xuXHRcdGlmIChmYWRlKSB7XG5cdFx0XHRsZXQgY3MgPSB0aGlzLmN1cnJlbnRTb25nO1xuXHRcdFx0Y3MuZmFkZSgwLjUsIDAuMCwgMS4wKTtcblx0XHRcdGNzLm9uY2UoJ2ZhZGVkJywgKCkgPT4gY3Muc3RvcCgpKTtcblx0XHR9XG5cdFx0ZWxzZSB7XG5cdFx0XHRjcy5zdG9wKCk7XG5cdFx0fVxuXHRcdHRoaXMuY3VycmVudFNvbmcgPSBudWxsO1xuXHR9LFxuXG5cdHBsYXlNdXNpYyhpZCwgZmFkZT10cnVlKSB7XG5cdFx0aWYgKCEoaWQgaW4gdGhpcykpIGlkID0gJ3NvbmcnK2lkO1xuXHRcdGlmICh0aGlzLmN1cnJlbnRTb25nKSB7XG5cdFx0XHRsZXQgY3MgPSB0aGlzLmN1cnJlbnRTb25nO1xuXHRcdFx0bGV0IG5zID0gdGhpcy5jdXJyZW50U29uZyA9IHRoaXNbaWRdO1xuXHRcdFx0aWYgKGZhZGUpIHtcblx0XHRcdFx0Y3MuZmFkZSgwLjUsIDAuMCwgMS4wKTtcblx0XHRcdFx0Y3Mub25jZSgnZmFkZWQnLCAoKSA9PiB7XG5cdFx0XHRcdFx0Y3Muc3RvcCgpO1xuXHRcdFx0XHRcdGlmIChucyA9PT0gdGhpcy5jdXJyZW50U29uZykge1xuXHRcdFx0XHRcdFx0bnMucGxheSgpO1xuXHRcdFx0XHRcdFx0bnMuZmFkZSgwLjAsIDAuNSwgMS4wKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH0pO1xuXHRcdFx0fVxuXHRcdFx0ZWxzZSB7XG5cdFx0XHRcdGNzLnN0b3AoKTtcblx0XHRcdFx0bnMucGxheSgpO1xuXHRcdFx0fVxuXHRcdH1cblx0XHRlbHNlIGlmIChpZCBpbiB0aGlzKSB7XG5cdFx0XHR0aGlzLmN1cnJlbnRTb25nID0gdGhpc1tpZF07XG5cdFx0XHR0aGlzLmN1cnJlbnRTb25nLnBsYXkoKTtcblx0XHRcdGlmIChmYWRlKSB7XG5cdFx0XHRcdHRoaXMuY3VycmVudFNvbmcuZmFkZSgwLjAsIDAuNSwgMS4wKTtcblx0XHRcdH1cblx0XHR9XG5cdH0sXG5cblx0cGxheUVmZmVjdChuYW1lKSB7XG5cdFx0aWYgKG5hbWUgPT09ICd3b2JibGUnKSB0aGlzLnBsYXlXb2JibGUoKTtcblx0XHRlbHNlIGlmIChuYW1lIGluIHRoaXMpIHtcblx0XHRcdFJORy5jaG9vc2UodGhpc1tuYW1lXSkucGxheSgpO1xuXHRcdH1cblx0XHRlbHNlIHtcblx0XHRcdGNvbnNvbGUud2FybignY25hdCBwbGF5ICcrbmFtZSk7XG5cdFx0fVxuXHR9LFxuXG5cdHBsYXlXb2JibGUod2hpY2g9LTEpIHtcblx0XHRpZiAod2hpY2ggPCAwKSB7XG5cdFx0XHR3aGljaCA9IFJORy51cFRvKDYpO1xuXHRcdH1cblx0XHR0aGlzLndvYmJsZXMucGxheSgnd29iYmxlJysod2hpY2glNSkpO1xuXHR9XG5cbn1cblxuU291bmRzLnBsYXkgPSBTb3VuZHMucGxheUVmZmVjdDtcblxud2luZG93LlNvdW5kcyA9IFNvdW5kcztcblxuXG5tb2R1bGUuZXhwb3J0cyA9IFNvdW5kcztcbiIsIid1c2Ugc3RyaWN0JztcbmNvbnN0IFBhcnRpY2xlID0gcmVxdWlyZSgnLi9wYXJ0aWNsZScpO1xuY29uc3QgQ29uc3RzID0gcmVxdWlyZSgnLi9jb25zdGFudHMnKTtcbmNvbnN0IENsb2NrID0gcmVxdWlyZSgnLi9jbG9jaycpO1xuY29uc3Qge1JOR30gPSByZXF1aXJlKCcuL3JhbmQnKVxuY29uc3QgbWF0aCA9IHJlcXVpcmUoJy4vbWF0aCcpO1xuXG5jbGFzcyBCbG9vZCBleHRlbmRzIFBhcnRpY2xlIHtcblx0Y29uc3RydWN0b3IoZ2FtZSwgeCwgeSwgeikge1xuXHRcdHN1cGVyKGdhbWUsIHgsIHksIHopO1xuXHRcdHRoaXMuY29sbGlkZXNXaXRoRW50aXRpZXMgPSBmYWxzZTtcblx0XHR0aGlzLmNvbGxpZGVzV2l0aFBsYXllciA9IGZhbHNlO1xuXHRcdHRoaXMucmFkaXVzID0gMC41O1xuXHRcdHRoaXMuekFjYyA9IC04MFxuXG5cdFx0dGhpcy5jb2xvciA9IFJORy5jb2xvckJldHdlZW4oMHhmZjAwMDA2MCwgMHhmZjAwMDA4MCk7XG5cdFx0dGhpcy56Qm91bmNlID0gMC4xO1xuXHR9XG5cblx0dXBkYXRlKGR0KSB7XG5cdFx0c3VwZXIudXBkYXRlKGR0KTtcblx0XHRpZiAoUk5HLm9uZUNoYW5jZUluKDEwKSkge1xuXHRcdFx0dGhpcy5nYW1lLmJsb29kQnVmZmVyLnB1dFBpeGVsKE1hdGgucm91bmQodGhpcy5wb3MueCksIE1hdGgucm91bmQodGhpcy5wb3MueSksIHRoaXMuY29sb3IpO1xuXHRcdH1cblx0fVxuXG5cdG9uR3JvdW5kQ29sbGlzaW9uKCkge1xuXHRcdHRoaXMuZ2FtZS5ibG9vZEJ1ZmZlci5wdXRQaXhlbChNYXRoLnJvdW5kKHRoaXMucG9zLngpLCBNYXRoLnJvdW5kKHRoaXMucG9zLnkpLCB0aGlzLmNvbG9yKTtcblx0fVxufVxubW9kdWxlLmV4cG9ydHMgPSBCbG9vZDsiLCIndXNlIHN0cmljdCc7XG5cbmNvbnN0IHtUd2VlbiwgVHdlZW5Hcm91cH0gPSByZXF1aXJlKCcuL3R3ZWVucycpXG5jb25zdCBFbnRpdHkgPSByZXF1aXJlKCcuL2VudGl0eScpO1xuY29uc3QgSW5wdXQgPSByZXF1aXJlKCcuL2lucHV0Jyk7XG5jb25zdCBkcmF3aW5nID0gcmVxdWlyZSgnLi9kcmF3aW5nJyk7XG5jb25zdCBDb25zdHMgPSByZXF1aXJlKCcuL2NvbnN0YW50cycpO1xuY29uc3QgQ2xvY2sgPSByZXF1aXJlKCcuL2Nsb2NrJyk7XG5jb25zdCB7Uk5HfSA9IHJlcXVpcmUoJy4vcmFuZCcpO1xuY29uc3QgR29yZSA9IHJlcXVpcmUoJy4vZ29yZScpO1xuY29uc3QgU291bmRzID0gcmVxdWlyZSgnLi9hdWRpbycpO1xuY2xhc3MgQnVsbGV0IGV4dGVuZHMgRW50aXR5IHtcblx0Y29uc3RydWN0b3IoZ2FtZSwgc2hvb3RlciwgZHgsIGR5LCBkbWc9Uk5HLnVwVG8oNCksIHNwZWVkPTQwMCkge1xuXHRcdHN1cGVyKGdhbWUsIHNob290ZXIucG9zLngrZHgqc2hvb3Rlci5yYWRpdXMsIHNob290ZXIucG9zLnkrZHkqc2hvb3Rlci5yYWRpdXMpO1xuXHRcdFNvdW5kcy5wbGF5KCdiYW5nJyk7XG5cdFx0dGhpcy5kbWcgPSBkbWc7XG5cdFx0dGhpcy5zcGVlZCA9IHNwZWVkO1xuXHRcdHRoaXMuc2hvb3RlciA9IHNob290ZXI7XG5cdFx0dGhpcy5kcmFnLnNldCgwLCAwKTtcblx0XHR0aGlzLnZlbC54ID0gZHgqdGhpcy5zcGVlZDtcblx0XHR0aGlzLnZlbC55ID0gZHkqdGhpcy5zcGVlZDtcblx0XHR0aGlzLmxpZmUgPSAzLjA7XG5cdFx0dGhpcy50aW1lZCA9IHRydWU7XG5cdH1cblxuXHRyZW5kZXIoY3R4LCBidWZmZXIsIG1pblgsIG1pblkpIHtcblx0XHRsZXQgeDAgPSBNYXRoLnJvdW5kKHRoaXMucG9zLngtbWluWCk7XG5cdFx0bGV0IHkwID0gTWF0aC5yb3VuZCh0aGlzLnBvcy55LW1pblkpO1xuXHRcdGxldCB4MSA9IE1hdGgucm91bmQodGhpcy5sYXN0UG9zLngtbWluWCk7XG5cdFx0bGV0IHkxID0gTWF0aC5yb3VuZCh0aGlzLmxhc3RQb3MueS1taW5ZKTtcblxuXHRcdGxldCBkeCA9IHgxLXgwLCBkeSA9IHkxLXkwO1xuXHRcdGxldCBkaXN0ID0gTWF0aC5jZWlsKE1hdGguc3FydChkeCpkeCtkeSpkeSkpO1xuXHRcdGZvciAobGV0IGkgPSAwOyBpIDwgZGlzdDsgKytpKSB7XG5cdFx0XHQvLyBpZiAoUk5HLnhDaGFuY2VJblkoaSwgZGlzdCkpIGNvbnRpbnVlO1xuXHRcdFx0bGV0IGJyID0gKGkgKiAxMjggLyBkaXN0KzY0KSYweGZmO1xuXHRcdFx0bGV0IHh4ID0gKHgwIC0gZHggKiBpIC8gZGlzdCl8MDtcblx0XHRcdGxldCB5eSA9ICh5MCAtIGR5ICogaSAvIGRpc3QpfDA7XG5cdFx0XHRsZXQgcGl4ZWwgPSAweGZmMDAwMDAwIHwgKGJyICogMHgxMDEwMSk7XG5cdFx0XHRidWZmZXIucHV0UGl4ZWwoeHgsIHl5LCBwaXhlbCk7XG5cdFx0fVxuXHR9XG5cblx0b25Db2xsaXNpb24od2hvKSB7XG5cdFx0aWYgKCF0aGlzLmVuYWJsZWQpIHJldHVybjtcblx0XHRpZiAod2hvICE9IG51bGwgJiYgd2hvICE9IHRoaXMuc2hvb3Rlcikge1xuXHRcdFx0d2hvLmRhbWFnZSh0aGlzLmRtZywgdGhpcy5wb3MsIHRoaXMudmVsKTtcblx0XHRcdHRoaXMuZW5hYmxlZCA9IGZhbHNlO1xuXHRcdH1cblx0XHRpZiAod2hvICE9IHRoaXMuc2hvb3RlcikgdGhpcy5lbmFibGVkID0gZmFsc2U7XG5cdH1cblxufVxubW9kdWxlLmV4cG9ydHMgPSBCdWxsZXQ7XG4iLCIndXNlIHN0cmljdCc7XG5jb25zdCBtYXRoID0gcmVxdWlyZSgnLi9tYXRoJyk7XG5jb25zdCBWZWMyID0gcmVxdWlyZSgnLi92ZWMyJyk7XG5jb25zdCBDbG9jayA9IHJlcXVpcmUoJy4vY2xvY2snKTtcbmNvbnN0IHtSTkd9ID0gcmVxdWlyZSgnLi9yYW5kJyk7XG5jb25zdCB7QVNTRVJUfSA9IHJlcXVpcmUoJy4vZGVidWcnKTtcbmNvbnN0IElucHV0ID0gcmVxdWlyZSgnLi9pbnB1dCcpO1xuY29uc3QgQ29uc3RzID0gcmVxdWlyZSgnLi9jb25zdGFudHMnKTtcblxuY2xhc3MgQ2FtZXJhIHtcblx0Y29uc3RydWN0b3IoZ2FtZSwgZm9jdXMsIHRhcmdldCwgd2lkdGgsIGhlaWdodCkge1xuXHRcdHRoaXMuZ2FtZSA9IGdhbWU7XG5cdFx0dGhpcy5mb2N1cyA9IGZvY3VzO1xuXHRcdHRoaXMudGFyZ2V0ID0gdGFyZ2V0O1xuXHRcdC8vIHRoaXMucmVhbFRhcmdldCA9IG5ldyBWZWMyKDAuMCwgMC4wKTtcblx0XHR0aGlzLndpZHRoID0gd2lkdGg7XG5cdFx0dGhpcy5oZWlnaHQgPSBoZWlnaHQ7XG5cdFx0dGhpcy5nb2FsID0gbmV3IFZlYzIoMC4wLCAwLjApO1xuXHRcdHRoaXMudW5jbGFtcGVkUG9zID0gbmV3IFZlYzIoMC4wLCAwLjApO1xuXHRcdHRoaXMucG9zID0gbmV3IFZlYzIoMC4wLCAwLjApO1xuXHRcdC8vIHRoaXMudmVsID0gbmV3IFZlYzIoMC4wLCAwLjApO1xuXHRcdC8vIHRoaXMubWF4U3BlZWQgPSBOdW1iZXIuTUFYX1ZBTFVFO1xuXHRcdC8vIHRoaXMuc21vb3RoaW5nID0gMC4zO1xuXHRcdHRoaXMuaml0dGVyTGV2ZWwgPSAwO1xuXHRcdHRoaXMuc2hha2UgPSBuZXcgVmVjMigwLjAsIDAuMCk7XG5cdFx0dGhpcy5zaGFrZURyYWcgPSAwLjI7XG5cdFx0dGhpcy5kcmlmdE11bCA9IG5ldyBWZWMyKDAuMSwgMC4yKTtcblxuXHRcdHRoaXMubG9va2FoZWFkID0gMS4xO1xuXHRcdHRoaXMuc3BlZWQgPSAyLjU7XG5cblx0XHR0aGlzLm1pblggPSAwO1xuXHRcdHRoaXMubWF4WCA9IHdpZHRoO1xuXHRcdHRoaXMubWluWSA9IDA7XG5cdFx0dGhpcy5tYXhZID0gaGVpZ2h0O1xuXHR9XG5cblx0eEJvdW5kKCkgeyByZXR1cm4gdGhpcy5nYW1lLndpZHRoOyB9XG5cdHlCb3VuZCgpIHsgcmV0dXJuIHRoaXMuZ2FtZS5oZWlnaHQ7IH1cblxuXHRzZXRQb3NpdGlvbihueCwgbnksIHJlc2V0KSB7XG5cdFx0aWYgKHJlc2V0KSB7XG5cdFx0XHQvLyB0aGlzLnZlbC5zZXQoMCwgMCk7XG5cdFx0XHR0aGlzLmdvYWwuc2V0KG54LCBueSk7XG5cdFx0XHR0aGlzLnNoYWtlLnNldCgwLCAwKTtcblx0XHR9XG5cdFx0dGhpcy51bmNsYW1wZWRQb3Muc2V0KG54LCBueSlcblx0XHR0aGlzLnBvcy54ID0gbWF0aC5jbGFtcChueCwgdGhpcy53aWR0aCowLjUsIHRoaXMueEJvdW5kKCktdGhpcy53aWR0aCowLjUpO1xuXHRcdHRoaXMucG9zLnkgPSBtYXRoLmNsYW1wKG55LCB0aGlzLmhlaWdodCowLjUsIHRoaXMueUJvdW5kKCktdGhpcy5oZWlnaHQqMC41KTtcblxuXG5cdFx0dGhpcy5taW5YID0gdGhpcy5wb3MueC10aGlzLndpZHRoKjAuNTtcblx0XHR0aGlzLm1pblkgPSB0aGlzLnBvcy55LXRoaXMuaGVpZ2h0KjAuNTtcblxuXHRcdHRoaXMubWF4WCA9IHRoaXMubWluWCt0aGlzLndpZHRoO1xuXHRcdHRoaXMubWF4WSA9IHRoaXMubWluWSt0aGlzLmhlaWdodDtcblxuXHRcdGxldCB7cG9zOnt4OmZ4LCB5OmZ5fSwgcmFkaXVzfSA9IHRoaXMuZm9jdXM7XG5cblx0XHQvLyBASEFDSzogcHJldmVudCBjYW1lcmEgZnJvbSBub3QgY29udGFpbmluZyBwbGF5ZXIuLi5cblx0XHRpZiAoZnggLSByYWRpdXMgPCB0aGlzLm1pblgpIHtcblx0XHRcdHRoaXMubWluWCA9IGZ4LXJhZGl1cztcblx0XHRcdHRoaXMucG9zLnggPSB0aGlzLm1pblggKyB0aGlzLndpZHRoKjAuNTtcblx0XHRcdHRoaXMubWF4WCA9IHRoaXMubWluWCArIHRoaXMud2lkdGg7XG5cdFx0fVxuXG5cdFx0aWYgKGZ5IC0gcmFkaXVzIDwgdGhpcy5taW5ZKSB7XG5cdFx0XHR0aGlzLm1pblkgPSBmeS1yYWRpdXM7XG5cdFx0XHR0aGlzLnBvcy55ID0gdGhpcy5taW5ZICsgdGhpcy5oZWlnaHQqMC41O1xuXHRcdFx0dGhpcy5tYXhZID0gdGhpcy5taW5ZICsgdGhpcy5oZWlnaHQ7XG5cdFx0fVxuXG5cdFx0aWYgKGZ4ICsgcmFkaXVzID4gdGhpcy5tYXhYKSB7XG5cdFx0XHR0aGlzLm1heFggPSBmeCArIHJhZGl1cztcblx0XHRcdHRoaXMucG9zLnggPSB0aGlzLm1heFggLSB0aGlzLndpZHRoKjAuNTtcblx0XHRcdHRoaXMubWluWCA9IHRoaXMubWF4WCAtIHRoaXMud2lkdGg7XG5cdFx0fVxuXG5cdFx0aWYgKGZ5ICsgcmFkaXVzID4gdGhpcy5tYXhZKSB7XG5cdFx0XHR0aGlzLm1heFkgPSBmeSArIHJhZGl1cztcblx0XHRcdHRoaXMucG9zLnkgPSB0aGlzLm1heFkgLSB0aGlzLmhlaWdodCowLjU7XG5cdFx0XHR0aGlzLm1pblkgPSB0aGlzLm1heFkgLSB0aGlzLmhlaWdodDtcblx0XHR9XG5cdFx0QVNTRVJUKCt0aGlzLm1pblggPT09IHRoaXMubWluWCk7XG5cdFx0QVNTRVJUKCt0aGlzLm1pblkgPT09IHRoaXMubWluWSk7XG5cdFx0QVNTRVJUKCt0aGlzLm1heFggPT09IHRoaXMubWF4WCk7XG5cdFx0QVNTRVJUKCt0aGlzLm1heFkgPT09IHRoaXMubWF4WSk7XG5cdFx0dGhpcy5wb3MubmFuQ2hlY2soKTtcblx0XHQvLyB0aGlzLnZlbC5uYW5DaGVjaygpO1xuXHRcdHRoaXMuZ29hbC5uYW5DaGVjaygpO1xuXHRcdHRoaXMudGFyZ2V0Lm5hbkNoZWNrKCk7XG5cdH1cblxuXG5cdHVwZGF0ZShkdCkge1xuXHRcdGxldCBjeCA9IHRoaXMucG9zLng7XG5cdFx0bGV0IGN5ID0gdGhpcy5wb3MueTtcblx0XHRsZXQgZnggPSB0aGlzLmZvY3VzLnBvcy54O1xuXHRcdGxldCBmeSA9IHRoaXMuZm9jdXMucG9zLnk7XG5cblx0XHRpZiAoTWF0aC5hYnMoZnggLSBjeCkgPCAxMDAvQ29uc3RzLlNDQUxFKSB7XG5cdFx0XHRmeCA9IGN4O1xuXHRcdH1cblx0XHRpZiAoTWF0aC5hYnMoZnkgLSBjeSkgPCAxMDAvQ29uc3RzLlNDQUxFKSB7XG5cdFx0XHRmeSA9IGN5O1xuXHRcdH1cblxuXHRcdGxldCBmdnggPSB0aGlzLmZvY3VzLnZlbC54KjAuMTtcblx0XHRsZXQgZnZ5ID0gdGhpcy5mb2N1cy52ZWwueSowLjE7XG5cblx0XHRsZXQgZ3ggPSBmeCArIGZ2eCAqIHRoaXMubG9va2FoZWFkO1xuXHRcdGxldCBneSA9IGZ5ICsgZnZ5ICogdGhpcy5sb29rYWhlYWQ7XG5cdFx0bGV0IGFpbWluZyA9IGZhbHNlO1xuXHRcdGxldCBhaW1EaXYgPSAxO1xuXG5cdFx0aWYgKElucHV0Lm1vdXNlLmlzRG93bikge1xuXHRcdFx0Ly8gYWltaW5nID0gdHJ1ZTtcblx0XHRcdGFpbURpdiA9IDQ7XG5cdFx0fVxuXG5cdFx0aWYgKElucHV0LmtleWJvYXJkLmlzRG93bignc3BhY2UnKSkge1xuXHRcdFx0Ly8gYWltaW5nID0gdHJ1ZTtcblx0XHRcdGFpbURpdiA9IDI7XG5cdFx0fVxuXG5cdFx0aWYgKGFpbWluZykge1xuXHRcdFx0bGV0IG13eCA9IHRoaXMuZ2FtZS5tb3VzZS54O1xuXHRcdFx0bGV0IG13eSA9IHRoaXMuZ2FtZS5tb3VzZS55O1xuXG5cdFx0XHRsZXQgZnJ4ID0gbXd4IC0gdGhpcy5mb2N1cy5wb3MueDtcblx0XHRcdGxldCBmcnkgPSBtd3kgLSB0aGlzLmZvY3VzLnBvcy55O1xuXHRcdFx0Z3ggKz0gZnJ4IC8gYWltRGl2O1xuXHRcdFx0Z3kgKz0gZnJ5IC8gYWltRGl2O1xuXHRcdH1cblxuXHRcdGd4ID0gbWF0aC5jbGFtcChneCwgdGhpcy53aWR0aC8yLCB0aGlzLnhCb3VuZCgpLXRoaXMud2lkdGgvMik7XG5cdFx0Z3kgPSBtYXRoLmNsYW1wKGd5LCB0aGlzLmhlaWdodC8yLCB0aGlzLnlCb3VuZCgpLXRoaXMuaGVpZ2h0LzIpO1xuXG5cdFx0dmFyIG54ID0gZ3ggLSBjeDtcblx0XHR2YXIgbnkgPSBneSAtIGN5O1xuXG5cdFx0dmFyIHJlbGF4ID0gMS4wIC0gTWF0aC5leHAoLXRoaXMuc3BlZWQqZHQpO1xuXG5cdFx0bnggPSB0aGlzLnBvcy54ICsgbngqcmVsYXg7XG5cdFx0bnkgPSB0aGlzLnBvcy55ICsgbnkqcmVsYXg7XG5cblx0XHR0aGlzLnNldFBvc2l0aW9uKG54LCBueSk7XG5cblx0XHQvKlxuXHRcdHNtb290aERhbXBWMih0aGlzLmdvYWwsIHRoaXMuZ29hbCwgdGhpcy50YXJnZXQsIHRoaXMudmVsLCB0aGlzLnNtb290aGluZywgdGhpcy5tYXhTcGVlZCwgZHQpO1xuXHRcdGxldCBkcmlmdFggPSBNYXRoLmNvcyhDbG9jay5hY2N1bVRpbWUqdGhpcy5kcmlmdE11bC54KSAqIDUgKiB0aGlzLmppdHRlckxldmVsXG5cdFx0bGV0IGRyaWZ0WSA9IE1hdGguY29zKENsb2NrLmFjY3VtVGltZSp0aGlzLmRyaWZ0TXVsLnkpICogNSAqIHRoaXMuaml0dGVyTGV2ZWxcblxuXHRcdHRoaXMudW5jbGFtcGVkUG9zLnggPSB0aGlzLmdvYWwueCArIGRyaWZ0WCArIHRoaXMuc2hha2UueDtcblx0XHR0aGlzLnVuY2xhbXBlZFBvcy55ID0gdGhpcy5nb2FsLnkgKyBkcmlmdFkgKyB0aGlzLnNoYWtlLnk7XG5cblx0XHR0aGlzLnNoYWtlLnggLT0gdGhpcy5zaGFrZURyYWcqdGhpcy5zaGFrZS54KmR0O1xuXHRcdHRoaXMuc2hha2UueSAtPSB0aGlzLnNoYWtlRHJhZyp0aGlzLnNoYWtlLnkqZHQ7XG5cblx0XHR0aGlzLnNldFBvc2l0aW9uKHRoaXMudW5jbGFtcGVkUG9zLngsIHRoaXMudW5jbGFtcGVkUG9zLnkpOyovXG5cdH1cblxuXG59XG5cbm1vZHVsZS5leHBvcnRzID0gQ2FtZXJhO1xuIiwiJ3VzZSBzdHJpY3QnO1xuY29uc3QgQ2xvY2sgPSB7fTtcblxuQ2xvY2subm93ID0gd2luZG93LnBlcmZvcm1hbmNlID8gZnVuY3Rpb24oKSB7IHJldHVybiBwZXJmb3JtYW5jZS5ub3coKTsgfSA6IERhdGUubm93O1xuXG5DbG9jay50aWNrcyA9IDA7XG5DbG9jay5mcHMgPSA2MC4wO1xuQ2xvY2sudGltZSA9IDAuMDtcbkNsb2NrLnJlYWxUaW1lID0gMC4wO1xuQ2xvY2suYWNjdW1UaW1lID0gMC4wO1xuQ2xvY2suZGVsdGFUaW1lID0gMS4wIC8gQ2xvY2suZnBzO1xuQ2xvY2sucmVhbERlbHRhVGltZSA9IENsb2NrLmRlbHRhVGltZTtcblxuQ2xvY2sudGltZVNjYWxlID0gMS4wO1xuXG4vLyBkZWJ1Z2dpbmdcbndpbmRvdy5DTE9DSyA9IENsb2NrO1xuXG5tb2R1bGUuZXhwb3J0cyA9IENsb2NrO1xuIiwiJ3VzZSBzdHJpY3QnO1xuY29uc3Qge0FTU0VSVH0gPSByZXF1aXJlKCcuL2RlYnVnJyk7XG5cbmxldCBzY3JhdGNoQXJyYXkgPSBbXTtcbmNsYXNzIENvbGxpc2lvbkdyaWQge1xuXHRjb25zdHJ1Y3Rvcih3aWR0aCwgaGVpZ2h0LCBjZWxsU2l6ZSkge1xuXHRcdHRoaXMud2lkdGggPSBNYXRoLmNlaWwod2lkdGgvY2VsbFNpemUpO1xuXHRcdHRoaXMuaGVpZ2h0ID0gTWF0aC5jZWlsKGhlaWdodC9jZWxsU2l6ZSk7XG5cdFx0dGhpcy5jZWxsU2l6ZSA9IGNlbGxTaXplO1xuXHRcdHRoaXMuY2VsbHMgPSBuZXcgQXJyYXkodGhpcy53aWR0aCp0aGlzLmhlaWdodCk7XG5cdFx0Zm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLndpZHRoKnRoaXMuaGVpZ2h0OyArK2kpIHtcblx0XHRcdHRoaXMuY2VsbHNbaV0gPSBbXTtcblx0XHR9XG5cdH1cblxuXHRhZGQoZSkge1xuXHRcdEFTU0VSVChlLnBvcy54ID49IDAgJiYgZS5wb3MueCA8IHRoaXMud2lkdGgqdGhpcy5jZWxsU2l6ZSk7XG5cdFx0QVNTRVJUKGUucG9zLnkgPj0gMCAmJiBlLnBvcy55IDwgdGhpcy5oZWlnaHQqdGhpcy5jZWxsU2l6ZSk7XG5cdFx0QVNTRVJUKGUuX2NlbGwgPT09IC0xKTtcblx0XHRjb25zdCBjZWxsWCA9IE1hdGguZmxvb3IoZS5wb3MueCAvIHRoaXMuY2VsbFNpemUpO1xuXHRcdGNvbnN0IGNlbGxZID0gTWF0aC5mbG9vcihlLnBvcy55IC8gdGhpcy5jZWxsU2l6ZSk7XG5cblx0XHRjb25zdCBjZWxsSW5kZXggPSBjZWxsWCArIGNlbGxZKnRoaXMud2lkdGg7XG5cdFx0Y29uc3QgbmV3Q2VsbCA9IHRoaXMuY2VsbHNbY2VsbEluZGV4XTtcblx0XHRlLl9jZWxsID0gY2VsbEluZGV4O1xuXHRcdGUuX2luZGV4SW5DZWxsID0gbmV3Q2VsbC5sZW5ndGg7XG5cdFx0bmV3Q2VsbC5wdXNoKGUpO1xuXHR9XG5cblx0cmVtb3ZlKGUpIHtcblx0XHRBU1NFUlQoZS5fY2VsbCAhPT0gLTEpO1xuXHRcdEFTU0VSVChlLl9pbmRleEluQ2VsbCAhPT0gLTEpO1xuXHRcdGNvbnN0IGNlbGwgPSB0aGlzLmNlbGxzW2UuX2NlbGxdO1xuXHRcdEFTU0VSVChjZWxsW2UuX2luZGV4SW5DZWxsXSA9PT0gZSk7XG5cdFx0Y29uc3QgaW5kZXhJbkNlbGwgPSBlLl9pbmRleEluQ2VsbDtcdFxuXG5cdFx0Y2VsbFtpbmRleEluQ2VsbF0gPSBjZWxsW2NlbGwubGVuZ3RoLTFdO1xuXHRcdGNlbGxbaW5kZXhJbkNlbGxdLl9pbmRleEluQ2VsbCA9IGluZGV4SW5DZWxsO1xuXHRcdGNlbGwucG9wKCk7XG5cdFx0ZS5fY2VsbCA9IC0xO1xuXHRcdGUuX2luZGV4SW5DZWxsID0gLTE7XG5cdH1cblxuXHR1cGRhdGUoZSkge1xuXHRcdHRoaXMucmVtb3ZlKGUpO1xuXHRcdHRoaXMuYWRkKGUpO1xuXHR9XG5cblx0ZW50aXRpZXNBcm91bmQoZSkge1xuXHRcdGxldCByZXN1bHQgPSBzY3JhdGNoQXJyYXk7XG5cblx0XHRjb25zdCB7Y2VsbHMsIHdpZHRoLCBoZWlnaHR9ID0gdGhpcztcblxuXHRcdGNvbnN0IGNlbGxZID0gTWF0aC5mbG9vcihlLl9jZWxsIC8gd2lkdGgpO1xuXHRcdGNvbnN0IGNlbGxYID0gZS5fY2VsbCAlIHdpZHRoO1xuXG5cdFx0Y29uc3QgbWluWCA9IE1hdGgubWF4KDAsIGNlbGxYLTEpO1xuXHRcdGNvbnN0IG1heFggPSBNYXRoLm1pbihjZWxsWCsxLCB3aWR0aC0xKTtcblx0XHRcblx0XHRjb25zdCBtaW5ZID0gTWF0aC5tYXgoMCwgY2VsbFktMSk7XG5cdFx0Y29uc3QgbWF4WSA9IE1hdGgubWluKGNlbGxZKzEsIGhlaWdodC0xKTtcblxuXHRcdGZvciAobGV0IHkgPSBtaW5ZOyB5IDw9IG1heFk7ICsreSkge1xuXHRcdFx0Zm9yIChsZXQgeCA9IG1pblg7IHggPD0gbWF4WDsgKyt4KSB7XG5cdFx0XHRcdGNvbnN0IGNlbGxJbmRleCA9IHggKyB5ICogd2lkdGg7XG5cdFx0XHRcdGNvbnN0IGNlbGwgPSBjZWxsc1tjZWxsSW5kZXhdO1xuXHRcdFx0XHRmb3IgKGxldCBpID0gMCwgbCA9IGNlbGwubGVuZ3RoOyBpIDwgbDsgKytpKSB7XG5cdFx0XHRcdFx0cmVzdWx0LnB1c2goY2VsbFtpXSk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cdFx0cmV0dXJuIHJlc3VsdDtcblx0fVxuXG5cdC8vIGdldENvbGxpZGFibGVQYWlycyhvdXRQMCwgb3V0UDEsIGVudGl0aWVzKSB7XG5cdC8vIFx0bGV0IGxvb2t1cCA9IHt9O1xuXHQvLyBcdG91dFAxLmxlbmd0aCA9IDA7XG5cdC8vIFx0b3V0UDAubGVuZ3RoID0gMDtcblx0Ly8gXHRsZXQge2NlbGxzLCB3aWR0aCwgaGVpZ2h0fSA9IHRoaXM7XG5cdC8vIFx0Zm9yIChsZXQgeSA9IDA7IHkgPCBoZWlnaHQ7ICsreSkge1xuXHQvLyBcdFx0Zm9yIChsZXQgeCA9IDA7IHggPCB3aWR0aDsgKyt4KSB7XG5cdC8vIFx0XHRcdGNvbnN0IG1pblggPSBNYXRoLm1heCgwLCB4LTEpO1xuXHQvLyBcdFx0XHRjb25zdCBtYXhYID0gTWF0aC5taW4oeCsxLCB3aWR0aC0xKTtcblx0Ly8gXHRcdFx0Y29uc3QgbWluWSA9IE1hdGgubWF4KDAsIHktMSk7XG5cdC8vIFx0XHRcdGNvbnN0IG1heFkgPSBNYXRoLm1pbih5KzEsIGhlaWdodC0xKTtcblxuXHQvLyBcdFx0XHRmb3IgKGxldCB5eSA9IG1pblk7IHl5IDw9IG1heFk7ICsreXkpIHtcblx0Ly8gXHRcdFx0XHRmb3IgKGxldCB4eCA9IG1pblg7IHh4IDw9IG1heFg7ICsreHgpIHtcblx0Ly8gXHRcdFx0XHRcdGNvbnN0IGNlbGxJbmRleCA9IHh4ICsgeXkgKiB3aWR0aDtcblx0Ly8gXHRcdFx0XHRcdGNvbnN0IGNlbGwgPSBjZWxsc1tjZWxsSW5kZXhdO1xuXHQvLyBcdFx0XHRcdFx0Zm9yIChsZXQgaSA9IDAsIGwgPSBjZWxsLmxlbmd0aDsgaSA8IGw7ICsraSkge1xuXHQvLyBcdFx0XHRcdFx0fVxuXHQvLyBcdFx0XHRcdH1cblx0Ly8gXHRcdFx0fVxuXG5cdC8vIFx0XHR9XG5cdC8vIFx0fVxuXHQvLyB9XG59XG5cbm1vZHVsZS5leHBvcnRzID0gQ29sbGlzaW9uR3JpZDtcbiIsIid1c2Ugc3RyaWN0JztcblxuY29uc3QgRlBTID0gZXhwb3J0cy5GUFMgPSA2MC4wO1xuY29uc3QgU2NhbGUgPSBleHBvcnRzLlNjYWxlID0gMztcblxuY29uc3QgQ2xpZW50U2NyZWVuV2lkdGggPSBleHBvcnRzLkNsaWVudFNjcmVlbldpZHRoID0gOTYwO1xuY29uc3QgQ2xpZW50U2NyZWVuSGVpZ2h0ID0gZXhwb3J0cy5DbGllbnRTY3JlZW5IZWlnaHQgPSA1NDA7XG5cbmNvbnN0IFNjcmVlbkhlaWdodCA9IGV4cG9ydHMuU2NyZWVuSGVpZ2h0ID0gKENsaWVudFNjcmVlbkhlaWdodC9TY2FsZSk+Pj4wO1xuY29uc3QgU2NyZWVuV2lkdGggPSBleHBvcnRzLlNjcmVlbldpZHRoID0gKENsaWVudFNjcmVlbldpZHRoL1NjYWxlKT4+PjA7XG5cbmNvbnN0IERldmljZVBpeGVscyA9IGV4cG9ydHMuRGV2aWNlUGl4ZWxzID0gKHdpbmRvdy5kZXZpY2VQaXhlbFJhdGlvIHx8IHdpbmRvdy53ZWJraXREZXZpY2VQaXhlbFJhdGlvIHx8IDEuMCk7XG5cbmNvbnN0IFRpbGVTaXplID0gZXhwb3J0cy5UaWxlU2l6ZSA9IDE2O1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG5jb25zdCBERUJVRyA9IGZhbHNlO1xuXG5cbndpbmRvdy5ERUJVRyA9IERFQlVHO1xuXG5cbmZ1bmN0aW9uIGFzc2VydChjbmQsIG1zZykge1xuXHRpZiAoY25kKSByZXR1cm47XG5cdGNvbnNvbGUuZXJyb3IoXCJBc3NlcnRhdGlvbiBmYWlsZWQ6IFwiKyhtc2d8fFwibm8gbWVzc2FnZVwiKSk7XG5cdHRocm93IG5ldyBFcnJvcihcIkFzc2VydGF0aW9uIGZhaWx1cmVcIik7XG59XG5cbmlmICh3aW5kb3cuREVCVUcpIHtcblx0d2luZG93LkFTU0VSVCA9IGV4cG9ydHMuQVNTRVJUID0gYXNzZXJ0O1xufVxuZWxzZSB7XG5cdHdpbmRvdy5BU1NFUlQgPSBleHBvcnRzLkFTU0VSVCA9IGZ1bmN0aW9uKCkge307XG59XG5cblxuZXhwb3J0cy5kZWJ1ZyA9IERFQlVHO1xuXG4iLCIndXNlIHN0cmljdCc7XG5cblxuZXhwb3J0cy5ibGl0RnVsbENhbnZhcyA9IGJsaXRGdWxsQ2FudmFzO1xuZnVuY3Rpb24gYmxpdEZ1bGxDYW52YXMoY29udGV4dCwgY2FudmFzKSB7XG5cdGNvbnRleHQuZHJhd0ltYWdlKGNhbnZhcyxcblx0XHQwLCAwLCBjYW52YXMud2lkdGgsIGNhbnZhcy5oZWlnaHQsXG5cdFx0MCwgMCwgY29udGV4dC5jYW52YXMud2lkdGgsIGNvbnRleHQuY2FudmFzLmhlaWdodCk7XG59XG5cbi8vIHRoZXNlIGFyZSBtb3N0bHkgZm9yIHRoZSBkZWJ1ZyBjYW52YXNcbmV4cG9ydHMuZHJhd0xpbmUgPSBkcmF3TGluZTtcbmZ1bmN0aW9uIGRyYXdMaW5lKGN0eCwgeDAsIHkwLCB4MSwgeTEsIHtlbmRwb2ludHM9ZmFsc2UsIGNvbG9yPScnfT17fSkge1xuXHRsZXQgb2xkU3Ryb2tlU3R5bGUgPSBjdHguc3Ryb2tlU3R5bGU7XG5cdGlmIChjb2xvcikgY3R4LnN0cm9rZVN0eWxlID0gY29sb3I7XG5cdGN0eC5iZWdpblBhdGgoKTtcblx0Y3R4Lm1vdmVUbyh4MCwgeTApO1xuXHRjdHgubGluZVRvKHgxLCB5MSk7XG5cdGN0eC5zdHJva2UoKTtcblx0aWYgKGVuZHBvaW50cykge1xuXHRcdGRyYXdCb3goY3R4LCB4MCwgeTApO1xuXHRcdGRyYXdCb3goY3R4LCB4MSwgeTEpO1xuXHR9XG5cdGlmIChjb2xvcikgY3R4LnN0cm9rZVN0eWxlID0gb2xkU3Ryb2tlU3R5bGU7XG59XG5cbmV4cG9ydHMuZHJhd0JveCA9IGRyYXdCb3g7XG5mdW5jdGlvbiBkcmF3Qm94KGN0eCwgeCwgeSwgc3o9Mikge1xuXHRsZXQgaHMgPSBzei8yXG5cdGN0eC5zdHJva2VSZWN0KHgtaHMsIHktaHMsIHN6LCBzeik7XG59XG5cbmV4cG9ydHMuZHJhd0Fycm93ID0gZHJhd0Fycm93O1xuZnVuY3Rpb24gZHJhd0Fycm93KGN0eCwgeDAsIHkwLCB4MSwgeTEsIG4pIHtcblx0ZHJhd0xpbmUoY3R4LCB4MCwgeTAsIHgxLCB5MSk7XG5cdGxldCBkeCA9IHgwLXgxLCBkeSA9IHkwLXkxO1xuXHRsZXQgbCA9IE1hdGguc3FydChkeCpkeCtkeSpkeSk7XG5cdGlmIChsICE9PSAwLjApIHtcblx0XHRkeCAvPSBsO1xuXHRcdGR5IC89IGw7XG5cdFx0ZHJhd0xpbmUoY3R4LCB4MSwgeTEsIHgxK24qZHgrbipkeSwgeTErbipkeS1uKmR4KTtcblx0fVxufVxuXG5leHBvcnRzLmRyYXdDaXJjbGUgPSBkcmF3Q2lyY2xlO1xuZnVuY3Rpb24gZHJhd0NpcmNsZShjdHgsIHgwLCB5MCwgcikge1xuXHRjdHguYmVnaW5QYXRoKCk7XG5cdGN0eC5tb3ZlVG8oeDAsIHkwKTtcblx0Y3R4LmFyYyh4MCwgeTAsIHIsIDAsIE1hdGguUEkqMik7XG5cdGN0eC5zdHJva2UoKTtcbn1cbiIsIid1c2Ugc3RyaWN0JztcbmNvbnN0IEVudGl0eSA9IHJlcXVpcmUoJy4vZW50aXR5Jyk7XG5jb25zdCBJbnB1dCA9IHJlcXVpcmUoJy4vaW5wdXQnKTtcbmNvbnN0IHtSTkd9ID0gcmVxdWlyZSgnLi9yYW5kJyk7XG5jb25zdCBkcmF3aW5nID0gcmVxdWlyZSgnLi9kcmF3aW5nJyk7XG5jb25zdCBDb25zdHMgPSByZXF1aXJlKCcuL2NvbnN0YW50cycpO1xuY29uc3QgQ2xvY2sgPSByZXF1aXJlKCcuL2Nsb2NrJyk7XG5jb25zdCBCdWxsZXQgPSByZXF1aXJlKCcuL2J1bGxldCcpO1xuY29uc3QgR29yZSA9IHJlcXVpcmUoJy4vZ29yZScpO1xuY29uc3QgQmxvb2QgPSByZXF1aXJlKCcuL2Jsb29kJyk7XG5jb25zdCBTb3VuZHMgPSByZXF1aXJlKCcuL2F1ZGlvJyk7XG5jb25zdCBtYXRoID0gcmVxdWlyZSgnLi9tYXRoJyk7XG5jb25zdCBWZWMyID0gcmVxdWlyZSgnLi92ZWMyJyk7XG5jb25zdCBTVEFURSA9IHtcblx0V2FuZGVyOiAwLFxuXHRBdHRhY2s6IDEsXG5cdFNlYXJjaDogMixcblx0V2FpdDogMyxcbn1cblxuY2xhc3MgRW5lbXkgZXh0ZW5kcyBFbnRpdHkge1xuXHRjb25zdHJ1Y3RvcihnYW1lLCB4LCB5KSB7XG5cdFx0c3VwZXIoZ2FtZSwgeCwgeSk7XG5cdFx0dGhpcy5yYWRpdXMgPSA1LjA7XG5cdFx0dGhpcy5ub3JtYWxpemVBY2NlbCA9IHRydWU7XG5cdFx0dGhpcy5zcGVlZCA9IDE0KjIwO1xuXHRcdHRoaXMuZHJhZy5zZXQoOCwgOCk7XG5cdFx0dGhpcy53YWxraW5nID0gZmFsc2U7XG5cdFx0dGhpcy5hbmltUHJvZ3Jlc3MgPSAwLjA7XG5cdFx0dGhpcy5tYXhIZWFsdGggPSAxNTtcblx0XHR0aGlzLmhlYWx0aCA9IHRoaXMubWF4SGVhbHRoO1xuXHRcdHRoaXMuY2FzdHNTaGFkb3cgPSB0cnVlO1xuXHRcdHRoaXMudGFyZ2V0UG9zID0gbmV3IFZlYzIoKTtcblx0XHR0aGlzLmhhdmVUYXJnZXQgPSBmYWxzZTtcblx0XHR0aGlzLmxhc3RTYXdQbGF5ZXIgPSBuZXcgVmVjMigpO1xuXHRcdHRoaXMuc3RhdGUgPSBTVEFURS5XYW5kZXI7XG5cdFx0dGhpcy53YWl0VGltZXIgPSAwLjA7XG5cdFx0dGhpcy5zaG9vdFRpbWVyID0gMC4wO1xuXHRcdHRoaXMudHlwZSA9IFJORy51cFRvKHRoaXMuZ2FtZS5hc3NldHMuZW5lbXlSb3RhdGlvbnMubGVuZ3RoKTtcblx0fVxuXG5cdHBpY2tSYW5kb21UYXJnZXQoKSB7XG5cdFx0bGV0IHAgPSBWZWMyLnRlbXAoKSwgbiA9IFZlYzIudGVtcCgpO1xuXHRcdGZvciAobGV0IGkgPSAwOyBpIDwgMzsgKytpKSB7XG5cdFx0XHRsZXQgdiA9IFZlYzIudGVtcChSTkcuYmV0d2VlbkYoLTEsIDEpLCBSTkcuYmV0d2VlbkYoLTEsIDEpKS5ub3JtYWxpemUoKTtcblx0XHRcdGxldCByID0gdGhpcy5nYW1lLnJheWNhc3QodGhpcy50YXJnZXRQb3MsIG4sIHRoaXMucG9zLCB2LCAxMDAwKTtcblx0XHRcdGlmIChyID4gMjAgfHwgUk5HLm9uZUNoYW5jZUluKDEwKSkge1xuXHRcdFx0XHR0aGlzLm1vdmVUb3dhcmRzKHRoaXMudGFyZ2V0UG9zKTtcblx0XHRcdFx0dGhpcy5zdGF0ZSA9IFNUQVRFLldhbmRlcjtcblx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0fVxuXHRcdH1cblx0XHR0aGlzLnN0YXRlID0gU1RBVEUuV2FpdDtcblx0fVxuXG5cdG9uQ29sbGlzaW9uKHdobykge1xuXHRcdGlmICh0aGlzLnN0YXRlID09PSBTVEFURS5XYW5kZXIgJiYgd2hvID09IG51bGwpIHtcblx0XHRcdHRoaXMucGlja1JhbmRvbVRhcmdldCgpO1xuXHRcdH1cblx0fVxuXG5cdGRhbWFnZShhbXQsIHBvcywgdmVsKSB7XG5cdFx0dGhpcy5oZWFsdGggLT0gYW10O1xuXHRcdGlmICh0aGlzLmhlYWx0aCA8PSAwKSB7XG5cdFx0XHRTb3VuZHMucGxheSgnZGllJyk7XG5cdFx0XHR0aGlzLnNvbGlkID0gZmFsc2U7XG5cdFx0XHR0aGlzLmNhc3RzU2hhZG93ID0gZmFsc2U7XG5cdFx0XHR0aGlzLmdhbWUuZ3JpZC5yZW1vdmUodGhpcylcblx0XHRcdHRoaXMuY29sbGlkZXNXaXRoRW50aXRpZXMgPSBmYWxzZTtcblx0XHRcdHRoaXMuY29sbGlkZXNXaXRoUGxheWVyID0gZmFsc2U7XG5cdFx0fSBlbHNlIHtcblx0XHRcdFNvdW5kcy5wbGF5KCdtb25zdE91Y2gnKTtcblx0XHR9XG5cdFx0dGhpcy5kcmFnLnggKz0gMjtcblx0XHR0aGlzLmRyYWcueSArPSAyO1xuXG5cdFx0bGV0IGdpYiA9IG5ldyBHb3JlKHRoaXMuZ2FtZSwgcG9zLngsIHBvcy55KTtcblx0XHRnaWIudmVsLnNjYWxlKDAuMSkuYWRkU2NhbGVkKHZlbCwgMC40KTtcblx0XHR0aGlzLmdhbWUuYWRkRW50aXR5KGdpYik7XG5cdH1cblxuXHRtb3ZlVG93YXJkcyhwb3MpIHtcblx0XHRsZXQgZnkgPSBwb3MueS10aGlzLnBvcy55O1xuXHRcdGxldCBmeCA9IHBvcy54LXRoaXMucG9zLng7XG5cdFx0bGV0IGxlbiA9IE1hdGguc3FydChmeCpmeCtmeSpmeSk7XG5cblx0XHR0aGlzLmFjYy5zZXQoKHBvcy54LXRoaXMucG9zLngpL0NvbnN0cy5UaWxlU2l6ZSwgKHBvcy55LXRoaXMucG9zLnkpL0NvbnN0cy5UaWxlU2l6ZSk7XG5cdFx0dGhpcy53YWxraW5nID0gdHJ1ZTtcblx0XHR0aGlzLmhlYWRpbmcgPSBNYXRoLmF0YW4yKGZ5LCBmeCk7XG5cdH1cblxuXHR0aGluayhkdCkge1xuXHRcdGlmICh0aGlzLmhlYWx0aCA8PSAwKSByZXR1cm47XG5cblx0XHRpZiAodGhpcy5oZWFsdGggIT0gdGhpcy5tYXhIZWFsdGgpIHtcblx0XHRcdGlmIChSTkcueENoYW5jZUluWSh0aGlzLm1heEhlYWx0aC10aGlzLmhlYWx0aCwgdGhpcy5tYXhIZWFsdGgpKSB7XG5cdFx0XHRcdGxldCBibG9vZCA9IG5ldyBCbG9vZCh0aGlzLmdhbWUsIHRoaXMucG9zLngsIHRoaXMucG9zLnkpO1xuXHRcdFx0XHRibG9vZC56UG9zID0gNTtcblx0XHRcdFx0Ymxvb2QudmVsLnggKj0gMC4wNTsgYmxvb2QudmVsLnggKz0gdGhpcy52ZWwueDtcblx0XHRcdFx0Ymxvb2QudmVsLnkgKj0gMC4wNTsgYmxvb2QudmVsLnkgKz0gdGhpcy52ZWwueTtcblx0XHRcdFx0dGhpcy5nYW1lLmFkZEVudGl0eShibG9vZCk7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0aWYgKHRoaXMud2Fsa2luZykge1xuXHRcdFx0dGhpcy5hbmltUHJvZ3Jlc3MgKz0gTWF0aC5taW4odGhpcy5sYXN0UG9zLmRpc3RhbmNlKHRoaXMucG9zKS8xMCwgMSk7XG5cdFx0fVxuXG5cdFx0aWYgKHRoaXMuc3RhdGUgPT09IFNUQVRFLldhbmRlcikge1xuXHRcdFx0dGhpcy5kcmFnLnNldCgxMCwgMTApO1xuXHRcdH1cblx0XHRlbHNlIHtcblx0XHRcdHRoaXMuZHJhZy5zZXQoOCwgOCk7XG5cdFx0fVxuXG5cdFx0bGV0IGNhblNlZVBsYXllciA9IHRoaXMuZ2FtZS5jYW5TZWUodGhpcy5wb3MsIHRoaXMuZ2FtZS5wbGF5ZXIucG9zKTtcblx0XHRpZiAoY2FuU2VlUGxheWVyICYmIHRoaXMuc3RhdGUgIT09IFNUQVRFLkF0dGFjaykge1xuXHRcdFx0U291bmRzLnBsYXkoUk5HLmNob29zZShbJ3dhaXQnLCAnc3RvcCddKSk7XG5cdFx0XHR0aGlzLnN0YXRlID0gU1RBVEUuQXR0YWNrO1xuXHRcdFx0dGhpcy5sYXN0U2F3UGxheWVyLmNvcHkodGhpcy5nYW1lLnBsYXllci5wb3MpO1xuXHRcdFx0dGhpcy5zaG9vdEF0KHRoaXMuZ2FtZS5wbGF5ZXIucG9zKVxuXHRcdH1cblx0XHRlbHNlIGlmICh0aGlzLnN0YXRlID09PSBTVEFURS5BdHRhY2sgJiYgIWNhblNlZVBsYXllcikge1xuXHRcdFx0dGhpcy5zdGF0ZSA9IFNUQVRFLlNlYXJjaDtcblx0XHR9XG5cblx0XHRzd2l0Y2ggKHRoaXMuc3RhdGUpIHtcblx0XHRjYXNlIFNUQVRFLldhbmRlcjpcblx0XHRcdGlmICh0aGlzLnBvcy5kaXN0YW5jZSh0aGlzLnRhcmdldFBvcykgPCA4KSB7XG5cdFx0XHRcdHRoaXMud2FpdFRpbWVyID0gUk5HLmJldHdlZW5GKDEuMCwgMy4wKTtcblx0XHRcdFx0dGhpcy5zdGF0ZSA9IFNUQVRFLldhaXQ7XG5cdFx0XHR9XG5cdFx0XHRlbHNlIHtcblx0XHRcdFx0dGhpcy5tb3ZlVG93YXJkcyh0aGlzLnRhcmdldFBvcyk7XG5cdFx0XHR9XG5cdFx0XHRicmVhaztcblx0XHRjYXNlIFNUQVRFLldhaXQ6XG5cdFx0XHR0aGlzLndhaXRUaW1lciAtPSBkdDtcblx0XHRcdGlmICh0aGlzLndhaXRUaW1lciA8IDApIHtcblx0XHRcdFx0dGhpcy5zdGF0ZSA9IFNUQVRFLldhbmRlcjtcblx0XHRcdFx0dGhpcy5waWNrUmFuZG9tVGFyZ2V0KCk7XG5cdFx0XHR9XG5cdFx0XHRlbHNlIHtcblx0XHRcdFx0aWYgKFJORy5vbmVDaGFuY2VJbig2MCkpIHtcblx0XHRcdFx0XHR0aGlzLmhlYWRpbmcgPSBSTkcuYmV0d2VlbkYoMCwgTWF0aC5QSSoyKTtcblx0XHRcdFx0fVxuXHRcdFx0XHRpZiAoUk5HLm9uZUNoYW5jZUluKDYwKSkge1xuXHRcdFx0XHRcdHRoaXMuYWNjLnNldChSTkcuYmV0d2VlbkYoLTEwLCAxMCksIFJORy5iZXR3ZWVuRigtMTAsIDEwKSk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblxuXHRcdFx0YnJlYWs7XG5cdFx0Y2FzZSBTVEFURS5TZWFyY2g6XG5cdFx0XHRpZiAodGhpcy5wb3MuZGlzdGFuY2UodGhpcy5sYXN0U2F3UGxheWVyKSA8IDgpIHtcblx0XHRcdFx0dGhpcy5zdGF0ZSA9IFNUQVRFLldhaXQ7XG5cdFx0XHRcdHRoaXMud2FpdFRpbWVyID0gUk5HLmJldHdlZW5GKDAuMCwgMS4wKTtcblx0XHRcdH1cblx0XHRcdGVsc2Uge1xuXHRcdFx0XHR0aGlzLm1vdmVUb3dhcmRzKHRoaXMuZ2FtZS5wbGF5ZXIucG9zKTtcblx0XHRcdH1cblx0XHRcdGJyZWFrO1xuXHRcdGNhc2UgU1RBVEUuQXR0YWNrOlxuXHRcdFx0dGhpcy5zaG9vdFRpbWVyIC09IGR0O1xuXHRcdFx0bGV0IHBkaXN0ID0gdGhpcy5wb3MuZGlzdGFuY2UodGhpcy5nYW1lLnBsYXllci5wb3MpO1xuXHRcdFx0aWYgKHBkaXN0IDwgMzApIHtcblx0XHRcdFx0dGhpcy5zaG9vdFRpbWVyIC09IGR0KjI7XG5cdFx0XHR9XG5cdFx0XHRpZiAocGRpc3QgPCAxMDApIHtcblx0XHRcdFx0dGhpcy5tb3ZlVG93YXJkcyh0aGlzLmdhbWUucGxheWVyLnBvcyk7XG5cdFx0XHR9XG5cdFx0XHRpZiAodGhpcy5zaG9vdFRpbWVyIDwgMCkge1xuXHRcdFx0XHR0aGlzLnNob290QXQodGhpcy5nYW1lLnBsYXllci5wb3MpO1xuXHRcdFx0fVxuXHRcdFx0YnJlYWs7XG5cdFx0fVxuXHR9XG5cblx0cG9zdFVwZGF0ZSgpIHtcblx0XHR0aGlzLmFjYy5zZXQoMCwgMCk7XG5cdH1cblxuXHRzaG9vdEF0KHBvcykge1xuXHRcdGxldCBmeSA9IHBvcy55LXRoaXMucG9zLnk7XG5cdFx0bGV0IGZ4ID0gcG9zLngtdGhpcy5wb3MueDtcblx0XHRsZXQgbGVuID0gTWF0aC5zcXJ0KGZ4KmZ4K2Z5KmZ5KTtcblx0XHRpZiAobGVuICE9IDApIHtcblx0XHRcdGxldCBidWxsZXQgPSBuZXcgQnVsbGV0KHRoaXMuZ2FtZSwgdGhpcywgZngvbGVuLCBmeS9sZW4pO1xuXHRcdFx0dGhpcy5nYW1lLmFkZEVudGl0eShidWxsZXQpO1xuXHRcdH1cblx0XHR0aGlzLnNob290VGltZXIgPSBSTkcuYmV0d2VlbkYoMSwgNCk7XG5cdH1cblxuXHRyZW5kZXIobGF5ZXIpIHtcblx0XHRpZiAoIXRoaXMuZ2FtZS5jYW5TZWUodGhpcy5nYW1lLnBsYXllci5wb3MsIFZlYzIudGVtcCh0aGlzLnBvcy54K3RoaXMucmFkaXVzLCB0aGlzLnBvcy55K3RoaXMucmFkaXVzKSkmJlxuXHRcdCAgICAhdGhpcy5nYW1lLmNhblNlZSh0aGlzLmdhbWUucGxheWVyLnBvcywgVmVjMi50ZW1wKHRoaXMucG9zLngrdGhpcy5yYWRpdXMsIHRoaXMucG9zLnktdGhpcy5yYWRpdXMpKSYmXG5cdFx0ICAgICF0aGlzLmdhbWUuY2FuU2VlKHRoaXMuZ2FtZS5wbGF5ZXIucG9zLCBWZWMyLnRlbXAodGhpcy5wb3MueC10aGlzLnJhZGl1cywgdGhpcy5wb3MueSt0aGlzLnJhZGl1cykpJiZcblx0XHQgICAgIXRoaXMuZ2FtZS5jYW5TZWUodGhpcy5nYW1lLnBsYXllci5wb3MsIFZlYzIudGVtcCh0aGlzLnBvcy54LXRoaXMucmFkaXVzLCB0aGlzLnBvcy55LXRoaXMucmFkaXVzKSkpIHtcblx0XHRcdHJldHVybjtcblx0XHR9XG5cdFx0aWYgKHRoaXMuaGVhbHRoIDw9IDApIHtcblx0XHRcdGxheWVyLmNvbnRleHQuZHJhd0ltYWdlKHRoaXMuZ2FtZS5hc3NldHMuZGVhZEVuZW1pZXNbdGhpcy50eXBlXS5jYW52YXMsXG5cdFx0XHRcdDAsIDAsIDMyLCAxNiwgTWF0aC5yb3VuZCh0aGlzLnBvcy54LTE2KSwgTWF0aC5yb3VuZCh0aGlzLnBvcy55LTgpLCAzMiwgMTYpO1xuXHRcdFx0bGF5ZXIuY29udGV4dC5kcmF3SW1hZ2UodGhpcy5nYW1lLmFzc2V0cy5kZWFkRW5lbWllc1t0aGlzLnR5cGVdLmNhbnZhcyxcblx0XHRcdFx0MCwgMTYsIDMyLCAxNiwgTWF0aC5yb3VuZCh0aGlzLnBvcy54LTE2KSwgTWF0aC5yb3VuZCh0aGlzLnBvcy55LTgpLCAzMiwgMTYpO1xuXHRcdH1cblx0XHRlbHNlIHtcblx0XHRcdGxldCByb3RhdGlvbiA9IE1hdGgucm91bmQodGhpcy5oZWFkaW5nIC8gKE1hdGguUEkqMikqMTYpJjE1O1xuXG5cdFx0XHRsZXQgYW5pbSA9ICh0aGlzLndhbGtpbmcgPyBNYXRoLmZsb29yKHRoaXMuYW5pbVByb2dyZXNzJTcpIDogMCkgKyAwXG5cdFx0XHRsYXllci5jb250ZXh0LmRyYXdJbWFnZSh0aGlzLmdhbWUuYXNzZXRzLmVuZW15Um90YXRpb25zW3RoaXMudHlwZV0uY2FudmFzLFxuXHRcdFx0XHQxNiphbmltLCAxNipyb3RhdGlvbiwgMTYsIDE2LFxuXHRcdFx0XHRNYXRoLnJvdW5kKHRoaXMucG9zLngtOCksXG5cdFx0XHRcdE1hdGgucm91bmQodGhpcy5wb3MueS04KSxcblx0XHRcdFx0MTYsIDE2KTtcblx0XHR9XG5cdFx0Ly8gZHJhd2luZy5kcmF3Q2lyY2xlKHRoaXMuZ2FtZS5kZWJ1Z0NvbnRleHQsIHRoaXMucG9zLngsIHRoaXMucG9zLnksIHRoaXMucmFkaXVzKTtcblx0XHQvLyhsYXllci5jb250ZXh0LCB0aGlzLnBvcy54LW14LCB0aGlzLnBvcy55LW15LCB0aGlzLnJhZGl1cyk7XG5cdH1cblxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IEVuZW15O1xuXG5cblxuIiwiJ3VzZSBzdHJpY3QnO1xuXG5jb25zdCB7VHdlZW4sIFR3ZWVuR3JvdXB9ID0gcmVxdWlyZSgnLi90d2VlbnMnKVxuY29uc3Qge2Rpc3RhbmNlMkR9ID0gcmVxdWlyZSgnLi9tYXRoJyk7XG5jb25zdCBWZWMyID0gcmVxdWlyZSgnLi92ZWMyJyk7XG5jb25zdCBMaW5lU2VnbWVudCA9IHJlcXVpcmUoJy4vbGluZV9zZWdtZW50JylcbmNsYXNzIEVudGl0eSB7XG5cdGNvbnN0cnVjdG9yKGdhbWUsIHg9MC4wLCB5PTAuMCwgej0wLjApIHtcblx0XHR0aGlzLmdhbWUgPSBnYW1lO1xuXHRcdHRoaXMuaWQgPSBFbnRpdHkuaWRDb3VudGVyKys7XG5cdFx0dGhpcy5wb3MgPSBuZXcgVmVjMih4LCB5KTtcblx0XHR0aGlzLnZlbCA9IG5ldyBWZWMyKDAsIDApO1xuXHRcdHRoaXMucmFkaXVzID0gMS4wO1xuXHRcdHRoaXMuZW5hYmxlZCA9IHRydWU7XG5cdFx0dGhpcy5lbGFzdGljID0gZmFsc2U7XG5cblx0XHR0aGlzLmNvbGxpZGVzV2l0aFdvcmxkID0gdHJ1ZTtcblx0XHR0aGlzLmNvbGxpZGVzV2l0aEVudGl0aWVzID0gdHJ1ZTtcblx0XHR0aGlzLmNvbGxpZGVzV2l0aFBsYXllciA9IHRydWU7XG5cdFx0dGhpcy5saWZlID0gMDtcblx0XHR0aGlzLnRpbWVkID0gZmFsc2U7XG5cblx0XHR0aGlzLnR3ZWVuR3JvdXAgPSBuZXcgVHdlZW5Hcm91cCgpO1xuXG5cdFx0dGhpcy5tb2JpbGUgPSB0cnVlO1xuXHRcdHRoaXMuc29saWQgPSB0cnVlO1xuXHRcdHRoaXMuY2FzdHNTaGFkb3cgPSBmYWxzZTtcblxuXHRcdHRoaXMuYWxwaGEgPSAxLjA7XG5cdFx0dGhpcy5sYXN0UG9zID0gbmV3IFZlYzIoMC4wLCAwLjApO1xuXHRcdHRoaXMuYWNjID0gbmV3IFZlYzIoMC4wLCAwLjApO1xuXHRcdHRoaXMuZHJhZyA9IG5ldyBWZWMyKDAuMCwgMC4wKTtcblx0XHR0aGlzLmNvbGxpc2lvbkl0ZXJhdGlvbnMgPSAxO1xuXG5cdFx0dGhpcy5oZWFkaW5nID0gMDtcblx0XHR0aGlzLnNoYWRvd1NlZ21lbnRzID0gbnVsbDtcblxuXHRcdHRoaXMubm9ybWFsaXplQWNjZWwgPSBmYWxzZTtcblx0XHR0aGlzLnNwZWVkID0gMTtcblxuXHRcdHRoaXMuX2NlbGwgPSAtMTtcblx0XHR0aGlzLl9pbmRleEluQ2VsbCA9IC0xO1xuXHRcdHRoaXMuZWxhc3RpY2l0eSA9IDAuNDtcblx0XHQvLyBAQEBIQUNLXG5cdFx0dGhpcy5oYXNaID0gZmFsc2U7XG5cdFx0dGhpcy56UG9zID0gejtcblx0XHR0aGlzLnpWZWwgPSAwO1xuXHRcdHRoaXMuekFjYyA9IDA7XG5cdFx0dGhpcy56RHJhZyA9IDA7XG5cdFx0dGhpcy56Qm91bmNlID0gMC44O1xuXHR9XG5cblx0dGhpbmsoZHQpIHt9XG5cdHBvc3RVcGRhdGUoZHQpIHt9XG5cdHRyeUdyaWRVcGRhdGUoKSB7dHJ5IHsgdGhpcy5nYW1lLmdyaWQudXBkYXRlKHRoaXMpOyB9IGNhdGNoIChlKSB7IHRoaXMuZW5hYmxlZCA9IGZhbHNlOyB9fSAvLyBAQEhBQ0t9XG5cblx0dXBkYXRlKGR0KSB7XG5cdFx0aWYgKCF0aGlzLmVuYWJsZWQpIHJldHVybjtcblx0XHR0aGlzLnRoaW5rKGR0KTtcblx0XHR0aGlzLnR3ZWVuR3JvdXAudXBkYXRlKGR0KTtcblx0XHRpZiAodGhpcy5tb2JpbGUpIHtcblx0XHRcdHRoaXMubW92ZShkdCk7XG5cdFx0XHRpZiAodGhpcy5jb2xsaWRlc1dpdGhFbnRpdGllcyB8fCB0aGlzLmNvbGxpZGVzV2l0aFBsYXllcikge1xuXHRcdFx0XHR0aGlzLnRyeUdyaWRVcGRhdGUoKTtcblx0XHRcdH1cblx0XHR9XG5cdFx0aWYgKHRoaXMudGltZWQpIHtcblx0XHRcdHRoaXMubGlmZSAtPSBkdDtcblx0XHRcdGlmICh0aGlzLmxpZmUgPD0gMCkge1xuXHRcdFx0XHR0aGlzLmVuYWJsZWQgPSBmYWxzZTtcblx0XHRcdH1cblx0XHR9XG5cdH1cblxuXHRkYW1hZ2UoKSB7fVxuXG5cdHVwZGF0ZVNoYWRvd1NlZ21lbnRzKCkge1xuXHRcdGxldCBtaW5YID0gdGhpcy5wb3MueC10aGlzLnJhZGl1cy8yO1xuXHRcdGxldCBtYXhYID0gdGhpcy5wb3MueCt0aGlzLnJhZGl1cy8yO1xuXHRcdGxldCBtaW5ZID0gdGhpcy5wb3MueS10aGlzLnJhZGl1cy8yO1xuXHRcdGxldCBtYXhZID0gdGhpcy5wb3MueSt0aGlzLnJhZGl1cy8yO1xuXG5cdFx0bGV0IHQwID0gVmVjMi50ZW1wKG1pblgsIG1pblkpLnJvdGF0ZSh0aGlzLmhlYWRpbmcsIHRoaXMucG9zKTtcblx0XHRsZXQgdDEgPSBWZWMyLnRlbXAobWluWCwgbWF4WSkucm90YXRlKHRoaXMuaGVhZGluZywgdGhpcy5wb3MpO1xuXHRcdGxldCB0MiA9IFZlYzIudGVtcChtYXhYLCBtYXhZKS5yb3RhdGUodGhpcy5oZWFkaW5nLCB0aGlzLnBvcyk7XG5cdFx0bGV0IHQzID0gVmVjMi50ZW1wKG1heFgsIG1pblkpLnJvdGF0ZSh0aGlzLmhlYWRpbmcsIHRoaXMucG9zKTtcblxuXHRcdHRoaXMuc2hhZG93U2VnbWVudHNbMF0uc3RhcnQuY29weSh0MCk7IHRoaXMuc2hhZG93U2VnbWVudHNbMF0uZW5kLmNvcHkodDEpO1xuXHRcdHRoaXMuc2hhZG93U2VnbWVudHNbMV0uc3RhcnQuY29weSh0MSk7IHRoaXMuc2hhZG93U2VnbWVudHNbMV0uZW5kLmNvcHkodDIpO1xuXHRcdHRoaXMuc2hhZG93U2VnbWVudHNbMl0uc3RhcnQuY29weSh0Mik7IHRoaXMuc2hhZG93U2VnbWVudHNbMl0uZW5kLmNvcHkodDMpO1xuXHRcdHRoaXMuc2hhZG93U2VnbWVudHNbM10uc3RhcnQuY29weSh0Myk7IHRoaXMuc2hhZG93U2VnbWVudHNbM10uZW5kLmNvcHkodDApO1xuXHR9XG5cblx0Z2V0U2VnbWVudHMoKSB7XG5cdFx0aWYgKHRoaXMuY2FzdHNTaGFkb3cpIHtcblx0XHRcdGlmICh0aGlzLnNoYWRvd1NlZ21lbnRzID09IG51bGwpIHtcblx0XHRcdFx0dGhpcy5zaGFkb3dTZWdtZW50cyA9IFtcblx0XHRcdFx0XHRuZXcgTGluZVNlZ21lbnQobmV3IFZlYzIoMC4wLCAwLjApLCBuZXcgVmVjMigwLjAsIDAuMCkpLFxuXHRcdFx0XHRcdG5ldyBMaW5lU2VnbWVudChuZXcgVmVjMigwLjAsIDAuMCksIG5ldyBWZWMyKDAuMCwgMC4wKSksXG5cdFx0XHRcdFx0bmV3IExpbmVTZWdtZW50KG5ldyBWZWMyKDAuMCwgMC4wKSwgbmV3IFZlYzIoMC4wLCAwLjApKSxcblx0XHRcdFx0XHRuZXcgTGluZVNlZ21lbnQobmV3IFZlYzIoMC4wLCAwLjApLCBuZXcgVmVjMigwLjAsIDAuMCkpXG5cdFx0XHRcdF07XG5cdFx0XHR9XG5cdFx0XHR0aGlzLnVwZGF0ZVNoYWRvd1NlZ21lbnRzKClcblx0XHRcdHJldHVybiB0aGlzLnNoYWRvd1NlZ21lbnRzO1xuXHRcdH1cblx0XHRyZXR1cm4gbnVsbDtcblx0fVxuXG5cdG1vdmUoZHQpIHtcblx0XHR0aGlzLmxhc3RQb3MuY29weSh0aGlzLnBvcyk7XG5cdFx0dGhpcy5sYXN0UG9zLm5hbkNoZWNrKCk7XG5cdFx0aWYgKHRoaXMubm9ybWFsaXplQWNjZWwpIHtcblx0XHRcdGlmICh0aGlzLmFjYy5sZW5ndGgoKSA+IDEuMCkge1xuXHRcdFx0XHR0aGlzLmFjYy5ub3JtYWxpemVPclplcm8oKTtcblx0XHRcdH1cblx0XHR9XG5cdFx0dGhpcy5hY2Muc2NhbGUodGhpcy5zcGVlZCk7XG5cdFx0dGhpcy5hY2MueCArPSAtdGhpcy5kcmFnLnggKiB0aGlzLnZlbC54O1xuXHRcdHRoaXMuYWNjLnkgKz0gLXRoaXMuZHJhZy55ICogdGhpcy52ZWwueTtcblx0XHR0aGlzLmFjYy5uYW5DaGVjaygpO1xuXG5cdFx0dGhpcy5wb3MueCArPSB0aGlzLnZlbC54KmR0ICsgdGhpcy5hY2MueCpkdCpkdCowLjU7XG5cdFx0dGhpcy5wb3MueSArPSB0aGlzLnZlbC55KmR0ICsgdGhpcy5hY2MueSpkdCpkdCowLjU7XG5cdFx0dGhpcy5wb3MubmFuQ2hlY2soKTtcblxuXHRcdHRoaXMudmVsLnggKz0gdGhpcy5hY2MueCpkdDtcblx0XHR0aGlzLnZlbC55ICs9IHRoaXMuYWNjLnkqZHQ7XG5cdFx0dGhpcy52ZWwubmFuQ2hlY2soKTtcblxuXHRcdGlmICh0aGlzLmhhc1opIHtcblx0XHRcdHRoaXMuekFjYyArPSAtdGhpcy56RHJhZyAqIHRoaXMuelZlbDtcblx0XHRcdHRoaXMuelZlbCArPSB0aGlzLnpBY2MqZHQ7XG5cdFx0XHRsZXQgbnpQb3MgPSB0aGlzLnpQb3MgKyB0aGlzLnpWZWwqZHQgKyB0aGlzLnpBY2MqZHQqZHQqMC41O1xuXHRcdFx0bGV0IGRlbHRhWiA9IG56UG9zIC0gdGhpcy56UG9zO1xuXHRcdFx0bGV0IHN0ZXBzID0gTWF0aC5jZWlsKE1hdGguYWJzKGRlbHRhWikpO1xuXHRcdFx0Zm9yIChsZXQgaSA9IDA7IGkgPCBzdGVwczsgKytpKSB7XG5cdFx0XHRcdGxldCBueiA9IHRoaXMuelBvcyArIGRlbHRhWi9zdGVwcztcblx0XHRcdFx0aWYgKG56IDwgMCkge1xuXHRcdFx0XHRcdHRoaXMuelZlbCA9IC10aGlzLnpWZWwqdGhpcy56Qm91bmNlO1xuXHRcdFx0XHRcdHRoaXMub25Hcm91bmRDb2xsaXNpb24oKTtcblx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0fVxuXHRcdFx0XHR0aGlzLnpQb3MgPSBuejtcblx0XHRcdH1cblx0XHR9XG5cblx0XHRpZiAodGhpcy5jb2xsaWRlc1dpdGhXb3JsZCkge1xuXHRcdFx0Zm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLmNvbGxpc2lvbkl0ZXJhdGlvbnM7ICsraSkge1xuXHRcdFx0XHR0aGlzLmNvbGxpZGVXaXRoV29ybGQoZHQpO1xuXHRcdFx0fVxuXHRcdH1cblx0XHRpZiAodGhpcy5jb2xsaWRlc1dpdGhFbnRpdGllcykge1xuXHRcdFx0dGhpcy5jb2xsaWRlV2l0aE9iamVjdHMoZHQpO1xuXHRcdH1cblx0XHRlbHNlIGlmICh0aGlzLmNvbGxpZGVzV2l0aFBsYXllcikge1xuXHRcdFx0bGV0IGUgPSB0aGlzLmdhbWUucGxheWVyO1xuXHRcdFx0aWYgKHRoaXMucG9zLmRpc3RhbmNlKGUucG9zKSA8IHRoaXMucmFkaXVzICsgZS5yYWRpdXMpIHtcblx0XHRcdFx0aWYgKGUuc29saWQpIHtcblx0XHRcdFx0XHR0aGlzLmhhbmRsZUNvbGxpc2lvbihlLCB0aGlzLnBvcy50byhlLnBvcyksIHRoaXMucG9zLmRpc3RhbmNlKGUucG9zKSAtICh0aGlzLnJhZGl1cyArIGUucmFkaXVzKSwgZmFsc2UpO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXHR9XG5cblx0Y29sbGlkZVdpdGhPYmplY3RzKCkge1xuXHRcdGxldCBlcyA9IHRoaXMuZ2FtZS5ncmlkLmVudGl0aWVzQXJvdW5kKHRoaXMpO1xuXHRcdGZvciAobGV0IGkgPSAwOyBpIDwgZXMubGVuZ3RoOyArK2kpIHtcblx0XHRcdGxldCBlID0gZXNbaV07XG5cdFx0XHRpZiAoZSA9PT0gdGhpcyB8fCAhZS5lbmFibGVkKSBjb250aW51ZTtcblx0XHRcdGlmICh0aGlzLnBvcy5kaXN0YW5jZShlLnBvcykgPCB0aGlzLnJhZGl1cyArIGUucmFkaXVzKSB7XG5cdFx0XHRcdGlmIChlLnNvbGlkICYmIGUuY29sbGlkZXNXaXRoRW50aXRpZXMgfHwgKHRoaXMgPT0gdGhpcy5nYW1lLnBsYXllciAmJiBlLmNvbGxpZGVzV2l0aFBsYXllcikpXG5cdFx0XHRcdFx0dGhpcy5oYW5kbGVDb2xsaXNpb24oZSwgdGhpcy5wb3MudG8oZS5wb3MpLm5vcm1hbGl6ZSgpLCB0aGlzLnBvcy5kaXN0YW5jZShlLnBvcyktKHRoaXMucmFkaXVzICsgZS5yYWRpdXMpLCBmYWxzZSk7XG5cdFx0XHR9XG5cdFx0fVxuXHR9XG5cblx0b25Hcm91bmRDb2xsaXNpb24oKSB7fVxuXG5cdGNvbGxpZGVXaXRoV29ybGQoZHQpIHtcblx0XHRjb25zdCBjb2xsaXNpb25NYXhUcmllcyA9IDQ7XG5cdFx0bGV0IGNvbGxpc2lvblBvcyA9IFZlYzIuUG9vbC5nZXQoKTtcblx0XHRmb3IgKGxldCB0cmllcyA9IDA7Oykge1xuXHRcdFx0bGV0IHNpZ24gPSB0aGlzLmdhbWUuY2xvc2VzdFBvaW50KGNvbGxpc2lvblBvcywgdGhpcy5wb3MsIHRoaXMucmFkaXVzKTtcblx0XHRcdGlmIChzaWduID09PSAwKSB7XG5cdFx0XHRcdGJyZWFrO1xuXHRcdFx0fVxuXHRcdFx0Y29sbGlzaW9uUG9zLm5hbkNoZWNrKCk7XG5cdFx0XHRsZXQgZHggPSB0aGlzLnBvcy54IC0gY29sbGlzaW9uUG9zLng7XG5cdFx0XHRsZXQgZHkgPSB0aGlzLnBvcy55IC0gY29sbGlzaW9uUG9zLnk7XG5cblx0XHRcdGxldCBkaXN0ID0gTWF0aC5zcXJ0KGR4KmR4K2R5KmR5KTtcblxuXHRcdFx0bGV0IHBlbmV0cmF0aW9uID0gdGhpcy5yYWRpdXMgLSBzaWduICogZGlzdDtcblx0XHRcdGlmIChwZW5ldHJhdGlvbiA8PSAwLjAwMSkge1xuXHRcdFx0XHQvLyBAQFJPQlVTVE5FU1M6IHRoaXMgaXMgYSBoYWNrXG5cdFx0XHRcdGJyZWFrO1xuXHRcdFx0fVxuXHRcdFx0aWYgKGRpc3QgPT09IDApIHtcblx0XHRcdFx0YnJlYWs7XG5cdFx0XHR9XG5cdFx0XHRkeCAvPSBkaXN0O1xuXHRcdFx0ZHkgLz0gZGlzdDtcblx0XHRcdC8vIHRoaXMgc2hvdWxkIHByb2plY3QgdXMgb3V0IG9mIHRoZSBjb2xsaXNpb25cblx0XHRcdHRoaXMuaGFuZGxlQ29sbGlzaW9uKG51bGwsIGNvbGxpc2lvblBvcy5zZXQoZHgsIGR5KSwgc2lnbipwZW5ldHJhdGlvbiwgdHJ1ZSk7XG5cdFx0XHRpZiAoKyt0cmllcyA+PSBjb2xsaXNpb25NYXhUcmllcykge1xuXHRcdFx0XHQvLyBkZWdlbmVyYXRlIGNhc2VzIHdoZXJlIHByb2plY3RpbmcgdXMgb3V0IG9mIHNvbWV0aGluZ1xuXHRcdFx0XHQvLyBwcm9qZWN0cyB1cyBpbnRvIHNvbWV0aGluZyBlbHNlXG5cdFx0XHRcdGNvbnNvbGUud2FybihcIkNvbGxpc2lvbiBkZXRlY3Rpb24gaGl0IG1heCBpdGVyYXRpb24uXCIsIHBlbmV0cmF0aW9uKTtcblx0XHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdFx0fVxuXHRcdH1cblx0XHRyZXR1cm4gdHJ1ZTtcblx0fVxuXG5cdGhhbmRsZUNvbGxpc2lvbih3aG8sIG5vcm1hbCwgcGVuZXRyYXRpb24sIHdhc0hhcmQpIHtcblx0XHR0aGlzLnBvcy5uYW5DaGVjaygpO1xuXHRcdHRoaXMudmVsLm5hbkNoZWNrKCk7XG5cdFx0aWYgKHdhc0hhcmQpIHtcblx0XHRcdHRoaXMucG9zLnggKz0gbm9ybWFsLnggKiBwZW5ldHJhdGlvbjtcblx0XHRcdHRoaXMucG9zLnkgKz0gbm9ybWFsLnkgKiBwZW5ldHJhdGlvbjtcblx0XHRcdGxldCBkb3QgPSB0aGlzLnZlbC5kb3Qobm9ybWFsKTtcblx0XHRcdGlmICh0aGlzLmVsYXN0aWMpIHtcblx0XHRcdFx0dGhpcy52ZWwueCA9IC0oMipkb3Qqbm9ybWFsLnggLSB0aGlzLnZlbC54KTtcblx0XHRcdFx0dGhpcy52ZWwueSA9IC0oMipkb3Qqbm9ybWFsLnkgLSB0aGlzLnZlbC55KTtcblx0XHRcdFx0dGhpcy52ZWwueCAqPSB0aGlzLmVsYXN0aWNpdHk7XG5cdFx0XHRcdHRoaXMudmVsLnkgKj0gdGhpcy5lbGFzdGljaXR5O1xuXHRcdFx0fVxuXHRcdFx0ZWxzZSB7XG5cdFx0XHRcdGlmIChkb3QgPCAwKSB7XG5cdFx0XHRcdFx0dGhpcy52ZWwueCAtPSBkb3Qqbm9ybWFsLng7XG5cdFx0XHRcdFx0dGhpcy52ZWwueSAtPSBkb3Qqbm9ybWFsLnk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cdFx0ZWxzZSB7XG5cdFx0XHRpZiAod2hvID09IG51bGwgfHwgIXdoby5tb2JpbGUpIHtcblx0XHRcdFx0dGhpcy52ZWwueCArPSBub3JtYWwueCAqIHBlbmV0cmF0aW9uO1xuXHRcdFx0XHR0aGlzLnZlbC55ICs9IG5vcm1hbC55ICogcGVuZXRyYXRpb247XG5cdFx0XHRcdHRoaXMucG9zLnggKz0gbm9ybWFsLnggKiBwZW5ldHJhdGlvbjtcblx0XHRcdFx0dGhpcy5wb3MueSArPSBub3JtYWwueSAqIHBlbmV0cmF0aW9uO1xuXHRcdFx0fVxuXHRcdFx0ZWxzZSB7XG5cdFx0XHRcdHRoaXMudmVsLnggKz0gbm9ybWFsLnggKiBwZW5ldHJhdGlvbiAqIDAuNTtcblx0XHRcdFx0dGhpcy52ZWwueSArPSBub3JtYWwueSAqIHBlbmV0cmF0aW9uICogMC41O1xuXHRcdFx0XHQvLyB3aG8udmVsLnggLT0gbm9ybWFsLnggKiBwZW5ldHJhdGlvbiAqIDAuNTtcblx0XHRcdFx0Ly8gd2hvLnZlbC55IC09IG5vcm1hbC55ICogcGVuZXRyYXRpb24gKiAwLjU7XG5cblx0XHRcdFx0dGhpcy5wb3MueCArPSBub3JtYWwueCAqIHBlbmV0cmF0aW9uICogMC41O1xuXHRcdFx0XHR0aGlzLnBvcy55ICs9IG5vcm1hbC55ICogcGVuZXRyYXRpb24gKiAwLjU7XG5cblx0XHRcdFx0Ly8gd2hvLnBvcy54IC09IG5vcm1hbC54ICogcGVuZXRyYXRpb24gKiAwLjU7XG5cdFx0XHRcdC8vIHdoby5wb3MueSAtPSBub3JtYWwueSAqIHBlbmV0cmF0aW9uICogMC41O1xuXHRcdFx0XHQvLyB3aG8ub25Db2xsaXNpb24od2hvLCBub3JtYWwsIHBlbmV0cmF0aW9uLCB3YXNIYXJkKVxuXHRcdFx0fVxuXHRcdH1cblx0XHR0aGlzLnBvcy5uYW5DaGVjaygpO1xuXHRcdHRoaXMudmVsLm5hbkNoZWNrKCk7XG5cdFx0dGhpcy5vbkNvbGxpc2lvbih3aG8sIG5vcm1hbCwgcGVuZXRyYXRpb24sIHdhc0hhcmQpXG5cdH1cblx0b25Db2xsaXNpb24od2hvLCBub3JtYWwsIHBlbmV0cmF0aW9uLCB3YXNIYXJkKXt9XG5cblx0dHdlZW5UbyhmaWVsZCwgdHdlZW5PcHRpb25zKSB7XG5cdFx0dHdlZW5PcHRpb25zLmVuYWJsZWRGaWVsZCA9ICdlbmFibGVkJztcblx0XHRyZXR1cm4gdGhpcy50d2Vlbkdyb3VwLmFkZChuZXcgVHdlZW4odGhpcywgZmllbGQsIHR3ZWVuT3B0aW9ucykpLnByb21pc2U7XG5cdH1cbn1cbkVudGl0eS5pZENvdW50ZXIgPSAwO1xubW9kdWxlLmV4cG9ydHMgPSBFbnRpdHk7XG4iLCIndXNlIHN0cmljdCc7XG5cbmNvbnN0IENvbnN0cyA9IHJlcXVpcmUoJy4vY29uc3RhbnRzJylcbmNvbnN0IENhbWVyYSA9IHJlcXVpcmUoJy4vY2FtZXJhJyk7XG5jb25zdCBDb2xsaXNpb25HcmlkID0gcmVxdWlyZSgnLi9jb2xsaXNpb25fZ3JpZCcpO1xuY29uc3Qge1R3ZWVuLCBUd2Vlbkdyb3VwfSA9IHJlcXVpcmUoJy4vdHdlZW5zJylcbmNvbnN0IFBpeGVsQnVmZmVyID0gcmVxdWlyZSgnLi9waXhlbF9idWZmZXInKTtcbmNvbnN0IFBsYXllciA9IHJlcXVpcmUoJy4vcGxheWVyJyk7XG5jb25zdCB7VGVzdExldmVsLCBUaWxlcywgVGlsZUluZm99ID0gcmVxdWlyZSgnLi9sZXZlbF9kYXRhJyk7XG5jb25zdCBwb2x5Ym9vbCA9IHJlcXVpcmUoJ3BvbHktYm9vbCcpO1xuY29uc3QgTGluZVNlZ21lbnQgPSByZXF1aXJlKCcuL2xpbmVfc2VnbWVudCcpO1xuY29uc3QgTGF5ZXIgPSByZXF1aXJlKCcuL2dmeF9sYXllcicpO1xuY29uc3QgVmVjMiA9IHJlcXVpcmUoJy4vdmVjMicpO1xuY29uc3QgbWF0aCA9IHJlcXVpcmUoJy4vbWF0aCcpO1xuY29uc3QgSW5wdXQgPSByZXF1aXJlKCcuL2lucHV0Jyk7XG5jb25zdCB1dGlsID0gcmVxdWlyZSgnLi91dGlsJyk7XG5jb25zdCBkcmF3aW5nID0gcmVxdWlyZSgnLi9kcmF3aW5nJyk7XG5jb25zdCB7VmlzVHJhY2tlcn0gPSByZXF1aXJlKCcuL2xpZ2h0aW5nJyk7XG5jb25zdCBTb3VuZHMgPSByZXF1aXJlKCcuL2F1ZGlvJyk7XG5jb25zdCBLZXkgPSByZXF1aXJlKCcuL2tleScpO1xuY29uc3QgRW5lbXkgPSByZXF1aXJlKCcuL2VuZW15Jyk7XG5jb25zdCB7cGVybGluTm9pc2UsIG9jdGF2ZU5vaXNlLCBSTkd9ID0gcmVxdWlyZSgnLi9yYW5kJyk7XG5cbmNvbnN0IFNUQVRFUyA9IHsgTG9hZGluZzogMCwgTWVudTogMSwgR2FtZTogMiB9O1xuXG5cbmNvbnN0IEVuZW15TG9jYXRpb25zID0gW1xuXHRbMTIsIDFdLFxuXHRbMTksIDEwXSxcblx0WzIzLCA3XSxcblx0WzI3LCAxMF0sXG5cdFsyNSwgMTRdLFxuXHRbMTAsIDE5XSwgWzExLCAxOV0sIFsxMiwgMTldLCBbMTMsIDE5XSxcblx0WzI2LCAyMF0sXG5cdFsyNCwgMjFdLFxuXHRbMTQsIDI3XSxcblx0WzQsIDldLFxuXG5cbl1cblxuZnVuY3Rpb24gbG9hZExldmVsKHRteCkge1xuXHRsZXQgbWFwRWxlbSA9IHRteC5xdWVyeVNlbGVjdG9yKCdtYXAnKTtcblx0bGV0IHJlc3VsdCA9IHtcblx0XHR3aWR0aDogbWFwRWxlbS5nZXRBdHRyaWJ1dGUoJ3dpZHRoJyksXG5cdFx0aGVpZ2h0OiBtYXBFbGVtLmdldEF0dHJpYnV0ZSgnaGVpZ2h0JyksXG5cdH07XG5cdFtdLmZvckVhY2guY2FsbChtYXBFbGVtLnF1ZXJ5U2VsZWN0b3JBbGwoJ3Byb3BlcnRpZXMgcHJvcGVydHknKSwgZnVuY3Rpb24oZWxlbSkge1xuXHRcdGxldCB2YWwgPSBlbGVtLmdldEF0dHJpYnV0ZSgndmFsdWUnKTtcblx0XHRpZiAoIWlzTmFOKHZhbCkpIHtcblx0XHRcdGxldCBmdmFsID0gTnVtYmVyKHZhbCk7XG5cdFx0XHRpZiAoK2Z2YWwgPT09IGZ2YWwpIHZhbCA9IGZ2YWw7XG5cdFx0fVxuXHRcdHJlc3VsdFtlbGVtLmdldEF0dHJpYnV0ZSgnbmFtZScpXSA9IHZhbDtcblx0fSk7XG5cblx0W10uZm9yRWFjaC5jYWxsKG1hcEVsZW0ucXVlcnlTZWxlY3RvckFsbCgnbGF5ZXInKSwgZnVuY3Rpb24obGF5ZXIpIHtcblx0XHRpZiAocmVzdWx0LmRhdGEgIT0gbnVsbCkgcmV0dXJuOyAvLyBUT0RPXG5cdFx0bGV0IGRhdGEgPSBsYXllci5xdWVyeVNlbGVjdG9yKCdkYXRhJyk7XG5cdFx0aWYgKGRhdGEgPT0gbnVsbCkge1xuXHRcdFx0Y29uc29sZS53YXJuKFwiTGF5ZXIgd2l0aG91dCBkYXRhLi4uXCIsIGxheWVyLCB0bXgpO1xuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblx0XHRpZiAoZGF0YS5nZXRBdHRyaWJ1dGUoJ2VuY29kaW5nJykgJiYgZGF0YS5nZXRBdHRyaWJ1dGUoJ2VuY29kaW5nJykudG9Mb3dlckNhc2UoKSAhPT0gJ2NzdicpIHtcblx0XHRcdGNvbnNvbGUuZXJyb3IoXCJJbGxlZ2FsIHRpbGVtYXAgdHlwZVwiKTtcblx0XHR9XG5cdFx0Ly8gdHJ5IGFueXdheVxuXHRcdGxldCB0ZXh0ID0gZGF0YS50ZXh0Q29udGVudC50cmltKCk7XG5cdFx0bGV0IHRpbGVJZHMgPSB0ZXh0LnNwbGl0KC9bXFxzLF0rL2cpLmZpbHRlcih2ID0+IHYubGVuZ3RoICE9PSAwKS5tYXAodiA9PiB2fDApO1xuXHRcdGlmICh0aWxlSWRzLmxlbmd0aCAhPSByZXN1bHQud2lkdGgqcmVzdWx0LmhlaWdodCkge1xuXHRcdFx0Y29uc29sZS5lcnJvcihcIk5vdCBzdXJlIHdoYXQgdG8gZG8gYWJvdXQgdGhpcywgd3Jvbmcgc2l6ZSB0aWxlIG1hcC4uLlwiLCB0aWxlSWRzLCB0bXgpO1xuXHRcdFx0dGhyb3cgRXJyb3IoXCJCYWQgdGlsZSBtYXBcIik7XG5cdFx0fVxuXHRcdHJlc3VsdC50aWxlcyA9IHRpbGVJZHNcblx0fSk7XG5cblxuXG5cdHJldHVybiByZXN1bHQ7XG59XG5cbmNvbnN0IHNlZ21lbnRUbXAgPSBbXTtcbmNsYXNzIExEMzQge1xuXHRjb25zdHJ1Y3RvcihkcmF3Q2FudiwgZGJnQ2Fudikge1xuXHRcdHRoaXMuZGVidWdDYW52YXMgPSBkYmdDYW52O1xuXHRcdHRoaXMuZGVidWdDb250ZXh0ID0gZGJnQ2Fudi5nZXRDb250ZXh0KCcyZCcpO1xuXHRcdHRoaXMuZW50aXRpZXMgPSBbXTtcblxuXHRcdHRoaXMucGF1c2VkID0gZmFsc2U7XG5cdFx0dGhpcy5zY3JlZW4gPSBkcmF3Q2Fudjtcblx0XHR0aGlzLmN0eCA9IGRyYXdDYW52LmdldENvbnRleHQoJzJkJyk7XG5cdFx0dGhpcy50d2Vlbkdyb3VwID0gbmV3IFR3ZWVuR3JvdXAoKTtcblx0XHR0aGlzLmxvYWRpbmdGYWlsZWQgPSBmYWxzZTtcblxuXHRcdHRoaXMuYmdMYXllciA9IG5ldyBMYXllcignYmcnLCBkcmF3Q2Fudi53aWR0aCwgZHJhd0NhbnYuaGVpZ2h0KTtcblx0XHR0aGlzLmJnbW9kTGF5ZXIgPSBuZXcgTGF5ZXIoJ2JnbW9kJywgZHJhd0NhbnYud2lkdGgsIGRyYXdDYW52LmhlaWdodCk7XG5cdFx0dGhpcy50aWxlTGF5ZXIgPSBuZXcgTGF5ZXIoJ3RpbGUnLCAgZHJhd0NhbnYud2lkdGgsIGRyYXdDYW52LmhlaWdodCk7XG5cdFx0dGhpcy5lbnRzTGF5ZXIgPSBuZXcgTGF5ZXIoJ2VudHMnLCBkcmF3Q2Fudi53aWR0aCwgZHJhd0NhbnYuaGVpZ2h0KTtcblx0XHR0aGlzLmZ4TGF5ZXIgPSBuZXcgTGF5ZXIoJ2Z4JywgZHJhd0NhbnYud2lkdGgsIGRyYXdDYW52LmhlaWdodCk7XG5cdFx0dGhpcy5saWdodExheWVyID0gbmV3IExheWVyKCdsaWdodCcsIGRyYXdDYW52LndpZHRoLCBkcmF3Q2Fudi5oZWlnaHQpO1xuXHRcdHRoaXMuaHVkTGF5ZXIgPSBuZXcgTGF5ZXIoJ2h1ZCcsIGRyYXdDYW52LndpZHRoLCBkcmF3Q2Fudi5oZWlnaHQpO1xuXHRcdHRoaXMub3ZlcmxheUxheWVyID0gbmV3IExheWVyKCdvdmVybGF5JywgZHJhd0NhbnYud2lkdGgsIGRyYXdDYW52LmhlaWdodCk7XG5cblx0XHR0aGlzLnN0YXJ0ZWRHYW1lID0gZmFsc2U7XG5cdFx0dGhpcy5wbGF5ZXJEZWFkID0gZmFsc2U7XG5cdFx0dGhpcy5kZWFkUGxheWVyVGltZXIgPSAwLjA7XG5cblx0XHR0aGlzLmxheWVycyA9IFtcblx0XHRcdHRoaXMuYmdMYXllcixcblx0XHRcdC8vdGhpcy5iZ21vZExheWVyLFxuXHRcdFx0dGhpcy5iZ21vZExheWVyLFxuXG5cdFx0XHR0aGlzLmZ4TGF5ZXIsXG5cdFx0XHR0aGlzLmVudHNMYXllcixcblx0XHRcdHRoaXMubGlnaHRMYXllcixcblx0XHRcdHRoaXMudGlsZUxheWVyLFxuXHRcdFx0dGhpcy5odWRMYXllcixcblx0XHRcdHRoaXMub3ZlcmxheUxheWVyLFxuXHRcdF07XG5cdFx0dGhpcy5tb3VzZSA9IG5ldyBWZWMyKDAuMCwgMC4wKTtcblxuXHRcdHRoaXMud2lkdGggPSAxMDAwO1xuXHRcdHRoaXMuaGVpZ2h0ID0gMTAwMDtcblxuXHRcdHRoaXMuZ3JpZCA9IG51bGw7XG5cdFx0dGhpcy52aXNUcmFja2VyID0gbmV3IFZpc1RyYWNrZXIoKTtcblx0XHR0aGlzLmtleXMgPSBbXTtcblx0XHR0aGlzLmxvY2tzID0gW107XG5cblx0XHR0aGlzLnBsYXllciA9IG5ldyBQbGF5ZXIodGhpcyk7XG5cdFx0dGhpcy5jYW1UYXJnZXQgPSBuZXcgVmVjMigwLjAsIDAuMCk7XG5cdFx0dGhpcy5jYW1lcmEgPSBuZXcgQ2FtZXJhKHRoaXMsIHRoaXMucGxheWVyLCB0aGlzLmNhbVRhcmdldCwgZHJhd0NhbnYud2lkdGgsIGRyYXdDYW52LmhlaWdodCk7XG5cdFx0dGhpcy50aWxlcyA9IFtdO1xuXHRcdHRoaXMuZWRnZUdlb20gPSBbXTtcblx0XHR0aGlzLnN0YXRlID0gU1RBVEVTLkxvYWRpbmc7XG5cdFx0dGhpcy5sb2FkUHJvZ3Jlc3MgPSAwO1xuXHRcdHRoaXMuYXNzZXRzID0ge307XG5cdFx0dGhpcy5zZWVuQnVmZmVyID0gbnVsbDtcblx0XHR0aGlzLmJnYnVmZmVyID0gbnVsbDtcblx0XHR0aGlzLmxpZ2h0TWFza0NhbnZhcyA9IHV0aWwuY3JlYXRlQ2FudmFzKGRyYXdDYW52LndpZHRoLCBkcmF3Q2Fudi5oZWlnaHQpO1xuXHRcdHRoaXMubGlnaHRNYXNrQ3R4ID0gdGhpcy5saWdodE1hc2tDYW52YXMuZ2V0Q29udGV4dCgnMmQnKTtcblx0XHR0aGlzLmVtcHR5VGlsZXMgPSBudWxsO1xuXHRcdHRoaXMuYmxvb2RCdWZmZXIgPSBudWxsO1xuXHRcdHRoaXMuZ2FtZVdvbiA9IGZhbHNlO1xuXHRcdHRoaXMubG9hZEFzc2V0cygpO1xuXHR9XG5cblx0bG9hZEFzc2V0cygpIHtcblx0XHRsZXQgaXRlbXMgPSBbXG5cdFx0XHR7cGF0aDogJ3Jlcy9wbGF5ZXIucG5nJywgbmFtZTogJ3BsYXllcicsIHR5cGU6ICdpbWFnZSd9LFxuXHRcdFx0e3BhdGg6ICdyZXMvc3ByaXRlcy5wbmcnLCBuYW1lOiAndGlsZXMnLCB0eXBlOiAnaW1hZ2UnfSxcblx0XHRcdHtwYXRoOiAncmVzL2x2bDEudG14JywgbmFtZTogJ2xldmVsMCcsIHR5cGU6ICdsZXZlbCd9LFxuXHRcdFx0e3BhdGg6ICdyZXMvbWlzYy5wbmcnLCBuYW1lOiAnbWlzYycsIHR5cGU6ICdpbWFnZSd9LFxuXHRcdFx0e3BhdGg6ICdyZXMvZGVhZC5wbmcnLCBuYW1lOiAnZGVhZCcsIHR5cGU6ICdpbWFnZSd9XG5cdFx0XTtcblx0XHRsZXQgbG9hZGVkID0gMDtcblx0XHRyZXR1cm4gUHJvbWlzZS5hbGwoaXRlbXMubWFwKCh7cGF0aCwgbmFtZSwgdHlwZX0pID0+IHtcblx0XHRcdGxldCBwID0gbnVsbDtcblx0XHRcdHN3aXRjaCAodHlwZSkge1xuXHRcdFx0Y2FzZSAnaW1hZ2UnOlxuXHRcdFx0XHRwID0gdXRpbC5sb2FkSW1hZ2UocGF0aCk7XG5cdFx0XHRcdGJyZWFrO1xuXHRcdFx0Y2FzZSAnbGV2ZWwnOlxuXHRcdFx0XHRwID0gdXRpbC5sb2FkWE1MKHBhdGgpLnRoZW4oZG9jID0+IGxvYWRMZXZlbChkb2MpKTtcblx0XHRcdFx0YnJlYWs7XG5cdFx0XHRkZWZhdWx0OlxuXHRcdFx0XHRjb25zb2xlLmVycm9yKFwiTm90IHN1cmUgaG93IHRvIGxvYWQgXCIsIHR5cGUsIG5hbWUsIHBhdGgpO1xuXHRcdFx0XHRkZWJ1Z2dlcjtcblx0XHRcdH1cblx0XHRcdHJldHVybiBwLnRoZW4oc3R1ZmYgPT4ge1xuXHRcdFx0XHR0aGlzLmFzc2V0c1tuYW1lXSA9IHN0dWZmO1xuXHRcdFx0XHR0aGlzLmxvYWRQcm9ncmVzcyA9ICgoKytsb2FkZWQpL2l0ZW1zLmxlbmd0aCkqMC44O1xuXHRcdFx0XHRyZXR1cm4gc3R1ZmY7XG5cdFx0XHR9KTtcblx0XHR9KSkudGhlbigoKSA9PiB7XG5cdFx0XHR0aGlzLmFzc2V0cy5wbGF5ZXJSb3RhdGlvbnMgPSBQaXhlbEJ1ZmZlci5nZXRSb3RhdGVkVGlsZXModGhpcy5hc3NldHMucGxheWVyLCAxNik7XG5cdFx0XHRsZXQgaGlsaWdodCA9IHRoaXMuYXNzZXRzLnBsYXllclJvdGF0aW9ucy5nZXRQaXhlbCg0LCA3KTtcblx0XHRcdGxldCBtaWQgPSB0aGlzLmFzc2V0cy5wbGF5ZXJSb3RhdGlvbnMuZ2V0UGl4ZWwoOCwgNSk7XG5cdFx0XHRsZXQgY29sb3JzID0gW1xuXHRcdFx0XHRbW2hpbGlnaHQsIDB4ZmYxNzE3YjRdLCBbbWlkLCAweGZmMGYwZjZlXV0sXG5cdFx0XHRcdFtbaGlsaWdodCwgMHhmZjAwYmFjYl0sIFttaWQsIDB4ZmYwMDk5YTddXSxcblx0XHRcdFx0W1toaWxpZ2h0LCAweGZmMDBiYWNiXSwgW21pZCwgMHhmZjAwOTlhN11dLFxuXHRcdFx0XHRbW2hpbGlnaHQsIDB4ZmZjYjAwODRdLCBbbWlkLCAweGZmYTcwMDZjXV0sXG5cdFx0XHRdO1xuXHRcdFx0dGhpcy5hc3NldHMuZW5lbXlSb3RhdGlvbnMgPSBjb2xvcnMubWFwKChyZXBsYWNlbWVudHMpID0+XG5cdFx0XHRcdHRoaXMuYXNzZXRzLnBsYXllclJvdGF0aW9ucy53aXRoUmVwbGFjZWRDb2xvcnMocmVwbGFjZW1lbnRzKSk7XG5cdFx0XHRsZXQgZGVhZFBsYXllciA9IFBpeGVsQnVmZmVyLmZyb21JbWFnZSh0aGlzLmFzc2V0cy5kZWFkKTtcblx0XHRcdHRoaXMuYXNzZXRzLmRlYWRFbmVtaWVzID0gY29sb3JzLm1hcCgocmVwbGFjZW1lbnRzKSA9PiBkZWFkUGxheWVyLndpdGhSZXBsYWNlZENvbG9ycyhyZXBsYWNlbWVudHMpKTtcblxuXHRcdFx0dGhpcy5zZXRTdGF0ZShTVEFURVMuR2FtZSk7XG5cdFx0fSkuY2F0Y2goZSA9PiB7XG5cdFx0XHRjb25zb2xlLmVycm9yKGUpO1xuXHRcdFx0dGhpcy5sb2FkaW5nRmFpbGVkID0gdHJ1ZTtcblx0XHR9KTtcblx0fVxuXG5cdHN0YXJ0TGV2ZWwobGV2ZWwpIHtcblx0XHR0aGlzLnBsYXllciA9IG5ldyBQbGF5ZXIodGhpcyk7XG5cdFx0dGhpcy5jYW1lcmEgPSBuZXcgQ2FtZXJhKHRoaXMsIHRoaXMucGxheWVyLCB0aGlzLmNhbVRhcmdldCwgdGhpcy5zY3JlZW4ud2lkdGgsIHRoaXMuc2NyZWVuLmhlaWdodCk7XG5cblx0XHR0aGlzLnN0YXJ0ZWRHYW1lID0gdHJ1ZTtcblx0XHR0aGlzLmVudGl0aWVzLmxlbmd0aCA9IDA7XG5cdFx0dGhpcy5wbGF5ZXJEZWFkID0gZmFsc2U7XG5cdFx0dGhpcy5kZWFkUGxheWVyVGltZXIgPSAwLjA7XG5cblx0XHR0aGlzLndpZHRoID0gbGV2ZWwud2lkdGgqQ29uc3RzLlRpbGVTaXplO1xuXHRcdHRoaXMuaGVpZ2h0ID0gbGV2ZWwuaGVpZ2h0KkNvbnN0cy5UaWxlU2l6ZTtcblx0XHR0aGlzLmdyaWQgPSBuZXcgQ29sbGlzaW9uR3JpZCh0aGlzLndpZHRoLCB0aGlzLmhlaWdodCwgQ29uc3RzLlRpbGVTaXplKjQpOyAvLyBobS4uLlxuXG5cdFx0Ly8gdGhpcy5wbGF5ZXIucmVzZXQoKTtcblx0XHR0aGlzLmFkZEVudGl0eSh0aGlzLnBsYXllciwgbGV2ZWwuc3Bhd25YKkNvbnN0cy5UaWxlU2l6ZSs4LjEsIGxldmVsLnNwYXduWSpDb25zdHMuVGlsZVNpemUrOC4xKTtcblx0XHRFbmVteUxvY2F0aW9ucy5tYXAoKFt4LCB5XSkgPT4ge1xuXHRcdFx0eCAqPSBDb25zdHMuVGlsZVNpemU7XG5cdFx0XHR5ICo9IENvbnN0cy5UaWxlU2l6ZTtcblx0XHRcdHRoaXMuYWRkRW50aXR5KG5ldyBFbmVteSh0aGlzLCB4KzgsIHkrOCkpO1xuXHRcdH0pO1xuXHRcdC8vIHRoaXMuYWRkRW4gdGl0eShuZXcgRW5lbXkodGhpcywgMioxNis4LCA1KjE2KzgpKTtcblx0XHR0aGlzLmNhbWVyYS5zZXRQb3NpdGlvbih0aGlzLnBsYXllci5wb3MueCwgdGhpcy5wbGF5ZXIucG9zLnksIHRydWUpO1xuXHRcdHRoaXMudGlsZVdpZHRoID0gbGV2ZWwud2lkdGg7XG5cdFx0dGhpcy50aWxlSGVpZ2h0ID0gbGV2ZWwuaGVpZ2h0O1xuXHRcdHRoaXMudGlsZXMgPSBuZXcgQXJyYXkodGhpcy50aWxlV2lkdGgqdGhpcy50aWxlSGVpZ2h0KTtcblx0XHR0aGlzLmVtcHR5VGlsZXMgPSBuZXcgVWludDhBcnJheSh0aGlzLnRpbGVXaWR0aCp0aGlzLnRpbGVIZWlnaHQpO1xuXHRcdHRoaXMubG9ja2VkVGlsZXMgPSBuZXcgQXJyYXkodGhpcy50aWxlV2lkdGgqdGhpcy50aWxlSGVpZ2h0KTsgLy8gd2FzdGUgb2YgbWVtb3J5Li4uXG5cblx0XHRsZXQga25vd25LZXlzT3JMb2NrcyA9IHt9O1xuXHRcdGZvciAobGV0IHkgPSAwOyB5IDwgdGhpcy50aWxlSGVpZ2h0OyArK3kpIHtcblx0XHRcdGZvciAobGV0IHggPSAwOyB4IDwgdGhpcy50aWxlV2lkdGg7ICsreCkge1xuXHRcdFx0XHRsZXQgaSA9IHgreSp0aGlzLnRpbGVXaWR0aDtcblx0XHRcdFx0bGV0IHRpbGVJZCA9IGxldmVsLnRpbGVzW2ldO1xuXHRcdFx0XHRpZiAodGlsZUlkID49IFRpbGVzLmxlbmd0aCkge1xuXHRcdFx0XHRcdGlmICghKHRpbGVJZCBpbiBrbm93bktleXNPckxvY2tzKSkge1xuXHRcdFx0XHRcdFx0a25vd25LZXlzT3JMb2Nrc1t0aWxlSWRdID0gW107XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdGtub3duS2V5c09yTG9ja3NbdGlsZUlkXS5wdXNoKHt4LCB5fSk7XG5cdFx0XHRcdFx0dGlsZUlkID0gMDtcblx0XHRcdFx0fVxuXHRcdFx0XHRsZXQgdGlsZUluZm8gPSBUaWxlc1t0aWxlSWRdO1xuXHRcdFx0XHR0aGlzLnRpbGVzW2ldID0gdGlsZUlkID8gdGlsZUluZm8ub2Zmc2V0QnkoeCpDb25zdHMuVGlsZVNpemUsIHkqQ29uc3RzLlRpbGVTaXplKSA6IHRpbGVJbmZvO1xuXHRcdFx0XHRpZiAoIXRpbGVJZCkge1xuXHRcdFx0XHRcdHRoaXMuZW1wdHlUaWxlc1tpXSA9IDE7XG5cdFx0XHRcdH1cblx0XHRcdFx0dGhpcy50aWxlc1tpXS5pZCA9IHRpbGVJZDtcblx0XHRcdH1cblx0XHR9XG5cblx0XHRsZXQgZ2VvbSA9IGxldmVsLmdlb207XG5cdFx0aWYgKHRoaXMuZWRnZUdlb20ubGVuZ3RoID09PSAwKSB7XG5cdFx0XHRsZXZlbC5nZW9tID0gZ2VvbSA9IFtdO1xuXHRcdFx0Zm9yIChsZXQgeSA9IDA7IHkgPCB0aGlzLnRpbGVIZWlnaHQ7ICsreSkge1xuXHRcdFx0XHRmb3IgKGxldCB4ID0gMDsgeCA8IHRoaXMudGlsZVdpZHRoOyArK3gpIHtcblx0XHRcdFx0XHRsZXQgaSA9IHgreSp0aGlzLnRpbGVXaWR0aDtcblx0XHRcdFx0XHRsZXQgdGlsZUlkID0gbGV2ZWwudGlsZXNbaV07XG5cdFx0XHRcdFx0aWYgKHRpbGVJZCA+PSBUaWxlcy5sZW5ndGgpIGNvbnRpbnVlO1xuXHRcdFx0XHRcdGxldCB0aWxlSW5mbyA9IFRpbGVzW3RpbGVJZF07XG5cdFx0XHRcdFx0aWYgKHRpbGVJZCkge1xuXHRcdFx0XHRcdFx0Z2VvbSA9IHBvbHlib29sKGdlb20sIFt0aGlzLnRpbGVzW2ldLmVkZ2VzLm1hcCgoe3N0YXJ0fSkgPT4gW3N0YXJ0LngsIHN0YXJ0LnldKV0pXG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cblx0XHRcdGdlb20uZm9yRWFjaCgocG9seSkgPT4ge1xuXHRcdFx0XHRmb3IgKGxldCBpID0gMTsgaSA8IHBvbHkubGVuZ3RoOyArK2kpIHtcblx0XHRcdFx0XHRsZXQgW3B4LCBweV0gPSBwb2x5W2ktMV07XG5cdFx0XHRcdFx0bGV0IFtjeCwgY3ldID0gcG9seVtpXTtcblx0XHRcdFx0XHRsZXQgW254LCBueV0gPSBwb2x5WyhpKzEpJXBvbHkubGVuZ3RoXTtcblx0XHRcdFx0XHRsZXQgZHB4ID0gY3gtcHgsIGRweSA9IGN5LXB5O1xuXHRcdFx0XHRcdGxldCBkbnggPSBueC1jeCwgZG55ID0gbnktY3k7XG5cdFx0XHRcdFx0bGV0IGxwID0gTWF0aC5zcXJ0KGRweCpkcHgrZHB5KmRweSk7XG5cdFx0XHRcdFx0aWYgKGxwICE9PSAwKSB7IGRweCAvPSBscDsgZHB5IC89IGxwOyB9XG5cdFx0XHRcdFx0bGV0IGxuID0gTWF0aC5zcXJ0KGRueCpkbngrZG55KmRueSk7XG5cdFx0XHRcdFx0aWYgKGxuICE9PSAwKSB7IGRueCAvPSBsbjsgZG55IC89IGxuOyB9XG5cdFx0XHRcdFx0Ly8gc2FtZSBkaXJlY3Rpb24uXG5cdFx0XHRcdFx0aWYgKE1hdGguYWJzKGRueCpkcHggKyBkbnkqZHB5IC0gMSkgPCAwLjAwMDEpIHtcblx0XHRcdFx0XHRcdHBvbHkuc3BsaWNlKGksIDEpO1xuXHRcdFx0XHRcdFx0LS1pO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fSk7XG5cblx0XHRcdHRoaXMuZWRnZUdlb20ubGVuZ3RoID0gMDtcblx0XHRcdGdlb20uZm9yRWFjaCgocG9seSwgaSkgPT4ge1xuXHRcdFx0XHRmb3IgKGxldCBpID0gMDsgaSA8IHBvbHkubGVuZ3RoOyArK2kpIHtcblx0XHRcdFx0XHRsZXQgW3B4LCBweV0gPSBwb2x5W2ldO1xuXHRcdFx0XHRcdGxldCBbbngsIG55XSA9IHBvbHlbKGkrMSklcG9seS5sZW5ndGhdO1xuXHRcdFx0XHRcdHRoaXMuZWRnZUdlb20ucHVzaChuZXcgTGluZVNlZ21lbnQobmV3IFZlYzIocHgsIHB5KSwgbmV3IFZlYzIobngsIG55KSkpO1xuXHRcdFx0XHR9XG5cdFx0XHR9KTtcblxuXHRcdH1cblxuXG5cdFx0dGhpcy5rZXlzLmxlbmd0aCA9IDA7XG5cdFx0dGhpcy5sb2Nrcy5sZW5ndGggPSAwO1xuXHRcdE9iamVjdC5rZXlzKGtub3duS2V5c09yTG9ja3MpLmZvckVhY2goKGlkLCBpZHgpID0+IHtcblx0XHRcdGxldCBsayA9IGtub3duS2V5c09yTG9ja3NbaWRdO1xuXHRcdFx0bGV0IGxvY2tzID0gW107XG5cdFx0XHRsZXQga2V5ID0ge2lkOiBpZHgsIHBvczogbnVsbCwgbG9ja3MsIGxvY2tlZDogdHJ1ZX07XG5cblx0XHRcdGxrLmZvckVhY2goKHt4LCB5fSkgPT4ge1xuXG5cdFx0XHRcdGxldCBsZWZ0ID0geCAhPT0gMCAmJiAodGhpcy50aWxlc1soeC0xKSt5KnRoaXMudGlsZVdpZHRoXS5pZCA9PT0gMSk7XG5cdFx0XHRcdGxldCByaWdodCA9IHggIT09IHRoaXMudGlsZVdpZHRoLTEgJiYgKHRoaXMudGlsZXNbeCsxK3kqdGhpcy50aWxlV2lkdGhdLmlkID09PSAxKTtcblx0XHRcdFx0bGV0IHRvcCA9IHkgIT09IDAgJiYgKHRoaXMudGlsZXNbKHktMSkqdGhpcy50aWxlV2lkdGgreF0uaWQgPT09IDEpO1xuXHRcdFx0XHRsZXQgYm90dG9tID0geSAhPT0gdGhpcy50aWxlSGVpZ2h0LTEgJiYgKHRoaXMudGlsZXNbeCsoeSsxKSp0aGlzLnRpbGVXaWR0aF0uaWQgPT09IDEpO1xuXHRcdFx0XHRpZiAobGVmdCB8fCByaWdodCB8fCB0b3AgfHwgYm90dG9tKSB7XG5cdFx0XHRcdFx0bGV0IGxvY2sgPSB7a2V5LCBpZDogaWR4LCBwb3M6IG5ldyBWZWMyKHgsIHkpLCB0aWxlOiBUaWxlc1sxXS5vZmZzZXRCeSh4KkNvbnN0cy5UaWxlU2l6ZSwgeSpDb25zdHMuVGlsZVNpemUpfTtcblx0XHRcdFx0XHRsb2Nrcy5wdXNoKGxvY2spO1xuXHRcdFx0XHRcdHRoaXMubG9ja2VkVGlsZXNbeCt5KnRoaXMudGlsZVdpZHRoXSA9IGxvY2s7XG5cdFx0XHRcdFx0dGhpcy5sb2Nrcy5wdXNoKGxvY2spO1xuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdGNvbnNvbGUuYXNzZXJ0KGtleS5wb3MgPT0gbnVsbCk7XG5cdFx0XHRcdFx0a2V5LnBvcyA9IG5ldyBWZWMyKHgsIHkpO1xuXHRcdFx0XHR9XG5cdFx0XHR9KTtcblx0XHRcdGNvbnNvbGUuYXNzZXJ0KGtleS5wb3MgIT0gbnVsbCk7XG5cdFx0XHR0aGlzLmtleXMucHVzaChrZXkpO1xuXHRcdH0pO1xuXG5cdFx0dGhpcy5rZXlzLmZvckVhY2goKGspID0+XG5cdFx0XHR0aGlzLmFkZEVudGl0eShuZXcgS2V5KHRoaXMsIGsucG9zLngqQ29uc3RzLlRpbGVTaXplLCBrLnBvcy55KkNvbnN0cy5UaWxlU2l6ZSwgaykpKVxuXG5cdFx0Ly8gbGV0IGNvdW50ID0gTWF0aC5jZWlsKCh0aGlzLmdlb21Qb2ludHMubGVuZ3RoKzQpKjEuNSk7XG5cdFx0Ly8gbGV0IHB0WFlBID0gbmV3IEZsb2F0MzJBcnJheShjb3VudCozKTtcblx0XHQvLyBsZXQgdG1wUG9pbnQgPSBuZXcgVWludDhBcnJheShjb3VudClcblx0XHR0aGlzLnZpc1RyYWNrZXIuc2V0U2VnbWVudHModGhpcy5lZGdlR2VvbSk7XG5cdFx0dGhpcy5iZ2J1ZmZlciA9IG5ldyBQaXhlbEJ1ZmZlcih0aGlzLndpZHRoLCB0aGlzLmhlaWdodCk7XG5cdFx0Ly8gdGhpcy5zZWVuQnVmZmVyID0gbmV3IFBpeGVsQnVmZmVyKHRoaXMud2lkdGgsIHRoaXMuaGVpZ2h0KTtcblx0XHQvLyB0aGlzLnNlZW5CdWZmZXIuY29udGV4dC5maWxsU3R5bGUgPSAnYmxhY2snXG5cdFx0Ly8gdGhpcy5zZWVuQnVmZmVyLmNvbnRleHQuZmlsbFJlY3QoMCwgMCwgdGhpcy53aWR0aCwgdGhpcy5oZWlnaHQpO1xuXHRcdHRoaXMuYmxvb2RCdWZmZXIgPSBuZXcgUGl4ZWxCdWZmZXIodGhpcy53aWR0aCwgdGhpcy5oZWlnaHQpO1xuXG5cdFx0U291bmRzLnBsYXlNdXNpYygxKTtcblx0fVxuXG5cdGFkZEVudGl0eShlbnQsIHg9ZW50LnBvcy54LCB5PWVudC5wb3MueSkge1xuXHRcdGVudC5wb3MueCA9IHg7XG5cdFx0ZW50LnBvcy55ID0geTtcblx0XHR0aGlzLmVudGl0aWVzLnB1c2goZW50KTtcblx0XHRpZiAoZW50LmNvbGxpZGVzV2l0aEVudGl0aWVzIHx8IGVudC5jb2xsaWRlc1dpdGhQbGF5ZXIpIHtcblx0XHRcdHRoaXMuZ3JpZC5hZGQoZW50KTtcblx0XHR9XG5cdFx0cmV0dXJuIGVudDtcblx0fVxuXG5cdHNlZ21lbnRzQXJvdW5kKHBvcywgcmFkaXVzKSB7XG5cdFx0bGV0IGxlZnQgPSBtYXRoLmNsYW1wKE1hdGguZmxvb3IoKHBvcy54IC0gcmFkaXVzKSAvIENvbnN0cy5UaWxlU2l6ZSktMSwgMCwgdGhpcy50aWxlV2lkdGgtMSk7XG5cdFx0bGV0IHJpZ2h0ID0gbWF0aC5jbGFtcChNYXRoLmNlaWwoKHBvcy54ICsgcmFkaXVzKSAvIENvbnN0cy5UaWxlU2l6ZSkrMSwgMCwgdGhpcy50aWxlV2lkdGgtMSk7XG5cdFx0bGV0IHRvcCA9IG1hdGguY2xhbXAoTWF0aC5mbG9vcigocG9zLnkgLSByYWRpdXMpIC8gQ29uc3RzLlRpbGVTaXplKS0xLCAwLCB0aGlzLnRpbGVIZWlnaHQtMSk7XG5cdFx0bGV0IGJvdHRvbSA9IG1hdGguY2xhbXAoTWF0aC5jZWlsKChwb3MueSArIHJhZGl1cykgLyBDb25zdHMuVGlsZVNpemUpKzEsIDAsIHRoaXMudGlsZUhlaWdodC0xKTtcblx0XHRsZXQgcmVzdWx0ID0gc2VnbWVudFRtcDtcblx0XHRyZXN1bHQubGVuZ3RoID0gMDtcblx0XHRmb3IgKGxldCB5ID0gdG9wOyB5IDw9IGJvdHRvbTsgKyt5KSB7XG5cdFx0XHRmb3IgKGxldCB4ID0gbGVmdDsgeCA8PSByaWdodDsgKyt4KSB7XG5cdFx0XHRcdGxldCB0aWxlSWR4ID0geSAqIHRoaXMudGlsZVdpZHRoICsgeDtcblx0XHRcdFx0cmVzdWx0LnB1c2guYXBwbHkocmVzdWx0LCB0aGlzLnRpbGVzW3RpbGVJZHhdLmVkZ2VzKTtcblx0XHRcdFx0aWYgKHRoaXMubG9ja2VkVGlsZXNbdGlsZUlkeF0gJiYgdGhpcy5sb2NrZWRUaWxlc1t0aWxlSWR4XS5rZXkubG9ja2VkKSB7XG5cdFx0XHRcdFx0cmVzdWx0LnB1c2guYXBwbHkocmVzdWx0LCB0aGlzLmxvY2tlZFRpbGVzW3RpbGVJZHhdLnRpbGUuZWRnZXMpO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXHRcdHJldHVybiByZXN1bHQ7XG5cdH1cblxuXHR1cGRhdGUoZHQpIHtcblx0XHRpZiAod2luZG93LlRJTUVfRlVOQ1RJT05TKSBjb25zb2xlLnRpbWUoJ3VwZGF0ZScpO1xuXHRcdHN3aXRjaCAodGhpcy5zdGF0ZSkge1xuXHRcdGNhc2UgU1RBVEVTLkdhbWU6XG5cdFx0XHRpZiAoIXRoaXMuc3RhcnRlZEdhbWUpIHtcblx0XHRcdFx0dGhpcy5zdGFydExldmVsKHRoaXMuYXNzZXRzLmxldmVsMCk7XG5cdFx0XHR9XG5cdFx0XHRlbHNlIGlmICh0aGlzLnBsYXllckRlYWQpIHtcblx0XHRcdFx0dGhpcy5kZWFkUGxheWVyVGltZXIgLT0gZHQ7XG5cdFx0XHRcdGlmICh0aGlzLmRlYWRQbGF5ZXJUaW1lcjwwKSB7XG5cdFx0XHRcdFx0dGhpcy5zdGFydExldmVsKHRoaXMuYXNzZXRzLmxldmVsMCk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHRcdHRoaXMuZ2FtZVN0YXRlVXBkYXRlKGR0KTtcblx0XHRcdGJyZWFrO1xuXHRcdGNhc2UgU1RBVEVTLkxvYWRpbmc6XG5cdFx0XHQvLyB0aGlzIGlzICpzdHVwaWQqXG5cdFx0XHRpZiAodGhpcy5sb2FkUHJvZ3Jlc3MgPT09IDEuMCkge1xuXHRcdFx0XHR0aGlzLnN0YXRlID0gU1RBVEVTLkdhbWU7XG5cdFx0XHR9IGVsc2UgaWYgKHRoaXMubG9hZFByb2dyZXNzID49IDAuOSkge1xuXHRcdFx0XHR0aGlzLmxvYWRQcm9ncmVzcyA9IDEuMDtcblx0XHRcdH1cblx0XHRcdGJyZWFrO1xuXHRcdGNhc2UgU1RBVEVTLk1lbnU6XG5cdFx0XHRicmVhazsgLy8gTllJXG5cdFx0fVxuXHRcdGlmICh3aW5kb3cuVElNRV9GVU5DVElPTlMpIGNvbnNvbGUudGltZUVuZCgndXBkYXRlJyk7XG5cdH1cblxuXHRnYW1lU3RhdGVVcGRhdGUoZHQpIHtcblx0XHR0aGlzLmRlYnVnQ29udGV4dC5jbGVhclJlY3QoMCwgMCwgdGhpcy5kZWJ1Z0NvbnRleHQuY2FudmFzLndpZHRoLCB0aGlzLmRlYnVnQ29udGV4dC5jYW52YXMuaGVpZ2h0KTtcblx0XHR0aGlzLmRlYnVnQ29udGV4dC5zYXZlKCk7XG5cdFx0dGhpcy5kZWJ1Z0NvbnRleHQuc2NhbGUoQ29uc3RzLlNjYWxlLCBDb25zdHMuU2NhbGUpO1xuXG5cdFx0Ly8gdGhpcy5jYW1UYXJnZXQuY29weSh0aGlzLnBsYXllci5wb3MpO1xuXG5cdFx0dGhpcy5tb3VzZS54ID0gdGhpcy5jYW1lcmEubWluWCArIElucHV0Lm1vdXNlLng7XG5cdFx0dGhpcy5tb3VzZS55ID0gdGhpcy5jYW1lcmEubWluWSArIElucHV0Lm1vdXNlLnk7XG5cdFx0aWYgKC8qSW5wdXQubW91c2UuaXNEb3duIHx8ICovSW5wdXQua2V5Ym9hcmQuaXNEb3duKCdzcGFjZScpKSB7XG5cdFx0XHRsZXQgbWR4ID0gdGhpcy5tb3VzZS54LXRoaXMucGxheWVyLnBvcy54O1xuXHRcdFx0bGV0IG1keSA9IHRoaXMubW91c2UueS10aGlzLnBsYXllci5wb3MueTtcblx0XHRcdG1keCAvPSA0O1xuXHRcdFx0bWR5IC89IDQ7XG5cdFx0XHRpZiAobWR4IDwgMjAgJiYgbWR5IDwgMjApIHtcblx0XHRcdFx0Ly8gdGhpcy5jYW1UYXJnZXQuY29weSh0aGlzLnBsYXllci5wb3MpXG5cdFx0XHR9XG5cdFx0XHRlbHNlIHtcblx0XHRcdFx0Ly8gdGhpcy5jYW1UYXJnZXQuc2V0KHRoaXMucGxheWVyLnBvcy54K21keCwgdGhpcy5wbGF5ZXIucG9zLnkrbWR5KTtcblx0XHRcdH1cblx0XHR9XG5cdFx0ZWxzZSB7XG5cdFx0XHR0aGlzLmNhbVRhcmdldC5jb3B5KHRoaXMucGxheWVyLnBvcyk7XG5cdFx0fVxuXHRcdGxldCBleHRyYUdlb20gPSBbXTtcblxuXHRcdC8vIGlmICh3aW5kb3cuVElNRV9GVU5DVElPTlMpIGNvbnNvbGUudGltZSgndXBkYXRlOmVudGl0aWVzJyk7XG5cdFx0e1xuXHRcdFx0bGV0IGVudGl0aWVzID0gdGhpcy5lbnRpdGllcztcblx0XHRcdGZvciAobGV0IGkgPSAwOyBpIDwgZW50aXRpZXMubGVuZ3RoOyArK2kpIHtcblx0XHRcdFx0ZW50aXRpZXNbaV0udXBkYXRlKGR0KTtcblx0XHRcdFx0ZW50aXRpZXNbaV0ucG9zdFVwZGF0ZShkdCk7XG5cdFx0XHR9XG5cdFx0XHRsZXQgaiA9IDA7XG5cdFx0XHRmb3IgKGxldCBpID0gMCwgbCA9IGVudGl0aWVzLmxlbmd0aDsgaSA8IGw7ICsraSkge1xuXHRcdFx0XHRpZiAoZW50aXRpZXNbaV0uZW5hYmxlZCkge1xuXHRcdFx0XHRcdGVudGl0aWVzW2orK10gPSBlbnRpdGllc1tpXTtcblx0XHRcdFx0XHRsZXQgc2VncyA9IGVudGl0aWVzW2ldLmdldFNlZ21lbnRzKCk7XG5cdFx0XHRcdFx0aWYgKHNlZ3MpIGV4dHJhR2VvbS5wdXNoLmFwcGx5KGV4dHJhR2VvbSwgc2Vncyk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHRcdGVudGl0aWVzLmxlbmd0aCA9IGo7XG5cdFx0fVxuXHRcdC8vIGlmICh3aW5kb3cuVElNRV9GVU5DVElPTlMpIGNvbnNvbGUudGltZUVuZCgndXBkYXRlOmVudGl0aWVzJyk7XG5cblx0XHR0aGlzLmNhbWVyYS51cGRhdGUoZHQpO1xuXHRcdGlmICh3aW5kb3cuVElNRV9GVU5DVElPTlMpIGNvbnNvbGUudGltZSgnbGlnaHRpbmcnKTtcblx0XHQvL3RoaXMuY29tcHV0ZUxpZ2h0aW5nKCk7XG5cdFx0bGV0IHttaW5YLCBtaW5ZLCBtYXhYLCBtYXhZfSA9IHRoaXMuY2FtZXJhO1xuXHRcdGxldCBwMCA9IFZlYzIudGVtcChtaW5YLTEsIG1pblktMSk7XG5cdFx0bGV0IHAxID0gVmVjMi50ZW1wKG1pblgtMSwgbWF4WSsxKTtcblx0XHRsZXQgcDIgPSBWZWMyLnRlbXAobWF4WCsxLCBtYXhZKzEpO1xuXHRcdGxldCBwMyA9IFZlYzIudGVtcChtYXhYKzEsIG1pblktMSk7XG5cdFx0ZXh0cmFHZW9tLnB1c2gobmV3IExpbmVTZWdtZW50KHAwLCBwMSksIG5ldyBMaW5lU2VnbWVudChwMSwgcDIpLFxuXHRcdCAgICAgICAgICAgICAgIG5ldyBMaW5lU2VnbWVudChwMiwgcDMpLCBuZXcgTGluZVNlZ21lbnQocDMsIHAwKSlcblxuXHRcdGxldCBwaCA9IHRoaXMucGxheWVyLmhlYWRpbmc7XG5cdFx0bGV0IGh4ID0gTWF0aC5jb3MocGgpO1xuXHRcdGxldCBoeSA9IE1hdGguc2luKHBoKTtcblx0XHRsZXQgaWh4ID0gLWh4XG5cdFx0bGV0IGloeSA9IC1oeTtcblx0XHRsZXQgaWggPSBWZWMyLnRlbXAoaWh4KjMrdGhpcy5wbGF5ZXIucG9zLngsIGloeSozK3RoaXMucGxheWVyLnBvcy55KTtcblx0XHRsZXQgbWluQW5nbGUgPSBwaC1NYXRoLlBJLzU7XG5cdFx0bGV0IG1heEFuZ2xlID0gcGgrTWF0aC5QSS81O1xuXHRcdGxldCBtaW5BeCA9IE1hdGguY29zKG1pbkFuZ2xlKSoyMDAgKyBpaC54O1xuXHRcdGxldCBtaW5BeSA9IE1hdGguc2luKG1pbkFuZ2xlKSoyMDAgKyBpaC55O1xuXG5cdFx0bGV0IG1heEF4ID0gTWF0aC5jb3MobWF4QW5nbGUpKjIwMCArIGloLng7XG5cdFx0bGV0IG1heEF5ID0gTWF0aC5zaW4obWF4QW5nbGUpKjIwMCArIGloLnk7XG5cblx0XHQvLyBAVE9ETzogYXZvaWQgY29weWluZyB0aGlzIHNvIGZyZXF1ZW50bHlcblx0XHR0aGlzLnZpc1RyYWNrZXIuc2V0U2VnbWVudHModGhpcy5lZGdlR2VvbS5jb25jYXQoZXh0cmFHZW9tLCAuLi50aGlzLmxvY2tzLmZpbHRlcihsID0+IGwua2V5LmxvY2tlZCkubWFwKGwgPT4gbC50aWxlLmVkZ2VzKSkpO1xuXG5cdFx0dGhpcy52aXNUcmFja2VyLnNldENlbnRlcih0aGlzLnBsYXllci5wb3MpO1xuXHRcdHRoaXMudmlzVHJhY2tlci5zd2VlcCgpO1xuXHRcdGlmICh3aW5kb3cuVElNRV9GVU5DVElPTlMpIGNvbnNvbGUudGltZUVuZCgnbGlnaHRpbmcnKTtcblxuXHRcdC8vIGlmICh3aW5kb3cuVElNRV9GVU5DVElPTlMpIGNvbnNvbGUudGltZUVuZCgndXBkYXRlOmVmZmVjdHMnKTtcblx0XHR0aGlzLmRlYnVnQ29udGV4dC5yZXN0b3JlKCk7XG5cdH1cblxuXHRjbG9zZXN0UG9pbnQob3V0LCBwb3MsIHJhZGl1cykge1xuXHRcdGxldCBtaW4gPSBOdW1iZXIuTUFYX1ZBTFVFO1xuXHRcdGxldCBjbG9zZXN0WCA9IDAuMDtcblx0XHRsZXQgY2xvc2VzdFkgPSAwLjA7XG5cdFx0bGV0IHNpZ24gPSAwO1xuXHRcdGxldCBzZWdzID0gdGhpcy5zZWdtZW50c0Fyb3VuZChwb3MsIHJhZGl1cyk7XG5cdFx0bGV0IHRtcENsb3Nlc3QgPSBWZWMyLnRlbXAoMC4wLCAwLjApO1xuXHRcdGxldCB7eDpweCwgeTpweX0gPSBwb3M7XG5cdFx0Y29uc3QgcGFwZXJXaWR0aCA9IDAuMTtcblx0XHRmb3IgKGxldCBzaSA9IDAsIHNsID0gc2Vncy5sZW5ndGg7IHNpIDwgc2w7ICsrc2kpIHtcblx0XHRcdGxldCBzZWcgPSBzZWdzW3NpXTtcblx0XHRcdGxldCBiYWNrZmFjZSA9IHNlZy5jbG9zZXN0UG9pbnQodG1wQ2xvc2VzdCwgcG9zKTtcblx0XHRcdGxldCBkeCA9IHRtcENsb3Nlc3QueC1weCwgZHkgPSB0bXBDbG9zZXN0LnktcHk7XG5cdFx0XHRsZXQgZGlzdCA9IGR4KmR4K2R5KmR5O1xuXHRcdFx0aWYgKCFiYWNrZmFjZSkgZGlzdCAtPSBwYXBlcldpZHRoO1xuXHRcdFx0aWYgKGRpc3QgPCBtaW4pIHtcblx0XHRcdFx0Y2xvc2VzdFggPSB0bXBDbG9zZXN0Lng7XG5cdFx0XHRcdGNsb3Nlc3RZID0gdG1wQ2xvc2VzdC55O1xuXHRcdFx0XHRtaW4gPSBkaXN0O1xuXHRcdFx0XHRzaWduID0gYmFja2ZhY2UgPyAtMSA6IDE7XG5cdFx0XHR9XG5cdFx0fVxuXHRcdG91dC54ID0gY2xvc2VzdFg7XG5cdFx0b3V0LnkgPSBjbG9zZXN0WTtcblx0XHRyZXR1cm4gc2lnbjtcblx0fVxuXG5cdHJheWNhc3RDZWxsKG91dFAsIG91dE4sIHgsIHksIHJheVBvcywgcmF5RGlyKSB7XG5cdFx0bGV0IHRpbGVJZHggPSB4ICsgeSp0aGlzLnRpbGVXaWR0aDtcblx0XHRsZXQgc2VncyA9IHRoaXMudGlsZXNbdGlsZUlkeF0uZWRnZXM7XG5cdFx0aWYgKHNlZ3MubGVuZ3RoID09PSAwKSB7XG5cdFx0XHRpZiAodGhpcy5sb2NrZWRUaWxlc1t0aWxlSWR4XSAmJiB0aGlzLmxvY2tlZFRpbGVzW3RpbGVJZHhdLmtleS5sb2NrZWQpIHtcblx0XHRcdFx0c2VncyA9IHRoaXMubG9ja2VkVGlsZXNbdGlsZUlkeF0udGlsZS5lZGdlcztcblx0XHRcdH1cblx0XHR9XG5cdFx0bGV0IGN1ckJlc3QgPSAyLjA7XG5cdFx0bGV0IHRtcFAgPSBWZWMyLnRlbXAoMC4wLCAwLjApO1xuXHRcdGxldCB0bXBOID0gVmVjMi50ZW1wKDAuMCwgMC4wKTtcblx0XHRmb3IgKGxldCBpID0gMCwgbCA9IHNlZ3MubGVuZ3RoOyBpIDwgbDsgKytpKSB7XG5cdFx0XHRsZXQgc2VnID0gc2Vnc1tpXTtcblx0XHRcdGxldCBpc2VjdCA9IHNlZy5yYXljYXN0KHRtcFAsIHRtcE4sIHJheVBvcywgcmF5RGlyLCAwKTtcblx0XHRcdGlmIChpc2VjdCA9PT0gLTEpIHJldHVybiAtMTtcblx0XHRcdGlmIChpc2VjdCA8IGN1ckJlc3QpIHtcblx0XHRcdFx0Y3VyQmVzdCA9IGlzZWN0O1xuXHRcdFx0XHRvdXRQLmNvcHkodG1wUCk7XG5cdFx0XHRcdG91dE4uY29weSh0bXBOKTtcblx0XHRcdH1cblx0XHR9XG5cdFx0cmV0dXJuIGN1ckJlc3Q7XG5cdH1cblxuXHRzZXRTdGF0ZShzdGF0ZSkge1xuXHRcdHRoaXMubGFzdFN0YXRlID0gdGhpcy5zdGF0ZTtcblx0XHR0aGlzLnN0YXRlID0gc3RhdGU7XG5cdH1cblxuXHRjYW5TZWUocHQwLCBwdDEpIHtcblx0XHRsZXQgcCA9IFZlYzIudGVtcCgpO1xuXHRcdGxldCBuID0gVmVjMi50ZW1wKCk7XG5cdFx0bGV0IGRlbHRhID0gcHQwLnRvKHB0MSk7XG5cdFx0bGV0IHIgPSB0aGlzLnJheWNhc3QocCwgbiwgcHQwLCBkZWx0YS5ub3JtYWxpemVkKCkpO1xuXHRcdGlmIChyIDwgMCB8fCByIDwgZGVsdGEubGVuZ3RoKCkpIHtcblx0XHRcdHJldHVybiBmYWxzZTtcblx0XHR9XG5cdFx0cmV0dXJuIHRydWU7XG5cdH1cblxuXHRyYXljYXN0KG91dFAsIG91dE4sIHJheVBvcywgcmF5RGlyLCByYXlMZW4sIGV4dHJhU2Vncykge1xuXHRcdGxldCB7eDpyYXlYLCB5OnJheVl9ID0gcmF5UG9zO1xuXHRcdGxldCB7eDpyYXlEaXJYLCB5OnJheURpcll9ID0gcmF5RGlyO1xuXHRcdGxldCBneCA9IE1hdGguZmxvb3IocmF5WCAvIENvbnN0cy5UaWxlU2l6ZSk7XG5cdFx0bGV0IGd5ID0gTWF0aC5mbG9vcihyYXlZIC8gQ29uc3RzLlRpbGVTaXplKTtcblx0XHRsZXQgcmF5RHhJID0gMDtcblx0XHRsZXQgcmF5RHlJID0gMDtcblx0XHRsZXQgc3ggPSA5OTk5OTkuMDtcblx0XHRsZXQgc3kgPSA5OTk5OTkuMDtcblx0XHRsZXQgZXggPSAwLjA7XG5cdFx0bGV0IGV5ID0gMC4wO1xuXG5cdFx0aWYgKHJheURpclggPCAwKSB7XG5cdFx0XHRyYXlEeEkgPSAtMTtcblx0XHRcdHN4ID0gKGd4ICogQ29uc3RzLlRpbGVTaXplIC0gcmF5WCkgLyByYXlEaXJYO1xuXHRcdFx0ZXggPSBDb25zdHMuVGlsZVNpemUgLyAtcmF5RGlyWDtcblx0XHR9XG5cdFx0ZWxzZSBpZiAocmF5RGlyWCA+IDApIHtcblx0XHRcdHJheUR4SSA9IDE7XG5cdFx0XHRzeCA9ICgoZ3ggKyAxKSAqIENvbnN0cy5UaWxlU2l6ZSAtIHJheVgpIC8gcmF5RGlyWDtcblx0XHRcdGV4ID0gQ29uc3RzLlRpbGVTaXplIC8gcmF5RGlyWDtcblx0XHR9XG5cblx0XHRpZiAocmF5RGlyWSA8IDApIHtcblx0XHRcdHJheUR5SSA9IC0xO1xuXHRcdFx0c3kgPSAoZ3kgKiBDb25zdHMuVGlsZVNpemUgLSByYXlZKSAvIHJheURpclk7XG5cdFx0XHRleSA9IENvbnN0cy5UaWxlU2l6ZSAvIC1yYXlEaXJZO1xuXHRcdH1cblx0XHRlbHNlIGlmIChyYXlEaXJZID4gMCkge1xuXHRcdFx0cmF5RHlJID0gMTtcblx0XHRcdHN5ID0gKChneSArIDEpICogQ29uc3RzLlRpbGVTaXplIC0gcmF5WSkgLyByYXlEaXJZO1xuXHRcdFx0ZXkgPSBDb25zdHMuVGlsZVNpemUgLyByYXlEaXJZO1xuXHRcdH1cblxuXHRcdGlmIChyYXlEeEkgPT09IDAgJiYgcmF5RHlJID09PSAwKSB7XG5cdFx0XHRjb25zb2xlLmVycm9yKFwiRW1wdHkgcmF5IHZlY3RvciBpbiByYXljYXN0KCk6IFwiLCByYXlEaXJYLCByYXlEaXJZKTtcblx0XHRcdHJldHVybiAtMTtcblx0XHR9XG5cblx0XHRsZXQgcmF5TWF4RGlzdCA9IHJheUxlbiB8fCAxMDAwMC4wO1xuXHRcdGxldCB0bXBSYXlQID0gVmVjMi50ZW1wKHJheVgsIHJheVkpO1xuXHRcdGxldCB0bXBSYXlWID0gVmVjMi50ZW1wKHJheURpclgqcmF5TWF4RGlzdCwgcmF5RGlyWSpyYXlNYXhEaXN0KTtcblxuXHRcdGxldCBlc0Jlc3RUID0gMjtcblx0XHRsZXQgZXNCZXN0TiA9IFZlYzIudGVtcCgpO1xuXHRcdGxldCBlc0Jlc3RQID0gVmVjMi50ZW1wKCk7XG5cdFx0aWYgKGV4dHJhU2VncyAhPSBudWxsKSB7XG5cdFx0XHRsZXQgc2VnVG1wUCA9IFZlYzIudGVtcCgpO1xuXHRcdFx0bGV0IHNlZ1RtcE4gPSBWZWMyLnRlbXAoKTtcblx0XHRcdGZvciAobGV0IHNpID0gMDsgc2kgPCBleHRyYVNlZ3MubGVuZ3RoOyArK3NpKSB7XG5cdFx0XHRcdGxldCB0ID0gZXh0cmFTZWdzW3NpXS5yYXljYXN0KHNlZ1RtcFAsIHNlZ1RtcE4sIHRtcFJheVAsIHRtcFJheVYsIDApO1xuXHRcdFx0XHRpZiAobWF0aC5iZXR3ZWVuSSh0LCAwLjAsIDEuMCkgJiYgdCA8IGVzQmVzdFQpIHtcblx0XHRcdFx0XHRlc0Jlc3RUID0gdDtcblx0XHRcdFx0XHRlc0Jlc3ROLmNvcHkoc2VnVG1wTik7XG5cdFx0XHRcdFx0ZXNCZXN0UC5jb3B5KHNlZ1RtcFApO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0bGV0IHRyYXZlbCA9IC0xO1xuXHRcdHdoaWxlICgodHJhdmVsID0gdGhpcy5yYXljYXN0Q2VsbChvdXRQLCBvdXROLCBneCwgZ3ksIHRtcFJheVAsIHRtcFJheVYpKSAhPT0gLTEpIHtcblxuXHRcdFx0aWYgKHRyYXZlbCAhPT0gMikge1xuXHRcdFx0XHRpZiAoZXNCZXN0VCA+PSAwICYmIGVzQmVzdFQgIT09IDIpIHtcblx0XHRcdFx0XHR0cmF2ZWwgPSBNYXRoLm1pbihlc0Jlc3RULCB0cmF2ZWwpO1xuXHRcdFx0XHRcdG91dFAuY29weShlc0Jlc3RQKTtcblx0XHRcdFx0XHRvdXROLmNvcHkoZXNCZXN0Tik7XG5cdFx0XHRcdH1cblx0XHRcdFx0cmV0dXJuIHRyYXZlbCAqIHJheU1heERpc3Q7XG5cdFx0XHR9XG5cblxuXHRcdFx0aWYgKHN4IDwgc3kpIHtcblx0XHRcdFx0c3ggKz0gZXg7XG5cdFx0XHRcdGd4ICs9IHJheUR4STtcblx0XHRcdFx0aWYgKGd4IDwgMCB8fCBneCA+PSB0aGlzLnRpbGVXaWR0aCkge1xuXHRcdFx0XHRcdGNvbnNvbGUud2FybihcInJheWNhc3QgbWlzc2VkIGV2ZXJ5dGhpbmchXCIsIG5ldyBWZWMyKHJheVgsIHJheVkpLCBuZXcgVmVjMihyYXlEaXJYLCByYXlEaXJZKSk7XG5cdFx0XHRcdFx0cmV0dXJuIC0xO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0XHRlbHNlIHtcblx0XHRcdFx0c3kgKz0gZXk7XG5cdFx0XHRcdGd5ICs9IHJheUR5STtcblx0XHRcdFx0aWYgKGd5IDwgMCB8fCBneSA+PSB0aGlzLnRpbGVIZWlnaHQpIHtcblx0XHRcdFx0XHRjb25zb2xlLndhcm4oXCJyYXljYXN0IG1pc3NlZCBldmVyeXRoaW5nIVwiLCBuZXcgVmVjMihyYXlYLCByYXlZKSwgbmV3IFZlYzIocmF5RGlyWCwgcmF5RGlyWSkpO1xuXHRcdFx0XHRcdHJldHVybiAtMTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblx0XHRjb25zb2xlLndhcm4oXCJyYXljYXN0IGdvdCBiYWQgcmF5IChzdGFydCBwb3MgaW5zaWRlIGdlb20pXCIsIG5ldyBWZWMyKHJheVgsIHJheVkpLCBuZXcgVmVjMihyYXlEaXJYLCByYXlEaXJZKSk7XG5cdFx0cmV0dXJuIC0xO1xuXHR9XG5cblx0cmVuZGVyKCkge1xuXHRcdGlmICh3aW5kb3cuVElNRV9GVU5DVElPTlMpIGNvbnNvbGUudGltZSgncmVuZGVyJyk7XG5cdFx0c3dpdGNoICh0aGlzLmxhc3RTdGF0ZSkge1xuXHRcdFx0Y2FzZSBTVEFURVMuR2FtZTogdGhpcy5nYW1lU3RhdGVSZW5kZXIoKTsgYnJlYWs7XG5cdFx0XHRjYXNlIFNUQVRFUy5Mb2FkaW5nOiB0aGlzLnJlbmRlckxvYWRpbmcoKTsgYnJlYWs7XG5cdFx0XHRjYXNlIFNUQVRFUy5NZW51OiBicmVhazsgLy8gTllJXG5cdFx0fVxuXHRcdGlmICh3aW5kb3cuVElNRV9GVU5DVElPTlMpIGNvbnNvbGUudGltZUVuZCgncmVuZGVyJyk7XG5cdFx0dGhpcy5sYXN0U3RhdGUgPSB0aGlzLnN0YXRlOyAvLyBAQEhBQ0s6IHdlIGRvbid0IHdhbnQgdG8gcmVuZGVyIHVudGlsIHdlJ3ZlIHVwZGF0ZWQgd2l0aCBvdXIgbmV3IHN0YXRlIGF0IGxlYXN0IG9uY2UuXG5cdH1cblxuXHRyZW5kZXJMb2FkaW5nKCkge1xuXHRcdHRoaXMub3ZlcmxheUxheWVyLmNsZWFyKCk7XG5cdFx0dGhpcy5odWRMYXllci5maWxsKCdibGFjaycpO1xuXHRcdGxldCBwcm9ncmVzc0JhcldpZHRoID0gdGhpcy5odWRMYXllci53aWR0aCA+PiAxO1xuXHRcdGxldCBwcm9ncmVzc0JhckhlaWdodCA9IDg7XG5cblx0XHR0aGlzLmh1ZExheWVyLmNvbnRleHQuc3Ryb2tlU3R5bGUgPSAnd2hpdGUnO1xuXHRcdHRoaXMuaHVkTGF5ZXIuY29udGV4dC5zdHJva2VSZWN0KFxuXHRcdFx0KHRoaXMuaHVkTGF5ZXIud2lkdGggLSBwcm9ncmVzc0JhcldpZHRoKS8yLFxuXHRcdFx0KHRoaXMuaHVkTGF5ZXIuaGVpZ2h0IC0gcHJvZ3Jlc3NCYXJIZWlnaHQpLzIsXG5cdFx0XHRwcm9ncmVzc0JhcldpZHRoLFxuXHRcdFx0cHJvZ3Jlc3NCYXJIZWlnaHRcblx0XHQpO1xuXG5cdFx0dGhpcy5odWRMYXllci5jb250ZXh0LmZpbGxTdHlsZSA9ICdibGFjayc7XG5cdFx0dGhpcy5odWRMYXllci5jb250ZXh0LmZpbGxSZWN0KFxuXHRcdFx0KHRoaXMuaHVkTGF5ZXIud2lkdGggLSBwcm9ncmVzc0JhcldpZHRoKS8yLFxuXHRcdFx0KHRoaXMuaHVkTGF5ZXIuaGVpZ2h0IC0gcHJvZ3Jlc3NCYXJIZWlnaHQpLzIsXG5cdFx0XHRwcm9ncmVzc0JhcldpZHRoLFxuXHRcdFx0cHJvZ3Jlc3NCYXJIZWlnaHRcblx0XHQpO1xuXG5cdFx0dGhpcy5odWRMYXllci5jb250ZXh0LmZpbGxTdHlsZSA9IHRoaXMubG9hZGluZ0ZhaWxlZCA/ICdyZWQnOiAnd2hpdGUnO1xuXG5cdFx0dGhpcy5odWRMYXllci5jb250ZXh0LmZpbGxSZWN0KFxuXHRcdFx0KHRoaXMuaHVkTGF5ZXIud2lkdGggLSBwcm9ncmVzc0JhcldpZHRoKS8yLFxuXHRcdFx0KHRoaXMuaHVkTGF5ZXIuaGVpZ2h0IC0gcHJvZ3Jlc3NCYXJIZWlnaHQpLzIsXG5cdFx0XHRwcm9ncmVzc0JhcldpZHRoKnRoaXMubG9hZFByb2dyZXNzLFxuXHRcdFx0cHJvZ3Jlc3NCYXJIZWlnaHRcblx0XHQpO1xuXHR9XG5cblx0dW5sb2NrKGtleSkge1xuXHRcdGtleS5sb2NrZWQgPSBmYWxzZTtcblx0XHRrZXkubG9ja3MuZm9yRWFjaChsID0+IHtcblx0XHRcdGwubG9ja2VkID0gZmFsc2U7XG5cdFx0fSk7XG5cblx0XHRpZiAoIXRoaXMua2V5cy5zb21lKGsgPT4gay5sb2NrZWQpKSB7XG5cdFx0XHR0aGlzLmdhbWVXb24gPSB0cnVlO1xuXHRcdFx0YWxlcnQoXCJZb3Ugd2luICh0aGlzIG1lc3NhZ2UgaXMgYWxsIEkgaGFkIHRpbWUgZm9yLCBzb3JyeSlcIik7XG5cdFx0fVxuXG5cdH1cblxuXHRraWxsUGxheWVyKCkge1xuXHRcdHRoaXMuZGVhZFBsYXllclRpbWVyID0gMS4wO1xuXHRcdHRoaXMucGxheWVyRGVhZCA9IHRydWU7XG5cdH1cblxuXHRnYW1lU3RhdGVSZW5kZXIoKSB7XG5cblx0XHRsZXQge21pblgsIG1pblksIG1heFgsIG1heFl9ID0gdGhpcy5jYW1lcmE7XG5cdFx0Ly8gbWluWCA9IE1hdGguZmxvb3IobWluWCk7XG5cdFx0Ly8gbWluWSA9IE1hdGguZmxvb3IobWluWSk7XG5cdFx0bGV0IGlNaW5YID0gTWF0aC5yb3VuZChtaW5YKTtcblx0XHRsZXQgaU1pblkgPSBNYXRoLnJvdW5kKG1pblkpO1xuXG5cdFx0Zm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLmxheWVycy5sZW5ndGg7ICsraSkge1xuXHRcdFx0bGV0IHBiID0gdGhpcy5sYXllcnNbaV0uYnVmZmVyO1xuXHRcdFx0aWYgKHBiLnBpeGVsc0RpcnR5KSBwYi5yZXNldCgpO1xuXHRcdFx0dGhpcy5sYXllcnNbaV0uY2xlYXIoKTtcblx0XHRcdHRoaXMubGF5ZXJzW2ldLmNvbnRleHQuc2F2ZSgpO1xuXHRcdFx0dGhpcy5sYXllcnNbaV0uY29udGV4dC50cmFuc2xhdGUoLWlNaW5YLCAtaU1pblkpO1xuXHRcdH1cblxuXHRcdHRoaXMuZGVidWdDb250ZXh0LnNhdmUoKTtcblx0XHR0aGlzLmRlYnVnQ29udGV4dC5zY2FsZShDb25zdHMuU2NhbGUsIENvbnN0cy5TY2FsZSk7XG5cdFx0dGhpcy5kZWJ1Z0NvbnRleHQubGluZVdpZHRoID0gMSAvIENvbnN0cy5TY2FsZTtcblx0XHR0aGlzLmRlYnVnQ29udGV4dC5zdHJva2VTdHlsZSA9ICdyZWQnO1xuXHRcdHRoaXMuZGVidWdDb250ZXh0LnRyYW5zbGF0ZSgtbWluWCwgLW1pblkpO1xuXG5cdFx0bGV0IG1pblRpbGVYID0gbWF0aC5jbGFtcChNYXRoLmZsb29yKG1pblgvQ29uc3RzLlRpbGVTaXplKSwgMCwgdGhpcy50aWxlV2lkdGgtMSk7XG5cdFx0bGV0IG1pblRpbGVZID0gbWF0aC5jbGFtcChNYXRoLmZsb29yKG1pblkvQ29uc3RzLlRpbGVTaXplKSwgMCwgdGhpcy50aWxlSGVpZ2h0LTEpO1xuXG5cdFx0bGV0IG1heFRpbGVYID0gbWF0aC5jbGFtcChNYXRoLmNlaWwobWF4WC9Db25zdHMuVGlsZVNpemUpLCAwLCB0aGlzLnRpbGVXaWR0aC0xKTtcblx0XHRsZXQgbWF4VGlsZVkgPSBtYXRoLmNsYW1wKE1hdGguY2VpbChtYXhZL0NvbnN0cy5UaWxlU2l6ZSksIDAsIHRoaXMudGlsZUhlaWdodC0xKTtcblxuXHRcdC8vIHRoaXMuYmdtb2RMYXllci5jb250ZXh0LmRyYXdJbWFnZSh0aGlzLmJnYnVmZmVyLmNhbnZhcywgLW1pblgsIC1taW5ZKTtcblx0XHQvLyB0aGlzLmJnbW9kTGF5ZXIuYmxlbmRNb2RlID0gJ292ZXJsYXknO1xuXHRcdC8vIHRoaXMuYmdtb2RMYXllci5hbHBoYSA9IDAuMjtcblx0XHR7XG5cdFx0XHRpZiAod2luZG93LlRJTUVfRlVOQ1RJT05TKSBjb25zb2xlLnRpbWUoJ3JlbmRlciB0aWxlcycpO1xuXHRcdFx0bGV0IHRpbGVDdHggPSB0aGlzLnRpbGVMYXllci5jb250ZXh0O1xuXHRcdFx0dGlsZUN0eC5maWxsU3R5bGUgPSAncmVkJztcblx0XHRcdGZvciAobGV0IHR5ID0gbWluVGlsZVk7IHR5IDw9IG1heFRpbGVZOyArK3R5KSB7XG5cdFx0XHRcdGxldCByb3cgPSB0eSp0aGlzLnRpbGVXaWR0aDtcblx0XHRcdFx0Zm9yIChsZXQgdHggPSBtaW5UaWxlWDsgdHggPD0gbWF4VGlsZVg7ICsrdHgpIHtcblx0XHRcdFx0XHRsZXQgdGlsZSA9IHRoaXMudGlsZXNbdHggKyByb3ddO1xuXHRcdFx0XHRcdGlmICh0aWxlLmlkID09PSAwKSB7XG5cdFx0XHRcdFx0XHRsZXQgbG9jayA9IHRoaXMubG9ja2VkVGlsZXNbdHgrcm93XTtcblx0XHRcdFx0XHRcdGlmIChsb2NrICYmIGxvY2sua2V5LmxvY2tlZCkge1xuXHRcdFx0XHRcdFx0XHR0aGlzLmVudHNMYXllci5jb250ZXh0LmRyYXdJbWFnZSh0aGlzLmFzc2V0cy5taXNjLFxuXHRcdFx0XHRcdFx0XHRcdDAsIGxvY2suaWQqMTYsIDE2LCAxNixcblx0XHRcdFx0XHRcdFx0XHR0eCAqIENvbnN0cy5UaWxlU2l6ZSxcblx0XHRcdFx0XHRcdFx0XHR0eSAqIENvbnN0cy5UaWxlU2l6ZSxcblx0XHRcdFx0XHRcdFx0XHRDb25zdHMuVGlsZVNpemUsIENvbnN0cy5UaWxlU2l6ZSk7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRjb250aW51ZTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0bGV0IHRpbGVJZCA9IHRpbGUuaWQtMTtcblx0XHRcdFx0XHR2YXIgdGlsZVggPSB0aWxlSWQgJSAxNlxuXHRcdFx0XHRcdHZhciB0aWxlWSA9ICh0aWxlSWQgLyAxNil8MDtcblx0XHRcdFx0XHR0aWxlWCAqPSAxNjtcblx0XHRcdFx0XHR0aWxlWSAqPSAxNjtcblxuXHRcdFx0XHRcdHRpbGVDdHguZHJhd0ltYWdlKHRoaXMuYXNzZXRzLnRpbGVzLFxuXHRcdFx0XHRcdFx0dGlsZVgsIHRpbGVZLCAxNiwgMTYsXG5cdFx0XHRcdFx0XHR0eCAqIENvbnN0cy5UaWxlU2l6ZSxcblx0XHRcdFx0XHRcdHR5ICogQ29uc3RzLlRpbGVTaXplLFxuXHRcdFx0XHRcdFx0Q29uc3RzLlRpbGVTaXplLCBDb25zdHMuVGlsZVNpemUpO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0XHRpZiAod2luZG93LlRJTUVfRlVOQ1RJT05TKSBjb25zb2xlLnRpbWVFbmQoJ3JlbmRlciB0aWxlcycpO1xuXHRcdH1cblxuXHRcdC8vIGlmICh3aW5kb3cuVElNRV9GVU5DVElPTlMpIGNvbnNvbGUudGltZSgncmVuZGVyIGVudGl0aWVzJyk7XG5cdFx0Zm9yIChsZXQgZWkgPSAxOyBlaSA8IHRoaXMuZW50aXRpZXMubGVuZ3RoOyArK2VpKSB7XG5cdFx0XHRsZXQgZW50ID0gdGhpcy5lbnRpdGllc1tlaV07XG5cdFx0XHRpZiAoZW50LmVuYWJsZWQpIHtcblx0XHRcdFx0ZW50LnJlbmRlcih0aGlzLmVudHNMYXllciwgdGhpcy5meExheWVyLmJ1ZmZlciwgbWluWCwgbWluWSk7XG5cdFx0XHR9XG5cdFx0fVxuXHRcdHRoaXMuZW50aXRpZXNbMF0ucmVuZGVyKHRoaXMuZW50c0xheWVyLCB0aGlzLmZ4TGF5ZXIuYnVmZmVyLCBtaW5YLCBtaW5ZKTsgLy8gcGxheWVyXG5cdFx0Ly8gaWYgKHdpbmRvdy5USU1FX0ZVTkNUSU9OUykgY29uc29sZS50aW1lRW5kKCdyZW5kZXIgZW50aXRpZXMnKTtcblxuXG5cdFx0aWYgKHRoaXMudmlzVHJhY2tlci5vdXRYcy5sZW5ndGgpIHtcblx0XHRcdGlmICh3aW5kb3cuVElNRV9GVU5DVElPTlMpIGNvbnNvbGUudGltZSgncmVuZGVyIGxpZ2h0aW5nJyk7XG5cdFx0XHR0aGlzLmxpZ2h0TGF5ZXIuY2xlYXIoKTtcblxuXHRcdFx0dGhpcy5saWdodExheWVyLmFscGhhID0gMC41O1xuXHRcdFx0dGhpcy5saWdodExheWVyLmJsZW5kTW9kZSA9ICdtdWx0aXBseSc7XG5cdFx0XHRsZXQgbGN0eCA9IHRoaXMubGlnaHRMYXllci5jb250ZXh0O1xuXHRcdFx0Ly8gbGV0IHNjdHggPSB0aGlzLnNlZW5CdWZmZXIuY29udGV4dDtcblx0XHRcdGxjdHguc2F2ZSgpO1xuXHRcdFx0bGN0eC5iZWdpblBhdGgoKTtcblx0XHRcdGxjdHgubW92ZVRvKHRoaXMucGxheWVyLnBvcy54LCB0aGlzLnBsYXllci5wb3MueSk7XG5cblx0XHRcdGxldCB7b3V0WHMsIG91dFlzfSA9IHRoaXMudmlzVHJhY2tlcjtcblx0XHRcdGxjdHgubW92ZVRvKG91dFhzWzBdLCBvdXRZc1swXSk7XG5cdFx0XHRmb3IgKGxldCBpID0gMCwgbCA9IG91dFhzLmxlbmd0aDsgaSA8IGw7ICsraSkge1xuXHRcdFx0XHRsZXQgcHggPSBvdXRYc1tpXTtcblx0XHRcdFx0bGV0IHB5ID0gb3V0WXNbaV07XG5cdFx0XHRcdGlmIChpID09PSAwKSB7IGxjdHgubW92ZVRvKHB4LCBweSk7IC8qc2N0eC5tb3ZlVG8ocHgsIHB5KTsqLyB9XG5cdFx0XHRcdGVsc2UgeyBsY3R4LmxpbmVUbyhweCwgcHkpOyAvKnNjdHgubGluZVRvKHB4LCBweSk7Ki8gfVxuXHRcdFx0XHRpZiAoREVCVUcpIGRyYXdpbmcuZHJhd0Fycm93KHRoaXMuZGVidWdDb250ZXh0LCB0aGlzLnBsYXllci5wb3MueCwgdGhpcy5wbGF5ZXIucG9zLnksIHB4LCBweSk7XG5cdFx0XHR9XG5cdFx0XHRjb25zdCBTaGFkb3dCbHVyID0gMTA7XG5cdFx0XHRsY3R4LnNoYWRvd0NvbG9yID0gJ3doaXRlJztcblx0XHRcdGxjdHguc2hhZG93Qmx1ciA9IFNoYWRvd0JsdXIvMjtcblx0XHRcdGxjdHguc2hhZG93T2Zmc2V0WCA9IDA7XG5cdFx0XHRsY3R4LnNoYWRvd09mZnNldFkgPSAwO1xuXG5cdFx0XHRsY3R4LmNsb3NlUGF0aCgpO1xuXHRcdFx0Ly8gc2N0eC5jbG9zZVBhdGgoKTtcblx0XHRcdGxjdHguZmlsbFN0eWxlID0gJ3doaXRlJztcblx0XHRcdC8vIHNjdHguZmlsbFN0eWxlID0gJ3doaXRlJztcblx0XHRcdGxjdHguZmlsbCgpO1xuXHRcdFx0Ly8gc2N0eC5maWxsKCk7XG5cblx0XHRcdGxldCBtYXNrQ3R4ID0gdGhpcy5saWdodE1hc2tDdHg7XG5cdFx0XHRtYXNrQ3R4LnNhdmUoKTtcblx0XHRcdG1hc2tDdHguY2xlYXJSZWN0KDAsIDAsIG1hc2tDdHguY2FudmFzLndpZHRoLCBtYXNrQ3R4LmNhbnZhcy5oZWlnaHQpXG5cdFx0XHRtYXNrQ3R4Lmdsb2JhbENvbXBvc2l0ZU9wZXJhdGlvbiA9ICdzb3VyY2Utb3Zlcic7XG5cblx0XHRcdG1hc2tDdHguc2hhZG93Q29sb3IgPSAnYmxhY2snO1xuXHRcdFx0bWFza0N0eC5zaGFkb3dCbHVyID0gU2hhZG93Qmx1cjtcblx0XHRcdG1hc2tDdHguc2hhZG93T2Zmc2V0WCA9IDA7XG5cdFx0XHRtYXNrQ3R4LnNoYWRvd09mZnNldFkgPSAwO1xuXHRcdFx0bWFza0N0eC5iZWdpblBhdGgoKTtcblx0XHRcdG1hc2tDdHgubW92ZVRvKHRoaXMucGxheWVyLnBvcy54LW1pblgsIHRoaXMucGxheWVyLnBvcy55LW1pblkpO1xuXHRcdFx0bWFza0N0eC5hcmMoXG5cdFx0XHRcdHRoaXMucGxheWVyLnBvcy54LW1pblgsXG5cdFx0XHRcdHRoaXMucGxheWVyLnBvcy55LW1pblksXG5cdFx0XHRcdDIwMCxcblx0XHRcdFx0dGhpcy5wbGF5ZXIuaGVhZGluZy1NYXRoLlBJLzUsXG5cdFx0XHRcdHRoaXMucGxheWVyLmhlYWRpbmcrTWF0aC5QSS81KTtcblx0XHRcdG1hc2tDdHguY2xvc2VQYXRoKClcblx0XHRcdG1hc2tDdHguZmlsbCgpO1xuXHRcdFx0bWFza0N0eC5yZXN0b3JlKCk7XG5cblx0XHRcdG1hc2tDdHguZ2xvYmFsQ29tcG9zaXRlT3BlcmF0aW9uID0gJ3NvdXJjZS1pbic7XG5cdFx0XHRtYXNrQ3R4LmRyYXdJbWFnZShsY3R4LmNhbnZhcywgMCwgMCk7XG5cdFx0XHRsY3R4LnJlc3RvcmUoKTtcblx0XHRcdGxjdHgudHJhbnNsYXRlKGlNaW5YLCBpTWluWSk7XG5cblx0XHRcdGxjdHguY2xlYXJSZWN0KDAsIDAsIGxjdHguY2FudmFzLndpZHRoLCBsY3R4LmNhbnZhcy5oZWlnaHQpO1xuXHRcdFx0bGN0eC5maWxsU3R5bGUgPSAnYmxhY2snO1xuXHRcdFx0bGN0eC5maWxsUmVjdCgwLCAwLCBsY3R4LmNhbnZhcy53aWR0aCwgbGN0eC5jYW52YXMuaGVpZ2h0KTtcblx0XHRcdGxjdHguZHJhd0ltYWdlKG1hc2tDdHguY2FudmFzLCAwLCAwKTtcblx0XHRcdC8vIHRoaXMuc2VlbkJ1ZmZlci5jb250ZXh0LmRyYXdJbWFnZShtYXNrQ3R4LmNhbnZhcywgaU1pblgsIGlNaW5ZKTtcblx0XHRcdGlmICh3aW5kb3cuVElNRV9GVU5DVElPTlMpIGNvbnNvbGUudGltZUVuZCgncmVuZGVyIGxpZ2h0aW5nJyk7XG5cdFx0fVxuXG5cdFx0Ly8gdGhpcy5iZ0xheWVyLmZpbGwoJ3JnYig1NSwgNTUsIDU1KScpO1xuXHRcdC8vIHRoaXMuYmdtb2RMYXllci5jbGVhcigpO1xuXHRcdC8vIHRoaXMuYmdtb2RMYXllci5jb250ZXh0LmRyYXdJbWFnZSh0aGlzLnNlZW5CdWZmZXIuY2FudmFzLCAwLCAwKTtcblx0XHQvLyxcblx0XHQvL1x0MCwgMCwgdGhpcy5iZ21vZExheWVyLndpZHRoLCB0aGlzLmJnbW9kTGF5ZXIuaGVpZ2h0LFxuXHRcdC8vXHQtaU1pblgsIC1pTWluWSwgdGhpcy5iZ21vZExheWVyLndpZHRoLCB0aGlzLmJnbW9kTGF5ZXIuaGVpZ2h0KTtcblx0XHQvLyB0aGlzLmJnbW9kTGF5ZXIuYmxlbmRNb2RlID0gJ211bHRpcGx5Jztcblx0XHQvLyB0aGlzLmJnbW9kTGF5ZXIuYWxwaGEgPSAwLjNcblxuXHRcdGxldCBEUkFXX0RFQlVHX0dFT00gPSBmYWxzZTtcblxuXHRcdGlmIChEUkFXX0RFQlVHX0dFT00pIHtcblx0XHRcdHRoaXMuZGVidWdDb250ZXh0LnN0cm9rZVN0eWxlID0gJ3llbGxvdyc7XG5cdFx0XHR0aGlzLmVkZ2VHZW9tLmZvckVhY2goc2VnID0+XG5cdFx0XHRcdHNlZy5kZWJ1Z1JlbmRlcih0aGlzLmRlYnVnQ29udGV4dCkpO1xuXHRcdFx0dGhpcy5kZWJ1Z0NvbnRleHQuc3Ryb2tlU3R5bGUgPSAneWVsbG93Jztcblx0XHR9XG5cblx0XHRmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMubGF5ZXJzLmxlbmd0aDsgKytpKSB7XG5cdFx0XHR0aGlzLmxheWVyc1tpXS5jb250ZXh0LnJlc3RvcmUoKTtcblx0XHRcdGlmICh0aGlzLmxheWVyc1tpXS5idWZmZXIucGl4ZWxzRGlydHkpXG5cdFx0XHRcdHRoaXMubGF5ZXJzW2ldLmJ1ZmZlci51cGRhdGUoZmFsc2UpO1xuXHRcdH1cblxuXHRcdHRoaXMuYmxvb2RCdWZmZXIudXBkYXRlKHRydWUpO1xuXHRcdHRoaXMuYmdtb2RMYXllci5jb250ZXh0LmRyYXdJbWFnZSh0aGlzLmJsb29kQnVmZmVyLmNhbnZhcyxcblx0XHRcdGlNaW5YLCBpTWluWSwgdGhpcy5iZ21vZExheWVyLndpZHRoLCB0aGlzLmJnbW9kTGF5ZXIuaGVpZ2h0LFxuXHRcdFx0MCwgMCwgdGhpcy5iZ21vZExheWVyLndpZHRoLCB0aGlzLmJnbW9kTGF5ZXIuaGVpZ2h0KVxuXG5cdFx0dGhpcy5kZWJ1Z0NvbnRleHQucmVzdG9yZSgpO1xuXHR9XG59XG5cbm1vZHVsZS5leHBvcnRzID0gTEQzNDtcbiIsIid1c2Ugc3RyaWN0JztcbmNvbnN0IEdhbWUgPSByZXF1aXJlKCcuL2dhbWUnKTtcbmNvbnN0IHt1cGRhdGU6IHVwZGF0ZUlucHV0fSA9IHJlcXVpcmUoJy4vaW5wdXQnKTtcbmNvbnN0IENsb2NrID0gcmVxdWlyZSgnLi9jbG9jaycpO1xuY29uc3QgQ29uc3RzID0gcmVxdWlyZSgnLi9jb25zdGFudHMnKTtcbmNvbnN0IElucHV0ID0gcmVxdWlyZSgnLi9pbnB1dCcpO1xuY29uc3Qge2NyZWF0ZUNhbnZhcywgY3JlYXRlQ29udGV4dDJEfSA9IHJlcXVpcmUoJy4vdXRpbCcpO1xuY29uc3QgVmVjMiA9IHJlcXVpcmUoJy4vdmVjMicpO1xuXG5jbGFzcyBHYW1lUnVubmVyIHtcblx0Y29uc3RydWN0b3IoKSB7XG5cdFx0bGV0IHNjcmVlbiA9IHRoaXMuc2NyZWVuID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ3NjcmVlbicpO1xuXHRcdHRoaXMuc2NyZWVuLndpZHRoID0gQ29uc3RzLkNsaWVudFNjcmVlbldpZHRoICogQ29uc3RzLkRldmljZVBpeGVscztcblx0XHR0aGlzLnNjcmVlbi5oZWlnaHQgPSBDb25zdHMuQ2xpZW50U2NyZWVuSGVpZ2h0ICogQ29uc3RzLkRldmljZVBpeGVscztcblx0XHR0aGlzLnNjcmVlbi5zdHlsZS53aWR0aCA9IENvbnN0cy5DbGllbnRTY3JlZW5XaWR0aCtcInB4XCI7XG5cdFx0dGhpcy5zY3JlZW4uc3R5bGUuaGVpZ2h0ID0gQ29uc3RzLkNsaWVudFNjcmVlbkhlaWdodCtcInB4XCI7XG5cdFx0dGhpcy5zY3JlZW5DdHggPSBzY3JlZW4uZ2V0Q29udGV4dCgnMmQnKTtcblxuXHRcdHRoaXMuZGVidWdFbGVtID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ2RlYnVnJyk7XG5cblx0XHR0aGlzLmRlYnVnQ2FudmFzID0gY3JlYXRlQ2FudmFzKENvbnN0cy5DbGllbnRTY3JlZW5XaWR0aCwgQ29uc3RzLkNsaWVudFNjcmVlbkhlaWdodCk7XG5cdFx0dGhpcy5kZWJ1Z0N0eCA9IHRoaXMuZGVidWdDYW52YXMuZ2V0Q29udGV4dCgnMmQnKTtcblxuXHRcdHRoaXMuZHJhd0NhbnZhcyA9IGNyZWF0ZUNhbnZhcyhDb25zdHMuU2NyZWVuV2lkdGgsIENvbnN0cy5TY3JlZW5IZWlnaHQpO1xuXHRcdHRoaXMuZHJhd0NvbnRleHQgPSB0aGlzLmRyYXdDYW52YXMuZ2V0Q29udGV4dCgnMmQnKTtcblxuXHRcdElucHV0LmluaXRpYWxpemUoc2NyZWVuKTtcblx0XHR3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcigna2V5ZG93bicsIChlKSA9PiB7XG5cdFx0XHRpZiAoZS53aGljaCA9PT0gMjcpIHtcblx0XHRcdFx0dGhpcy5wYXVzZWQgPSAhdGhpcy5wYXVzZWQ7XG5cdFx0XHRcdGlmICghdGhpcy5wYXVzZWQpXG5cdFx0XHRcdFx0dGhpcy5zdGFydCgpO1xuXHRcdFx0fVxuXHRcdH0pXG5cdFx0dGhpcy5wYXVzZWQgPSBmYWxzZTtcblx0XHR0aGlzLmdhbWUgPSBudWxsO1xuXHRcdHRoaXMuc3RhcnRUaW1lID0gMDtcblx0XHR0aGlzLmFjY3VtID0gMDtcblx0XHR0aGlzLmxhc3RVcGRhdGUgPSAwO1xuXHRcdHRoaXMuZnJhbWVzID0gMDtcblx0XHR0aGlzLnRpY2tzID0gMDtcblx0XHR0aGlzLmxhc3RTZWNvbmQgPSAwO1xuXHRcdHRoaXMuZnBzRWxlbSA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCdmcHMnKTtcblx0XHR0aGlzLnRwc0VsZW0gPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgndHBzJyk7XG5cdFx0dGhpcy5tc3BmRWxlbSA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCdtc3BmJyk7XG5cdFx0dGhpcy5kb1VwZGF0ZSA9ICh0aW1lc3RhbXApID0+IHRoaXMudXBkYXRlKHRpbWVzdGFtcCk7XG5cdH1cblxuXHRzdGFydCgpIHtcblx0XHRpZiAoIXRoaXMuZ2FtZSkgdGhpcy5nYW1lID0gbmV3IEdhbWUodGhpcy5kcmF3Q2FudmFzLCB0aGlzLmRlYnVnQ2FudmFzKTtcblx0XHR0aGlzLnN0YXJ0VGltZSA9IDA7XG5cdFx0dGhpcy5hY2N1bSA9IDA7XG5cdFx0dGhpcy5sYXN0VXBkYXRlID0gMDtcblx0XHR0aGlzLmZyYW1lcyA9IDA7XG5cdFx0dGhpcy50aWNrcyA9IDA7XG5cdFx0dGhpcy5sYXN0U2Vjb25kID0gMDtcblx0XHRyZXF1ZXN0QW5pbWF0aW9uRnJhbWUodGhpcy5kb1VwZGF0ZSk7XG5cdH1cblxuXHR1cGRhdGUodGltZXN0YW1wKSB7XG5cdFx0aWYgKHRoaXMucGF1c2VkKSB7XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXHRcdGlmICghdGhpcy5sYXN0VXBkYXRlKSB7XG5cdFx0XHR0aGlzLmxhc3RVcGRhdGUgPSB0aW1lc3RhbXA7XG5cdFx0XHR0aGlzLmxhc3RTZWNvbmQgPSB0aW1lc3RhbXA7XG5cdFx0XHRyZXR1cm4gcmVxdWVzdEFuaW1hdGlvbkZyYW1lKHRoaXMuZG9VcGRhdGUpO1xuXHRcdH1cblx0XHRyZXF1ZXN0QW5pbWF0aW9uRnJhbWUodGhpcy5kb1VwZGF0ZSk7XG5cdFx0Q2xvY2sucmVhbFRpbWUgPSB0aW1lc3RhbXAgLyAxMDAwLjA7XG5cdFx0bGV0IHVuc2NhbGVkRGVsdGFUaW1lID0gMS4wIC8gQ2xvY2suZnBzO1xuXG5cdFx0bGV0IGR0ID0gdW5zY2FsZWREZWx0YVRpbWUgKiBDbG9jay50aW1lU2NhbGU7XG5cdFx0Q2xvY2sucmVhbERlbHRhVGltZSA9ICh0aW1lc3RhbXAgLSB0aGlzLmxhc3RVcGRhdGUpIC8gMTAwMC4wO1xuXHRcdENsb2NrLmRlbHRhVGltZSA9IGR0O1xuXHRcdHRoaXMubGFzdFVwZGF0ZSA9IHRpbWVzdGFtcDtcblxuXHRcdHRoaXMuYWNjdW0gKz0gQ2xvY2sucmVhbERlbHRhVGltZTtcblx0XHRpZiAodGhpcy5hY2N1bSA+PSA1KnVuc2NhbGVkRGVsdGFUaW1lKSB7XG5cdFx0XHR0aGlzLmFjY3VtID0gdW5zY2FsZWREZWx0YVRpbWU7XG5cdFx0fVxuXHRcdGxldCBmcmFtZVN0YXJ0ID0gQ2xvY2subm93KCk7XG5cdFx0d2hpbGUgKHRoaXMuYWNjdW0gPj0gZHQpIHtcblx0XHRcdCsrdGhpcy50aWNrcztcblx0XHRcdFZlYzIuUG9vbC5yZXNldCgpO1xuXHRcdFx0dGhpcy5nYW1lLnVwZGF0ZShkdCk7XG5cdFx0XHRDbG9jay5hY2N1bVRpbWUgKz0gZHQ7XG5cdFx0XHRJbnB1dC51cGRhdGUoKTtcblx0XHRcdHRoaXMuYWNjdW0gLT0gZHQ7XG5cdFx0XHQrK0Nsb2NrLnRpY2tzO1xuXHRcdH1cblx0XHQrK3RoaXMuZnJhbWVzO1xuXHRcdHRoaXMuZ2FtZS5yZW5kZXIoKTtcblx0XHR0aGlzLnJlbmRlcigpO1xuXG5cdFx0bGV0IGZyYW1lRW5kID0gQ2xvY2subm93KCk7XG5cdFx0aWYgKHRoaXMubXNwZkVsZW0gIT0gbnVsbCkge1xuXHRcdFx0dGhpcy5tc3BmRWxlbS50ZXh0Q29udGVudCA9ICdtc3BmOiAnKyhmcmFtZUVuZCAtIGZyYW1lU3RhcnQpLnRvRml4ZWQoMik7XG5cdFx0fVxuXG5cdFx0aWYgKHRpbWVzdGFtcCAtIHRoaXMubGFzdFNlY29uZCA+PSAxMDAwLjApIHtcblx0XHRcdHRoaXMubGFzdFNlY29uZCA9IHRpbWVzdGFtcDtcblx0XHRcdGNvbnNvbGUubG9nKFwiZnBzOiBcIit0aGlzLmZyYW1lcytcIiwgdHBzOiBcIit0aGlzLnRpY2tzKycsIG1zcGY6ICcrKGZyYW1lRW5kLWZyYW1lU3RhcnQpLnRvRml4ZWQoMikpO1xuXHRcdFx0aWYgKHRoaXMudHBzRWxlbSAhPSBudWxsKSB7XG5cdFx0XHRcdHRoaXMudHBzRWxlbS50ZXh0Q29udGVudCA9IFwidHBzOiBcIit0aGlzLnRpY2tzO1xuXHRcdFx0fVxuXHRcdFx0aWYgKHRoaXMuZnBzRWxlbSAhPSBudWxsKSB7XG5cdFx0XHRcdHRoaXMuZnBzRWxlbS50ZXh0Q29udGVudCA9IFwiZnBzOiBcIit0aGlzLmZyYW1lcztcblx0XHRcdH1cblx0XHRcdHRoaXMuZnJhbWVzID0gdGhpcy50aWNrcyA9IDA7XG5cdFx0fVxuXHR9XG5cblx0cmVuZGVyKCkge1xuXHRcdGNvbnN0IHtzY3JlZW5DdHgsIHNjcmVlbn0gPSB0aGlzO1xuXHRcdHNjcmVlbkN0eC5pbWFnZVNtb290aGluZ0VuYWJsZWQgPSBmYWxzZTtcblx0XHRzY3JlZW5DdHgubW96SW1hZ2VTbW9vdGhpbmdFbmFibGVkID0gZmFsc2U7XG5cdFx0c2NyZWVuQ3R4LndlYmtpdEltYWdlU21vb3RoaW5nRW5hYmxlZCA9IGZhbHNlO1xuXHRcdHNjcmVlbkN0eC5jbGVhclJlY3QoMCwgMCwgc2NyZWVuQ3R4LmNhbnZhcy53aWR0aCwgc2NyZWVuQ3R4LmNhbnZhcy5oZWlnaHQpO1xuXHRcdHNjcmVlbkN0eC5nbG9iYWxDb21wb3NpdGVPcGVyYXRpb24gPSAnc291cmNlLW92ZXInO1xuXHRcdHNjcmVlbkN0eC5nbG9iYWxBbHBoYSA9IDEuMDtcblx0XHRpZiAodGhpcy5nYW1lLmxheWVycykge1xuXHRcdFx0Ly8gbGV0IGNhbU1pblggPSAwLCBjYW1NaW5ZID0gMDtcblx0XHRcdC8vIGlmICh0aGlzLmdhbWUubmVlZENhbWVyYUFkanVzdCkge1xuXHRcdFx0Ly8gXHRjYW1NaW5YID0gdGhpcy5nYW1lLmNhbWVyYS5taW5YO1xuXHRcdFx0Ly8gXHRjYW1NaW5ZID0gdGhpcy5nYW1lLmNhbWVyYS5taW5ZO1xuXHRcdFx0Ly8gfVxuXHRcdFx0bGV0IGdjbyA9ICdzb3VyY2Utb3Zlcic7XG5cdFx0XHRsZXQgZ2xvYmFsQWxwaGEgPSAxLjA7XG5cdFx0XHRmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMuZ2FtZS5sYXllcnMubGVuZ3RoOyArK2kpIHtcblx0XHRcdFx0bGV0IHtibGVuZE1vZGUsIGFscGhhLCBjYW52YXN9ID0gdGhpcy5nYW1lLmxheWVyc1tpXTtcblx0XHRcdFx0aWYgKGJsZW5kTW9kZSAmJiBibGVuZE1vZGUgIT09IGdjbykge1xuXHRcdFx0XHRcdGdjbyA9IHNjcmVlbkN0eC5nbG9iYWxDb21wb3NpdGVPcGVyYXRpb24gPSBibGVuZE1vZGU7XG5cdFx0XHRcdH1cblx0XHRcdFx0aWYgKGdsb2JhbEFscGhhICYmIGdsb2JhbEFscGhhICE9PSBhbHBoYSkge1xuXHRcdFx0XHRcdGdsb2JhbEFscGhhID0gc2NyZWVuQ3R4Lmdsb2JhbEFscGhhID0gYWxwaGE7XG5cdFx0XHRcdH1cblx0XHRcdFx0c2NyZWVuQ3R4LmRyYXdJbWFnZShjYW52YXMsXG5cdFx0XHRcdFx0MCwgMCwgY2FudmFzLndpZHRoLCBjYW52YXMuaGVpZ2h0LFxuXHRcdFx0XHRcdDAsIDAsIHNjcmVlbi53aWR0aCwgc2NyZWVuLmhlaWdodCk7XG5cdFx0XHR9XG5cdFx0fVxuXHRcdGVsc2Uge1xuXHRcdFx0c2NyZWVuQ3R4LmRyYXdJbWFnZSh0aGlzLmRyYXdDYW52YXMsXG5cdFx0XHRcdDAsIDAsIHRoaXMuZHJhd0NhbnZhcy53aWR0aCwgdGhpcy5kcmF3Q2FudmFzLmhlaWdodCxcblx0XHRcdFx0MCwgMCwgc2NyZWVuLndpZHRoLCBzY3JlZW4uaGVpZ2h0KTtcblx0XHR9XG5cdFx0c2NyZWVuQ3R4LmRyYXdJbWFnZSh0aGlzLmRlYnVnQ2FudmFzLFxuXHRcdFx0MCwgMCwgdGhpcy5kZWJ1Z0NhbnZhcy53aWR0aCwgdGhpcy5kZWJ1Z0NhbnZhcy5oZWlnaHQsXG5cdFx0XHQwLCAwLCBzY3JlZW4ud2lkdGgsIHNjcmVlbi5oZWlnaHQpO1xuXHR9XG59XG5cblxuXG5cblxubW9kdWxlLmV4cG9ydHMgPSBHYW1lUnVubmVyO1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG5jb25zdCBQaXhlbEJ1ZmZlciA9IHJlcXVpcmUoJy4vcGl4ZWxfYnVmZmVyJyk7XG5cbmNsYXNzIExheWVyIHtcblx0Y29uc3RydWN0b3IobmFtZSwgd2lkdGgsIGhlaWdodCkge1xuXHRcdHRoaXMubmFtZSA9IG5hbWU7XG5cdFx0dGhpcy5idWZmZXIgPSBuZXcgUGl4ZWxCdWZmZXIod2lkdGgsIGhlaWdodCk7XG5cdFx0dGhpcy53aWR0aCA9IHRoaXMuYnVmZmVyLndpZHRoO1xuXHRcdHRoaXMuaGVpZ2h0ID0gdGhpcy5idWZmZXIuaGVpZ2h0O1xuXHRcdHRoaXMuY2FudmFzID0gdGhpcy5idWZmZXIuY2FudmFzO1xuXHRcdHRoaXMuY29udGV4dCA9IHRoaXMuYnVmZmVyLmNvbnRleHQ7XG5cdFx0dGhpcy52aWV3cG9ydCA9IHsgeDogMCwgeTogMCwgd2lkdGg6IHRoaXMud2lkdGgsIGhlaWdodDogdGhpcy5oZWlnaHQgfTtcblxuXHRcdHRoaXMuYWxwaGEgPSAxLjA7XG5cdFx0dGhpcy5ibGVuZE1vZGUgPSAnc291cmNlLW92ZXInO1xuXHR9XG5cblx0Y2xlYXIoKSB7XG5cdFx0dGhpcy5jb250ZXh0LmNsZWFyUmVjdCgwLCAwLCB0aGlzLndpZHRoLCB0aGlzLmhlaWdodCk7XG5cdH1cblxuXHRmaWxsKGNvbG9yKSB7XG5cdFx0dGhpcy5jb250ZXh0LmZpbGxTdHlsZSA9IGNvbG9yO1xuXHRcdHRoaXMuY29udGV4dC5maWxsUmVjdCgwLCAwLCB0aGlzLndpZHRoLCB0aGlzLmhlaWdodCk7XG5cdH1cblxufVxubW9kdWxlLmV4cG9ydHMgPSBMYXllcjsiLCIndXNlIHN0cmljdCc7XG5jb25zdCBQYXJ0aWNsZSA9IHJlcXVpcmUoJy4vcGFydGljbGUnKTtcbmNvbnN0IENvbnN0cyA9IHJlcXVpcmUoJy4vY29uc3RhbnRzJyk7XG5jb25zdCBDbG9jayA9IHJlcXVpcmUoJy4vY2xvY2snKTtcbmNvbnN0IHtSTkd9ID0gcmVxdWlyZSgnLi9yYW5kJylcbmNvbnN0IG1hdGggPSByZXF1aXJlKCcuL21hdGgnKTtcbmNvbnN0IEJsb29kID0gcmVxdWlyZSgnLi9ibG9vZCcpO1xuXG5jbGFzcyBHb3JlIGV4dGVuZHMgUGFydGljbGUge1xuXHRjb25zdHJ1Y3RvcihnYW1lLCB4LCB5LCB6PTUpIHtcblx0XHRzdXBlcihnYW1lLCB4LCB5LCB6KTtcblx0XHR0aGlzLnJhZGl1cyA9IDE7XG5cdFx0dGhpcy5saWZlICo9IDI7XG5cdFx0dGhpcy50aW1lZCA9IHRydWU7XG5cdFx0dGhpcy5jb2xsaWRlc1dpdGhFbnRpdGllcyA9IGZhbHNlO1xuXHRcdHRoaXMuZHJhZy5zZXQoMiwgMik7XG5cdFx0dGhpcy5lbGFzdGljID0gdHJ1ZTtcblx0XHR0aGlzLmNvbG9yID0gUk5HLmNvbG9yQmV0d2VlbigweGZmMWEzOTVmLCAweGZmMzA0ODgwKTsvLyAweGZmNzg5OGYwLCAweGZmODhhOGZmKVxuXHR9XG5cblx0dXBkYXRlKGR0KSB7XG5cdFx0c3VwZXIudXBkYXRlKGR0KTtcblx0XHRpZiAodGhpcy52ZWwubGVuZ3RoKCkgPiA1KSB7XG5cdFx0XHRsZXQgYmxvb2QgPSBuZXcgQmxvb2QodGhpcy5nYW1lLCB0aGlzLnBvcy54LCB0aGlzLnBvcy55LCBNYXRoLm1heCgwLjEsIHRoaXMucG9zLnotMSkpO1xuXHRcdFx0Ymxvb2QuelBvcyA9IHRoaXMuelBvcztcblx0XHRcdGJsb29kLnZlbC54ICo9IDAuMDU7IGJsb29kLnZlbC54ICs9IHRoaXMudmVsLnhcblx0XHRcdGJsb29kLnZlbC55ICo9IDAuMDU7IGJsb29kLnZlbC55ICs9IHRoaXMudmVsLnlcblx0XHRcdGJsb29kLnpWZWwgKj0gMC4wNTsgYmxvb2QuelZlbCArPSB0aGlzLnpWZWxcblx0XHRcdHRoaXMuZ2FtZS5hZGRFbnRpdHkoYmxvb2QpO1xuXHRcdH1cblx0fVxuXG5cdGRvQ29sbGlzaW9uKG8pIHtcblx0XHRpZiAoIXRoaXMuZW5hYmxlZCkgcmV0dXJuO1xuXHRcdGlmIChvICYmIG8gaW5zdGFuY2VvZiBHb3JlKSByZXR1cm47XG5cdFx0Zm9yIChsZXQgaSA9IDA7IGkgPCAyMDsgaSsrKSB7XG5cdFx0XHRsZXQgYmxvb2QgPSBuZXcgQmxvb2QodGhpcy5nYW1lLCB0aGlzLnBvcy54LCB0aGlzLnBvcy55KTtcblx0XHRcdGJsb29kLnpQb3MgPSB0aGlzLnpQb3M7XG5cdFx0XHRibG9vZC52ZWwueCAqPSAwLjA1OyBibG9vZC52ZWwueCArPSB0aGlzLnZlbC54KjAuNTtcblx0XHRcdGJsb29kLnZlbC55ICo9IDAuMDU7IGJsb29kLnZlbC55ICs9IHRoaXMudmVsLnkqMC41O1xuXHRcdFx0Ymxvb2QuelZlbCAqPSAwLjA1OyBibG9vZC56VmVsICs9IHRoaXMuelZlbCowLjVcblx0XHRcdHRoaXMuZ2FtZS5hZGRFbnRpdHkoYmxvb2QpO1xuXHRcdH1cblx0fVxuXG5cdG9uR3JvdW5kQ29sbGlzaW9uKCkge1xuXHRcdGlmIChNYXRoLmFicyh0aGlzLnpWZWwpID4gNSkgdGhpcy5kb0NvbGxpc2lvbigpO1xuXHR9XG5cblx0b25Db2xsaXNpb24obykge1xuXHRcdHRoaXMuZG9Db2xsaXNpb24obyk7XG5cdH1cblxuXG5cbn1cbm1vZHVsZS5leHBvcnRzID0gR29yZTtcblxuXG4iLCIndXNlIHN0cmljdCc7XG5jb25zdCB7QVNTRVJUfSA9IHJlcXVpcmUoJy4vZGVidWcnKTtcbmNvbnN0IENvbnN0cyA9IHJlcXVpcmUoJy4vY29uc3RhbnRzJyk7XG4vLyBtb3N0bHkgYm9ycm93ZWQgZnJvbSBteSBsaWJyYXJ5LCBkZW1vbi5qcywgd2l0aCBzb21lIG1vZGlmaWNhdGlvbnNcbmNvbnN0IE1vdXNlID0ge1xuXHR4OiAwLFxuXHR5OiAwLFxuXHRkeDogMCxcblx0ZHk6IDAsXG5cdGxhc3RYOiAwLFxuXHRsYXN0WTogMCxcblx0aXNEb3duOiBmYWxzZSxcblx0dHJhbnNpdGlvbnM6IDAsXG5cdHdhc1ByZXNzZWQoKSB7IHJldHVybiB0aGlzLmlzRG93biAmJiB0aGlzLnRyYW5zaXRpb25zID4gMDsgfSxcblx0d2FzUmVsZWFzZWQoKSB7IHJldHVybiAhdGhpcy5pc0Rvd24gJiYgdGhpcy50cmFuc2l0aW9ucyA+IDA7IH0sXG59O1xuXG5sZXQgTW91c2VTY3JlZW4gPSBudWxsO1xuZnVuY3Rpb24gdXBkYXRlTW91c2VQb3MoY3gsIGN5KSB7XG5cdGxldCByZWN0ID0gTW91c2VTY3JlZW4uZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG5cdGN4IC09IHJlY3QubGVmdDtcblx0Y3kgLT0gcmVjdC50b3A7XG5cdE1vdXNlLnggPSBjeCAvIENvbnN0cy5TY2FsZTtcblx0TW91c2UueSA9IGN5IC8gQ29uc3RzLlNjYWxlO1xuXHRNb3VzZS5keCA9IE1vdXNlLngtTW91c2UubGFzdFg7XG5cdE1vdXNlLmR5ID0gTW91c2UueS1Nb3VzZS5sYXN0WTtcbn1cblxuZnVuY3Rpb24gaW5pdE1vdXNlKHNjcmVlbikge1xuXHRNb3VzZVNjcmVlbiA9IHNjcmVlbjtcblx0d2luZG93LmFkZEV2ZW50TGlzdGVuZXIoJ2JsdXInLCBmdW5jdGlvbigpIHtcblx0XHRNb3VzZS5pc0Rvd24gPSBmYWxzZTtcblx0XHRNb3VzZS5sYXN0WCA9IE1vdXNlLmR4ID0gTW91c2UueCA9IE1vdXNlLmxhc3RZID0gTW91c2UuZHkgPSBNb3VzZS55ID0gMDtcblx0XHRNb3VzZS50cmFuc2l0aW9ucyA9IDA7XG5cdH0pO1xuXG5cdHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKCdtb3VzZWRvd24nLCBmdW5jdGlvbihlKSB7XG5cdFx0aWYgKGUuYnV0dG9uID09PSAwKSB7IE1vdXNlLmlzRG93biA9IHRydWU7ICsrTW91c2UudHJhbnNpdGlvbnM7IH1cblx0XHR1cGRhdGVNb3VzZVBvcyhlLmNsaWVudFgsIGUuY2xpZW50WSk7XG5cdFx0ZS5wcmV2ZW50RGVmYXVsdCgpO1xuXHR9KTtcblxuXHR3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcignbW91c2V1cCcsIGZ1bmN0aW9uKGUpIHtcblx0XHRpZiAoZS5idXR0b24gPT09IDApIHsgTW91c2UuaXNEb3duID0gZmFsc2U7ICsrTW91c2UudHJhbnNpdGlvbnM7IH1cblx0XHR1cGRhdGVNb3VzZVBvcyhlLmNsaWVudFgsIGUuY2xpZW50WSk7XG5cdFx0ZS5wcmV2ZW50RGVmYXVsdCgpO1xuXHR9KTtcblxuXHR3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcignbW91c2Vtb3ZlJywgZnVuY3Rpb24oZSkge1xuXHRcdHVwZGF0ZU1vdXNlUG9zKGUuY2xpZW50WCwgZS5jbGllbnRZKTtcblx0XHRlLnByZXZlbnREZWZhdWx0KCk7XG5cdH0pO1xufVxuXG5mdW5jdGlvbiB1cGRhdGVNb3VzZSgpIHtcblx0TW91c2UudHJhbnNpdGlvbnMgPSAwO1xuXHRNb3VzZS5sYXN0WCA9IE1vdXNlLng7XG5cdE1vdXNlLmxhc3RZID0gTW91c2UueTtcbn1cblxuY29uc3QgS0VZTUFYID0gMjU2O1xuXG5jb25zdCBLZXlib2FyZCA9IHtcblx0S2V5Q29kZXM6IG51bGwsXG5cdEtleUNvZGVJbnZlcnNlOiBudWxsLFxuXHRLQzoge30sXG5cdEtDSToge30sXG5cdGtleVRyYW5zaXRpb25zOiBuZXcgVWludDhBcnJheShLRVlNQVgpLFxuXHRrZXlzRG93bjogbmV3IFVpbnQ4QXJyYXkoS0VZTUFYKSxcblx0ZGVmYXVsdFByZXZlbnRlZDogbmV3IEFycmF5KEtFWU1BWCksXG5cblx0aXNEb3duQyhrYykgeyByZXR1cm4gISF0aGlzLmtleXNEb3duW2tjID4+PiAwXTsgfSxcblx0dHJhbnNpdGlvbnNDKGtjKSB7IHJldHVybiB0aGlzLmtleVRyYW5zaXRpb25zW2tjID4+PiAwXTsgfSxcblx0d2FzUHJlc3NlZEMoa2MpIHsgY29uc3QgY29kZSA9IGtjID4+PiAwOyByZXR1cm4gISEodGhpcy5rZXlzRG93bltjb2RlXSAmJiB0aGlzLmtleVRyYW5zaXRpb25zW2NvZGVdKTsgfSxcblx0d2FzUmVsZWFzZWRDKGtjKSB7IGNvbnN0IGNvZGUgPSBrYyA+Pj4gMDsgcmV0dXJuICEhKCF0aGlzLmtleXNEb3duW2NvZGVdICYmIHRoaXMua2V5VHJhbnNpdGlvbnNbY29kZV0pOyB9LFxuXG5cdGlzRG93bihrZXkpIHsgcmV0dXJuIHRoaXMuaXNEb3duQyhrZXlUb0NvZGUoa2V5KSk7IH0sXG5cdHRyYW5zaXRpb25zKGtleSkgeyByZXR1cm4gdGhpcy50cmFuc2l0aW9uc0Moa2V5VG9Db2RlKGtleSkpOyB9LFxuXHR3YXNQcmVzc2VkKGtleSkgeyByZXR1cm4gdGhpcy53YXNQcmVzc2VkQyhrZXlUb0NvZGUoa2V5KSk7IH0sXG5cdHdhc1JlbGVhc2VkKGtleSkgeyByZXR1cm4gdGhpcy53YXNSZWxlYXNlZEMoa2V5VG9Db2RlKGtleSkpOyB9LFxufTtcblxuS2V5Ym9hcmQuS2V5Q29kZXMgPSBLZXlib2FyZC5LQztcbktleWJvYXJkLktleUNvZGVJbnZlcnNlID0gS2V5Ym9hcmQuS0NJO1xuY29uc3QgS25vd25LZXlzID0gbmV3IFVpbnQ4QXJyYXkoS0VZTUFYKTtcblxuZnVuY3Rpb24ga2V5VG9Db2RlKGtleSkge1xuXHRsZXQgY29kZSA9IDA7XG5cdGlmICh0eXBlb2Yga2V5ID09PSAnbnVtYmVyJykge1xuXHRcdGNvZGUgPSBrZXkgPj4+IDA7XG5cdFx0aWYgKEtub3duS2V5c1tjb2RlXSA9PT0gMCkgeyBjb25zb2xlLmVycm9yKFwiS2V5Y29kZSBcIitrZXkrXCIgaXMgbm90IG1hcHBlZCB0byBhbnkga25vd24ga2V5XCIpOyByZXR1cm4gMDsgfVxuXHR9IGVsc2Uge1xuXHRcdGNvbnN0IG1heWJlQ29kZSA9IEtleWJvYXJkLktDW2tleV07XG5cdFx0aWYgKG1heWJlQ29kZSA9PT0gMCkgeyBjb25zb2xlLmVycm9yKFwiVW5rbm93biBrZXk6IFwiK2tleSk7IHJldHVybiAwOyB9XG5cdFx0Y29kZSA9IG1heWJlQ29kZSA+Pj4gMDtcblx0fVxuXHRpZiAoY29kZSA+PSBLRVlNQVggfHwgY29kZSA9PT0gMCkgeyBjb25zb2xlLmVycm9yKFwiS2V5Y29kZSBcIitrZXkrXCIgaXMgb3V0c2lkZSB2YWxpZCByYW5nZTogXCIrY29kZSk7IHJldHVybiAwOyB9XG5cdHJldHVybiBjb2RlO1xufVxuXG4oZnVuY3Rpb24oKSB7XG5cdGNvbnN0IGtleXNUb0NvZGVzID0ge1xuXHRcdEE6IDY1LCBCOiA2NiwgQzogNjcsIEQ6IDY4LCBFOiA2OSwgRjogNzAsIEc6IDcxLCBIOiA3MiwgSTogNzMsIEo6IDc0LCBLOiA3NSwgTDogNzYsIE06IDc3LCBOOiA3OCwgTzogNzksIFA6IDgwLCBROiA4MSwgUjogODIsIFM6IDgzLCBUOiA4NCwgVTogODUsIFY6IDg2LCBXOiA4NywgWDogODgsIFk6IDg5LCBaOiA5MCxcblx0XHRMZWZ0OiAzNywgVXA6IDM4LCBSaWdodDogMzksIERvd246IDQwLFxuXHRcdEVzY2FwZTogMjcsIFJldHVybjogMTMsXG5cdFx0QmFja3NwYWNlOiA4LCBTcGFjZTogMzIsIFRhYjogOSxcblx0XHROdW0wOiA0OCwgTnVtMTogNDksIE51bTI6IDUwLCBOdW0zOiA1MSwgTnVtNDogNTIsIE51bTU6IDUzLCBOdW02OiA1NCwgTnVtNzogNTUsIE51bTg6IDU2LCBOdW05OiA1Nyxcblx0XHROdW1wYWQwOiA5NiwgTnVtcGFkMTogOTcsIE51bXBhZDI6IDk4LCBOdW1wYWQzOiA5OSwgTnVtcGFkNDogMTAwLCBOdW1wYWQ1OiAxMDEsIE51bXBhZDY6IDEwMiwgTnVtcGFkNzogMTAzLCBOdW1wYWQ4OiAxMDQsIE51bXBhZDk6IDEwNSxcblx0XHROdW1wYWRNaW51czogMTA5LCBOdW1wYWRQbHVzOiAxMDcsIE51bXBhZEVxdWFsOiAxMiwgTnVtcGFkU2xhc2g6IDExMSxcblx0XHRGMTogMTEyLCBGMjogMTEzLCBGMzogMTE0LCBGNDogMTE1LCBGNTogMTE2LCBGNjogMTE3LCBGNzogMTE4LCBGODogMTE5LCBGOTogMTIwLCBGMTA6IDEyMSwgRjExOiAxMjIsIEYxMjogMTIzLFxuXHRcdFRpbGRlOiAxOTIsIFNoaWZ0OiAxNiwgQ3RybDogMTcsIEFsdDogMTgsXG5cdFx0Q29sb246IDE4NiwgRXF1YWxzOiAxODcsIENvbW1hOiAxODgsIE1pbnVzOiAxODksIFBlcmlvZDogMTkwLCBTbGFzaDogMTkxLCBPcGVuQnJhY2tldDogMjE5LCBDbG9zZUJyYWNrZXQ6IDIyMSwgQmFja3NsYXNoOiAyMjAsIFF1b3RlOiAyMjJcblx0fTtcblxuXHRjb25zdCBrY0FsaWFzZXMgPSB7XG5cdFx0VGlsZGU6IFsnQmFja3RpY2snXSwgUmV0dXJuOiBbJ0VudGVyJ10sIEVzY2FwZTogWydFc2MnXSwgQ3RybDogWydDb250cm9sJ10sIEFsdDogWydNZXRhJ10sXG5cdFx0TnVtMDogWydaZXJvJ10sIE51bTE6IFsnT25lJ10sIE51bTI6IFsnVHdvJ10sIE51bTM6IFsnVGhyZWUnXSwgTnVtNDogWydGb3VyJ10sIE51bTU6IFsnRml2ZSddLCBOdW02OiBbJ1NpeCddLCBOdW03OiBbJ1NldmVuJ10sIE51bTg6IFsnRWlnaHQnXSwgTnVtOTogWydOaW5lJ10sXG5cdH07XG5cblx0T2JqZWN0LmtleXMoa2V5c1RvQ29kZXMpLmZvckVhY2goZnVuY3Rpb24oa2V5KSB7XG5cdFx0dmFyIGNvZGUgPSBrZXlzVG9Db2Rlc1trZXldO1xuXHRcdEFTU0VSVChjb2RlIDwgS0VZTUFYLCBcIltCVUddIGtleWNvZGUgZm9yIFwiK2tleStcIiBpcyBncmVhdGVyIHRoYW4gS0VZTUFYXCIpO1xuXHRcdEtleWJvYXJkLktDSVtjb2RlXSA9IGtleTtcblx0XHRLbm93bktleXNbY29kZV0gPSAxO1xuXHRcdHZhciBrZXlzID0gW2tleV0uY29uY2F0KGtjQWxpYXNlc1trZXldIHx8IFtdKTtcblx0XHRrZXlzLmZvckVhY2goZnVuY3Rpb24oa2V5TmFtZSkge1xuXHRcdFx0S2V5Ym9hcmQuS0Nba2V5TmFtZV0gPSBjb2RlO1xuXHRcdFx0S2V5Ym9hcmQuS0Nba2V5TmFtZS50b0xvd2VyQ2FzZSgpXSA9IGNvZGU7XG5cdFx0XHR2YXIgY2FtZWxDYXNlID0ga2V5TmFtZVswXS50b0xvd2VyQ2FzZSgpK2tleU5hbWUuc2xpY2UoMSk7XG5cdFx0XHRLZXlib2FyZC5LQ1tjYW1lbENhc2VdID0gY29kZTtcblx0XHRcdHZhciBjYXBDYXNlID0ga2V5TmFtZS5yZXBsYWNlKC8oW2Etel0pKFtBLVpdKS9nLCAnJDFfJDInKS50b1VwcGVyQ2FzZSgpXG5cdFx0XHRLZXlib2FyZC5LQ1tjYXBDYXNlXSA9IGNvZGU7XG5cdFx0fSk7XG5cdH0pO1xuXG5cdGZvciAobGV0IGkgPSAwOyBpIDwgS0VZTUFYOyArK2kpIHtcblx0XHRLZXlib2FyZC5kZWZhdWx0UHJldmVudGVkW2ldID0gdHJ1ZTtcblx0fVxuXG5cdGZvciAodmFyIGkgPSAxOyBpIDw9IDEyOyArK2kpIHtcblx0XHRLZXlib2FyZC5kZWZhdWx0UHJldmVudGVkW0tleWJvYXJkLktDW1wiRlwiK2ldXSA9IGZhbHNlO1xuXHR9XG59KCkpO1xuXG5jb25zdCBrZXlUcmFuc2l0aW9uczMyID0gbmV3IFVpbnQzMkFycmF5KEtleWJvYXJkLmtleVRyYW5zaXRpb25zLmJ1ZmZlcilcbmNvbnN0IGtleXNEb3duMzIgPSBuZXcgVWludDMyQXJyYXkoS2V5Ym9hcmQua2V5c0Rvd24uYnVmZmVyKVxuXG5cbmZ1bmN0aW9uIGluaXRLZXlib2FyZCgpIHtcblx0d2luZG93LmFkZEV2ZW50TGlzdGVuZXIoJ2tleWRvd24nLCBmdW5jdGlvbihlKSB7XG5cdFx0dmFyIGtjID0gZS5rZXlDb2RlID4+PiAwO1xuXHRcdGlmIChrYyA+IEtFWU1BWCB8fCBrYyA9PT0gMCkgeyBjb25zb2xlLndhcm4oXCJVbmtub3duIGtleWNvZGUgdmFsdWUgZnJvbSBET00gZXZlbnQuXCIsIGUpOyByZXR1cm47IH1cblx0XHRpZiAoIUtleWJvYXJkLmtleXNEb3duW2tjXSkgeyBLZXlib2FyZC5rZXlzRG93bltrY10gPSAxOyArK0tleWJvYXJkLmtleVRyYW5zaXRpb25zW2tjXTsgfVxuXHRcdGlmIChLZXlib2FyZC5kZWZhdWx0UHJldmVudGVkW2tjXSkgeyBlLnByZXZlbnREZWZhdWx0KCk7IH1cblx0fSk7XG5cblx0d2luZG93LmFkZEV2ZW50TGlzdGVuZXIoJ2tleXVwJywgZnVuY3Rpb24oZSkge1xuXHRcdHZhciBrYyA9IGUua2V5Q29kZSA+Pj4gMDtcblx0XHRpZiAoa2MgPiBLRVlNQVggfHwga2MgPT09IDApIHsgY29uc29sZS53YXJuKFwiVW5rbm93biBrZXljb2RlIHZhbHVlIGZyb20gRE9NIGV2ZW50LlwiLCBlKTsgcmV0dXJuOyB9XG5cdFx0aWYgKEtleWJvYXJkLmtleXNEb3duW2tjXSkgeyBLZXlib2FyZC5rZXlzRG93bltrY10gPSBmYWxzZTsgKytLZXlib2FyZC5rZXlUcmFuc2l0aW9uc1trY107IH1cblx0XHRpZiAoS2V5Ym9hcmQuZGVmYXVsdFByZXZlbnRlZFtrY10pIHsgZS5wcmV2ZW50RGVmYXVsdCgpOyB9XG5cdH0pO1xuXG5cdHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKCdibHVyJywgZnVuY3Rpb24oKSB7XG5cdFx0Zm9yIChsZXQgaSA9IDA7IGkgPCBrZXlUcmFuc2l0aW9uczMyLmxlbmd0aDsgKytpKSBrZXlUcmFuc2l0aW9uczMyW2ldID0gMDtcblx0XHRmb3IgKGxldCBpID0gMDsgaSA8IGtleXNEb3duMzIubGVuZ3RoOyArK2kpIGtleXNEb3duMzJbaV0gPSAwO1xuXHR9KTtcbn1cblxuZnVuY3Rpb24gdXBkYXRlS2V5Ym9hcmQoKSB7XG5cdGZvciAobGV0IGkgPSAwOyBpIDwga2V5VHJhbnNpdGlvbnMzMi5sZW5ndGg7ICsraSkga2V5VHJhbnNpdGlvbnMzMltpXSA9IDA7XG59XG5cbmV4cG9ydHMubW91c2UgPSBleHBvcnRzLk1vdXNlID0gTW91c2U7XG5leHBvcnRzLmtleWJvYXJkID0gZXhwb3J0cy5rZXlzID0gZXhwb3J0cy5LZXlib2FyZCA9IEtleWJvYXJkO1xuZXhwb3J0cy5LZXlDb2RlID0gS2V5Ym9hcmQuS2V5Q29kZXM7XG5cbmV4cG9ydHMuaW5pdGlhbGl6ZSA9IGZ1bmN0aW9uKHNjcmVlbikge1xuXHRpbml0TW91c2Uoc2NyZWVuKTtcblx0aW5pdEtleWJvYXJkKHNjcmVlbik7XG59O1xuXG5leHBvcnRzLnVwZGF0ZSA9IGZ1bmN0aW9uKCkge1xuXHR1cGRhdGVNb3VzZSgpO1xuXHR1cGRhdGVLZXlib2FyZCgpO1xufTtcblxuXG5cbiIsIid1c2Ugc3RyaWN0JztcbmNvbnN0IFBhcnRpY2xlID0gcmVxdWlyZSgnLi9wYXJ0aWNsZScpO1xuY29uc3QgQ29uc3RzID0gcmVxdWlyZSgnLi9jb25zdGFudHMnKTtcbmNvbnN0IENsb2NrID0gcmVxdWlyZSgnLi9jbG9jaycpO1xuY29uc3Qge1JOR30gPSByZXF1aXJlKCcuL3JhbmQnKVxuY29uc3QgbWF0aCA9IHJlcXVpcmUoJy4vbWF0aCcpO1xuY29uc3QgU291bmRzID0gcmVxdWlyZSgnLi9hdWRpbycpO1xuY29uc3QgRW50aXR5ID0gcmVxdWlyZSgnLi9lbnRpdHknKTtcbmNvbnN0IFZlYzIgPSByZXF1aXJlKCcuL3ZlYzInKTtcbmNsYXNzIEtleSBleHRlbmRzIEVudGl0eSB7XG5cdGNvbnN0cnVjdG9yKGdhbWUsIHgsIHksIGtleUluZm8pIHtcblx0XHRzdXBlcihnYW1lLCB4LCB5KTtcblx0XHR0aGlzLmtleUluZm8gPSBrZXlJbmZvO1xuXHRcdHRoaXMucmFkaXVzID0gODtcblx0XHR0aGlzLm1vYmlsZSA9IGZhbHNlO1xuXHRcdHRoaXMubm9pc2VUaW1lciA9IDA7XG5cdH1cblxuXHRvbkNvbGxpc2lvbih3aG8pIHtcblx0XHRpZiAod2hvID09PSB0aGlzLmdhbWUucGxheWVyKSB7XG5cdFx0XHR0aGlzLnVubG9jaygpXG5cdFx0fVxuXHR9XG5cdHVubG9jaygpIHtcblx0XHRTb3VuZHMucGxheSgndW5sb2NrJyk7XG5cdFx0dGhpcy5nYW1lLnVubG9jayh0aGlzLmtleUluZm8pO1xuXHRcdHRoaXMuZW5hYmxlZCA9IGZhbHNlO1xuXHR9XG5cblx0dXBkYXRlKGR0KSB7XG5cdFx0c3VwZXIudXBkYXRlKGR0KTtcblx0XHR0aGlzLm5vaXNlVGltZXIgKz0gZHQ7XG5cdFx0bGV0IHBkaXN0ID0gdGhpcy5nYW1lLnBsYXllci5wb3MuZGlzdGFuY2UodGhpcy5wb3MpO1xuXHRcdGlmIChwZGlzdCA8IHRoaXMucmFkaXVzICsgdGhpcy5nYW1lLnBsYXllci5yYWRpdXMpIHtcblx0XHRcdHRoaXMudW5sb2NrKCk7XG5cdFx0fSBlbHNlIGlmICh0aGlzLm5vaXNlVGltZXIgPiAzMDAwKSB7XG5cdFx0XHRpZiAodGhpcy5nYW1lLnBsYXllci5wb3MuZGlzdGFuY2UodGhpcy5wb3MpIDwgMTAqQ29uc3RzLlRpbGVTaXplKSB7XG5cdFx0XHRcdFNvdW5kcy5wbGF5V29iYmxlKHRoaXMua2V5SW5mby5pZCk7XG5cdFx0XHR9XG5cdFx0fVxuXHR9XG5cblxuXHRyZW5kZXIobGF5ZXIpIHtcblx0XHRpZiAoIXRoaXMuZ2FtZS5jYW5TZWUodGhpcy5nYW1lLnBsYXllci5wb3MsIFZlYzIudGVtcCh0aGlzLnBvcy54K3RoaXMucmFkaXVzLCB0aGlzLnBvcy55K3RoaXMucmFkaXVzKSkmJlxuXHRcdCAgICAhdGhpcy5nYW1lLmNhblNlZSh0aGlzLmdhbWUucGxheWVyLnBvcywgVmVjMi50ZW1wKHRoaXMucG9zLngrdGhpcy5yYWRpdXMsIHRoaXMucG9zLnktdGhpcy5yYWRpdXMpKSYmXG5cdFx0ICAgICF0aGlzLmdhbWUuY2FuU2VlKHRoaXMuZ2FtZS5wbGF5ZXIucG9zLCBWZWMyLnRlbXAodGhpcy5wb3MueC10aGlzLnJhZGl1cywgdGhpcy5wb3MueSt0aGlzLnJhZGl1cykpJiZcblx0XHQgICAgIXRoaXMuZ2FtZS5jYW5TZWUodGhpcy5nYW1lLnBsYXllci5wb3MsIFZlYzIudGVtcCh0aGlzLnBvcy54LXRoaXMucmFkaXVzLCB0aGlzLnBvcy55LXRoaXMucmFkaXVzKSkpIHtcblx0XHRcdHJldHVybjtcblx0XHR9XG5cdFx0bGF5ZXIuY29udGV4dC5kcmF3SW1hZ2UodGhpcy5nYW1lLmFzc2V0cy5taXNjLFxuXHRcdFx0MTYsIDE2KnRoaXMua2V5SW5mby5pZCwgMTYsIDE2LFxuXHRcdFx0dGhpcy5wb3MueC04LFxuXHRcdFx0dGhpcy5wb3MueS04LFxuXHRcdFx0MTYsIDE2XG5cdFx0KTtcblx0fVxufVxubW9kdWxlLmV4cG9ydHMgPSBLZXk7XG4iLCIndXNlIHN0cmljdCc7XG5jb25zdCBMaW5lU2VnbWVudCA9IHJlcXVpcmUoJy4vbGluZV9zZWdtZW50Jyk7XG5jb25zdCBWZWMyID0gcmVxdWlyZSgnLi92ZWMyJyk7XG5jb25zdCBDb25zdHMgPSByZXF1aXJlKCcuL2NvbnN0YW50cycpO1xuXG5jbGFzcyBUaWxlSW5mbyB7XG5cdGNvbnN0cnVjdG9yKGVkZ2VzLCB0eD0wLCB0eT0wKSB7XG5cdFx0dGhpcy5pZCA9IC0xO1xuXHRcdHRoaXMuZWRnZXMgPSBlZGdlcy5tYXAoKHtzdGFydDp7eDpzeCwgeTpzeX0sIGVuZDp7eDpleCwgeTpleX19KSA9PlxuXHRcdFx0bmV3IExpbmVTZWdtZW50KG5ldyBWZWMyKHN4K3R4LCBzeSt0eSksIG5ldyBWZWMyKGV4K3R4LCBleSt0eSkpKTtcblx0fVxuXG5cdG9mZnNldEJ5KHgsIHkpIHtcblx0XHRyZXR1cm4gbmV3IFRpbGVJbmZvKHRoaXMuZWRnZXMsIHgsIHkpO1xuXHR9XG59XG5cbi8vIGZ1bmN0aW9uIHRyaWFuZ2xlKHAwLCBwMSwgcDIpIHtcbi8vIFx0cmV0dXJuIG5ldyBUaWxlSW5mbyhbe3N0YXJ0OiBwMCwgZW5kOiBwMX0sIHtzdGFydDogcDEsIGVuZDogcDJ9LCB7c3RhcnQ6IHAyLCBlbmQ6IHAwfV0pXG4vLyB9XG5cbmZ1bmN0aW9uIHBvbHlnb24oLi4ucHRzKSB7XG5cdHJldHVybiBuZXcgVGlsZUluZm8ocHRzLm1hcCgocHQsIGkpID0+ICh7c3RhcnQ6IHB0LnNjYWxlZChDb25zdHMuVGlsZVNpemUpLCBlbmQ6IHB0c1soaSsxKSVwdHMubGVuZ3RoXS5zY2FsZWQoQ29uc3RzLlRpbGVTaXplKX0pKSk7XG59XG5cbmZ1bmN0aW9uIHYoeCwgeSkgeyByZXR1cm4gbmV3IFZlYzIoeCwgeSk7IH1cblxuY29uc3QgVElMRV9NSUQgPSBuZXcgVmVjMigwLjUsIDAuNSk7XG5cbi8vIGZ1bmN0aW9uIHRyaVRpbGUocDAsIHAxLCBwMikge1xuLy8gXHRyZXR1cm4gW1xuLy8gXHRcdHRyaWFuZ2xlKHAwLCBwMSwgcDIpLFxuLy8gXHRcdHRyaWFuZ2xlKHAwLnJvdGF0ZWQ5MChUSUxFX01JRCksIHAxLnJvdGF0ZWQ5MChUSUxFX01JRCksIHAyLnJvdGF0ZWQ5MChUSUxFX01JRCkpLFxuLy8gXHRcdHRyaWFuZ2xlKHAwLnJvdGF0ZWQxODAoVElMRV9NSUQpLCBwMS5yb3RhdGVkMTgwKFRJTEVfTUlEKSwgcDIucm90YXRlZDE4MChUSUxFX01JRCkpLFxuLy8gXHRcdHRyaWFuZ2xlKHAwLnJvdGF0ZWQyNzAoVElMRV9NSUQpLCBwMS5yb3RhdGVkMjcwKFRJTEVfTUlEKSwgcDIucm90YXRlZDI3MChUSUxFX01JRCkpXG4vLyBcdF07XG4vLyB9XG5cbmZ1bmN0aW9uIHBvbHlUaWxlKC4uLnB0cykge1xuXHRyZXR1cm4gW1xuXHRcdHBvbHlnb24oLi4ucHRzKSxcblx0XHRwb2x5Z29uKC4uLnB0cy5tYXAocHQgPT4gcHQucm90YXRlZDkwKFRJTEVfTUlEKSkpLFxuXHRcdHBvbHlnb24oLi4ucHRzLm1hcChwdCA9PiBwdC5yb3RhdGVkMTgwKFRJTEVfTUlEKSkpLFxuXHRcdHBvbHlnb24oLi4ucHRzLm1hcChwdCA9PiBwdC5yb3RhdGVkMjcwKFRJTEVfTUlEKSkpLFxuXHRdO1xufVxuXG5cbmZ1bmN0aW9uIHBvbHlUaWxlMlMoLi4ucHRzKSB7XG5cdHJldHVybiBbXG5cdFx0cG9seWdvbiguLi5wdHMpLFxuXHRcdHBvbHlnb24oLi4ucHRzLm1hcChwdCA9PiBwdC5yb3RhdGVkOTAoVElMRV9NSUQpKSksXG5cdFx0cG9seWdvbiguLi5wdHMubWFwKHB0ID0+IHB0LnhGbGlwcGVkKDAuNSkpLnJldmVyc2UoKSksXG5cdFx0cG9seWdvbiguLi5wdHMubWFwKHB0ID0+IHB0LnhGbGlwcGVkKDAuNSkucm90YXRlZDkwKFRJTEVfTUlEKSkucmV2ZXJzZSgpKSxcblx0XTtcbn1cbmZ1bmN0aW9uIHBvbHlUaWxlMiguLi5wdHMpIHtcblx0cmV0dXJuIFtcblx0XHRwb2x5Z29uKC4uLnB0cyksXG5cdFx0cG9seWdvbiguLi5wdHMubWFwKHB0ID0+IHB0LnJvdGF0ZWQ5MChUSUxFX01JRCkpKVxuXHRdO1xufVxuXG5mdW5jdGlvbiBwb2x5VGlsZTJGKC4uLnB0cykge1xuXHRyZXR1cm4gcG9seVRpbGUoLi4ucHRzKS5jb25jYXQocG9seVRpbGUoLi4ucHRzLm1hcChwdCA9PiBwdC54RmxpcHBlZCgpKSkpO1xufVxuXG5cbmNvbnN0IEggPSAwLjU7XG5jb25zdCBRID0gMC4yNTtcbmNvbnN0IFMgPSAwLjc1O1xuY29uc3QgVCA9IDEuMCAvIDMuMDtcbmNvbnN0IFggPSAyLjAgLyAzLjA7XG5cbmNvbnN0IFRpbGVzID0gW10uY29uY2F0KFxuXHRbbmV3IFRpbGVJbmZvKFtdKV0sIC8vIGVtcHR5XG5cdFtwb2x5Z29uKHYoMCwgMCksIHYoMCwgMSksIHYoMSwgMSksIHYoMSwgMCkpXSwgLy8gcXVhZCwgMTAwJSBzeW1tZXRyeVxuXHRwb2x5VGlsZSh2KDAsIDApLCB2KDAsIEgpLCB2KDEsIEgpLCB2KDEsIDApKSxcblx0cG9seVRpbGUodigwLCAwKSwgdigwLCAxKSwgdigxLCAwKSksXG5cdHBvbHlUaWxlKHYoMCwgMCksIHYoMCwgSCksIHYoMSwgMCkpLFxuXHRwb2x5VGlsZSh2KDAsIDApLCB2KDEsIEgpLCB2KDEsIDApKSxcblx0cG9seVRpbGUodigwLCAwKSwgdigwLCAxKSwgdigxLCBIKSwgdigxLCAwKSksXG5cdHBvbHlUaWxlKHYoMCwgMCksIHYoMCwgSCksIHYoMSwgMSksIHYoMSwgMCkpXG5cdCxcblxuXHRwb2x5VGlsZSh2KDAsIEgpLCB2KDEsIEgpLCB2KDEsIDApKSxcblx0cG9seVRpbGUodigwLCAwKSwgdigwLCBIKSwgdigxLCBIKSksXG5cdHBvbHlUaWxlKHYoMCwgMCksIHYoMCwgSCksIHYoSCwgMCkpLFxuXHRwb2x5VGlsZSh2KDAsIDApLCB2KDAsIEgpLCB2KEgsIEgpLCB2KEgsIDApKSxcblxuXHRwb2x5VGlsZTJTKHYoMCwgMCksIHYoSCwgMSksIHYoMSwgMSksIHYoSCwgMCkpLFxuXG5cdHBvbHlUaWxlMih2KDAsIDApLCB2KDAsIEgpLCB2KEgsIDEpLCB2KDEsIDEpLCB2KDEsIEgpLCB2KEgsIDApKSxcblx0cG9seVRpbGUodigwLCAwKSwgdigwLCAxKSwgdihILCAxKSwgdihILCBIKSwgdigxLCBIKSwgdigxLCAwKSksXG5cdHBvbHlUaWxlKHYoMCwgMCksIHYoMCwgMSksIHYoSCwgMSksIHYoMSwgSCksIHYoMSwgMCkpXG5cdC8vIHBvbHlUaWxlMkYodigwLCAwKSwgdigwLCAxKSwgdigxLCAxKSwgdihILCBIKSwgdihILCAwKSlcblxuKTtcblxuXG5jb25zdCBUZXN0TGV2ZWwgPSB7XG5cdHdpZHRoOiAzMCxcblx0aGVpZ2h0OiAzMCxcblx0c3Bhd25YOiAzLFxuXHRzcGF3blk6IDIsXG5cdHRpbGVzOiBbXG4xLDEsMSwxLDEsMSwxLDEsMSwxLDEsMSwxLDEsMSwxLDEsMSwxLDEsMSwxLDEsMSwxLDEsMSwxLDEsMSxcbjEsNiwwLDAsMTksMSwxLDEsMSwxOCwyLDIsMiwyLDIsMiwyLDEwLDAsMCwwLDE0LDEsMSwxOCwxMCwwLDAsNywxLFxuMSwwLDAsMCwxMSwxLDEsMSwxLDAsMTIsNCwwLDQsNCwwLDIsMzQsMCwxMiw0LDIwLDEsNiwwLDAsMCwwLDAsMSxcbjEsMCwwLDAsMCwxOSwxLDEsMSwwLDcsMSwwLDEsMSwwLDIsMzQsMTUsMjUsMCwxOSwyNSwwLDAsMCwxMiw0LDAsMSxcbjEsMCwwLDAsMCwwLDAsMCw3LDEzLDAsMSwwLDEsMSwwLDIsMzQsMyw1LDAsMywxNywwLDAsMTUsMTcsMCwwLDEsXG4xLDU2LDU3LDU4LDU5LDAsMSw5LDAsMCwxNSwxLDAsMSwxLDAsMiwzNCwzLDUsMCwzLDAsMCwwLDMsMCwwLDAsMSxcbjEsOSwwLDAsMCw4LDEsMSwxLDEsMSwxLDAsMSwxLDAsMiwzNCwzLDUsMCwxMSwwLDEzLDAsMywxMCwxMiw0LDEsXG4xLDEsMSwxLDEsMSwxLDEsMSwxLDEsMTgsMCwxLDEsMCwyLDM0LDExLDIxLDAsMCwxMiwxNywwLDMsMCwwLDAsMSxcbjEsMSwyNSwwLDAsMCwwLDAsMCwwLDAsMCwxMiwxLDEsMCwyLDM0LDAsMTQsMiwyLDEwLDAsMCwzLDAsMTIsNCwxLFxuMSwxLDUsMCwwLDAsMSwxLDEsMSwxLDEsMSwxLDEsMCwyLDM0LDAsMCwwLDAsMCwwLDAsMjMsMCwwLDAsMSxcbjEsMSwyMSwwLDAsMTUsMSwxLDEsMSwxLDEsMSwxLDEsMCwxLDEsMTcsMCwwLDAsMCwwLDE1LDI1LDAsMCwwLDEsXG4xLDEsMSwyMSwwLDIzLDEsMSwxLDEsMSwxLDEsMSwxLDAsMCwwLDAsMCwwLDAsMCwwLDIzLDE3LDAsMCwwLDEsXG4xLDEsMSwxLDAsMjIsMSwxLDEsMSwxLDEsMSwxLDEsMCwxOSwxLDEsMSwxLDEsMSwxLDEsMSwxLDEsMSwxLFxuMSwxMCwwLDE5LDAsMCwwLDAsMCwwLDE0LDEsMSwxLDEsMCwwLDAsMCwwLDAsMCwwLDAsMCwwLDAsMCwxMSwxLFxuMSwwLDAsMywwLDgsMSwxLDEsMjQsMCwxLDEsMSwxLDksMCwwLDAsMCwwLDAsMCwwLDAsMCwwLDAsMCwxLFxuMSwwLDAsMjMsMCwxLDEsMSwxLDEsMCwxLDEsMSwxLDEsMSwxLDEsMSwxLDEsMSw5LDAsMCwwLDAsMCwxLFxuMSwwLDIwLDE4LDAsMSwxLDEsMSwxLDAsMSwxLDEsMSwxLDEsMSwxLDEsMSwxLDEsMSwyMSwwLDIzLDEsMSwxLFxuMSw5LDAsMCwwLDcsMSwxLDEsMSwwLDEsMSwxLDEsMSwxNywwLDAsMCwwLDAsMTEsMSwyNSwwLDE5LDEsMSwxLFxuMSwxLDEsMSwxMywwLDEsMSwxLDEwLDAsMTQsMSwxLDEsMSwwLDgsMSwxLDEsMjEsMCwwLDAsMCwwLDAsMSwxLFxuMSwxLDEsMSwyMSwwLDEsMSwxLDAsMCwwLDEsMSwxLDEsMCwxLDEsMSwxLDYsMCwwLDAsMCwwLDAsMSwxLFxuMSwxLDEsMSwyNSwwLDEsMSwxLDE2LDAsMTIsMSwxLDEsMSwwLDEsMSwxLDEsMCwwLDAsMCwwLDAsMCwxLDEsXG4xLDEsMSwxLDE3LDE1LDEsMSwxLDEsMSwxLDEsMSwxLDEsMCwwLDcsMSwxLDI0LDE2LDAsMCwwLDAsMCwxLDEsXG4xLDEsMSwxLDAsMjMsMSwxLDEsMSwxLDEsMSwxLDEsMSwxLDIxLDAsMSwxLDEsMSwyNCwxNiwwLDAsOCwxLDEsXG4xLDEsMSwxLDAsMjIsMSwxLDEsNiwwLDAsMCwwLDAsMCwwLDAsOCwxLDEsMSwxLDEsMSwwLDAsMSwxLDEsXG4xLDEsMSwxLDksMCwwLDAsMCw4LDEsMSwxLDEsMSwxLDEsMTgsMjIsMSwxLDEsMSwxLDEsMCwwLDEsMSwxLFxuMSwxLDEsMSwxLDEsMSwxLDEsMSwxLDEsMSwxLDEsMSwxLDAsMCwxNCwyMiwyMiwyMiwyMiwyMiwwLDAsMSwxLDEsXG4xLDEsMSwxLDEsMSwxLDEsMSwxLDEsMSwxLDEsMSwxLDEsMCwwLDAsMCwwLDAsMCwwLDAsOCwxLDEsMSxcbjEsMSwxLDEsMSwxLDEsMSwxLDEsMSwxLDEsMSwxLDEsMSwxMywwLDEyLDIwLDIwLDIwLDIwLDIwLDEsMSwxLDEsMSxcbjEsMSwxLDEsMSwxLDEsMSwxLDEsMSwxLDEsMSwxLDEsMSwxLDEsMSwxLDEsMSwxLDEsMSwxLDEsMSwxLFxuMSwxLDEsMSwxLDEsMSwxLDEsMSwxLDEsMSwxLDEsMSwxLDEsMSwxLDEsMSwxLDEsMSwxLDEsMSwxLDFcblxuXHQvKlxuMSwxLDEsMSwxLDEsMSwxLDEsMSwxLDEsMSwxLDEsMSwxLDEsMSwxLDEsMSwxLDEsMSwxLDEsMSwxLDEsXG4xLDYsMCwwLDE5LDEsMSwxLDEsMTgsMiwyLDIsMiwyLDIsMiwxMCwwLDAsMCwxNCwxLDEsMTgsMTAsMCwwLDcsMSxcbjEsMCwwLDAsMTEsMSwxLDEsMSwwLDEyLDQsMCw0LDQsMCwyLDEwLDAsMTIsNCwyMCwxLDYsMCwwLDAsMCwwLDEsXG4xLDAsMCwwLDAsMTksMSwxLDEsMCw3LDEsMCwxLDEsMCwyLDEwLDE1LDI1LDAsMTksMjUsMCwwLDAsMTIsNCwwLDEsXG4xLDAsMCwwLDAsMCwwLDAsNywxMywwLDEsMCwxLDEsMCwyLDEwLDMsNSwwLDMsMTcsMCwwLDE1LDE3LDAsMCwxLFxuMSwwLDAsMCwwLDAsMSw5LDAsMCwxNSwxLDAsMSwxLDAsMiwxMCwzLDUsMCwzLDAsMCwwLDMsMCwwLDAsMSxcbjEsOSwwLDAsMCw4LDEsMSwxLDEsMSwxLDAsMSwxLDAsMiwxMCwzLDUsMCwxMSwwLDEzLDAsMywxMCwxMiw0LDEsXG4xLDEsMSwxLDEsMSwxLDEsMSwxLDEsMTgsMCwxLDEsMCwyLDEwLDExLDIxLDAsMCwxMiwxNywwLDMsMCwwLDAsMSxcbjEsMSwyNSwwLDAsMCwwLDAsMCwwLDAsMCwxMiwxLDEsMCwyLDEwLDAsMTQsMiwyLDEwLDAsMCwzLDAsMTIsNCwxLFxuMSwxLDUsMCwwLDAsMSwxLDEsMSwxLDEsMSwxLDEsMCwyLDEwLDAsMCwwLDAsMCwwLDAsMjMsMCwwLDAsMSxcbjEsMSwyMSwwLDAsMTUsMSwxLDEsMSwxLDEsMSwxLDEsMCwxLDEsMTcsMCwwLDAsMCwwLDE1LDI1LDAsMCwwLDEsXG4xLDEsMSwyMSwwLDIzLDEsMSwxLDEsMSwxLDEsMSwxLDAsMCwwLDAsMCwwLDAsMCwwLDIzLDE3LDAsMCwwLDEsXG4xLDEsMSwxLDAsMjIsMSwxLDEsMSwxLDEsMSwxLDEsMCwxOSwxLDEsMSwxLDEsMSwxLDEsMSwxLDEsMSwxLFxuMSwxMCwwLDE5LDAsMCwwLDAsMCwwLDE0LDEsMSwxLDEsMCwwLDAsMCwwLDAsMCwwLDAsMCwwLDAsMCwxMSwxLFxuMSwwLDAsMywwLDgsMSwxLDEsMjQsMCwxLDEsMSwxLDksMCwwLDAsMCwwLDAsMCwwLDAsMCwwLDAsMCwxLFxuMSwwLDAsMjMsMCwxLDEsMSwxLDEsMCwxLDEsMSwxLDEsMSwxLDEsMSwxLDEsMSw5LDAsMCwwLDAsMCwxLFxuMSwwLDIwLDE4LDAsMSwxLDEsMSwxLDAsMSwxLDEsMSwxLDEsMSwxLDEsMSwxLDEsMSwyMSwwLDIzLDEsMSwxLFxuMSw5LDAsMCwwLDcsMSwxLDEsMSwwLDEsMSwxLDEsMSwxNywwLDAsMCwwLDAsMTEsMSwyNSwwLDE5LDEsMSwxLFxuMSwxLDEsMSwxMywwLDEsMSwxLDEwLDAsMTQsMSwxLDEsMSwwLDgsMSwxLDEsMjEsMCwwLDAsMCwwLDAsMSwxLFxuMSwxLDEsMSwyMSwwLDEsMSwxLDAsMCwwLDEsMSwxLDEsMCwxLDEsMSwxLDYsMCwwLDAsMCwwLDAsMSwxLFxuMSwxLDEsMSwyNSwwLDEsMSwxLDE2LDAsMTIsMSwxLDEsMSwwLDEsMSwxLDEsMCwwLDAsMCwwLDAsMCwxLDEsXG4xLDEsMSwxLDE3LDE1LDEsMSwxLDEsMSwxLDEsMSwxLDEsMCwwLDcsMSwxLDI0LDE2LDAsMCwwLDAsMCwxLDEsXG4xLDEsMSwxLDAsMjMsMSwxLDEsMSwxLDEsMSwxLDEsMSwxLDIxLDAsMSwxLDEsMSwyNCwxNiwwLDAsOCwxLDEsXG4xLDEsMSwxLDAsMjIsMSwxLDEsNiwwLDAsMCwwLDAsMCwwLDAsOCwxLDEsMSwxLDEsMSwwLDAsMSwxLDEsXG4xLDEsMSwxLDksMCwwLDAsMCw4LDEsMSwxLDEsMSwxLDEsMTgsMjIsMSwxLDEsMSwxLDEsMCwwLDEsMSwxLFxuMSwxLDEsMSwxLDEsMSwxLDEsMSwxLDEsMSwxLDEsMSwxLDAsMCwxNCwyMiwyMiwyMiwyMiwyMiwwLDAsMSwxLDEsXG4xLDEsMSwxLDEsMSwxLDEsMSwxLDEsMSwxLDEsMSwxLDEsMCwwLDAsMCwwLDAsMCwwLDAsOCwxLDEsMSxcbjEsMSwxLDEsMSwxLDEsMSwxLDEsMSwxLDEsMSwxLDEsMSwxMywwLDEyLDIwLDIwLDIwLDIwLDIwLDEsMSwxLDEsMSxcbjEsMSwxLDEsMSwxLDEsMSwxLDEsMSwxLDEsMSwxLDEsMSwxLDEsMSwxLDEsMSwxLDEsMSwxLDEsMSwxLFxuMSwxLDEsMSwxLDEsMSwxLDEsMSwxLDEsMSwxLDEsMSwxLDEsMSwxLDEsMSwxLDEsMSwxLDEsMSwxLDEqL1xuXVxufVxuXG5leHBvcnRzLlRlc3RMZXZlbCA9IFRlc3RMZXZlbDtcblxuZXhwb3J0cy5UaWxlcyA9IFRpbGVzO1xuZXhwb3J0cy5UaWxlSW5mbyA9IFRpbGVJbmZvO1xuXG4iLCIndXNlIHN0cmljdCc7XG5jb25zdCBWZWMyID0gcmVxdWlyZSgnLi9WZWMyJyk7XG4vLyBjb25zdCBMaW5lU2VnbWVudCA9IHJlcXVpcmUoJy4vbGluZV9zZWdtZW50Jyk7XG5jb25zdCBtYXRoID0gcmVxdWlyZSgnLi9tYXRoJyk7XG5jb25zdCB7QVNTRVJUfSA9IHJlcXVpcmUoJy4vZGVidWcnKTtcbi8vIGJhc2VkIG9uIGNvZGUgb3JpZ2luYWxseSBieSBhbWl0IHBhdGVsOiB3d3cucmVkYmxvYmdhbWVzLmNvbS9hcnRpY2xlcy92aXNpYmlsaXR5L1xuLy8gbmVlZHMgc29tZSB3b3JrIHNpbmNlIGl0IHNlZW1zIHRvIGJlIE8obl4yKSBpbiB0aGUgbnVtYmVyIG9mIHBvaW50cyBpbiB0aGUgbGV2ZWwuLi4gQE5PVEU6IG1heSBoYXZlIGZpeGVkIHRoaXMgbm93XG4vLyBpZiB0aGlzIHdlcmVuJ3QgaW4gYSBqYW0gaSdkIG1ha2UgYW4gZWZmb3J0IHRvIGZpeCB0aGF0IHByb2JsZW0sIGFuZCB0byByZXVzZSB0aGVcbi8vIGxpbmUgc2VnbWVudCAvIHJheWNhc3RpbmcgY29kZSBJIGFscmVhZHkgd3JvdGUuLi5cblxuXG5mdW5jdGlvbiBsZWZ0T2Yoe3N0YXJ0LCBlbmR9LCB4LCB5KSB7XG5cdHJldHVybiAoZW5kLngtc3RhcnQueCkqKHktc3RhcnQueSkgLSAoZW5kLnktc3RhcnQueSkqKHgtc3RhcnQueCkgPCAwLjA7XG59XG5cbmZ1bmN0aW9uIGluRnJvbnRPZihhLCBiLCBjZW50ZXIpIHtcblx0Ly8gQE5PVEU6IGNoZWNrIGlmIHdlIGNhbiBqdXN0IGNvbXBhcmUgYS5kIHRvIGIuZC4uLlxuXHRsZXQgYTEgPSBsZWZ0T2YoYSwgbWF0aC5sZXJwKGIuc3RhcnQueCwgYi5lbmQueCwgMC4wMSksXG5cdCAgICAgICAgICAgICAgICAgICBtYXRoLmxlcnAoYi5zdGFydC55LCBiLmVuZC55LCAwLjAxKSk7XG5cdGxldCBhMiA9IGxlZnRPZihhLCBtYXRoLmxlcnAoYi5lbmQueCwgYi5zdGFydC54LCAwLjAxKSxcblx0ICAgICAgICAgICAgICAgICAgIG1hdGgubGVycChiLmVuZC55LCBiLnN0YXJ0LnksIDAuMDEpKTtcblx0bGV0IGEzID0gbGVmdE9mKGEsIGNlbnRlci54LCBjZW50ZXIueSk7XG5cblx0bGV0IGIxID0gbGVmdE9mKGIsIG1hdGgubGVycChhLnN0YXJ0LngsIGEuZW5kLngsIDAuMDEpLFxuXHQgICAgICAgICAgICAgICAgICAgbWF0aC5sZXJwKGEuc3RhcnQueSwgYS5lbmQueSwgMC4wMSkpO1xuXHRsZXQgYjIgPSBsZWZ0T2YoYiwgbWF0aC5sZXJwKGEuZW5kLngsIGEuc3RhcnQueCwgMC4wMSksXG5cdCAgICAgICAgICAgICAgICAgICBtYXRoLmxlcnAoYS5lbmQueSwgYS5zdGFydC55LCAwLjAxKSk7XG5cdGxldCBiMyA9IGxlZnRPZihiLCBjZW50ZXIueCwgY2VudGVyLnkpO1xuXG5cdGlmIChiMSA9PT0gYjIgJiYgYjIgIT09IGIzKSByZXR1cm4gdHJ1ZTtcblx0aWYgKGExID09PSBhMiAmJiBhMiA9PT0gYTMpIHJldHVybiB0cnVlO1xuXHRpZiAoYTEgPT09IGEyICYmIGEyICE9PSBhMykgcmV0dXJuIGZhbHNlO1xuXHRpZiAoYjEgPT09IGIyICYmIGIyID09PSBiMykgcmV0dXJuIGZhbHNlO1xuXHRyZXR1cm4gZmFsc2U7XG59XG5sZXQgaWRjdHIgPSAwO1xuY2xhc3MgVmlzU2VnbWVudCB7XG5cdGNvbnN0cnVjdG9yKHN0YXJ0LCBlbmQpIHtcblx0XHR0aGlzLnN0YXJ0ID0gc3RhcnQ7XG5cdFx0dGhpcy5lbmQgPSBlbmQ7XG5cdFx0dGhpcy5zdGFydC5zZWdtZW50ID0gdGhpcztcblx0XHR0aGlzLmVuZC5zZWdtZW50ID0gdGhpcztcblx0XHR0aGlzLmQgPSAwLjA7XG5cdFx0dGhpcy5uZXh0ID0gbnVsbDtcblx0XHR0aGlzLnByZXYgPSBudWxsO1xuXHRcdHRoaXMubGlzdEdlbl8gPSAtMTtcblx0XHR0aGlzLmlkXyA9ICsraWRjdHI7XG5cdH1cblx0Y2xvbmUoKSB7XG5cdFx0bGV0IHZzID0gbmV3IFZpc1NlZ21lbnQodGhpcy5zdGFydCwgdGhpcy5lbmQpO1xuXHRcdHZzLnN0YXJ0ID0gdGhpcy5zdGFydDtcblx0XHR2cy5lbmQgPSB0aGlzLmVuZDtcblx0XHR2cy5zdGFydCA9IHRoaXMuc3RhcnQ7XG5cdFx0dnMuZW5kID0gdGhpcy5lbmQ7XG5cdFx0dnMuZCA9IHRoaXMuZDtcblx0XHR2cy5uZXh0ID0gdGhpcy5uZXh0O1xuXHRcdHZzLnByZXYgPSB0aGlzLnByZXY7XG5cdFx0Ly8gdnMubGlzdEdlbl8gPSB0aGlzLmxpc3RHZW5fO1xuXHRcdC8vIHZzLmlkXyA9IHRoaXMuaWRfO1xuXHRcdHJldHVybiB2cztcblx0fVxufVxuXG5sZXQgY3VycmVudExpc3RHZW4gPSAwO1xuXG5mdW5jdGlvbiBsaW5lSW50ZXJzZWN0aW9uKHAxeCwgcDF5LCBwMngsIHAyeSwgcDN4LCBwM3ksIHA0eCwgcDR5KSB7XG4gICAgdmFyIHMgPSAoKHA0eCAtIHAzeCkgKiAocDF5IC0gcDN5KSAtIChwNHkgLSBwM3kpICogKHAxeCAtIHAzeCkpLyAoKHA0eSAtIHAzeSkgKiAocDJ4IC0gcDF4KSAtIChwNHggLSBwM3gpICogKHAyeSAtIHAxeSkpO1xuICAgIHJldHVybiBWZWMyLnRlbXAocDF4ICsgcyAqIChwMnggLSBwMXgpLCBwMXkgKyBzICogKHAyeSAtIHAxeSkpO1xufVxuXG5mdW5jdGlvbiBwb2ludFNvcnRlcihhLCBiKSB7XG5cdGxldCBhQW5nbGUgPSArYS5hbmdsZSwgYkFuZ2xlID0gK2IuYW5nbGU7XG5cdGlmIChhQW5nbGUgIT09IGJBbmdsZSkgcmV0dXJuIGFBbmdsZSAtIGJBbmdsZTtcblx0ZWxzZSByZXR1cm4gKCFhLmJlZ2luICYmIGIuYmVnaW4pID8gLTEgOiAoYS5iZWdpbiAmJiAhYi5iZWdpbiA/IDEgOiAwKTtcbn1cblxuY2xhc3MgU2VnTGlzdCB7XG5cdGNvbnN0cnVjdG9yKCkge1xuXHRcdHRoaXMuaGVhZCA9IG51bGw7XG5cdFx0dGhpcy50YWlsID0gbnVsbDtcblx0fVxuXG5cdGFwcGVuZChzZWcpIHtcblx0XHQvLyBjb25zb2xlLmxvZygnQVBQRU5EOiAnK3NlZy5pZF8pO1xuXHRcdGlmIChzZWcubGlzdEdlbl8gPT09IGN1cnJlbnRMaXN0R2VuKSB7XG5cdFx0XHRzZWcgPSBzZWcuY2xvbmUoKTtcblx0XHRcdC8vIGNvbnNvbGUubG9nKCcgTkVXIElEID0+ICcrc2VnLmlkXylcblx0XHR9XG5cdFx0c2VnLmxpc3RHZW5fID0gY3VycmVudExpc3RHZW47XG5cdFx0c2VnLm5leHQgPSBzZWcucHJldiA9IG51bGw7XG5cdFx0aWYgKHRoaXMuaGVhZCA9PSBudWxsICYmIHRoaXMudGFpbCA9PSBudWxsKSB7XG5cdFx0XHR0aGlzLmhlYWQgPSB0aGlzLnRhaWwgPSBzZWc7XG5cdFx0XHQvLyBjb25zb2xlLmxvZygnICBPTkxZIE5PREU6ICcrc2VnLmlkXyk7XG5cdFx0fSBlbHNlIHtcblx0XHRcdEFTU0VSVChzZWcgIT0gdGhpcy5oZWFkICYmIHNlZyAhPSB0aGlzLnRhaWwpO1xuXHRcdFx0Ly8gY29uc29sZS5sb2coJyAgVEFJTCAnK3RoaXMudGFpbC5pZF8rJyA9PiAnK3NlZy5pZF8pO1xuXHRcdFx0dGhpcy50YWlsLm5leHQgPSBzZWc7XG5cdFx0XHRzZWcucHJldiA9IHRoaXMudGFpbDtcblx0XHRcdHRoaXMudGFpbCA9IHNlZztcblx0XHR9XG5cdFx0Ly8gdGhpcy5jaGVjaygpO1xuXHR9XG5cblx0cmVtb3ZlKHNlZykge1xuXHRcdGlmIChzZWcgPT09IHRoaXMudGFpbCkgdGhpcy50YWlsID0gc2VnLnByZXY7XG5cdFx0aWYgKHNlZyA9PT0gdGhpcy5oZWFkKSB0aGlzLmhlYWQgPSBzZWcubmV4dDtcblx0XHRpZiAoc2VnLm5leHQpIHNlZy5uZXh0LnByZXYgPSBzZWcucHJldjtcblx0XHRpZiAoc2VnLnByZXYpIHNlZy5wcmV2Lm5leHQgPSBzZWcubmV4dDtcblx0XHRzZWcubmV4dCA9IHNlZy5wcmV2ID0gbnVsbDtcblx0fVxuXG5cdGVtcHR5KCkge1xuXHRcdHJldHVybiAhdGhpcy5oZWFkO1xuXHR9XG5cblx0aW5zZXJ0QmVmb3JlKHNlZywgb3RoZXIpIHtcblx0XHQvLyBjb25zb2xlLmxvZygnSU5TRVJUX0JFRk9SRTogJytzZWcuaWRfKycsICcrb3RoZXIuaWRfKTtcblx0XHRpZiAob3RoZXIubGlzdEdlbl8gPT09IGN1cnJlbnRMaXN0R2VuKSB7XG5cdFx0XHRvdGhlciA9IG90aGVyLmNsb25lKCk7XG5cdFx0XHQvLyBjb25zb2xlLmxvZygnICBORVcgSUQgPT4gJytvdGhlci5pZF8pO1xuXHRcdH1cblx0XHRvdGhlci5saXN0R2VuXyA9IGN1cnJlbnRMaXN0R2VuO1xuXHRcdG90aGVyLm5leHQgPSBvdGhlci5wcmV2ID0gbnVsbDtcblx0XHRBU1NFUlQoc2VnICE9IG51bGwpO1xuXHRcdGlmICh0aGlzLmVtcHR5KCkgfHwgc2VnID09IG51bGwpIHtcblx0XHRcdHJldHVybiB0aGlzLmFwcGVuZChvdGhlcik7XG5cdFx0fVxuXHRcdC8vIGNvbnNvbGUubG9nKCcgIEJFVFdFRU46ICcrKCFzZWcucHJldiA/ICdub3RoaW5nJyA6IHNlZy5wcmV2LmlkXykrJyBBTkQ6ICcrc2VnLmlkXyk7XG5cblx0XHRvdGhlci5wcmV2ID0gc2VnLnByZXY7XG5cdFx0b3RoZXIubmV4dCA9IHNlZztcblx0XHRzZWcucHJldiA9IG90aGVyO1xuXHRcdGlmIChvdGhlci5wcmV2KSB7XG5cdFx0XHRvdGhlci5wcmV2Lm5leHQgPSBvdGhlcjtcblx0XHR9XG5cdFx0b3RoZXIubmV4dC5wcmV2ID0gb3RoZXI7XG5cdFx0aWYgKHNlZyA9PT0gdGhpcy5oZWFkKSB7XG5cdFx0XHR0aGlzLmhlYWQgPSBvdGhlcjtcblx0XHR9XG5cdFx0Ly8gdGhpcy5jaGVjaygpO1xuXHR9XG5cblx0Y2xlYXIodW5saW5rKSB7XG5cdFx0d2hpbGUgKHRoaXMuaGVhZCAhPSBudWxsKSB7XG5cdFx0XHRsZXQge25leHR9ID0gdGhpcy5oZWFkO1xuXHRcdFx0dGhpcy5oZWFkLnByZXYgPSB0aGlzLmhlYWQubmV4dCA9IG51bGw7XG5cdFx0XHR0aGlzLmhlYWQgPSBuZXh0O1xuXHRcdH1cblx0XHR0aGlzLmhlYWQgPSB0aGlzLnRhaWwgPSBudWxsO1xuXG5cdH1cblxuXHR0b1N0cmluZygpIHtcblx0XHRsZXQgciA9IFtdO1xuXHRcdGZvciAobGV0IG4gPSB0aGlzLmhlYWQ7IG4gIT0gbnVsbDsgbiA9IG4ubmV4dCkge1xuXHRcdFx0ci5wdXNoKCdbJytuLmlkXysnXScpO1xuXHRcdFx0aWYgKG4ubmV4dCA9PT0gdGhpcy5oZWFkKSB7XG5cdFx0XHRcdGRlYnVnZ2VyO1xuXHRcdFx0XHRkb2N1bWVudC5ib2R5LmlubmVySFRNTCArPSAnQkFEJztcblx0XHRcdH1cblx0XHR9XG5cdFx0cmV0dXJuICdbJytyLmpvaW4oJyAnKSsnXSdcblx0fVxuXG5cdGNoZWNrKCkge1xuXHRcdC8vIGNvbnNvbGUubG9nKHRoaXMudG9TdHJpbmcoKSk7XG5cdFx0bGV0IHNlZW4gPSB7fTtcblx0XHRBU1NFUlQoKHRoaXMuaGVhZCA9PSBudWxsKSA9PT0gKHRoaXMudGFpbCA9PSBudWxsKSk7XG5cdFx0QVNTRVJUKHRoaXMuaGVhZC5wcmV2ID09IG51bGwpO1xuXHRcdEFTU0VSVCh0aGlzLnRhaWwubmV4dCA9PSBudWxsKTtcblxuXHRcdGZvciAobGV0IG4gPSB0aGlzLmhlYWQ7IG4gIT0gbnVsbDsgbiA9IG4ubmV4dCkge1xuXG5cdFx0XHRpZiAobi5wcmV2KSBBU1NFUlQobi5wcmV2Lm5leHQgPT09IG4pO1xuXHRcdFx0ZWxzZSBBU1NFUlQobiA9PT0gdGhpcy5oZWFkKTtcblxuXHRcdFx0aWYgKG4ubmV4dCkgQVNTRVJUKG4ubmV4dC5wcmV2ID09PSBuKTtcblx0XHRcdGVsc2UgQVNTRVJUKG4gPT09IHRoaXMudGFpbCk7XG5cdFx0XHRBU1NFUlQoIShuLmlkXyBpbiBzZWVuKSk7XG5cdFx0XHRzZWVuW24uaWRfXSA9IHRydWU7XG5cdFx0fVxuXG5cdH1cbn1cblxuY2xhc3MgU2VnUG9pbnQge1xuXHRjb25zdHJ1Y3Rvcihwb3MpIHtcblx0XHR0aGlzLnggPSBwb3MueDtcblx0XHR0aGlzLnkgPSBwb3MueTtcblx0XHR0aGlzLnBvcyA9IHBvcztcblx0XHR0aGlzLmJlZ2luID0gZmFsc2U7XG5cdFx0dGhpcy5zZWdtZW50ID0gbnVsbDtcblx0XHR0aGlzLmFuZ2xlID0gMC4wO1xuXHR9XG59XG5cbi8vIEBUT0RPOiBzdXBwb3J0IGNhbWVyYSBleHBsaWNpdGx5LlxuY2xhc3MgVmlzVHJhY2tlciB7XG5cdGNvbnN0cnVjdG9yKCkge1xuXHRcdHRoaXMuc2VnbWVudHMgPSBbXTtcblx0XHR0aGlzLnBvaW50cyA9IFtdO1xuXHRcdHRoaXMub3BlbiA9IG5ldyBTZWdMaXN0KCk7XG5cdFx0dGhpcy5jZW50ZXIgPSBuZXcgVmVjMigwLjAsIDAuMCk7XG5cdFx0dGhpcy5vdXRYcyA9IFtdO1xuXHRcdHRoaXMub3V0WXMgPSBbXTtcblx0fVxuXG5cdHNldFNlZ21lbnRzKHNlZ3MpIHtcblx0XHR0aGlzLnNlZ21lbnRzLmxlbmd0aCA9IDA7XG5cdFx0dGhpcy5wb2ludHMubGVuZ3RoID0gMDtcblx0XHQvLyB0aGlzLm9wZW4uY2xlYXIoKTtcblx0XHQvLyB0aGlzLm91dFhzLmxlbmd0aCA9IDA7XG5cdFx0Ly8gdGhpcy5vdXRZcy5sZW5ndGggPSAwO1xuXHRcdGZvciAobGV0IGkgPSAwOyBpIDwgc2Vncy5sZW5ndGg7ICsraSkge1xuXHRcdFx0dGhpcy5hZGRTZWdtZW50KHNlZ3NbaV0uc3RhcnQsIHNlZ3NbaV0uZW5kKTtcblx0XHR9XG5cdH1cblxuXHRhZGRTZWdtZW50KHN0YXJ0LCBlbmQpIHtcblx0XHRsZXQgc3AgPSBuZXcgU2VnUG9pbnQoc3RhcnQpO1xuXHRcdGxldCBlcCA9IG5ldyBTZWdQb2ludChlbmQpO1xuXHRcdHRoaXMuc2VnbWVudHMucHVzaChuZXcgVmlzU2VnbWVudChzcCwgZXApKTtcblx0XHR0aGlzLnBvaW50cy5wdXNoKHNwLCBlcCk7XG5cdH1cblxuXHRzZXRDZW50ZXIoe3gsIHl9KSB7XG5cdFx0dGhpcy5jZW50ZXIuc2V0KHgsIHkpO1xuXHRcdGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy5zZWdtZW50cy5sZW5ndGg7ICsraSkge1xuXHRcdFx0bGV0IHNlZyA9IHRoaXMuc2VnbWVudHNbaV07XG5cdFx0XHRsZXQgZHggPSAwLjUgKiAoc2VnLnN0YXJ0LnggKyBzZWcuZW5kLngpIC0geDtcblx0XHRcdGxldCBkeSA9IDAuNSAqIChzZWcuc3RhcnQueSArIHNlZy5lbmQueSkgLSB5O1xuXHRcdFx0c2VnLmQgPSBkeCpkeCArIGR5KmR5O1xuXHRcdFx0c2VnLnN0YXJ0LmFuZ2xlID0gTWF0aC5hdGFuMihzZWcuc3RhcnQueS15LCBzZWcuc3RhcnQueC14KTtcblx0XHRcdHNlZy5lbmQuYW5nbGUgPSBNYXRoLmF0YW4yKHNlZy5lbmQueS15LCBzZWcuZW5kLngteCk7XG5cdFx0XHR2YXIgZGVsdGEgPSBzZWcuZW5kLmFuZ2xlIC0gc2VnLnN0YXJ0LmFuZ2xlO1xuXHRcdFx0aWYgKGRlbHRhIDw9IC1NYXRoLlBJKSB7IGRlbHRhICs9IDIqTWF0aC5QSTsgfVxuXHRcdFx0aWYgKGRlbHRhID4gTWF0aC5QSSkgeyBkZWx0YSAtPSAyKk1hdGguUEk7IH1cblx0XHRcdHNlZy5zdGFydC5iZWdpbiA9IChkZWx0YSA+IDAuMCk7XG5cdFx0XHRzZWcuZW5kLmJlZ2luID0gIXNlZy5zdGFydC5iZWdpbjtcblx0XHR9XG5cdH1cblxuXHRzd2VlcChtYXhBbmdsZT05OTkpIHtcblx0XHQrK2N1cnJlbnRMaXN0R2VuO1xuXHRcdHRoaXMub3V0WHMubGVuZ3RoID0gMDtcblx0XHR0aGlzLm91dFlzLmxlbmd0aCA9IDA7XG5cdFx0dGhpcy5wb2ludHMuc29ydChwb2ludFNvcnRlcik7XG5cdFx0dGhpcy5vcGVuLmNsZWFyKCk7XG5cdFx0bGV0IGJlZ2luQW5nbGUgPSAwO1xuXHRcdGZvciAobGV0IHBhc3MgPSAwOyBwYXNzIDwgMjsgKytwYXNzKSB7XG5cdFx0XHRmb3IgKGxldCBlcCA9IDAsIGVwbCA9IHRoaXMucG9pbnRzLmxlbmd0aDsgZXAgPCBlcGw7ICsrZXApIHtcblx0XHRcdFx0bGV0IHAgPSB0aGlzLnBvaW50c1tlcF07XG5cdFx0XHRcdGlmIChwYXNzID09PSAxICYmIHAuYW5nbGUgPiBtYXhBbmdsZSkge1xuXHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHR9XG5cdFx0XHRcdHZhciBjdXJyZW50T2xkID0gdGhpcy5vcGVuLmhlYWQ7XG5cdFx0XHRcdGlmIChwLmJlZ2luKSB7XG5cdFx0XHRcdFx0bGV0IG5vZGUgPSB0aGlzLm9wZW4uaGVhZDtcblx0XHRcdFx0XHR3aGlsZSAobm9kZSAhPSBudWxsICYmIGluRnJvbnRPZihwLnNlZ21lbnQsIG5vZGUsIHRoaXMuY2VudGVyKSkge1xuXHRcdFx0XHRcdFx0bm9kZSA9IG5vZGUubmV4dDtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0aWYgKG5vZGUgPT0gbnVsbCkgeyB0aGlzLm9wZW4uYXBwZW5kKHAuc2VnbWVudCk7IH1cblx0XHRcdFx0XHRlbHNlIHsgdGhpcy5vcGVuLmluc2VydEJlZm9yZShub2RlLCBwLnNlZ21lbnQpOyB9XG5cdFx0XHRcdFx0dGhpcy5vcGVuLmNoZWNrKCk7XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0dGhpcy5vcGVuLnJlbW92ZShwLnNlZ21lbnQpO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0bGV0IGN1cnJlbnROZXcgPSB0aGlzLm9wZW4uaGVhZDtcblx0XHRcdFx0aWYgKGN1cnJlbnRPbGQgIT0gY3VycmVudE5ldykge1xuXHRcdFx0XHRcdGlmIChwYXNzID09PSAxKSB7XG5cdFx0XHRcdFx0XHR0aGlzLmFkZFRyaV8oYmVnaW5BbmdsZSwgcC5hbmdsZSwgY3VycmVudE9sZCk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdGJlZ2luQW5nbGUgPSBwLmFuZ2xlO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXHR9XG5cblx0YWRkVHJpXyhhMSwgYTIsIHNlZ21lbnQpIHtcblx0XHRsZXQgY2VudGVyWCA9ICt0aGlzLmNlbnRlci54LCBjZW50ZXJZID0gK3RoaXMuY2VudGVyLnk7XG5cdFx0bGV0IHAxeCA9IGNlbnRlclgsIHAxeSA9ICtjZW50ZXJZO1xuXHRcdGxldCBwMnggPSBwMXggKyBNYXRoLmNvcyhhMSksIHAyeSA9IHAxeSArIE1hdGguc2luKGExKTtcblx0XHRsZXQgcDN4ID0gMC4wLCBwM3kgPSAwLjA7XG5cdFx0bGV0IHA0eCA9IDAuMCwgcDR5ID0gMC4wO1xuXG5cdFx0aWYgKHNlZ21lbnQpIHtcblx0XHRcdHAzeCA9ICtzZWdtZW50LnN0YXJ0Lng7XG5cdFx0XHRwM3kgPSArc2VnbWVudC5zdGFydC55O1xuXHRcdFx0cDR4ID0gK3NlZ21lbnQuZW5kLng7XG5cdFx0XHRwNHkgPSArc2VnbWVudC5lbmQueTtcblx0XHR9XG5cdFx0ZWxzZSB7XG5cdFx0XHRwM3ggPSBjZW50ZXJYICsgTWF0aC5jb3MoYTEpKjEwMDAwO1xuXHRcdFx0cDN5ID0gY2VudGVyWSArIE1hdGguc2luKGExKSoxMDAwMDtcblx0XHRcdHA0eCA9IGNlbnRlclggKyBNYXRoLmNvcyhhMikqMTAwMDA7XG5cdFx0XHRwNHkgPSBjZW50ZXJZICsgTWF0aC5zaW4oYTIpKjEwMDAwO1xuXHRcdH1cblxuXHRcdGxldCB7eDogeEJlZ2luLCB5OiB5QmVnaW59ID0gbGluZUludGVyc2VjdGlvbihwM3gsIHAzeSwgcDR4LCBwNHksXG5cdFx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHAxeCwgcDF5LCBwMngsIHAyeSk7XG5cdFx0cDJ4ID0gY2VudGVyWCArIE1hdGguY29zKGEyKTtcblx0XHRwMnkgPSBjZW50ZXJZICsgTWF0aC5zaW4oYTIpO1xuXG5cdFx0bGV0IHt4OiB4RW5kLCB5OiB5RW5kfSA9IGxpbmVJbnRlcnNlY3Rpb24ocDN4LCBwM3ksIHA0eCwgcDR5LFxuXHRcdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHAxeCwgcDF5LCBwMngsIHAyeSk7XG5cblxuLypcblx0XHRsZXQgZDIxeCA9IHAyeC1wMXgsIGQyMXkgPSBwMnktcDF5O1xuXHRcdGxldCBkMzF4ID0gcDN4LXAxeCwgZDMxeSA9IHAzeS1wMXk7XG5cdFx0bGV0IGQ0M3ggPSBwNHgtcDN4LCBkNDN5ID0gcDR5LXAzeTtcblxuXHRcdGxldCBzID0gKGQyMXgqZDMxeSAtIGQyMXkqZDMxeCkgLyAoZDIxeSpkNDN4IC0gZDIxeCpkNDN5KTtcblx0XHRsZXQgeEJlZ2luID0gcDN4ICsgcyAqIGQ0M3g7XG5cdFx0bGV0IHlCZWdpbiA9IHAzeSArIHMgKiBkNDN5O1xuXG5cdFx0cDJ4ID0gY2VudGVyWCArIE1hdGguY29zKGEyKTtcblx0XHRwMnkgPSBjZW50ZXJZICsgTWF0aC5zaW4oYTIpO1xuXG5cdFx0ZDIxeCA9IHAyeC1wMXg7XG5cdFx0ZDIxeSA9IHAyeS1wMXk7XG5cdFx0cyA9IChkMjF4KmQzMXkgLSBkMjF5KmQzMXgpIC8gKGQyMXkqZDQzeCAtIGQyMXgqZDQzeSk7XG5cblx0XHRsZXQgeEVuZCA9IHAzeCArIHMgKiBkNDN4O1xuXHRcdGxldCB5RW5kID0gcDN5ICsgcyAqIGQ0M3k7XG5cblx0XHR0aGlzLm91dFhzLnB1c2goeEVuZCk7XG5cdFx0dGhpcy5vdXRZcy5wdXNoKHlFbmQpOyovXG5cblx0XHR0aGlzLm91dFhzLnB1c2goeEJlZ2luLCB4RW5kKTtcblx0XHR0aGlzLm91dFlzLnB1c2goeUJlZ2luLCB5RW5kKTtcblx0fVxuXG5cblxufVxuXG5leHBvcnRzLlZpc1RyYWNrZXIgPSBWaXNUcmFja2VyO1xuIiwiJ3VzZSBzdHJpY3QnO1xuY29uc3QgVmVjMiA9IHJlcXVpcmUoJy4vdmVjMicpO1xuY29uc3QgbWF0aCA9IHJlcXVpcmUoJy4vbWF0aCcpO1xuY29uc3Qge0FTU0VSVH0gPSByZXF1aXJlKCcuL2RlYnVnJyk7XG5jb25zdCBkcmF3aW5nID0gcmVxdWlyZSgnLi9kcmF3aW5nJyk7XG5cbmNsYXNzIExpbmVTZWdtZW50IHtcblx0Y29uc3RydWN0b3Ioc3RhcnQsIGVuZCwgZmxhZ3M9MCkge1xuXHRcdHRoaXMuc3RhcnQgPSBzdGFydDtcblx0XHR0aGlzLmVuZCA9IGVuZDtcblx0XHR0aGlzLmZsYWdzID0gZmxhZ3N8MDtcblx0fVxuXG5cdG5vcm1hbCgpIHtcblx0XHQvLyBASEFDSzogc2VnIGlzIGJyb2tlbi5cblx0XHRsZXQgaWR4ID0gdGhpcy5zdGFydC54IC0gdGhpcy5lbmQueDtcblx0XHRsZXQgaWR5ID0gdGhpcy5zdGFydC55IC0gdGhpcy5lbmQueTtcblx0XHRsZXQgcHggPSAtaWR5LCBweSA9IGlkeDtcblx0XHRsZXQgaWwgPSAxLjAvKE1hdGguc3FydChweCpweCtweSpweSkrMWUtMzcpXG5cdFx0cmV0dXJuIFZlYzIudGVtcChweCppbCwgcHkqaWwpO1xuXHR9XG5cblx0Y2xvc2VzdFBvaW50KG91dCwge3gsIHl9KSB7XG5cdFx0Y29uc3Qgc2VnWCA9IHRoaXMuZW5kLnggLSB0aGlzLnN0YXJ0Lng7XG5cdFx0Y29uc3Qgc2VnWSA9IHRoaXMuZW5kLnkgLSB0aGlzLnN0YXJ0Lnk7XG5cblx0XHRjb25zdCBmeCA9IHggLSB0aGlzLnN0YXJ0Lng7XG5cdFx0Y29uc3QgZnkgPSB5IC0gdGhpcy5zdGFydC55O1xuXG5cdFx0Y29uc3QgcHJvaiA9IHNlZ1ggKiBmeCArIHNlZ1kgKiBmeTtcblx0XHRjb25zdCBzZG90ID0gc2VnWCpzZWdYK3NlZ1kqc2VnWTtcblx0XHRpZiAob3V0KSB7XG5cdFx0XHRpZiAocHJvaiA8PSAwKSB7XG5cdFx0XHRcdG91dC54ID0gdGhpcy5zdGFydC54O1xuXHRcdFx0XHRvdXQueSA9IHRoaXMuc3RhcnQueTtcblx0XHRcdH0gZWxzZSBpZiAocHJvaiA+PSBzZG90KSB7XG5cdFx0XHRcdG91dC54ID0gdGhpcy5lbmQueDtcblx0XHRcdFx0b3V0LnkgPSB0aGlzLmVuZC55O1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0Y29uc3QgYW1vdW50ID0gcHJvaiAvIHNkb3Q7XG5cdFx0XHRcdG91dC54ID0gdGhpcy5zdGFydC54ICsgYW1vdW50ICogc2VnWDtcblx0XHRcdFx0b3V0LnkgPSB0aGlzLnN0YXJ0LnkgKyBhbW91bnQgKiBzZWdZO1xuXHRcdFx0fVxuXHRcdH1cblx0XHRpZiAodGhpcy5mbGFncyAmIExpbmVTZWdtZW50LkRvdWJsZVNpZGVkKVxuXHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdHJldHVybiBmeCAqIC1zZWdZICsgZnkgKiBzZWdYIDwgMDtcblx0fVxuXG5cdGdldENsb3Nlc3RQb2ludChvdXQsIHBvaW50KSB7XG5cdFx0aWYgKCFvdXQpIG91dCA9IFZlYzIudGVtcCgwLjAsIDAuMCk7XG5cdFx0dGhpcy5jbG9zZXN0UG9pbnQob3V0LCBwb2ludCk7XG5cdFx0cmV0dXJuIG91dDtcblx0fVxuXG5cdGRlYnVnUmVuZGVyKGRiZ0N0eCkge1xuXHRcdGRyYXdpbmcuZHJhd0xpbmUoZGJnQ3R4LCB0aGlzLnN0YXJ0LngsIHRoaXMuc3RhcnQueSwgdGhpcy5lbmQueCwgdGhpcy5lbmQueSwge2VuZHBvaW50czogdHJ1ZX0pO1xuXHRcdC8vIGRyYXdpbmcuZHJhd0JveChkYmdDdHgsIHRoaXMuc3RhcnQueCwgdGhpcy5zdGFydC55KTtcblx0XHQvLyBkcmF3aW5nLmRyYXdCb3goZGJnQ3R4LCB0aGlzLmVuZC54LCB0aGlzLmVuZC55KTtcblx0XHRsZXQgZGVsdGEgPSB0aGlzLnN0YXJ0LnRvKHRoaXMuZW5kKTtcblx0XHRsZXQgbm9ybSA9IGRlbHRhLnBlcnAoKS5ub3JtYWxpemUoKTtcblx0XHRsZXQgbXggPSAodGhpcy5zdGFydC54ICsgdGhpcy5lbmQueCkgKiAwLjU7XG5cdFx0bGV0IG15ID0gKHRoaXMuc3RhcnQueSArIHRoaXMuZW5kLnkpICogMC41O1xuXHRcdGRyYXdpbmcuZHJhd0xpbmUoZGJnQ3R4LCBteCwgbXksIG14ICsgNCpub3JtLngsIG15ICsgNCpub3JtLnkpO1xuXHR9XG5cblx0cmF5Y2FzdChvdXRQb3MsIG91dERpciwgcmF5UG9zLCByYXlEaXIsIHNpemUpIHtcblx0XHRsZXQgYmduSGl0ID0gbWF0aC5yYXljYXN0VGltZVBvaW50KHJheVBvcywgcmF5RGlyLCB0aGlzLnN0YXJ0LCBWZWMyLlpFUk8sIHNpemUpO1xuXHRcdGxldCBlbmRIaXQgPSBtYXRoLnJheWNhc3RUaW1lUG9pbnQocmF5UG9zLCByYXlEaXIsIHRoaXMuZW5kLCAgIFZlYzIuWkVSTywgc2l6ZSk7XG5cdFx0bGV0IG1pZEhpdCA9IG1hdGgucmF5Y2FzdFRpbWVMaW5lKHJheVBvcywgcmF5RGlyLCB0aGlzLnN0YXJ0LCB0aGlzLmVuZCwgc2l6ZSk7XG5cblx0XHRsZXQgaGl0ID0gTWF0aC5taW4oTWF0aC5taW4oYmduSGl0LCBtaWRIaXQpLCBlbmRIaXQpO1xuXHRcdGlmICgwIDw9IGhpdCAmJiBoaXQgPD0gMSkge1xuXHRcdFx0bGV0IHJheVBvaW50ID0gVmVjMi50ZW1wKHJheVBvcy54ICsgaGl0ICogcmF5RGlyLngsXG5cdFx0XHQgICAgICAgICAgICAgICAgICAgICAgICAgcmF5UG9zLnkgKyBoaXQgKiByYXlEaXIueSk7XG5cdFx0XHRpZiAoc2l6ZSA+IDApIHtcblx0XHRcdFx0bGV0IGNsb3Nlc3QgPSB0aGlzLmdldENsb3Nlc3RQb2ludChWZWMyLnRlbXAoMC4wLCAwLjApLCByYXlQb2ludCk7XG5cdFx0XHRcdGxldCBkeCA9IHJheVBvaW50LnggLSBjbG9zZXN0Lng7XG5cdFx0XHRcdGxldCBkeSA9IHJheVBvaW50LnkgLSBjbG9zZXN0Lnk7XG5cdFx0XHRcdGxldCBpbCA9IDEuMCAvIChNYXRoLnNxcnQoZHgqZHggKyBkeSpkeSkrMWUtMzcpO1xuXHRcdFx0XHRkeCAqPSBpbDtcblx0XHRcdFx0ZHkgKj0gaWw7XG5cdFx0XHRcdG91dFBvcy5jb3B5KGNsb3Nlc3QpO1xuXHRcdFx0XHRvdXREaXIuc2V0KGR4LCBkeSk7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRsZXQgbnggPSAtKHRoaXMuZW5kLnkgLSB0aGlzLnN0YXJ0LnkpO1xuXHRcdFx0XHRsZXQgbnkgPSB0aGlzLmVuZC54IC0gdGhpcy5zdGFydC54O1xuXHRcdFx0XHRsZXQgaWwgPSAxLjAgLyAoTWF0aC5zcXJ0KG54Km54ICsgbnkqbnkpKzFlLTM3KTtcblx0XHRcdFx0bnggKj0gaWw7XG5cdFx0XHRcdG55ICo9IGlsO1xuXHRcdFx0XHRpZiAobnggKiByYXlEaXIueCArIG55ICogcmF5RGlyLnkgPiAwKSB7XG5cdFx0XHRcdFx0bnggPSAtbng7XG5cdFx0XHRcdFx0bnkgPSAtbnk7XG5cdFx0XHRcdH1cblx0XHRcdFx0b3V0UG9zLmNvcHkocmF5UG9zKTtcblx0XHRcdFx0b3V0RGlyLnNldChueCwgbnkpO1xuXHRcdFx0fVxuXHRcdH1cblx0XHRyZXR1cm4gaGl0O1xuXHR9XG59XG5cbkxpbmVTZWdtZW50LkZsYWdzID0ge1xuXHROb25lOiAwLFxuXHREb3VibGVTaWRlZDogKDEgPDwgMCksXG5cdC8vIFRyYW5zcGFyZW50OiAoMSA8PCAxKSxcblx0Ly8gTm9uc3BhdGlhbDogKDEgPDwgMiksXG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IExpbmVTZWdtZW50O1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG5cbndpbmRvdy5USU1FX0ZVTkNUSU9OUyA9IGZhbHNlO1xuXG53aW5kb3cub25sb2FkID0gZnVuY3Rpb24oKSB7XG5cdGNvbnN0IEdhbWVSdW5uZXIgPSByZXF1aXJlKCcuL2dhbWVfcnVubmVyJyk7XG5cdHdpbmRvdy5nYW1lUnVubmVyID0gbmV3IEdhbWVSdW5uZXIoZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ3NjcmVlbicpKTtcblx0d2luZG93LmdhbWVSdW5uZXIuc3RhcnQoKTtcbn07XG4iLCIndXNlIHN0cmljdCc7XG5jb25zdCB7QVNTRVJUfSA9IHJlcXVpcmUoJy4vZGVidWcnKTtcblxuY29uc3QgRVBTSUxPTiA9IDAuMDAwMTtcbmNvbnN0IERFRzJSQUQgPSBNYXRoLlBJIC8gMTgwLjA7XG5jb25zdCBSQUQyREVHID0gMTgwLjAgLyBNYXRoLlBJO1xuXG5leHBvcnRzLkVQU0lMT04gPSBFUFNJTE9OO1xuZXhwb3J0cy5ERUcyUkFEID0gREVHMlJBRDtcbmV4cG9ydHMuUkFEMkRFRyA9IFJBRDJERUc7XG5cbmV4cG9ydHMudG9SYWRpYW5zID0gdG9SYWRpYW5zO1xuZnVuY3Rpb24gdG9SYWRpYW5zKHYpIHsgcmV0dXJuIHYgKiBERUcyUkFEOyB9XG5cbmV4cG9ydHMudG9EZWdyZWVzID0gdG9EZWdyZWVzO1xuZnVuY3Rpb24gdG9EZWdyZWVzKHYpIHsgcmV0dXJuIHYgKiBSQUQyREVHOyB9XG5cbmV4cG9ydHMuY2xhbXAgPSBjbGFtcDtcbmZ1bmN0aW9uIGNsYW1wKG4sIGxvLCBoaSkgeyByZXR1cm4gTWF0aC5taW4oaGksIE1hdGgubWF4KGxvLCBuKSk7IH1cblxuZXhwb3J0cy5zYXR1cmF0ZSA9IHNhdHVyYXRlO1xuZnVuY3Rpb24gc2F0dXJhdGUodikgeyByZXR1cm4gY2xhbXAodiwgMC4wLCAxLjApOyB9XG5cbmV4cG9ydHMubGVycCA9IGxlcnA7XG5mdW5jdGlvbiBsZXJwKGEsIGIsIHQpIHsgbGV0IHMgPSBzYXR1cmF0ZSh0KTsgcmV0dXJuIGEgKiAoMS4wIC0gcykgKyBiICogczsgfVxuXG5leHBvcnRzLnVMZXJwID0gdUxlcnA7XG5mdW5jdGlvbiB1TGVycChhLCBiLCB0KSB7IHJldHVybiBhICsgKGIgLSBhKSAqIHQ7IH1cblxuZXhwb3J0cy5zcXVhcmUgPSBzcXVhcmU7XG5mdW5jdGlvbiBzcXVhcmUodikgeyByZXR1cm4gdip2OyB9XG5cbmV4cG9ydHMuY3ViZSA9IGN1YmU7XG5mdW5jdGlvbiBjdWJlKHYpIHsgcmV0dXJuIHYqdip2OyB9XG5cbmV4cG9ydHMuYXBwcm94WmVybyA9IGFwcHJveFplcm87XG5mdW5jdGlvbiBhcHByb3haZXJvKHYsIGVwcz1FUFNJTE9OKSB7IHJldHVybiB2IDw9IGVwcyB8fCB2ID49IC1lcHM7IH1cblxuZXhwb3J0cy5hcHByb3hFcXVhbCA9IGFwcHJveEVxdWFsO1xuZnVuY3Rpb24gYXBwcm94RXF1YWwoYSwgYiwgZXBzPUVQU0lMT04pIHsgcmV0dXJuIE1hdGguYWJzKGEtYikgPD0gZXBzICogTWF0aC5tYXgoMS4wLCBNYXRoLmFicyhhKSwgTWF0aC5hYnMoYikpOyB9XG5cbmV4cG9ydHMuc2FmZURpdiA9IHNhZmVEaXY7XG5mdW5jdGlvbiBzYWZlRGl2KGEsIGIsIHIpIHsgcmV0dXJuIGIgPT09IDAuMCA/IHIgOiBhL2I7IH1cblxuZXhwb3J0cy5zYWZlRGl2MCA9IHNhZmVEaXYwO1xuZnVuY3Rpb24gc2FmZURpdjAoYSwgYikgeyByZXR1cm4gc2FmZURpdihhLCBiLCAwLjApOyB9XG5cbmV4cG9ydHMuc2FmZURpdjEgPSBzYWZlRGl2MTtcbmZ1bmN0aW9uIHNhZmVEaXYxKGEsIGIpIHsgcmV0dXJuIHNhZmVEaXYoYSwgYiwgMS4wKTsgfVxuXG5leHBvcnRzLnNpZ25PZiA9IHNpZ25PZjtcbmZ1bmN0aW9uIHNpZ25PZih2KSB7IHJldHVybiB2IDwgMCA/IC0xIDogKHYgPiAwID8gMSA6IDApOyB9XG5cbmV4cG9ydHMuc21vb3RoU3RlcDAxID0gc21vb3RoU3RlcDAxO1xuZnVuY3Rpb24gc21vb3RoU3RlcDAxKHQpIHsgcmV0dXJuIHQqdCp0Kih0Kih0KjYuMCAtIDE1LjApICsgMTAuMCk7IH1cblxuZXhwb3J0cy5saW5lYXJTdGVwID0gbGluZWFyU3RlcDtcbmZ1bmN0aW9uIGxpbmVhclN0ZXAoYSwgYiwgdCkgeyByZXR1cm4gc2F0dXJhdGUoc2FmZURpdjAodC1hLCBiLWEpKTsgfVxuXG5leHBvcnRzLnNtb290aFN0ZXAgPSBzbW9vdGhTdGVwO1xuZnVuY3Rpb24gc21vb3RoU3RlcChhLCBiLCB0KSB7IHJldHVybiBzbW9vdGhTdGVwMDEobGluZWFyU3RlcChhLCBiLCB0KSk7IH1cblxuZXhwb3J0cy5yZXBlYXQgPSByZXBlYXQ7XG5mdW5jdGlvbiByZXBlYXQodCwgbGVuKSB7IHJldHVybiB0IC0gTWF0aC5mbG9vcih0L2xlbikqbGVuOyB9XG5cbmV4cG9ydHMucGluZ3BvbmcgPSBwaW5ncG9uZztcbmZ1bmN0aW9uIHBpbmdwb25nKHQsIGxlbikgeyByZXR1cm4gbGVuIC0gTWF0aC5hYnMocmVwZWF0KHQsIGxlbioyKS1sZW4pOyB9XG5cbmV4cG9ydHMubGVuZ3RoMkQgPSBsZW5ndGgyRDtcbmZ1bmN0aW9uIGxlbmd0aDJEKHgsIHkpIHsgcmV0dXJuIE1hdGguc3FydCh4KngreSp5KTsgfVxuXG5leHBvcnRzLmxlbmd0aDNEID0gbGVuZ3RoM0Q7XG5mdW5jdGlvbiBsZW5ndGgzRCh4LCB5LCB6KSB7IHJldHVybiBNYXRoLnNxcnQoeCp4K3kqeSt6KnopOyB9XG5cbmV4cG9ydHMuZGlzdGFuY2UyRCA9IGRpc3RhbmNlMkQ7XG5mdW5jdGlvbiBkaXN0YW5jZTJEKHgwLCB5MCwgeDEsIHkxKSB7XG5cdGxldCBkeCA9IHgwLXgxLCBkeSA9IHkwLXkxO1xuXHRyZXR1cm4gTWF0aC5zcXJ0KGR4KmR4ICsgZHkqZHkpO1xufTtcblxuZXhwb3J0cy5kaXN0YW5jZTNEID0gZGlzdGFuY2UzRDtcbmZ1bmN0aW9uIGRpc3RhbmNlM0QoeDAsIHkwLCB6MCwgeDEsIHkxLCB6MSkge1xuXHRsZXQgZHggPSB4MC14MSwgZHkgPSB5MC15MSwgZHogPSB6MC16MTtcblx0cmV0dXJuIE1hdGguc3FydChkeCpkeCArIGR5KmR5ICsgZHoqZHopO1xufTtcblxuZXhwb3J0cy5ub3JtTGVuMkQgPSBub3JtTGVuMkQ7XG5mdW5jdGlvbiBub3JtTGVuMkQoeCwgeSkge1xuXHRsZXQgbCA9IHgqeCArIHkqeTtcblx0cmV0dXJuIGwgPCBFUFNJTE9OID8gMS4wIDogTWF0aC5zcXJ0KGwpO1xufTtcblxuZXhwb3J0cy5zYWZlSW52TGVuID0gZXhwb3J0cy5zYWZlSW52ZXJzZUxlbmd0aCA9IHNhZmVJbnZMZW47XG5mdW5jdGlvbiBzYWZlSW52TGVuKHgsIHkpIHtcblx0cmV0dXJuIDEuMCAvIChNYXRoLnNxcnQoeCp4K3kqeSkrMWUtMzcpO1xufTtcblxuZXhwb3J0cy5ub3JtTGVuM0QgPSBub3JtTGVuM0Q7XG5mdW5jdGlvbiBub3JtTGVuM0QoeCwgeSwgeikge1xuXHRsZXQgbCA9IHgqeCArIHkqeSArIHoqejtcblx0cmV0dXJuIGwgPCBFUFNJTE9OID8gMS4wIDogTWF0aC5zcXJ0KGwpO1xufTtcblxuZXhwb3J0cy5sZXJwQ29sb3JzID0gbGVycENvbG9ycztcbmZ1bmN0aW9uIGxlcnBDb2xvcnMoYzAsIGMxLCB0LCBzdXBwb3J0QWxwaGE9ZmFsc2UpIHtcblx0bGV0IGIwID0gKChjMCA+Pj4gMTYpICYgMHhmZikvMjU1LjA7XG5cdGxldCBnMCA9ICgoYzAgPj4+IDgpICYgMHhmZikvMjU1LjA7XG5cdGxldCByMCA9ICgoYzAgPj4+IDApICYgMHhmZikvMjU1LjA7XG5cdGxldCBhMCA9ICgoYzAgPj4+IDI0KSAmIDB4ZmYpLzI1NS4wO1xuXG5cdGxldCBiMSA9ICgoYzEgPj4+IDE2KSAmIDB4ZmYpLzI1NS4wO1xuXHRsZXQgZzEgPSAoKGMxID4+PiA4KSAmIDB4ZmYpLzI1NS4wO1xuXHRsZXQgcjEgPSAoKGMxID4+PiAwKSAmIDB4ZmYpLzI1NS4wO1xuXHRsZXQgYTEgPSAoKGMxID4+PiAyNCkgJiAweGZmKS8yNTUuMDtcblxuXHRsZXQgcnIgPSAobGVycChyMCwgcjEsIHQpICogMjU1KXwwO1xuXHRsZXQgcmcgPSAobGVycChnMCwgZzEsIHQpICogMjU1KXwwO1xuXHRsZXQgcmIgPSAobGVycChiMCwgYjEsIHQpICogMjU1KXwwO1xuXHRsZXQgcmEgPSBzdXBwb3J0QWxwaGEgPyAobGVycChhMCwgYTEsIHQpICogMjU1KXwwIDogMHhmZjtcblxuXHRyZXR1cm4gKHJhIDw8IDI0KXwocmIgPDwgMTYpfChyZyA8PCA4KXxycjtcbn07XG5cbmV4cG9ydHMuYnVpbGRQaXhlbFJHQkEgPSBidWlsZFBpeGVsUkdCQTtcbmZ1bmN0aW9uIGJ1aWxkUGl4ZWxSR0JBKHIsIGcsIGIsIGEpIHtcblx0ciA9IHImMHhmZjsgZyA9IGcmMHhmZjsgYiA9IGImMHhmZjsgYSA9IGEmMHhmZjtcblx0cmV0dXJuIChhIDw8IDI0KXwoYiA8PCAxNil8KGcgPDwgOCl8cjtcbn1cblxuZXhwb3J0cy5idWlsZFBpeGVsUkdCID0gYnVpbGRQaXhlbFJHQjtcbmZ1bmN0aW9uIGJ1aWxkUGl4ZWxSR0IociwgZywgYikge1xuXHRyID0gciYweGZmOyBnID0gZyYweGZmOyBiID0gYiYweGZmO1xuXHRyZXR1cm4gKGIgPDwgMTYpfChnIDw8IDgpfHI7XG59XG5cbmV4cG9ydHMuZ2FtbWFUb0xpbmVhcjMyID0gZ2FtbWFUb0xpbmVhcjMyO1xuZnVuY3Rpb24gZ2FtbWFUb0xpbmVhcjMyKHBpeGVsKSB7XG5cdGxldCBiID0gKChwaXhlbCA+Pj4gMTYpICYgMHhmZikvMjU1LjA7XG5cdGxldCBnID0gKChwaXhlbCA+Pj4gOCkgJiAweGZmKS8yNTUuMDtcblx0bGV0IHIgPSAoKHBpeGVsID4+PiAwKSAmIDB4ZmYpLzI1NS4wO1xuXG5cdGxldCByciA9ICgocipyKSAqIDI1NSl8MDtcblx0bGV0IHJnID0gKChnKmcpICogMjU1KXwwO1xuXHRsZXQgcmIgPSAoKGIqYikgKiAyNTUpfDA7XG5cblx0cmV0dXJuIChwaXhlbCAmIDB4ZmYwMDAwMDApIHwgKHJiIDw8IDE2KSB8IChyZyA8PCA4KSB8IHJyO1xufVxuXG5leHBvcnRzLmNoYW5nZVNhdHVyYXRpb24gPSBjaGFuZ2VTYXR1cmF0aW9uO1xuZnVuY3Rpb24gY2hhbmdlU2F0dXJhdGlvbihwaXhlbCwgbGV2ZWwsIGdhbW1hKSB7XG5cdGxldCByID0gKChwaXhlbCA+Pj4gMTYpICYgMHhmZikvMjU1LjA7XG5cdGxldCBnID0gKChwaXhlbCA+Pj4gOCkgJiAweGZmKS8yNTUuMDtcblx0bGV0IGIgPSAoKHBpeGVsID4+PiAwKSAmIDB4ZmYpLzI1NS4wO1xuXHRsZXQgYSA9IHBpeGVsICYgMHhmZjAwMDAwMDtcblxuXHRpZiAoZ2FtbWEpIHtcblx0XHRyICo9IHI7XG5cdFx0ZyAqPSBnO1xuXHRcdGIgKj0gYjtcblx0fVxuXG5cdGxldCBhdmcgPSAoMS4wIC8gMy4wKSAqIChyICsgZyArIGIpO1xuXG5cdGxldCBkciA9IHItYXZnO1xuXHRsZXQgZGcgPSBnLWF2Zztcblx0bGV0IGRiID0gYi1hdmc7XG5cblx0bGV0IHJyID0gYXZnICsgbGV2ZWwqZHI7XG5cdGxldCByZyA9IGF2ZyArIGxldmVsKmRnO1xuXHRsZXQgcmIgPSBhdmcgKyBsZXZlbCpkYjtcblxuXHRpZiAoZ2FtbWEpIHtcblx0XHRyciA9IE1hdGguc3FydChycik7XG5cdFx0cmcgPSBNYXRoLnNxcnQocmcpO1xuXHRcdHJiID0gTWF0aC5zcXJ0KHJiKTtcblx0fVxuXG5cdGxldCBwciA9IChycioyNTUuMCl8MDtcblx0bGV0IHBnID0gKHJnKjI1NS4wKXwwO1xuXHRsZXQgcGIgPSAocmIqMjU1LjApfDA7XG5cblx0cmV0dXJuIChwaXhlbCAmIDB4ZmYwMDAwMDApIHwgKHByIDw8IDE2KSB8IChwZyA8PCA4KSB8IHBiO1xufVxuXG5leHBvcnRzLnJheWNhc3RUaW1lUG9pbnQgPSByYXljYXN0VGltZVBvaW50O1xuZnVuY3Rpb24gcmF5Y2FzdFRpbWVQb2ludChwb3MwLCBkaXIwLCBwb3MxLCBkaXIxLCBTaXplKSB7XG5cdGxldCBkaXJEWCA9IGRpcjAueCAtIGRpcjEueCwgZGlyRFkgPSBkaXIwLnkgLSBkaXIxLnk7XG5cdGxldCBwb3NEWCA9IHBvczAueCAtIHBvczEueCwgcG9zRFkgPSBwb3MwLnkgLSBwb3MxLnk7XG5cblx0bGV0IGRpck1hZyA9IGRpckRYKmRpckRYICsgZGlyRFkqZGlyRFk7XG5cdGxldCByZWYgPSAyLjAgKiAocG9zRFggKiBkaXJEWCArIHBvc0RZICogZGlyRFkpO1xuXHRsZXQgZDJkID0gcG9zRFggKiBwb3NEWCArIHBvc0RZICogcG9zRFkgLSBTaXplICogU2l6ZTtcblxuXHRsZXQgZXBzID0gMC4wMDAxO1xuXG5cdGlmIChkMmQgPD0gMCkgcmV0dXJuIC0xO1xuXHRpZiAoTWF0aC5hYnMoZGlyTWFnKSA8IGVwcykgcmV0dXJuIDI7XG5cblx0aWYgKHJlZiA+PSAwKSByZXR1cm4gMjtcblxuXHRsZXQgdCA9IHJlZipyZWYgLSA0KmRpck1hZypkMmQ7XG5cdGlmICh0IDwgMCkgcmV0dXJuIDI7XG5cblx0bGV0IHMgPSAtMC41ICogKHJlZiAtIE1hdGguc3FydCh0KSk7XG5cdHJldHVybiBNYXRoLm1pbihzIC8gZGlyTWFnLCBkMmQgLyBzKTtcbn07XG5cbmV4cG9ydHMucmF5Y2FzdFRpbWVMaW5lID0gcmF5Y2FzdFRpbWVMaW5lO1xuZnVuY3Rpb24gcmF5Y2FzdFRpbWVMaW5lKHJheVBvcywgcmF5RGlyLCBwMCwgcDEsIHNpemUpIHtcblx0bGV0IHNlZ0RpclggPSBwMS54IC0gcDAueCwgc2VnRGlyWSA9IHAxLnkgLSBwMC55O1xuXHRsZXQgc2VnTGVuID0gTWF0aC5zcXJ0KHNlZ0Rpclgqc2VnRGlyWCArIHNlZ0Rpclkqc2VnRGlyWSk7XG5cblx0QVNTRVJUKHNlZ0xlbiAhPT0gMCk7XG5cblx0c2VnRGlyWCAvPSBzZWdMZW47XG5cdHNlZ0RpclkgLz0gc2VnTGVuO1xuXG5cdGxldCBzZWdOb3JtWCA9IC1zZWdEaXJZO1xuXHRsZXQgc2VnTm9ybVkgPSAgc2VnRGlyWDtcblxuXHRsZXQgZnggPSByYXlQb3MueCAtIHAwLng7XG5cdGxldCBmeSA9IHJheVBvcy55IC0gcDAueTtcblxuXHRsZXQgcG5mID0gc2VnTm9ybVggKiBmeCArIHNlZ05vcm1ZICogZnk7XG5cdGxldCBwbnIgPSBzZWdOb3JtWCAqIHJheURpci54ICsgc2VnTm9ybVkgKiByYXlEaXIueTtcblxuXHRsZXQgZnNwID0gc2VnRGlyWCAqIGZ4ICsgc2VnRGlyWSAqIGZ5O1xuXG5cdGxldCBkaXN0ID0gTWF0aC5hYnMocG5mKSAtIHNpemU7XG5cblx0aWYgKGRpc3QgPCAwKSB7XG5cdFx0cmV0dXJuIGZzcCA8IDAgfHwgZnNwID4gc2VnTGVuID8gMiA6IC0xO1xuXHR9XG5cblx0aWYgKHBuZiAqIHBuciA+PSAwKSB7XG5cdFx0cmV0dXJuIDI7XG5cdH1cblxuXHRsZXQgdGltZSA9IGRpc3QgLyBNYXRoLmFicyhwbnIpO1xuXHRsZXQgc2VncmF5ID0gc2VnRGlyWCAqIHJheURpci54ICsgc2VnRGlyWSAqIHJheURpci55O1xuXHRsZXQgdCA9IGZzcCArIHRpbWUgKiBzZWdyYXk7XG5cblx0cmV0dXJuIHQgPCAwIHx8IHQgPiBzZWdMZW4gPyAyIDogdGltZTtcbn1cblxuLy8gaG0uLi5cbmV4cG9ydHMuVmVjMiA9IHJlcXVpcmUoJy4vdmVjMicpO1xuXG5cbmV4cG9ydHMuYmV0d2VlbkkgPSBiZXR3ZWVuSTtcbmZ1bmN0aW9uIGJldHdlZW5JKG4sIGxvLCBoaSkgeyByZXR1cm4gbiA+PSBsbyAmJiBuIDw9IGhpOyB9XG5cbmV4cG9ydHMuYmV0d2VlblggPSBleHBvcnRzLmJldHdlZW4gPSBiZXR3ZWVuWDtcbmZ1bmN0aW9uIGJldHdlZW5YKG4sIGxvLCBoaSkgeyByZXR1cm4gbiA+IGxvICYmIG4gPCBoaTsgfVxuXG5leHBvcnRzLmJldHdlZW5YSSA9IGJldHdlZW5YSTtcbmZ1bmN0aW9uIGJldHdlZW5YSShuLCBsbywgaGkpIHsgcmV0dXJuIG4gPiBsbyAmJiBuIDw9IGhpOyB9XG5cbmV4cG9ydHMuYmV0d2VlbklYID0gYmV0d2VlbklYO1xuZnVuY3Rpb24gYmV0d2VlbklYKG4sIGxvLCBoaSkgeyByZXR1cm4gbiA+PSBsbyAmJiBuIDwgaGk7IH1cbiIsIid1c2Ugc3RyaWN0JztcbmNvbnN0IEVudGl0eSA9IHJlcXVpcmUoJy4vZW50aXR5Jyk7XG5jb25zdCBJbnB1dCA9IHJlcXVpcmUoJy4vaW5wdXQnKTtcbmNvbnN0IGRyYXdpbmcgPSByZXF1aXJlKCcuL2RyYXdpbmcnKTtcbmNvbnN0IENvbnN0cyA9IHJlcXVpcmUoJy4vY29uc3RhbnRzJyk7XG5jb25zdCBDbG9jayA9IHJlcXVpcmUoJy4vY2xvY2snKTtcbmNvbnN0IHtSTkd9ID0gcmVxdWlyZSgnLi9yYW5kJylcbmNvbnN0IG1hdGggPSByZXF1aXJlKCcuL21hdGgnKTtcblxuXG5jbGFzcyBQYXJ0aWNsZSBleHRlbmRzIEVudGl0eSB7XG5cdGNvbnN0cnVjdG9yKGdhbWUsIHg9MC4wLCB5PTAuMCwgej0wLjApIHtcblx0XHRzdXBlcihnYW1lLCB4LCB5LCB6KTtcblx0XHR0aGlzLmNvbGxpZGVzV2l0aEVudGl0aWVzID0gZmFsc2U7XG5cdFx0dGhpcy5jb2xsaWRlc1dpdGhQbGF5ZXIgPSBmYWxzZTtcblx0XHR0aGlzLnJhZGl1cyA9IDE7XG5cdFx0dGhpcy5kcmFnLnNldCgxLCAxKTtcblxuXHRcdHRoaXMuaGFzWiA9IHRydWU7XG5cdFx0dGhpcy56RHJhZyA9IDAuNTtcblx0XHR0aGlzLmNvbG9yID0gMHhmZjAwMDAwMDtcblx0XHR0aGlzLmxpZmUgPSBSTkcuYmV0d2VlbkYoMC40LCAwLjgpO1xuXHRcdGRvIHtcblx0XHRcdHRoaXMudmVsLnggPSBSTkcuYmV0d2VlbkYoLTEuMCwgMS4wKTtcblx0XHRcdHRoaXMudmVsLnkgPSBSTkcuYmV0d2VlbkYoLTEuMCwgMS4wKTtcblx0XHR9IHdoaWxlICh0aGlzLnZlbC5sZW5TcSgpID4gMS4wKTtcblx0XHR0aGlzLnZlbC54ICo9IDYwO1xuXHRcdHRoaXMudmVsLnkgKj0gNjA7XG5cdFx0dGhpcy56QWNjID0gLTYwO1xuXHR9XG5cblx0dXBkYXRlKGR0KSB7XG5cdFx0c3VwZXIudXBkYXRlKGR0KTtcblx0XHR0aGlzLmxpZmUgLT0gZHQ7XG5cdFx0aWYgKHRoaXMubGlmZSA8PSAwKSB7XG5cdFx0XHR0aGlzLmVuYWJsZWQgPSBmYWxzZTtcblx0XHR9XG5cdH1cblx0cG9zdFVwZGF0ZShkdCkge1xuXHRcdHRoaXMuYWNjLnNldCgwLCAwKTtcblx0XHR0aGlzLnpBY2MgPSAtNjA7XG5cdH1cblxuXHRyZW5kZXIoY3R4LCBidWZmZXIsIG1pblgsIG1pblkpIHtcblx0XHRsZXQge3dpZHRoLCBoZWlnaHR9ID0gYnVmZmVyO1xuXHRcdGxldCB4ID0gTWF0aC5yb3VuZCh0aGlzLnBvcy54LW1pblgpO1xuXHRcdGxldCB5ID0gTWF0aC5yb3VuZCh0aGlzLnBvcy55LW1pblkpOy8vLXRoaXMuelBvcyk7IC8vIG5vIHZpc3VhbCByZXByZXNlbnRhdGlvbiBmb3IgelxuXHRcdGlmICgoeCA+Pj4gMCkgPj0gd2lkdGgpIHJldHVybjtcblx0XHRpZiAoKHkgPj4+IDApID49IGhlaWdodCkgcmV0dXJuO1xuXHRcdGxldCB7cGl4ZWxzfSA9IGJ1ZmZlci5nZXRQaXhidWYoKTtcblx0XHRsZXQgYyA9IHRoaXMuY29sb3IgPj4+IDA7XG5cdFx0aWYgKHRoaXMucmFkaXVzIDwgMS4wKSB7XG5cdFx0XHRwaXhlbHNbeCt5KndpZHRoXSA9IGM7XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXHRcdGxldCB4MCA9IG1hdGguY2xhbXAoTWF0aC5yb3VuZCh4LXRoaXMucmFkaXVzKSwgMCwgd2lkdGgtMSk+Pj4wO1xuXHRcdGxldCB4MSA9IG1hdGguY2xhbXAoTWF0aC5yb3VuZCh4K3RoaXMucmFkaXVzKSwgMCwgd2lkdGgtMSk+Pj4wO1xuXHRcdGxldCB5MCA9IG1hdGguY2xhbXAoTWF0aC5yb3VuZCh5LXRoaXMucmFkaXVzKSwgMCwgaGVpZ2h0LTEpPj4+MDtcblx0XHRsZXQgeTEgPSBtYXRoLmNsYW1wKE1hdGgucm91bmQoeSt0aGlzLnJhZGl1cyksIDAsIGhlaWdodC0xKT4+PjA7XG5cdFx0Zm9yIChsZXQgeXkgPSB5MDsgeXkgPCB5MTsgKyt5eSkge1xuXHRcdFx0bGV0IHJvdyA9ICh5eSp3aWR0aCkgPj4+IDA7XG5cdFx0XHRmb3IgKGxldCB4eCA9IHgwOyB4eCA8IHgxOyArK3h4KSB7XG5cdFx0XHRcdHBpeGVsc1t4eCtyb3ddID0gYztcblx0XHRcdH1cblx0XHR9XG5cdH1cblxuXG59XG5cbm1vZHVsZS5leHBvcnRzID0gUGFydGljbGU7XG4iLCIndXNlIHN0cmljdCc7XG5cbmxldCB7Y3JlYXRlQ2FudmFzfSA9IHJlcXVpcmUoJy4vdXRpbCcpXG5sZXQgbWF0aCA9IHJlcXVpcmUoJy4vbWF0aCcpO1xuY2xhc3MgUGl4ZWxCdWZmZXIge1xuXHRjb25zdHJ1Y3Rvcih3aWR0aCwgaGVpZ2h0LCB0cmFja0JvdW5kcz1mYWxzZSkge1xuXHRcdHRoaXMud2lkdGggPSB3aWR0aDtcblx0XHR0aGlzLmhlaWdodCA9IGhlaWdodDtcblx0XHR0aGlzLmNhbnZhcyA9IGNyZWF0ZUNhbnZhcyh0aGlzLndpZHRoLCB0aGlzLmhlaWdodCk7XG5cdFx0dGhpcy5jb250ZXh0ID0gdGhpcy5jYW52YXMuZ2V0Q29udGV4dCgnMmQnKTtcblx0XHR0aGlzLmltYWdlRGF0YSA9IHRoaXMuY29udGV4dC5jcmVhdGVJbWFnZURhdGEodGhpcy53aWR0aCwgdGhpcy5oZWlnaHQpO1xuXHRcdHRoaXMucGl4ZWxzID0gbmV3IFVpbnQzMkFycmF5KHRoaXMuaW1hZ2VEYXRhLmRhdGEuYnVmZmVyKTtcblx0XHR0aGlzLmJvdW5kcyA9IHttaW5YOiB3aWR0aCwgbWluWTogaGVpZ2h0LCBtYXhYOiAwLCBtYXhZOiAwfTsgLy8gZGlydHkgcmVjdFxuXHRcdHRoaXMudHJhY2tCb3VuZHMgPSB0cmFja0JvdW5kcztcblx0XHR0aGlzLnBpeGVsc0RpcnR5ID0gZmFsc2U7XG5cdH1cblxuXHRyZXNldCgpIHtcblx0XHR0aGlzLnJlc2V0Qm91bmRzKCk7XG5cdFx0Zm9yIChsZXQgaSA9IDAsIHBpeCA9IHRoaXMucGl4ZWxzLCBsZW4gPSBwaXgubGVuZ3RoOyBpIDwgbGVuOyArK2kpIHtcblx0XHRcdHBpeFtpXSA9IDA7XG5cdFx0fVxuXHR9XG5cblx0cmVmcmVzaEltYWdlRGF0YSgpIHtcblx0XHR0aGlzLmltYWdlRGF0YSA9IHRoaXMuY29udGV4dC5nZXRJbWFnZURhdGEoMCwgMCwgdGhpcy53aWR0aCwgdGhpcy5oZWlnaHQpO1xuXHRcdHRoaXMucGl4ZWxzID0gbmV3IFVpbnQzMkFycmF5KHRoaXMuaW1hZ2VEYXRhLmRhdGEuYnVmZmVyKTtcblx0fVxuXG5cdHJlc2V0Qm91bmRzKCkge1xuXHRcdHRoaXMuYm91bmRzLm1pblggPSB0aGlzLndpZHRoO1xuXHRcdHRoaXMuYm91bmRzLm1pblkgPSB0aGlzLmhlaWdodDtcblx0XHR0aGlzLmJvdW5kcy5tYXhYID0gMDtcblx0XHR0aGlzLmJvdW5kcy5tYXhZID0gMDtcblx0fVxuXG5cdHVwZGF0ZShjbGVhcj10cnVlKSB7XG5cdFx0aWYgKGNsZWFyKSB0aGlzLmNvbnRleHQuY2xlYXJSZWN0KDAsIDAsIHRoaXMud2lkdGgsIHRoaXMuaGVpZ2h0KTtcblx0XHR0aGlzLmNvbnRleHQucHV0SW1hZ2VEYXRhKHRoaXMuaW1hZ2VEYXRhLCAwLCAwKTtcblx0fVxuXG5cdHB1dFBpeGVsKHgsIHksIHYpIHtcblx0XHRpZiAoKHggPj4+IDApIDwgdGhpcy53aWR0aCAmJiAoeSA+Pj4gMCkgPCB0aGlzLmhlaWdodCkge1xuXHRcdFx0dGhpcy5waXhlbHNEaXJ0eSA9IHRydWU7XG5cdFx0XHR0aGlzLnBpeGVsc1t4K3kqdGhpcy53aWR0aF0gPSB2O1xuXHRcdFx0aWYgKHRoaXMudHJhY2tCb3VuZHMpIHtcblx0XHRcdFx0dGhpcy5ib3VuZHMubWluWCA9IE1hdGgubWluKHRoaXMuYm91bmRzLm1pblgsIHgpO1xuXHRcdFx0XHR0aGlzLmJvdW5kcy5tYXhYID0gTWF0aC5tYXgodGhpcy5ib3VuZHMubWF4WCwgeCk7XG5cdFx0XHRcdHRoaXMuYm91bmRzLm1pblkgPSBNYXRoLm1pbih0aGlzLmJvdW5kcy5taW5ZLCB5KTtcblx0XHRcdFx0dGhpcy5ib3VuZHMubWF4WSA9IE1hdGgubWF4KHRoaXMuYm91bmRzLm1heFksIHkpO1xuXHRcdFx0fVxuXHRcdH1cblx0fVxuXHRnZXRQaXhidWYoKSB7XG5cdFx0dGhpcy5waXhlbHNEaXJ0eSA9IHRydWU7XG5cdFx0cmV0dXJuIHRoaXM7XG5cdH1cblxuXHRpbkJvdW5kcyh4LCB5KSB7XG5cdFx0cmV0dXJuICh4ID4+PiAwKSA8IHRoaXMud2lkdGggJiYgKHkgPj4+IDApIDwgdGhpcy5oZWlnaHQ7XG5cdH1cblxuXHRnZXRQaXhlbCh4LCB5KSB7XG5cdFx0aWYgKCh4ID4+PiAwKSA8IHRoaXMud2lkdGggJiYgKHkgPj4+IDApIDwgdGhpcy5oZWlnaHQpIHtcblx0XHRcdHJldHVybiB0aGlzLnBpeGVsc1t4K3kqdGhpcy53aWR0aF07XG5cdFx0fVxuXHRcdHJldHVybiAwO1xuXHR9XG5cblx0YnJlc2VuaGFtKHgwLCB5MCwgeDEsIHkxLCBjb2xvcikge1xuXHRcdHRoaXMucGl4ZWxzRGlydHkgPSB0cnVlO1xuXHRcdHgwID0geDB8MDtcblx0XHR5MCA9IHkwfDA7XG5cdFx0eDEgPSB4MXwwO1xuXHRcdHkxID0geTF8MDtcblx0XHRjb2xvciA9IGNvbG9yfDA7XG5cdFx0dmFyIGR4ID0gTWF0aC5hYnMoeDEgLSB4MCl8MDtcblx0XHR2YXIgZHkgPSBNYXRoLmFicyh5MSAtIHkwKXwwO1xuXHRcdHZhciBzeCA9ICh4MCA8IHgxKSA/IDEgOiAtMTtcblx0XHR2YXIgc3kgPSAoeTAgPCB5MSkgPyAxIDogLTE7XG5cdFx0dmFyIGVyciA9IGR4IC0gZHk7XG5cdFx0dmFyIHBpeGVscyA9IHRoaXMucGl4ZWxzO1xuXHRcdHZhciB3aWR0aCA9IHRoaXMud2lkdGg+Pj4wO1xuXHRcdHZhciBoZWlnaHQgPSB0aGlzLmhlaWdodD4+PjA7XG5cdFx0aWYgKHgwID49IDAgJiYgeDAgPCB3aWR0aCAmJiB5MCA+PSAwICYmIHkwIDwgaGVpZ2h0KSB7XG5cdFx0XHRwaXhlbHNbeDAreTAqd2lkdGhdID0gY29sb3I7XG5cdFx0fVxuXHRcdGVsc2UgaWYgKHgxIDwgMCB8fCB4MSA+PSB3aWR0aCB8fCB5MSA8IDAgJiYgeTEgPj0gaGVpZ2h0KSB7XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXG5cdFx0dGhpcy5ib3VuZHMubWluWCA9IE1hdGgubWluKHRoaXMuYm91bmRzLm1pblgsIHgwLCB4MSk7XG5cdFx0dGhpcy5ib3VuZHMubWF4WCA9IE1hdGgubWF4KHRoaXMuYm91bmRzLm1heFgsIHgwLCB4MSk7XG5cdFx0dGhpcy5ib3VuZHMubWluWSA9IE1hdGgubWluKHRoaXMuYm91bmRzLm1pblksIHkwLCB5MSk7XG5cdFx0dGhpcy5ib3VuZHMubWF4WSA9IE1hdGgubWF4KHRoaXMuYm91bmRzLm1heFksIHkwLCB5MSk7XG5cblx0XHRwaXhlbHNbeDAreTAqd2lkdGhdID0gY29sb3I7XG5cdFx0d2hpbGUgKHgwICE9PSB4MSAmJiB5MCAhPT0geTEpIHtcblx0XHRcdHZhciBlMiA9IGVyciA8PCAxO1xuXHRcdFx0aWYgKGUyID4gLWR5KSB7XG5cdFx0XHRcdGVyciAtPSBkeTtcblx0XHRcdFx0eDAgKz0gc3g7XG5cdFx0XHRcdGlmICh4MCA8IDAgfHwgeDAgPiB3aWR0aCkge1xuXHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0XHRpZiAoZTIgPCAgZHgpIHtcblx0XHRcdFx0ZXJyICs9IGR4O1xuXHRcdFx0XHR5MCArPSBzeTtcblx0XHRcdFx0aWYgKHkwIDwgMCB8fCB5MCA+IGhlaWdodCkge1xuXHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0XHRwaXhlbHNbeDAreTAqd2lkdGhdID0gY29sb3I7XG5cdFx0fVxuXHR9XG5cblx0d2l0aFJlcGxhY2VkQ29sb3JzKHJlcGxhY2VtZW50cykge1xuXHRcdGxldCBwYiA9IG5ldyBQaXhlbEJ1ZmZlcih0aGlzLndpZHRoLCB0aGlzLmhlaWdodCk7XG5cdFx0bGV0IHBicGl4ID0gcGIucGl4ZWxzO1xuXHRcdGxldCBvd25QaXggPSB0aGlzLnBpeGVscztcblx0XHRmb3IgKGxldCBpID0gMDsgaSA8IG93blBpeC5sZW5ndGg7ICsraSkge1xuXHRcdFx0bGV0IHBpeGVsID0gb3duUGl4W2ldID4+PiAwO1xuXHRcdFx0cGJwaXhbaV0gPSBwaXhlbDtcblx0XHRcdGZvciAobGV0IHIgPSAwOyByIDwgcmVwbGFjZW1lbnRzLmxlbmd0aDsgKytyKSB7XG5cdFx0XHRcdGxldCBzZWFyY2ggPSByZXBsYWNlbWVudHNbcl1bMF0gPj4+IDA7XG5cdFx0XHRcdGlmIChwaXhlbCA9PT0gc2VhcmNoKSB7XG5cdFx0XHRcdFx0cGJwaXhbaV0gPSByZXBsYWNlbWVudHNbcl1bMV0gPj4+IDBcblx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblx0XHRwYi51cGRhdGUoKTtcblx0XHRyZXR1cm4gcGI7XG5cdH1cbn1cblxuUGl4ZWxCdWZmZXIuZnJvbUltYWdlID0gZnVuY3Rpb24oaW1hZ2UpIHtcblx0bGV0IHBiID0gbmV3IFBpeGVsQnVmZmVyKGltYWdlLndpZHRoLCBpbWFnZS5oZWlnaHQpO1xuXHRwYi5jb250ZXh0LmRyYXdJbWFnZShpbWFnZSwgMCwgMCk7XG5cdHBiLnJlZnJlc2hJbWFnZURhdGEoKTtcblx0cmV0dXJuIHBiO1xufTtcblxuUGl4ZWxCdWZmZXIuZ2V0Um90YXRlZFRpbGVzID0gZnVuY3Rpb24oaW1hZ2UsIHRpbGVTaXplLCByb3RhdGlvbnM9MTYpIHtcblx0bGV0IHBiID0gUGl4ZWxCdWZmZXIuZnJvbUltYWdlKGltYWdlKTtcblx0bGV0IHJlc3VsdCA9IG5ldyBQaXhlbEJ1ZmZlcihwYi53aWR0aCwgcGIuaGVpZ2h0ICogcm90YXRpb25zKTtcblx0bGV0IG51bVRpbGVzID0gTWF0aC5mbG9vcihpbWFnZS53aWR0aCAvIHRpbGVTaXplKTtcblx0Zm9yIChsZXQgcm90ID0gMDsgcm90IDwgcm90YXRpb25zOyArK3JvdCkge1xuXHRcdGxldCBhbmdsZSA9IChyb3QgLyByb3RhdGlvbnMpICogMiAqIE1hdGguUEk7XG5cdFx0bGV0IHNhID0gTWF0aC5zaW4oYW5nbGUpO1xuXHRcdGxldCBjYSA9IE1hdGguY29zKGFuZ2xlKTtcblx0XHRsZXQgeU9mZnNldCA9IHJvdCp0aWxlU2l6ZTtcblx0XHRmb3IgKGxldCB0aWxlID0gMDsgdGlsZSA8IG51bVRpbGVzOyArK3RpbGUpIHtcblx0XHRcdGxldCB4T2Zmc2V0ID0gdGlsZSp0aWxlU2l6ZTtcblx0XHRcdGZvciAobGV0IGogPSAwOyBqIDwgdGlsZVNpemU7ICsraikge1xuXHRcdFx0XHRmb3IgKGxldCBpID0gMDsgaSA8IHRpbGVTaXplOyArK2kpIHtcblx0XHRcdFx0XHRsZXQgcHggPSBNYXRoLmZsb29yKGNhKihpLXRpbGVTaXplLzIpICsgc2EqKGotdGlsZVNpemUvMikgKyB0aWxlU2l6ZS8yKTtcblx0XHRcdFx0XHRsZXQgcHkgPSBNYXRoLmZsb29yKGNhKihqLXRpbGVTaXplLzIpIC0gc2EqKGktdGlsZVNpemUvMikgKyB0aWxlU2l6ZS8yKTtcblx0XHRcdFx0XHRweCA9IG1hdGguY2xhbXAocHgsIDAsIHRpbGVTaXplLTEpO1xuXHRcdFx0XHRcdHB5ID0gbWF0aC5jbGFtcChweSwgMCwgdGlsZVNpemUtMSk7XG5cdFx0XHRcdFx0cmVzdWx0LnB1dFBpeGVsKHhPZmZzZXQraSwgeU9mZnNldCtqLCBwYi5nZXRQaXhlbCh4T2Zmc2V0K3B4LCBweSkpO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXHR9XG5cdHJlc3VsdC51cGRhdGUoKTtcblx0cmV0dXJuIHJlc3VsdDtcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gUGl4ZWxCdWZmZXI7XG4iLCIndXNlIHN0cmljdCc7XG5cbmNvbnN0IHtUd2VlbiwgVHdlZW5Hcm91cH0gPSByZXF1aXJlKCcuL3R3ZWVucycpXG5jb25zdCBFbnRpdHkgPSByZXF1aXJlKCcuL2VudGl0eScpO1xuY29uc3QgSW5wdXQgPSByZXF1aXJlKCcuL2lucHV0Jyk7XG5jb25zdCB7Uk5HfSA9IHJlcXVpcmUoJy4vcmFuZCcpO1xuY29uc3QgZHJhd2luZyA9IHJlcXVpcmUoJy4vZHJhd2luZycpO1xuY29uc3QgQ29uc3RzID0gcmVxdWlyZSgnLi9jb25zdGFudHMnKTtcbmNvbnN0IENsb2NrID0gcmVxdWlyZSgnLi9jbG9jaycpO1xuY29uc3QgQnVsbGV0ID0gcmVxdWlyZSgnLi9idWxsZXQnKTtcbmNvbnN0IEdvcmUgPSByZXF1aXJlKCcuL2dvcmUnKTtcbmNvbnN0IEJsb29kID0gcmVxdWlyZSgnLi9ibG9vZCcpO1xuY29uc3QgU291bmRzID0gcmVxdWlyZSgnLi9hdWRpbycpO1xuY2xhc3MgUGxheWVyIGV4dGVuZHMgRW50aXR5IHtcblx0Y29uc3RydWN0b3IoZ2FtZSkge1xuXHRcdHN1cGVyKGdhbWUpO1xuXHRcdHRoaXMucmFkaXVzID0gNS4wO1xuXHRcdHRoaXMubm9ybWFsaXplQWNjZWwgPSB0cnVlO1xuXHRcdHRoaXMuc3BlZWQgPSAyMCoyMDtcblx0XHR0aGlzLmRyYWcuc2V0KDUsIDUpO1xuXHRcdHRoaXMud2Fsa2luZyA9IGZhbHNlO1xuXHRcdHRoaXMuYW5pbVByb2dyZXNzID0gMC4wO1xuXHRcdHRoaXMuaGVhbHRoID0gNTA7XG5cdFx0dGhpcy5tYXhIZWFsdGggPSA1MDtcblx0fVxuXG5cdGRhbWFnZShhbXQsIHBvcywgdmVsKSB7XG5cdFx0bGV0IGdpYiA9IG5ldyBHb3JlKHRoaXMuZ2FtZSwgcG9zLngsIHBvcy55KTtcblx0XHRnaWIudmVsLnNjYWxlKDAuMSkuYWRkU2NhbGVkKHZlbCwgMC40KTtcblx0XHR0aGlzLnZlbC5hZGRTY2FsZWQodmVsLCAwLjMpO1xuXHRcdHRoaXMuZ2FtZS5hZGRFbnRpdHkoZ2liKTtcblx0XHR0aGlzLmhlYWx0aCAtPSBhbXQ7XG5cdFx0aWYgKHRoaXMuaGVhbHRoIDw9IDApIHtcblx0XHRcdFNvdW5kcy5wbGF5KCdkaWUnKTtcblx0XHRcdHRoaXMuZ2FtZS5raWxsUGxheWVyKClcblx0XHR9IGVsc2Uge1xuXHRcdFx0U291bmRzLnBsYXkoJ291Y2gnKTtcblx0XHR9XG5cdH1cblxuXHR0aGluayhkdCkge1xuXHRcdGlmICh0aGlzLndhbGtpbmcpIHtcblx0XHRcdHRoaXMuYW5pbVByb2dyZXNzICs9IE1hdGgubWluKHRoaXMubGFzdFBvcy5kaXN0YW5jZSh0aGlzLnBvcykvMTAsIDEpO1xuXHRcdH1cblx0XHRsZXQge3g6bXd4LCB5Om13eX0gPSB0aGlzLmdhbWUubW91c2U7XG5cdFx0bGV0IGZ5ID0gbXd5LXRoaXMucG9zLnk7XG5cdFx0bGV0IGZ4ID0gbXd4LXRoaXMucG9zLng7XG5cdFx0bGV0IGxlbiA9IE1hdGguc3FydChmeCpmeCtmeSpmeSk7XG5cblx0XHRpZiAodGhpcy5oZWFsdGggPiAwKSB7XG5cdFx0XHRpZiAoSW5wdXQubW91c2UuaXNEb3duICYmIGxlbiA+IDEgJiYgIUlucHV0LmtleWJvYXJkLmlzRG93bignc3BhY2UnKSkge1xuXHRcdFx0XHR0aGlzLmFjYy5zZXQoKG13eC10aGlzLnBvcy54KS9Db25zdHMuVGlsZVNpemUsIChtd3ktdGhpcy5wb3MueSkvQ29uc3RzLlRpbGVTaXplKTtcblx0XHRcdFx0dGhpcy53YWxraW5nID0gdHJ1ZTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdHRoaXMud2Fsa2luZyA9IGZhbHNlO1xuXHRcdFx0XHR0aGlzLmFuaW1Qcm9ncmVzcyA9IDAuMDtcblx0XHRcdFx0dGhpcy5hY2Muc2V0KDAuMCwgMC4wKTtcblx0XHRcdH1cblxuXHRcdFx0dGhpcy5oZWFkaW5nID0gTWF0aC5hdGFuMihmeSwgZngpO1xuXHRcdFx0aWYgKElucHV0Lm1vdXNlLndhc1ByZXNzZWQoKSAmJiBJbnB1dC5rZXlib2FyZC5pc0Rvd24oJ3NwYWNlJykpIHtcblx0XHRcdFx0bGV0IGJ1bGxldCA9IG5ldyBCdWxsZXQodGhpcy5nYW1lLCB0aGlzLCBmeC9sZW4sIGZ5L2xlbiwgMTApO1xuXHRcdFx0XHR0aGlzLmdhbWUuYWRkRW50aXR5KGJ1bGxldCk7XG5cdFx0XHR9XG5cdFx0fVxuXHRcdGlmICh0aGlzLmhlYWx0aCAhPSB0aGlzLm1heEhlYWx0aCkge1xuXHRcdFx0aWYgKFJORy54Q2hhbmNlSW5ZKHRoaXMubWF4SGVhbHRoLXRoaXMuaGVhbHRoLCB0aGlzLm1heEhlYWx0aCkpIHtcblx0XHRcdFx0bGV0IGJsb29kID0gbmV3IEJsb29kKHRoaXMuZ2FtZSwgdGhpcy5wb3MueCwgdGhpcy5wb3MueSk7XG5cdFx0XHRcdGJsb29kLnpQb3MgPSA1O1xuXHRcdFx0XHRibG9vZC52ZWwueCAqPSAwLjA1OyBibG9vZC52ZWwueCArPSB0aGlzLnZlbC54O1xuXHRcdFx0XHRibG9vZC52ZWwueSAqPSAwLjA1OyBibG9vZC52ZWwueSArPSB0aGlzLnZlbC55O1xuXHRcdFx0XHR0aGlzLmdhbWUuYWRkRW50aXR5KGJsb29kKTtcblx0XHRcdH1cblx0XHRcdGlmIChSTkcub25lQ2hhbmNlSW4oNjApKSB7XG5cdFx0XHRcdHRoaXMuaGVhbHRoID0gTWF0aC5taW4odGhpcy5oZWFsdGgrMSwgdGhpcy5tYXhIZWFsdGgpO1xuXHRcdFx0fVxuXHRcdH1cblx0fVxuXG5cdHJlbmRlcihsYXllciwgcGl4LCBtaW5YLCBtaW5ZKSB7XG5cdFx0aWYgKHRoaXMuaGVhbHRoIDw9IDApIHtcblx0XHRcdGxheWVyLmNvbnRleHQuZHJhd0ltYWdlKHRoaXMuZ2FtZS5hc3NldHMuZGVhZCxcblx0XHRcdFx0MCwgMCwgMzIsIDE2LCBNYXRoLnJvdW5kKHRoaXMucG9zLngtMTYpLCBNYXRoLnJvdW5kKHRoaXMucG9zLnktOCksIDMyLCAxNik7XG5cdFx0XHRsYXllci5jb250ZXh0LmRyYXdJbWFnZSh0aGlzLmdhbWUuYXNzZXRzLmRlYWQsXG5cdFx0XHRcdDAsIDE2LCAzMiwgMTYsIE1hdGgucm91bmQodGhpcy5wb3MueC0xNiksIE1hdGgucm91bmQodGhpcy5wb3MueS04KSwgMzIsIDE2KTtcblx0XHRcdHJldHVybjtcblx0XHR9XG5cdFx0bGV0IHJvdGF0aW9uID0gTWF0aC5yb3VuZCh0aGlzLmhlYWRpbmcgLyAoTWF0aC5QSSoyKSoxNikmMTU7XG5cdFx0bGV0IGFuaW0gPSAodGhpcy53YWxraW5nID8gTWF0aC5mbG9vcih0aGlzLmFuaW1Qcm9ncmVzcyU3KSA6IDApICsgMFxuXHRcdGxheWVyLmNvbnRleHQuc3Ryb2tlU3R5bGUgPSAnZ3JlZW4nO1xuXHRcdGxheWVyLmNvbnRleHQuZHJhd0ltYWdlKHRoaXMuZ2FtZS5hc3NldHMucGxheWVyUm90YXRpb25zLmNhbnZhcyxcblx0XHRcdDE2KmFuaW0sIDE2KnJvdGF0aW9uLCAxNiwgMTYsXG5cdFx0XHRNYXRoLnJvdW5kKHRoaXMucG9zLngtOCksXG5cdFx0XHRNYXRoLnJvdW5kKHRoaXMucG9zLnktOCksXG5cdFx0XHQxNiwgMTYpO1xuXG5cblx0XHQvLyBkcmF3aW5nLmRyYXdDaXJjbGUodGhpcy5nYW1lLmRlYnVnQ29udGV4dCwgdGhpcy5wb3MueCwgdGhpcy5wb3MueSwgdGhpcy5yYWRpdXMpO1xuXHRcdC8vKGxheWVyLmNvbnRleHQsIHRoaXMucG9zLngtbXgsIHRoaXMucG9zLnktbXksIHRoaXMucmFkaXVzKTtcblx0fVxuXG59XG5cbm1vZHVsZS5leHBvcnRzID0gUGxheWVyO1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG5jb25zdCBQQ0dSYW5kb20gPSByZXF1aXJlKCdwY2ctcmFuZG9tJyk7XG5jb25zdCBxdWlja05vaXNlID0gcmVxdWlyZSgncXVpY2stbm9pc2UtanMnKTtcblxuY29uc3QgUmFuZFV0aWxzID0ge1xuXHRuZXh0SW50KGEpIHsgcmV0dXJuIHRoaXMuaW50ZWdlcihhKTsgfSxcblx0cmFuZG9tKCkgeyByZXR1cm4gdGhpcy5udW1iZXIoKTsgfSxcblxuXHR1cFRvKGEpIHsgcmV0dXJuIHRoaXMuaW50ZWdlcihhKTsgfSxcblx0dXBUb0koYSkgeyByZXR1cm4gdGhpcy51cFRvKGErMSk7IH0sIC8vIGluY2x1c2l2ZVxuXHR1cFRvRihhKSB7IHJldHVybiB0aGlzLm51bWJlcigpICogYTsgfSxcblxuXHRiZXR3ZWVuRihtaW4sIG1heCkgeyByZXR1cm4gbWluICsgdGhpcy5udW1iZXIoKSAqIChtYXgtbWluKTsgfSxcblx0YmV0d2VlbkkobWluLCBtYXgpIHsgcmV0dXJuIG1pbiArIHRoaXMudXBUbyhtYXgtbWluKzEpOyB9LFxuXHRiZXR3ZWVuWChtaW4sIG1heCkgeyByZXR1cm4gbWluICsgdGhpcy51cFRvKG1heC1taW4pOyB9LFxuXG5cblx0b25lQ2hhbmNlSW4obikgeyByZXR1cm4gdGhpcy51cFRvKG4pID09PSAwOyB9LFxuXHRjb2luZmxpcCgpIHsgcmV0dXJuIHRoaXMub25lQ2hhbmNlSW4oMik7IH0sXG5cdHByb2JhYmlsaXR5KG4pIHsgcmV0dXJuIHRoaXMubnVtYmVyKCkgPCBuOyB9LFxuXG5cdHhDaGFuY2VJblkoeCwgeSkgeyByZXR1cm4gdGhpcy51cFRvKHkpIDwgeDsgfSxcblxuXHRjaG9vc2UoYXJyKSB7XG5cdFx0aWYgKGFyci5sZW5ndGggPT09IDApIHtcblx0XHRcdGNvbnNvbGUuZXJyb3IoXCJlbXB0eSBhcnJheSBpbiBjaG9vc2VcIik7XG5cdFx0XHRyZXR1cm4gbnVsbDtcblx0XHR9XG5cdFx0cmV0dXJuIGFyclt0aGlzLnVwVG8oYXJyLmxlbmd0aCldO1xuXHR9LFxuXG5cdHJvdW5kKHYpIHtcblx0XHRjb25zdCB2aSA9IE1hdGguZmxvb3Iodik7XG5cdFx0cmV0dXJuIHZpICsgdGhpcy5wcm9iYWJpbGl0eSh2LXZpKSA/IDEgOiAwO1xuXHR9LFxuXG5cdGRpY2VSb2xsKGNvdW50LCBzaXplKSB7XG5cdFx0aWYgKGNvdW50IDw9IDAgfHwgc2l6ZSA8PSAwKSByZXR1cm4gMDtcblx0XHRsZXQgcmVzdWx0ID0gY291bnQ7XG5cdFx0Zm9yIChsZXQgaSA9IDA7IGkgPCBjb3VudDsgKytpKSB7XG5cdFx0XHRyZXN1bHQgKz0gdGhpcy51cFRvKHNpemUpO1xuXHRcdH1cblx0XHRyZXR1cm4gcmVzdWx0O1xuXHR9LFxuXG5cdGJlc3RSb2xsKG1heCwgcm9sbHMpIHtcblx0XHRsZXQgYmVzdCA9IDA7XG5cdFx0Zm9yIChsZXQgaSA9IDA7IGkgPCByb2xsczsgKytpKSB7XG5cdFx0XHRiZXN0ID0gTWF0aC5tYXgodGhpcy51cFRvKG1heCksIGJlc3QpO1xuXHRcdH1cblx0XHRyZXR1cm4gYmVzdDtcblx0fSxcblxuXHRnYXVzc2lhbjAxKCkge1xuXHRcdGxldCB1ID0gMC4wLCB2ID0gMC4wLCByID0gMC4wO1xuXHRcdGRvIHtcblx0XHRcdHUgPSB0aGlzLm51bWJlcigpICogMi4wIC0gMS4wO1xuXHRcdFx0diA9IHRoaXMubnVtYmVyKCkgKiAyLjAgLSAxLjA7XG5cdFx0XHRyID0gdSp1ICsgdip2O1xuXHRcdH0gd2hpbGUgKHIgPT09IDAuMCB8fCByID4gMS4wKTtcblx0XHRjb25zdCBtdWwgPSBNYXRoLnNxcnQoLTIuMCAqIE1hdGgubG9nKHIpIC8gcik7XG5cdFx0cmV0dXJuIHUgKiBtdWw7XG5cdH0sXG5cblx0Z2F1c3NpYW4obWVhbiwgc3RkZGV2KSB7XG5cdFx0cmV0dXJuIHRoaXMuZ2F1c3NpYW4wMSgpICogc3RkZGV2ICsgbWVhbjtcblx0fSxcblxuXHR1bmlmb3JtKG1lYW49MC4wLCBoYWxmUmFuZ2U9MS4wKSB7XG5cdFx0cmV0dXJuIHRoaXMubnVtYmVyKCkgKiAoaGFsZlJhbmdlKjIuMCkgKyAobWVhbiAtIDEuMCk7XG5cdH0sXG5cblx0Y2hvb3NlSW5kZXhXZWlnaHRlZCh3ZWlnaHRzKSB7XG5cdFx0bGV0IGwgPSB3ZWlnaHRzLmxlbmd0aDtcblx0XHRpZiAobCA9PT0gMCkge1xuXHRcdFx0Y29uc29sZS5lcnJvcihcImVtcHR5IGFycmF5IHBhc3NlZCB0byBjaG9vc2VJbmRleFdlaWdodGVkXCIpO1xuXHRcdFx0cmV0dXJuIC0xO1xuXHRcdH1cblx0XHRsZXQgc3VtID0gMDtcblx0XHRmb3IgKGxldCBpID0gMDsgaSA8IGw7ICsraSlcblx0XHRcdHN1bSArPSB3ZWlnaHRzW2ldO1xuXHRcdHN1bSAqPSB0aGlzLm51bWJlcigpO1xuXHRcdGZvciAobGV0IGkgPSAwOyBpIDwgbDsgKytpKSB7XG5cdFx0XHRzdW0gLT0gd2VpZ2h0c1tpXTtcblx0XHRcdGlmIChzdW0gPD0gMC4wKVxuXHRcdFx0XHRyZXR1cm4gaTtcblx0XHR9XG5cdFx0Y29uc29sZS5lcnJvcihcImZlbGwgdGhyb3VnaCBjaG9pY2UgbG9vcFwiLCB3ZWlnaHRzKTtcblx0XHRyZXR1cm4gdGhpcy51cFRvKHdlaWdodHMubGVuZ3RoKTtcblx0fSxcblxuXHRjaG9vc2VXZWlnaHRlZEZuKGFyciwgZ2V0V2VpZ2h0KSB7XG5cdFx0bGV0IGwgPSBhcnIubGVuZ3RoO1xuXHRcdGlmIChsID09PSAwKSB7XG5cdFx0XHRjb25zb2xlLmVycm9yKFwiZW1wdHkgYXJyYXkgcGFzc2VkIHRvIGNob29zZVdlaWdodGVkRm5cIik7XG5cdFx0XHRyZXR1cm4gLTE7XG5cdFx0fVxuXHRcdGxldCBzdW0gPSAwO1xuXHRcdGZvciAobGV0IGkgPSAwOyBpIDwgbDsgKytpKVxuXHRcdFx0c3VtICs9IGdldFdlaWdodChhcnJbaV0pO1xuXHRcdHN1bSAqPSB0aGlzLm51bWJlcigpO1xuXHRcdGZvciAobGV0IGkgPSAwOyBpIDwgbDsgKytpKSB7XG5cdFx0XHRzdW0gLT0gZ2V0V2VpZ2h0KGFycltpXSk7XG5cdFx0XHRpZiAoc3VtIDw9IDAuMCkgcmV0dXJuIGk7XG5cdFx0fVxuXHRcdGNvbnNvbGUuZXJyb3IoXCJmZWxsIHRocm91Z2ggY2hvaWNlIGxvb3BcIiwgYXJyKTtcblx0XHRyZXR1cm4gdGhpcy51cFRvKGFyci5sZW5ndGgpO1xuXHR9LFxuXG5cdHNodWZmbGUoYXJyKSB7XG5cdFx0Zm9yIChsZXQgaSA9IGFyci5sZW5ndGgtMTsgaSA+IDA7IC0taSkge1xuXHRcdFx0bGV0IHIgPSB0aGlzLnVwVG9JKGkpO1xuXHRcdFx0bGV0IHRtcCA9IGFycltyXTsgYXJyW3JdID0gYXJyW2ldOyBhcnJbaV0gPSB0bXA7XG5cdFx0fVxuXHRcdHJldHVybiBhcnI7XG5cdH0sXG5cblx0Y29sb3JCZXR3ZWVuKGMwLCBjMSkge1xuXHRcdGxldCBhMCA9IGMwID4+PiAyNDtcblx0XHRsZXQgYjAgPSAoYzAgPj4+IDE2KSYweGZmO1xuXHRcdGxldCBnMCA9IChjMCA+Pj4gOCkmMHhmZjtcblx0XHRsZXQgcjAgPSBjMCAmIDB4ZmY7XG5cblx0XHRsZXQgYTEgPSBjMSA+Pj4gMjQ7XG5cdFx0bGV0IGIxID0gKGMxID4+PiAxNikmMHhmZjtcblx0XHRsZXQgZzEgPSAoYzEgPj4+IDgpJjB4ZmY7XG5cdFx0bGV0IHIxID0gYzEgJiAweGZmO1xuXG5cdFx0cmV0dXJuICgoUk5HLmJldHdlZW5JKGEwLCBhMSkgPDwgMjQpIHxcblx0XHQgICAgICAgIChSTkcuYmV0d2VlbkkoYjAsIGIxKSA8PCAxNikgfFxuXHRcdCAgICAgICAgKFJORy5iZXR3ZWVuSShnMCwgZzEpIDw8IDgpIHxcblx0XHQgICAgICAgIChSTkcuYmV0d2VlbkkocjAsIHIxKSkpO1xuXHR9XG59XG5cbk9iamVjdC5hc3NpZ24oUENHUmFuZG9tLnByb3RvdHlwZSwgUmFuZFV0aWxzKTtcblxuY29uc3QgUk5HID0gbmV3IFBDR1JhbmRvbSgpO1xuZXhwb3J0cy5STkcgPSBSTkc7XG5leHBvcnRzLlJOR1R5cGUgPSBQQ0dSYW5kb207XG5cbmNvbnN0IHBlcmxpbk5vaXNlID0gcXVpY2tOb2lzZS5ub2lzZTtcblxuZXhwb3J0cy5wZXJsaW5Ob2lzZSA9IHBlcmxpbk5vaXNlO1xuZXhwb3J0cy5vY3RhdmVOb2lzZSA9IG9jdGF2ZU5vaXNlO1xuXG5mdW5jdGlvbiBvY3RhdmVOb2lzZSh4LCB5LCB6LCBvY3RhdmVzPTMsIHBlcnNpc3RlbmNlPTAuNSkge1xuXHRsZXQgdG90YWwgPSAwLjA7XG5cdGxldCBmcmVxdWVuY3kgPSAxLjA7XG5cdGxldCBhbXBsaXR1ZGUgPSAxLjA7XG5cdGxldCBtYXhWYWx1ZSA9IDAuMDtcblx0Zm9yIChsZXQgaSA9IDA7IGkgPCBvY3RhdmVzOyArK2kpIHtcblx0XHR0b3RhbCArPSBwZXJsaW5Ob2lzZSh4ICogZnJlcXVlbmN5LCB5ICogZnJlcXVlbmN5LCB6ICogZnJlcXVlbmN5KSAqIGFtcGxpdHVkZTtcblx0XHRtYXhWYWx1ZSArPSBhbXBsaXR1ZGU7XG5cdFx0YW1wbGl0dWRlICo9IHBlcnNpc3RlbmNlO1xuXHRcdGZyZXF1ZW5jeSAqPSAyLjA7XG5cdH1cblx0cmV0dXJuIHRvdGFsIC8gbWF4VmFsdWU7XG59XG4iLCIndXNlIHN0cmljdCc7XG5jb25zdCB7Y29zLCBzaW4sIFBJLCBwb3csIHNxcnR9ID0gTWF0aDtcbmNvbnN0IHtSTkd9ID0gcmVxdWlyZSgnLi9yYW5kJyk7XG5jb25zdCBQcm9taXNlID0gcmVxdWlyZSgnYmx1ZWJpcmQnKTtcblxuY29uc3QgSEFMRl9QSSA9IFBJICogMC41O1xuY29uc3QgVFdPX1BJID0gUEkgKiAyLjA7XG5cbmNvbnN0IEVhc2VUeXBlSW4gPSAwO1xuY29uc3QgRWFzZVR5cGVPdXQgPSAxO1xuY29uc3QgRWFzZVR5cGVJbk91dCA9IDI7XG5jb25zdCBFYXNlVHlwZVNoYWtlID0gMztcblxuZXhwb3J0cy5FYXNlVHlwZSA9IHsgSW46IEVhc2VUeXBlSW4sIE91dDogRWFzZVR5cGVPdXQsIEluT3V0OiBFYXNlVHlwZUluT3V0LCBTaGFrZTogRWFzZVR5cGVTaGFrZSB9O1xuXG5mdW5jdGlvbiBib3VuY2VSZXZlcnNlKHQpIHtcblx0aWYgKHQgPCAxLjAgLyAyLjc1KSByZXR1cm4gNy41NjI1KnQqdDtcblx0ZWxzZSBpZiAodCA8IDIuMC8yLjc1KSB7IHQgLT0gMS41MC8yLjc1OyByZXR1cm4gNy41NjI1KnQqdCArIDAuNzU7IH1cblx0ZWxzZSBpZiAodCA8IDIuNS8yLjc1KSB7IHQgLT0gMi4yNS8yLjc1OyByZXR1cm4gNy41NjI1KnQqdCArIDAuOTM3NTsgfVxuXHRlbHNlIHsgdCAtPSAyLjYyNS8yLjc1OyByZXR1cm4gNy41NjI1KnQqdCArIDAuOTg0Mzc1OyB9XG59XG5cbmZ1bmN0aW9uIGJlemllcih0LCBwMCwgcDEsIHAyLCBwMykge1xuXHRjb25zdCBzID0gMS4wIC0gdDtcblx0cmV0dXJuIHMqcypzKnAwICsgMy4wKnQqcypzKnAxICsgMy4wKnQqdCpzKnAyICsgdCp0KnQqcDM7XG59XG5cbmZ1bmN0aW9uIGVhc2VMaW5lYXIodCkgeyByZXR1cm4gdDsgfVxuZnVuY3Rpb24gZWFzZVF1YWQodCkgeyByZXR1cm4gdCp0OyB9XG5mdW5jdGlvbiBlYXNlQ3ViaWModCkgeyByZXR1cm4gdCp0KnQ7IH1cbmZ1bmN0aW9uIGVhc2VRdWFydCh0KSB7IHJldHVybiB0KnQqdCp0OyB9XG5mdW5jdGlvbiBlYXNlUXVpbnQodCkgeyByZXR1cm4gdCp0KnQqdCp0OyB9XG5mdW5jdGlvbiBlYXNlRXhwbyh0KSB7IHJldHVybiBwb3coMi4wLCAxMC4wICogKHQgLSAxLjApKTsgfVxuZnVuY3Rpb24gZWFzZVNpbmUodCkgeyByZXR1cm4gLWNvcyhwICogSEFMRl9QSSkgKyAxLjA7IH1cbmZ1bmN0aW9uIGVhc2VDaXJjKHQpIHsgcmV0dXJuIC0oc3FydCgxLjAgLSAocCAqIHApKSAtIDEuMCk7IH1cbmZ1bmN0aW9uIGVhc2VCYWNrKHQpIHsgcmV0dXJuIHAgKiBwICogKDIuNyAqIHAgLSAxLjcpOyB9XG5mdW5jdGlvbiBlYXNlRWxhc3RpYyh0KSB7IHJldHVybiAtKHBvdygyLjAsIDEwLjAgKiAocCAtIDEuMCkpICogc2luKChwIC0gMS4wNzUpICogVFdPX1BJIC8gMC4zKSk7IH1cbmZ1bmN0aW9uIGVhc2VCb3VuY2UodCkgeyByZXR1cm4gMS4wIC0gYm91bmNlUmV2ZXJzZSgxLjAtdCk7IH1cbmZ1bmN0aW9uIGVhc2VaaWd6YWcodCkgeyByZXR1cm4gYmV6aWVyKHQsIDAuMCwgMi41LCAtMS41LCAxLjApOyB9XG5mdW5jdGlvbiBlYXNlU2hha2UodCkgeyByZXR1cm4gYmV6aWVyKHQsIDAuNSwgMS4yMiwgMS4yNSwgMC4wKTsgfVxuZnVuY3Rpb24gZWFzZVJ1YmJlcmJhbmQodCkgeyByZXR1cm4gYmV6aWVyKHQsIDAuMCwgMC43LCAxLjUsIDEuMCk7IH1cblxuY29uc3QgRWFzaW5ncyA9IGV4cG9ydHMuRWFzaW5ncyA9IHtcblx0bGluZWFyOiBlYXNlTGluZWFyLFxuXHRxdWFkOiBlYXNlUXVhZCxcblx0Y3ViaWM6IGVhc2VDdWJpYyxcblx0cXVhcnQ6IGVhc2VRdWFydCxcblx0cXVpbnQ6IGVhc2VRdWludCxcblx0ZXhwbzogZWFzZUV4cG8sXG5cdHNpbmU6IGVhc2VTaW5lLFxuXHRjaXJjOiBlYXNlQ2lyYyxcblx0YmFjazogZWFzZUJhY2ssXG5cdGVsYXN0aWM6IGVhc2VFbGFzdGljLFxuXHRib3VuY2U6IGVhc2VCb3VuY2UsXG5cdHppZ3phZzogZWFzZVppZ3phZyxcblx0c2hha2U6IGVhc2VTaGFrZSxcblx0cnViYmVyYmFuZDogZWFzZVJ1YmJlcmJhbmQsXG59O1xuXG5jb25zdCBvYmplY3RzID0gW107XG5cbmNsYXNzIFR3ZWVuIHtcblx0Y29uc3RydWN0b3Iob2JqZWN0LCBmaWVsZCwgeyBlbmQsIHN0YXJ0PW9iamVjdFtmaWVsZF0sIGR1cmF0aW9uPTEuMCwgZWFzaW5nPUVhc2luZ3MubGluZWFyLCB0eXBlPUVhc2VUeXBlSW4sIGxvb3A9ZmFsc2UsIHNuYXA9ZmFsc2UsIGVuYWJsZWRGaWVsZD0nJywgcmVzb2x2ZU9uRmluaXNoPXRydWUgfSkge1xuXHRcdHRoaXMub2JqZWN0ID0gb2JqZWN0O1xuXHRcdHRoaXMuZmllbGQgPSBmaWVsZDtcblx0XHR0aGlzLmVuZCA9IGVuZDtcblx0XHR0aGlzLnN0YXJ0ID0gc3RhcnQ7XG5cdFx0dGhpcy5kdXJhdGlvbiA9IGR1cmF0aW9uO1xuXHRcdHRoaXMuZWFzaW5nID0gdHlwZW9mIGVhc2luZyA9PT0gJ3N0cmluZycgPyBFYXNpbmdzW2Vhc2luZ10gOiBlYXNpbmc7XG5cdFx0dGhpcy50eXBlID0gdHlwZTtcblx0XHR0aGlzLmxvb3BlZCA9IGxvb3A7XG5cdFx0dGhpcy5zbmFwID0gc25hcDtcblx0XHR0aGlzLnRpbWUgPSAwLjA7XG5cdFx0dGhpcy5kZWZlcnJlZCA9IFByb21pc2UucGVuZGluZygpO1xuXHRcdHRoaXMucHJvbWlzZSA9IGRlZmVycmVkLnByb21pc2U7XG5cdFx0dGhpcy5vYmplY3RbdGhpcy5maWVsZF0gPSB0aGlzLnN0YXJ0O1xuXHRcdHRoaXMuZmluaXNoZWQgPSB0cnVlO1xuXHR9XG5cblx0dXBkYXRlKGRlbHRhVGltZSkge1xuXHRcdHRoaXMudGltZSArPSBkZWx0YVRpbWU7XG5cdFx0Y29uc3Qge3RpbWUsIGR1cmF0aW9uLCBvYmplY3QsIGZpZWxkLCBlYXNpbmcsIHN0YXJ0LCBlbmR9ID0gdGhpcztcblx0XHRpZiAodGltZSA+IGR1cmF0aW9uICYmICF0aGlzLmxvb3BlZCkge1xuXHRcdFx0b2JqZWN0W2ZpZWxkXSA9IHRoaXMuZW5kO1xuXHRcdFx0aWYgKHRoaXMucmVzb2x2ZU9uRmluaXNoKSB0aGlzLmRlZmVycmVkLnJlc29sdmUodGhpcy5vYmplY3QpO1xuXHRcdFx0cmV0dXJuIHRydWU7XG5cdFx0fVxuXHRcdGxldCB0ID0gMC4wO1xuXHRcdGxldCBwcm9ncmVzcyA9IHRpbWUgLyBkdXJhdGlvbjtcblx0XHRpZiAodGhpcy5sb29wZWQpIHtcblx0XHRcdHByb2dyZXNzID0gdGhpcy5sb29wZWQgPT09ICdwaW5ncG9uZycgPyBwaW5ncG9uZyhwcm9ncmVzcywgMS4wKSA6IHByb2dyZXNzICUgMS4wO1xuXHRcdH1cblx0XHRzd2l0Y2ggKHR5cGUpIHtcblx0XHRcdGNhc2UgRWFzZVR5cGVJbjogdCA9IGVhc2luZyhwcm9ncmVzcyk7IGJyZWFrO1xuXHRcdFx0Y2FzZSBFYXNlVHlwZU91dDogdCA9IDEuMCAtIGVhc2luZygxLjAgLSBwcm9ncmVzcyk7IGJyZWFrO1xuXHRcdFx0Y2FzZSBFYXNlVHlwZUluT3V0OiB0ID0gcHJvZ3Jlc3MgPCAwLjUgPyBlYXNpbmcocHJvZ3Jlc3MpIDogKDEuMCAtIGVhc2luZygxLjAgLSBwcm9ncmVzcykpOyBicmVhaztcblx0XHRcdGNhc2UgRWFzZVR5cGVTaGFrZTogdCA9IGVhc2luZyhwcm9ncmVzcykgKiBSTkcubnVtYmVyKCk7IGJyZWFrO1xuXHRcdFx0ZGVmYXVsdDogY29uc29sZS5lcnJvcihcImlsbGVnYWwgdmFsdWUgZm9yIHR5cGU6IFwiK3R5cGUpOyB0ID0gZWFzaW5nKHByb2dyZXNzKTsgYnJlYWs7XG5cdFx0fVxuXHRcdGxldCB2YWx1ZSA9IHN0YXJ0ICogKDEuMCAtIHQpICsgZW5kICogdDtcblx0XHRpZiAodGhpcy5zbmFwKSB7XG5cdFx0XHR2YWx1ZSA9IE1hdGgucm91bmQodmFsdWUpXG5cdFx0fVxuXHRcdG9iamVjdFtmaWVsZF0gPSB2YWx1ZTtcblx0XHRyZXR1cm4gZmFsc2U7XG5cdH1cblxuXHRjb21wbGV0ZSgpIHtcblx0XHRyZXR1cm4gdGhpcy5maW5pc2hlZCB8fCAodGhpcy5lbmFibGVkRmllbGQgJiYgIXRoaXMub2JqZWN0W3RoaXMuZW5hYmxlZEZpZWxkXSk7XG5cdH1cbn1cblxuY2xhc3MgVHdlZW5Hcm91cCB7XG5cdGNvbnN0cnVjdG9yKCkge1xuXHRcdHRoaXMudHdlZW5zID0gW107XG5cdFx0dGhpcy5yZXNvbHZlUXVldWVfID0gW107XG5cdH1cblxuXHRhZGQob2JqKSB7XG5cdFx0b2JqLnJlc29sdmVPbkZpbmlzaCA9IGZhbHNlO1xuXHRcdHRoaXMudHdlZW5zLnB1c2gob2JqKTtcblx0XHRyZXR1cm4gb2JqO1xuXHR9XG5cblx0dXBkYXRlKGRlbHRhVGltZSkge1xuXHRcdGxldCB0d2VlbnMgPSB0aGlzLnR3ZWVucztcblx0XHRsZXQgbCA9IHR3ZWVucy5sZW5ndGg7XG5cdFx0Zm9yIChsZXQgaSA9IDA7IGkgPCBsOyArK2kpIHtcblx0XHRcdHR3ZWVuc1tpXS51cGRhdGUoKTtcblx0XHR9XG5cdFx0bGV0IG5ld0xlbiA9IHR3ZWVucy5sZW5ndGgsIGogPSAwO1xuXHRcdHRoaXMucmVzb2x2ZVF1ZXVlXy5sZW5ndGggPSAwO1xuXHRcdGZvciAobGV0IGkgPSAwOyBpIDwgbDsgKytpKSB7XG5cdFx0XHRpZiAodHdlZW5zW2ldLmNvbXBsZXRlKCkpIHtcblx0XHRcdFx0dGhpcy5yZXNvbHZlUXVldWVfLnB1c2godHdlZW5zW2ldKTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdHRoaXMudHdlZW5zW2orK10gPSB0aGlzLnR3ZWVuc1tpXTtcblx0XHRcdH1cblx0XHR9XG5cdFx0dGhpcy50d2VlbnMubGVuZ3RoID0gaiArIE1hdGgubWF4KDAsIG5ld0xlbi1sKTtcblx0XHRmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMucmVzb2x2ZVF1ZXVlXy5sZW5ndGg7ICsraSkge1xuXHRcdFx0dGhpcy5yZXNvbHZlUXVldWVfW2ldLmRlZmVycmVkLnJlc29sdmUodGhpcy5yZXNvbHZlUXVldWVfW2ldLm9iamVjdCk7XG5cdFx0fVxuXHRcdHRoaXMucmVzb2x2ZVF1ZXVlXy5sZW5ndGggPSAwO1xuXHR9XG59XG5cblxuY29uc3QgVHdlZW5NYW5hZ2VyID0gbmV3IFR3ZWVuR3JvdXAoKTtcblxuZXhwb3J0cy5Ud2VlbiA9IFR3ZWVuO1xuZXhwb3J0cy5Ud2Vlbkdyb3VwID0gVHdlZW5Hcm91cDtcbmV4cG9ydHMuVHdlZW5NYW5hZ2VyID0gVHdlZW5NYW5hZ2VyO1xuXG4iLCIndXNlIHN0cmljdCc7XG5jb25zdCBQcm9taXNlID0gcmVxdWlyZSgnYmx1ZWJpcmQnKTtcblxuZXhwb3J0cy5jcmVhdGVDYW52YXMgPSBjcmVhdGVDYW52YXM7XG5mdW5jdGlvbiBjcmVhdGVDYW52YXMod2lkdGgsIGhlaWdodCkge1xuXHRsZXQgcmVzdWx0ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnY2FudmFzJyk7XG5cdHJlc3VsdC53aWR0aCA9IHdpZHRoO1xuXHRyZXN1bHQuaGVpZ2h0ID0gaGVpZ2h0O1xuXHRyZXR1cm4gcmVzdWx0O1xufVxuXG5leHBvcnRzLmNyZWF0ZUNvbnRleHQyRCA9IGNyZWF0ZUNvbnRleHQyRDtcbmZ1bmN0aW9uIGNyZWF0ZUNvbnRleHQyRCh3aWR0aCwgaGVpZ2h0KSB7XG5cdGxldCBjID0gY3JlYXRlQ2FudmFzKHdpZHRoLCBoZWlnaHQpO1xuXHRyZXR1cm4gYy5nZXRDb250ZXh0KCcyZCcpO1xufVxuXG5leHBvcnRzLmxvYWRJbWFnZSA9IGxvYWRJbWFnZTtcbmZ1bmN0aW9uIGxvYWRJbWFnZShzcmMpIHtcblx0cmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uKHJlc29sdmUsIHJlamVjdCkge1xuXHRcdHZhciBpbWFnZSA9IG5ldyBJbWFnZSgpO1xuXHRcdGltYWdlLm9ubG9hZCA9IGZ1bmN0aW9uKCkgeyByZXNvbHZlKGltYWdlKTsgfTtcblx0XHRpbWFnZS5vbmVycm9yID0gZnVuY3Rpb24oZSkge1xuXHRcdFx0Y29uc29sZS5sb2coZSk7XG5cdFx0XHRjb25zb2xlLmVycm9yKFwiRmFpbGVkIHRvIGxvYWQ6IFwiK3NyYylcblx0XHRcdHJlamVjdChlKTtcblx0XHR9O1xuXHRcdGltYWdlLnNyYyA9IHNyYztcblx0fSk7XG59XG5cbmV4cG9ydHMuZ2V0UmVxdWVzdCA9IGdldFJlcXVlc3Q7XG5mdW5jdGlvbiBnZXRSZXF1ZXN0KHNyYywgcHJlUmVxdWVzdD1udWxsKSB7XG5cdHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbihyZXNvbHZlLCByZWplY3QpIHtcblx0XHR2YXIgeGhyID0gbmV3IFhNTEh0dHBSZXF1ZXN0KCk7XG5cdFx0eGhyLm9wZW4oJ0dFVCcsIHNyYywgdHJ1ZSk7XG5cdFx0aWYgKHByZVJlcXVlc3QpIHByZVJlcXVlc3QoeGhyKTtcblx0XHR4aHIub25sb2FkID0gZnVuY3Rpb24oKSB7XG5cdFx0XHRpZiAoeGhyLnN0YXR1cyA+PSAyMDAgJiYgeGhyLnN0YXR1cyA8IDQwMCkge1xuXHRcdFx0XHRyZXNvbHZlKHhocik7XG5cdFx0XHR9XG5cdFx0XHRlbHNlIHtcblx0XHRcdFx0Y29uc29sZS5lcnJvcihcInJlcXVlc3QgZmFpbGVkXCIpO1xuXHRcdFx0XHRyZWplY3QoeGhyKTtcblx0XHRcdH1cblx0XHR9O1xuXHRcdHhoci5vbmVycm9yID0gZnVuY3Rpb24oZSkge1xuXHRcdFx0Y29uc29sZS5lcnJvcihlLCB4aHIpO1xuXHRcdFx0cmVqZWN0KHhocik7XG5cdFx0fTtcblx0XHR4aHIuc2VuZCgpO1xuXHR9KTtcbn1cblxuZXhwb3J0cy5sb2FkWE1MID0gbG9hZFhNTDtcbmZ1bmN0aW9uIGxvYWRYTUwoc3JjKSB7XG5cdHJldHVybiBnZXRSZXF1ZXN0KHNyYylcblx0LnRoZW4oZnVuY3Rpb24ocmVzcG9uc2UpIHtcblx0XHRyZXR1cm4gbmV3IERPTVBhcnNlcigpLnBhcnNlRnJvbVN0cmluZyhyZXNwb25zZS5yZXNwb25zZVRleHQsIFwiYXBwbGljYXRpb24veG1sXCIpO1xuXHR9KTtcbn1cblxuZXhwb3J0cy5sb2FkVGV4dCA9IGxvYWRUZXh0O1xuZnVuY3Rpb24gbG9hZFRleHQoc3JjKSB7XG5cdHJldHVybiBnZXRSZXF1ZXN0KHNyYylcblx0LnRoZW4oZnVuY3Rpb24ocmVzcG9uc2UpIHtcblx0XHRyZXR1cm4gcmVzcG9uc2UucmVzcG9uc2VUZXh0O1xuXHR9KTtcbn1cblxuZXhwb3J0cy5sb2FkSlNPTiA9IGxvYWRKU09OO1xuZnVuY3Rpb24gbG9hZEpTT04oc3JjKSB7XG5cdHJldHVybiBnZXRSZXF1ZXN0KHNyYylcblx0LnRoZW4oZnVuY3Rpb24ocmVzcG9uc2UpIHtcblx0XHRyZXR1cm4gSlNPTi5wYXJzZShyZXNwb25zZS5yZXNwb25zZVRleHQpXG5cdH0pO1xufVxuIiwiJ3VzZSBzdHJpY3QnXG5jb25zdCB7QVNTRVJUfSA9IHJlcXVpcmUoJy4vZGVidWcnKTtcbmNsYXNzIFZlYzIge1xuXHRjb25zdHJ1Y3Rvcih4LCB5KSB7IHRoaXMueCA9ICt4fHwwLjA7IHRoaXMueSA9ICt5fHwwLjA7IH1cblx0cGVycCgpIHsgcmV0dXJuIG5ldyBWZWMyKC10aGlzLnksIHRoaXMueCk7IH1cblx0dG8obykgeyByZXR1cm4gbmV3IFZlYzIoby54LXRoaXMueCwgby55LXRoaXMueSk7IH1cblx0ZG90KG8pIHsgcmV0dXJuIHRoaXMueCpvLngrdGhpcy55Km8ueTsgfVxuXG5cdHBlcnBEb3QobykgeyByZXR1cm4gLXRoaXMueSpvLngrdGhpcy54Km8ueTsgfVxuXHRwbHVzKG8pIHsgcmV0dXJuIG5ldyBWZWMyKHRoaXMueCtvLngsIHRoaXMueStvLnkpOyB9XG5cblx0bWludXMobykgeyByZXR1cm4gbmV3IFZlYzIodGhpcy54LW8ueCwgdGhpcy55LW8ueSk7IH1cblx0bGVuU3EoKSB7IHJldHVybiB0aGlzLngqdGhpcy54K3RoaXMueSp0aGlzLnk7IH1cblx0bGVuKCkgeyByZXR1cm4gTWF0aC5zcXJ0KHRoaXMueCp0aGlzLnggKyB0aGlzLnkqdGhpcy55KTsgfVxuXHRsZW5ndGgoKSB7IHJldHVybiB0aGlzLmxlbigpOyB9XG5cdGxlbmd0aFNxdWFyZWQoKSB7IHJldHVybiBsZW5TcSgpOyB9XG5cdHNjYWxlZChuKSB7IHJldHVybiBuZXcgVmVjMih0aGlzLngqbiwgdGhpcy55Km4pOyB9XG5cdG5vcm1hbGl6ZSgpIHsgdGhpcy5ub3JtYWxpemVHZXRMZW4oKTsgcmV0dXJuIHRoaXM7IH1cblx0Y2xvbmUoKSB7IHJldHVybiBuZXcgVmVjMih0aGlzLngsIHRoaXMueSk7IH1cblx0Y29weSh7eCwgeX0pIHsgdGhpcy54ID0geDsgOyB0aGlzLnkgPSB5OyByZXR1cm4gdGhpczsgfVxuXG5cdHNjYWxlKG4pIHsgdGhpcy54ICo9IG47IHRoaXMueSAqPSBuOyByZXR1cm4gdGhpczsgfVxuXHRzZXQoeCwgeSkgeyB0aGlzLnggPSB4OyB0aGlzLnkgPSB5OyByZXR1cm4gdGhpczsgfVxuXHRjbGVhcigpIHsgcmV0dXJuIHRoaXMuc2V0KDAuMCwgMC4wKTsgfVxuXHRhZGQobykgeyB0aGlzLnggKz0gby54OyB0aGlzLnkgKz0gby55OyByZXR1cm4gdGhpczsgfVxuXG5cdGFkZFNjYWxlZChvLCBuKSB7IHRoaXMueCArPSBvLngqbjsgdGhpcy55ICs9IG8ueSpuOyByZXR1cm4gdGhpczsgfVxuXG5cdHRyYW5zbGF0ZSh4LCB5KSB7IHRoaXMueCArPSB4OyB0aGlzLnkgKz0geTsgcmV0dXJuIHRoaXM7IH1cblx0bm9ybWFsaXplZCgpIHsgcmV0dXJuIHRoaXMuY2xvbmUoKS5ub3JtYWxpemUoKTsgfVxuXHRzY2FsZWQobikgeyByZXR1cm4gdGhpcy5jbG9uZSgpLnNjYWxlKG4pOyB9XG5cdHRvU3RyaW5nKCkgeyByZXR1cm4gYCgke3RoaXMueH0sICR7dGhpcy55fSlgOyB9XG5cblx0ZGlzdGFuY2Uobykge1xuXHRcdGxldCBkeCA9IHRoaXMueCAtIG8ueCwgZHkgPSB0aGlzLnkgLSBvLnk7XG5cdFx0cmV0dXJuIE1hdGguc3FydChkeCpkeCArIGR5KmR5KTtcblx0fVxuXG5cdGRpc3RhbmNlU3Eobykge1xuXHRcdHRoaXNcblx0XHRsZXQgZHggPSB0aGlzLnggLSBvLngsIGR5ID0gdGhpcy55IC0gby55O1xuXHRcdHJldHVybiBkeCpkeCArIGR5KmR5O1xuXHR9XG5cblx0bm9ybWFsaXplR2V0TGVuKCkge1xuXHRcdGxldCBsMiA9IHRoaXMueCp0aGlzLngrdGhpcy55KnRoaXMueTtcblx0XHRpZiAobDIgPT09IDAuMCkgeyB0aGlzLnggPSAwLjA7IHRoaXMueSA9IDEuMDsgcmV0dXJuIDAuMDAwMDE7IH1cblx0XHRsZXQgaWwgPSAxLjAvTWF0aC5zcXJ0KGwyKTtcblx0XHR0aGlzLnggKj0gaWw7XG5cdFx0dGhpcy55ICo9IGlsO1xuXHRcdHRoaXNcblx0XHRyZXR1cm4gbDIqaWw7XG5cdH1cblxuXHRub3JtYWxpemVPclplcm8oKSB7XG5cdFx0cmV0dXJuIHRoaXMuc2NhbGUoMS4wLyhNYXRoLnNxcnQodGhpcy54KnRoaXMueCt0aGlzLnkqdGhpcy55KSsxZS0zNykpO1xuXHR9XG5cblx0eEZsaXAoYWJvdXQ9MC4wKSB7IHRoaXMueCA9IDIuMCAqIGFib3V0IC0gdGhpcy54OyByZXR1cm4gdGhpczsgfVxuXHR5RmxpcChhYm91dD0wLjApIHsgdGhpcy55ID0gMi4wICogYWJvdXQgLSB0aGlzLnk7IHJldHVybiB0aGlzOyB9XG5cblx0cm90YXRlKGFuZ2xlLCBhYm91dCkge1xuXHRcdGxldCBhYm91dFggPSAwLjAsIGFib3V0WSA9IDAuMDtcblx0XHRpZiAoYWJvdXQpIHsgYWJvdXRYID0gYWJvdXQueDsgYWJvdXRZID0gYWJvdXQueTsgfVxuXHRcdGxldCB4ID0gdGhpcy54IC0gYWJvdXRYO1xuXHRcdGxldCB5ID0gdGhpcy55IC0gYWJvdXRZO1xuXHRcdGxldCBjID0gTWF0aC5jb3MoYW5nbGUpO1xuXHRcdGxldCBzID0gTWF0aC5zaW4oYW5nbGUpO1xuXHRcdGxldCBueCA9IHggKiBjIC0geSAqIHM7XG5cdFx0bGV0IG55ID0geCAqIHMgKyB5ICogYztcblx0XHR0aGlzLnggPSBueCArIGFib3V0WDtcblx0XHR0aGlzLnkgPSBueSArIGFib3V0WTtcblx0XHRyZXR1cm4gdGhpcztcblx0fVxuXG5cdHJvdGF0ZTkwKGFib3V0KSB7XG5cdFx0bGV0IGFib3V0WCA9IDAuMCwgYWJvdXRZID0gMC4wO1xuXHRcdGlmIChhYm91dCkgeyBhYm91dFggPSBhYm91dC54OyBhYm91dFkgPSBhYm91dC55OyB9XG5cdFx0bGV0IHggPSB0aGlzLnggLSBhYm91dFg7XG5cdFx0bGV0IHkgPSB0aGlzLnkgLSBhYm91dFk7XG5cdFx0dGhpcy54ID0gLXkrYWJvdXRYO1xuXHRcdHRoaXMueSA9ICB4K2Fib3V0WTtcblx0XHRyZXR1cm4gdGhpcztcblx0fTtcblxuXHRyb3RhdGUxODAoYWJvdXQpIHtcblx0XHRsZXQgYWJvdXRYID0gMC4wLCBhYm91dFkgPSAwLjA7XG5cdFx0aWYgKGFib3V0KSB7IGFib3V0WCA9IGFib3V0Lng7IGFib3V0WSA9IGFib3V0Lnk7IH1cblx0XHRsZXQgeCA9IHRoaXMueCAtIGFib3V0WDtcblx0XHRsZXQgeSA9IHRoaXMueSAtIGFib3V0WTtcblx0XHR0aGlzLnggPSAteCthYm91dFg7XG5cdFx0dGhpcy55ID0gLXkrYWJvdXRZO1xuXHRcdHJldHVybiB0aGlzO1xuXHR9O1xuXG5cdHJvdGF0ZTI3MChhYm91dCkge1xuXHRcdGxldCBhYm91dFggPSAwLjAsIGFib3V0WSA9IDAuMDtcblx0XHRpZiAoYWJvdXQpIHsgYWJvdXRYID0gYWJvdXQueDsgYWJvdXRZID0gYWJvdXQueTsgfVxuXHRcdGxldCB4ID0gdGhpcy54IC0gYWJvdXRYO1xuXHRcdGxldCB5ID0gdGhpcy55IC0gYWJvdXRZO1xuXHRcdHRoaXMueCA9ICB5K2Fib3V0WDtcblx0XHR0aGlzLnkgPSAteCthYm91dFk7XG5cdFx0cmV0dXJuIHRoaXM7XG5cdH07XG5cblx0cm90YXRlKGFuZ2xlLCBhYm91dCkge1xuXHRcdGxldCBhYm91dFggPSAwLjAsIGFib3V0WSA9IDAuMDtcblx0XHRpZiAoYWJvdXQpIHsgYWJvdXRYID0gYWJvdXQueDsgYWJvdXRZID0gYWJvdXQueTsgfVxuXHRcdGxldCBzaW4gPSBNYXRoLnNpbihhbmdsZSk7XG5cdFx0bGV0IGNvcyA9IE1hdGguY29zKGFuZ2xlKTtcblxuXHRcdGxldCB4ID0gdGhpcy54IC0gYWJvdXRYO1xuXHRcdGxldCB5ID0gdGhpcy55IC0gYWJvdXRZO1xuXHRcdGxldCBueCA9IChjb3MgKiB4KSAtIChzaW4gKiB5KTtcblx0XHRsZXQgbnkgPSAoc2luICogeCkgKyAoY29zICogeSk7XG5cdFx0dGhpcy54ID0gbnggKyBhYm91dFg7XG5cdFx0dGhpcy55ID0gbnkgKyBhYm91dFk7XG5cdFx0cmV0dXJuIHRoaXM7XG5cdH1cblxuXHRyb3RhdGVkOTAoYWJvdXQpIHsgcmV0dXJuIHRoaXMuY2xvbmUoKS5yb3RhdGU5MChhYm91dCk7IH1cblx0cm90YXRlZDE4MChhYm91dCkgeyByZXR1cm4gdGhpcy5jbG9uZSgpLnJvdGF0ZTE4MChhYm91dCk7IH1cblx0cm90YXRlZDI3MChhYm91dCkgeyByZXR1cm4gdGhpcy5jbG9uZSgpLnJvdGF0ZTI3MChhYm91dCk7IH1cblxuXHR4RmxpcHBlZChhYm91dFgpIHsgcmV0dXJuIHRoaXMuY2xvbmUoKS54RmxpcChhYm91dFgpOyB9XG5cdHlGbGlwcGVkKGFib3V0WSkgeyByZXR1cm4gdGhpcy5jbG9uZSgpLnlGbGlwKGFib3V0WSk7IH1cblxuXG5cdG5hbkNoZWNrKCkge1xuXHRcdEFTU0VSVCgrdGhpcy54ID09PSB0aGlzLngpO1xuXHRcdEFTU0VSVCgrdGhpcy55ID09PSB0aGlzLnkpO1xuXHRcdHJldHVybiB0aGlzO1xuXHR9XG59XG5cblZlYzIuWkVSTyA9IE9iamVjdC5mcmVlemUobmV3IFZlYzIoMC4wLCAwLjApKTtcblxuVmVjMi56ZXJvID0gZnVuY3Rpb24oKSB7IHJldHVybiBuZXcgVmVjMigwLjAsIDAuMCk7IH07XG5WZWMyLmZyb21EaXIgPSBmdW5jdGlvbihkaXIpIHsgcmV0dXJuIG5ldyBWZWMyKE1hdGguY29zKGRpciksIE1hdGguc2luKGRpcikpOyB9O1xuVmVjMi50b3dhcmRzID0gZnVuY3Rpb24ocDAsIHAxKSB7IHJldHVybiBuZXcgVmVjMihwMS54IC0gcDAueCwgcDEueSAtIHAwLnkpOyB9O1xuVmVjMi50b3dhcmRzWFkgPSBmdW5jdGlvbih4MCwgeTAsIHgxLCB5MSkgeyByZXR1cm4gbmV3IFZlYzIoeDEgLSB4MCwgeTEgLSB5MCk7IH07XG5cblZlYzIuUG9vbCA9IHtcblx0aXRlbXM6IFtdLFxuXHRjb3VudDogMCxcblx0Z2V0KHgsIHkpIHtcblx0XHRpZiAodGhpcy5jb3VudCA9PT0gdGhpcy5pdGVtcy5sZW5ndGgpXG5cdFx0XHR0aGlzLml0ZW1zLnB1c2gobmV3IFZlYzIoMC4wLCAwLjApKTtcblx0XHRyZXR1cm4gdGhpcy5pdGVtc1t0aGlzLmNvdW50KytdLnNldCgreHx8MC4wLCAreXx8MC4wKTtcblx0fSxcblx0cmVzZXQoKSB7IHRoaXMuY291bnQgPSAwOyB9LFxuXHR1cGRhdGUoKSB7IHRoaXMuY291bnQgPSAwOyB9XG59XG5cblZlYzIudGVtcCA9IGZ1bmN0aW9uKHgsIHkpIHsgcmV0dXJuIFZlYzIuUG9vbC5nZXQoeCwgeSk7IH07XG5cblxubW9kdWxlLmV4cG9ydHMgPSBWZWMyO1xuIl19
